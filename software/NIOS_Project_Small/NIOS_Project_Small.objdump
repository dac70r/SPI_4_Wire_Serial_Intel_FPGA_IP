
NIOS_Project_Small.elf:     file format elf32-littlenios2
NIOS_Project_Small.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00020180

Program Header:
    LOAD off    0x00001000 vaddr 0x00020000 paddr 0x00020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00020020 paddr 0x00020020 align 2**12
         filesz 0x00009800 memsz 0x00009800 flags r-x
    LOAD off    0x0000a820 vaddr 0x00029820 paddr 0x0002b0e0 align 2**12
         filesz 0x000018c0 memsz 0x000018c0 flags rw-
    LOAD off    0x000009a0 vaddr 0x0002c9a0 paddr 0x0002c9a0 align 2**12
         filesz 0x00000000 memsz 0x000003a0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00020000  00020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000160  00020020  00020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000073f0  00020180  00020180  00001180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000022b0  00027570  00027570  00008570  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000018c0  00029820  0002b0e0  0000a820  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000003a0  0002c9a0  0002c9a0  0000c9a0  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  0002cd40  0002cd40  0000c0e0  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  0000c0e0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000628  00000000  00000000  0000c110  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   00012155  00000000  00000000  0000c738  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 000044c2  00000000  00000000  0001e88d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   000080dc  00000000  00000000  00022d4f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  00001530  00000000  00000000  0002ae2c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    0000451e  00000000  00000000  0002c35c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000040  00000000  00000000  0003087c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000070  00000000  00000000  000308c0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000006ed  00000000  00000000  00030930  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00001043  00000000  00000000  0003101d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 00005745  00000000  00000000  00032060  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  0003d33a  2**0
                  CONTENTS, READONLY
 20 .cpu          00000004  00000000  00000000  0003d33d  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0003d341  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0003d342  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0003d343  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  0003d347  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0003d34b  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000005  00000000  00000000  0003d34f  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000005  00000000  00000000  0003d354  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000005  00000000  00000000  0003d359  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000015  00000000  00000000  0003d35e  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000004c  00000000  00000000  0003d373  2**0
                  CONTENTS, READONLY
 31 .jdi          0000527d  00000000  00000000  0003d3bf  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     0004fef6  00000000  00000000  0004263c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00020000 l    d  .entry	00000000 .entry
00020020 l    d  .exceptions	00000000 .exceptions
00020180 l    d  .text	00000000 .text
00027570 l    d  .rodata	00000000 .rodata
00029820 l    d  .rwdata	00000000 .rwdata
0002c9a0 l    d  .bss	00000000 .bss
0002cd40 l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.o
000201b8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
0002b044 l     O .rwdata	00000001 invert_me.0
00000000 l    df *ABS*	00000000 TENCL040_ESC.c
00000000 l    df *ABS*	00000000 ax58100_hw.c
00020468 l     F .text	00000144 HW_SPI_Read
000205ac l     F .text	00000118 HW_SPI_Write
00000000 l    df *ABS*	00000000 coeappl.c
00000000 l    df *ABS*	00000000 ecatappl.c
00000000 l    df *ABS*	00000000 ecatcoe.c
00000000 l    df *ABS*	00000000 ecatslv.c
00000000 l    df *ABS*	00000000 mailbox.c
00000000 l    df *ABS*	00000000 objdef.c
00000000 l    df *ABS*	00000000 sdoserv.c
00000000 l    df *ABS*	00000000 nios_it.c
00000000 l    df *ABS*	00000000 peripheral_linker.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00026b9c l     F .text	0000008c sbrk_aligned
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 freer.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0002b0d4 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
0002cabc g     O .bss	00000004 alt_instruction_exception_handler
0002ca14 g     O .bss	00000001 b3BufferMode
00026614 g     F .text	00000048 init_exti0_it
0002ca0c g     O .bss	00000002 nEcatStateTrans
0002b048 g     O .rwdata	00000004 GetTotalCurrentSetting0x8120
0002c9f8 g     O .bss	00000002 u16IdValue
000272a0 g     F .text	0000002c alt_main
0002a074 g     O .rwdata	00000024 CurrentChannel2MAProcessDataMapping0x1A03
000286d2 g     O .rodata	0000000c asEntryDesc0x6030
00026df4 g     F .text	00000080 _puts_r
0002cc40 g     O .bss	00000100 alt_irq
00027b88 g     O .rodata	0000000c asEntryDesc0x80F0
00029f30 g     O .rwdata	00000024 VoltageChannel3MVProcessDataMapping0x1A0C
0002b0c2 g     O .rwdata	00000006 sEntryDesc0x1000
00027a64 g     O .rodata	00000026 aName0x8110
0002b0e0 g       *ABS*	00000000 __flash_rwdata_start
00020768 g     F .text	0000000c HW_EscReadIsr
00029ab0 g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel10x8078
0002cd40 g       *ABS*	00000000 __alt_heap_start
0002a128 g     O .rwdata	000001e0 GenObjDic
0002b0b6 g     O .rwdata	00000006 sEntryDesc0x1008
000278e4 g     O .rodata	00000047 aName0x1018
0002a098 g     O .rwdata	00000024 CurrentChannel1MAProcessDataMapping0x1A02
0002461c g     F .text	00000008 OBJ_GetObjDesc
00027c80 g     O .rodata	0000003b aName0x80D0
0002ca0f g     O .bss	00000001 bApplEsmPending
0002084c g     F .text	00000004 HW_SYNC1_IRQHandler
000224b8 g     F .text	0000005c StartOutputHandler
00029c14 g     O .rwdata	00000024 VoltageChannel7MV0x6080
000295e4 g     O .rodata	0000009e aName0x1601
00020424 g     F .text	00000004 APPL_OutputMapping
000272d0 g     F .text	00000004 __malloc_unlock
00029014 g     O .rodata	00000096 aName0x1A07
0002c9e8 g     O .bss	00000004 pCoeSendStored
000294dc g     O .rodata	00000096 aName0x1A01
000267e4 g     F .text	000000b0 spi_transmit_receive
00029f54 g     O .rwdata	00000024 VoltageChannel2MVProcessDataMapping0x1A0B
00023e08 g     F .text	000000e0 MBX_MailboxWriteInd
0002ca80 g     O .bss	00000002 nSdoInfoIndex
00023328 g     F .text	000001e4 ECAT_StateChange
0002ca8c g     O .bss	00000004 pStoreData
0002c9e0 g     O .bss	00000004 pAPPL_CoeReadInd
00028cae g     O .rodata	00000036 asEntryDesc0x1A0C
000279b4 g     O .rodata	0000001a aName0x8128
0002ca4d g     O .bss	00000001 u8MbxReadCounter
000279dc g     O .rodata	00000036 aName0x8120
00027ff8 g     O .rodata	00000037 aName0x8070
00029c38 g     O .rwdata	00000024 VoltageChannel6MV0x6078
000218b8 g     F .text	00000068 COE_ContinueInd
00028640 g     O .rodata	00000019 aName0x6048
000282a8 g     O .rodata	00000024 aName0x8030
0002ca03 g     O .bss	00000001 nAlStatus
0002ca08 g     O .bss	00000002 nPdOutputSize
00027a12 g     O .rodata	0000000c asEntryDesc0x8120
00027568 g     F .text	00000008 altera_nios2_gen2_irq_init
0002cac0 g     O .bss	0000000c spiRxBuf
0002860a g     O .rodata	0000000c asEntryDesc0x6058
00020000 g     F .entry	0000000c __reset
0002c9bc g     O .bss	00000001 bInitFinished
0002a050 g     O .rwdata	00000024 CurrentChannel3MAProcessDataMapping0x1A04
0002ca9c g     O .bss	00000004 edge_capture
000290aa g     O .rodata	00000036 asEntryDesc0x1A07
000285a0 g     O .rodata	00000019 aName0x6068
0002803c g     O .rodata	00000056 aName0x8068
000299ea g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel40x8090
00020020 g       *ABS*	00000000 __flash_exceptions_start
000285c8 g     O .rodata	00000019 aName0x6060
00028a80 g     O .rodata	00000096 aName0x1A0E
00027e6e g     O .rodata	0000000c asEntryDesc0x80A0
0002ca12 g     O .bss	00000002 u16LocalErrorCode
0002ca6c g     O .bss	00000004 nSdoSegBytesToHandle
00027bd6 g     O .rodata	0000000c asEntryDesc0x80E8
00020434 g     F .text	00000034 main_initial
00021920 g     F .text	0000004c ResetALEventMask
0002caa8 g     O .bss	00000004 errno
0002c9a0 g     O .bss	00000002 bootSwitchID
0002ca10 g     O .bss	00000001 u8LocalErrorState
0002a31c g     O .rwdata	0000000d acDevicename
000298b0 g     O .rwdata	0000000a ResetFallingEdgeChannelByDigitalInputGroupInputGroup0x80E8
000284f4 g     O .rodata	0000000c asEntryDesc0x7000
0002cb74 g     O .bss	00000034 sMbxSendQueue
0002ca02 g     O .bss	00000001 bExplicitDevIdRequested
0002afe4 g     O .rwdata	0000000c sErrorSettings
0002cab4 g     O .bss	00000004 alt_argv
000201e4 g     F .text	00000004 APPL_AckErrorInd
00033044 g       *ABS*	00000000 _gp
00027320 g     F .text	00000004 usleep
0002b09c g     O .rwdata	00000006 sEntryDesc0x100A
00027fac g     O .rodata	0000003d aName0x8078
00027ec8 g     O .rodata	0000003d aName0x8090
00029bb8 g     O .rwdata	0000000a AnalogOutputLightModeGroup0x8028
00029a6e g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel20x8080
00022520 g     F .text	000000a0 StopInputHandler
0002cb40 g     O .bss	00000034 sMbxReceiveQueue
0002ca38 g     O .bss	00000001 bNoMbxMemoryAvailable
00023c20 g     F .text	000000a0 MBX_MailboxReadInd
0002a308 g     O .rwdata	00000014 sIdentity
000290e0 g     O .rodata	00000096 aName0x1A06
00027d58 g     O .rodata	00000034 aName0x80B8
0002ca22 g     O .bss	00000002 Sync0WdCounter
00026e84 g     F .text	00000028 memcpy
00027ae6 g     O .rodata	0000000c asEntryDesc0x8100
000247e0 g     F .text	0000010c CheckSyncTypeValue
0002b080 g     O .rwdata	00000006 sRxPDOassign
0002c9c8 g     O .bss	00000001 bMinCycleTimeMeasurementStarted
00027ac4 g     O .rodata	00000022 aName0x8100
00026e74 g     F .text	00000010 puts
00027544 g     F .text	00000024 alt_exception_cause_generated_bad_addr
00028730 g     O .rodata	00000019 aName0x6018
0002083c g     F .text	0000000c HW_EscWriteIsr
0002ca5a g     O .bss	00000001 bSendMbxIsFull
00027be4 g     O .rodata	00000041 aName0x80E0
00028550 g     O .rodata	00000019 aName0x6078
0002c9d4 g     O .bss	00000004 u32CycleTimeStartValue
0002a0bc g     O .rwdata	00000024 CurrentChannel0MAProcessDataMapping0x1A01
0002787c g     O .rodata	00000013 aName0x10F8
0002ca18 g     O .bss	00000002 LatchInputSync0Counter
00026b7c g     F .text	00000010 malloc
0002ca24 g     O .bss	00000002 i16WaitForPllRunningCnt
00026a94 g     F .text	00000064 .hidden __udivsi3
0002c9fe g     O .bss	00000002 nEscAddrOutputData
000299a8 g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel50x8098
0002ca59 g     O .bss	00000001 bMbxRunning
0002812e g     O .rodata	0000000c asEntryDesc0x8058
00029be4 g     O .rwdata	0000000a MLControlChannel0x7000
0002579c g     F .text	000008f4 SDOS_SdoInd
00020210 g     F .text	00000008 APPL_StopOutputHandler
00027d8c g     O .rodata	0000000c asEntryDesc0x80B8
00021adc g     F .text	00000270 CheckSmSettings
00029b04 g     O .rwdata	00000024 AnalogOutputTriggerDelayGroup0x8058
000288b2 g     O .rodata	00000036 asEntryDesc0x1A11
0002b05c g     O .rwdata	00000004 DigitalInputGroupReset0x80C8
0002768c g     O .rodata	00000108 aName0x1C32
0002ca20 g     O .bss	00000002 Sync0WdValue
00027ab6 g     O .rodata	0000000c asEntryDesc0x8108
00028184 g     O .rodata	00000035 aName0x8048
00029d58 g     O .rwdata	00000024 CurrentChannel6MA0x6038
000281c8 g     O .rodata	00000086 aName0x8040
0002881c g     O .rodata	00000096 aName0x1A11
00026ee8 g     F .text	00000048 _sbrk_r
000243e0 g     F .text	0000003c OBJ_GetEntryDesc
00029bd8 g     O .rwdata	0000000c MLParameterSetting0x8000
00028092 g     O .rodata	0000000c asEntryDesc0x8068
000279a8 g     O .rodata	0000000c aName0x1000
00020df4 g     F .text	00000068 GetSystemTimeDelay
00020200 g     F .text	00000008 APPL_StopInputHandler
0002ca26 g     O .bss	00000002 i16WaitForPllRunningTimeout
00029f9c g     O .rwdata	00000024 VoltageChannel0MVProcessDataMapping0x1A09
0002ca74 g     O .bss	00000001 bSdoSegAccess
00027d0c g     O .rodata	0000003e aName0x80C0
0002ca1c g     O .bss	00000002 Sync1WdValue
00029bf0 g     O .rwdata	00000024 MLInferenceChannel0x6088
00021d4c g     F .text	0000076c StartInputHandler
000284ac g     O .rodata	00000021 aName0x7008
00027a8a g     O .rodata	0000000c asEntryDesc0x8110
00020850 g     F .text	00000004 HW_TIMETASK_IRQHandler
000287f4 g     O .rodata	0000001b aName0x1C12
00029e54 g     O .rwdata	00000026 sTxPDOassign
000238d8 g     F .text	000000d4 MBX_StartMailboxHandler
0002cd40 g       *ABS*	00000000 __bss_end
000271b4 g     F .text	00000068 alt_iic_isr_register
000298ba g     O .rwdata	0000000a ResetRisingEdgeChannelByDigitalInputGroupInputGroup0x80E0
0002c9ec g     O .bss	00000001 EepromLoaded
00029cc8 g     O .rwdata	00000024 VoltageChannel2MV0x6058
000287a8 g     O .rodata	00000016 aName0x6000
0002974c g     O .rodata	00000036 asEntryDesc0x1600
0002ca75 g     O .bss	00000001 bSdoSegFollows
0002ca64 g     O .bss	00000004 nSdoSegCompleteSize
0002c9f7 g     O .bss	00000001 u8dummy
000298ce g     O .rwdata	0000000a DigitalInputChannelGroupMappingChannelRSTTRG0x80D0
0002c9fa g     O .bss	00000002 u16ALEventMask
0002719c g     F .text	00000018 alt_ic_irq_enabled
00029da0 g     O .rwdata	00000024 CurrentChannel4MA0x6028
0002a0e0 g     O .rwdata	00000024 OnOffContinuousModeGroupProcessDataMapping0x1601
000282d8 g     O .rodata	00000023 aName0x8028
000297a4 g     O .rodata	00000078 cAbortCode
00028108 g     O .rodata	00000026 aName0x8058
0002ca88 g     O .bss	00000004 pSdoPendFunc
0002ca2e g     O .bss	00000001 bDcRunning
000279ce g     O .rodata	0000000c asEntryDesc0x8128
0002caac g     O .bss	00000004 alt_irq_active
00029de8 g     O .rwdata	00000024 CurrentChannel2MA0x6018
000248ec g     F .text	00000610 OBJ_Read
000200fc g     F .exceptions	00000060 alt_irq_handler
0002c9e4 g     O .bss	00000001 bRunApplication
0002b07c g     O .rwdata	00000004 DeviceID0x6000
000284dc g     O .rodata	00000017 aName0x7000
0002ca52 g     O .bss	00000002 u16EscAddrReceiveMbx
00029820 g     O .rwdata	0000000c GetTemperatureReading0x8128
0002ca3c g     O .bss	00000004 psStoreMbx
0002b078 g     O .rwdata	00000004 OnOffContinuousModeGroup0x7008
0002401c g     F .text	000000c4 MBX_Main
0002c9ee g     O .bss	00000008 SyncManInfo
0002b090 g     O .rwdata	00000006 sSyncmanagertype
0002ca16 g     O .bss	00000001 b32BitDc
00021a80 g     F .text	0000005c EnableSyncManChannel
0002753c g     F .text	00000004 alt_dcache_flush_all
00028668 g     O .rodata	00000019 aName0x6040
000284ce g     O .rodata	0000000c asEntryDesc0x7008
000296b8 g     O .rodata	00000094 aName0x1600
00029ca4 g     O .rwdata	00000024 VoltageChannel3MV0x6060
0002b0e0 g       *ABS*	00000000 __ram_rwdata_end
00020960 g     F .text	0000005c COE_UpdateSyncErrorStatus
00027324 g     F .text	0000005c write
00027f06 g     O .rodata	0000000c asEntryDesc0x8090
0002c9cc g     O .bss	00000004 u32SystemTimeReadFailure
000282fc g     O .rodata	0000000c asEntryDesc0x8028
000239ac g     F .text	00000108 MBX_StopMailboxHandler
00027890 g     O .rodata	0000003f aName0x10F1
0002ca98 g     O .bss	00000001 u8PendingSdo
00029820 g       *ABS*	00000000 __ram_rodata_end
0002b0d8 g     O .rwdata	00000004 DEBUG
000294a6 g     O .rodata	00000036 asEntryDesc0x1A02
00027de4 g     O .rodata	0000003d aName0x80A8
00027b36 g     O .rodata	0000000c asEntryDesc0x80F8
0002b074 g     O .rwdata	00000004 AnalogOutputChannelReleaseGroup0x8010
00029cec g     O .rwdata	00000024 VoltageChannel1MV0x6050
000282cc g     O .rodata	0000000c asEntryDesc0x8030
0002a32c g     O .rwdata	00000ca8 ApplicationObjDic
00020f0c g     F .text	0000006c HandleCycleTimeMeasurement
0002ca1a g     O .bss	00000002 LatchInputSync0Value
00027c72 g     O .rodata	0000000c asEntryDesc0x80D8
00026af8 g     F .text	0000005c .hidden __umodsi3
0002865a g     O .rodata	0000000c asEntryDesc0x6048
00029ea0 g     O .rwdata	00000024 VoltageChannel7MVProcessDataMapping0x1A10
0002792c g     O .rodata	0000001e asEntryDesc0x1018
00029572 g     O .rodata	00000036 asEntryDesc0x1A01
00027a20 g     O .rodata	00000036 aName0x8118
00028578 g     O .rodata	00000019 aName0x6070
0002cd40 g       *ABS*	00000000 end
000201f8 g     F .text	00000008 APPL_StartInputHandler
0002ca56 g     O .bss	00000002 u16SendMbxSize
00028f48 g     O .rodata	00000096 aName0x1A08
0002ca0e g     O .bss	00000001 bEcatWaitForAlControlRes
000261a0 g     F .text	00000078 SDOS_ClearPendingResponse
00028f12 g     O .rodata	00000036 asEntryDesc0x1A09
00029e0c g     O .rwdata	00000024 CurrentChannel1MA0x6010
0002015c g     F .exceptions	00000024 alt_instruction_exception_entry
0002ca44 g     O .bss	00000004 psReadMbx
00022514 g     F .text	0000000c StopOutputHandler
000286aa g     O .rodata	0000000c asEntryDesc0x6038
0002796c g     O .rodata	0000001e aName0x1009
0002c9e7 g     O .bss	00000001 bEcatWaitForInputUpdate
00021308 g     F .text	000001c0 PDI_Isr
0002cba8 g     O .bss	00000044 sSyncManInPar
00034000 g       *ABS*	00000000 __alt_stack_pointer
0002b0b0 g     O .rwdata	00000006 acHardwareversion
00028c18 g     O .rodata	00000096 aName0x1A0C
000288e8 g     O .rodata	00000096 aName0x1A10
00027e22 g     O .rodata	0000000c asEntryDesc0x80A8
00026218 g     F .text	000003d8 SDOS_SdoInfoInd
000273a4 g     F .text	00000030 altera_avalon_jtag_uart_write
0002c9c4 g     O .bss	00000004 u32MinCycleTimeValue
0002ca0a g     O .bss	00000002 nPdInputSize
00029fc0 g     O .rwdata	00000024 CurrentChannel7MAProcessDataMapping0x1A08
00026f30 g     F .text	00000100 _free_r
00027998 g     O .rodata	0000000f aName0x1001
00020774 g     F .text	00000038 HW_EscWrite
000201f0 g     F .text	00000008 APPL_StopMailboxHandler
00028b16 g     O .rodata	00000036 asEntryDesc0x1A0E
0002afd4 g     O .rwdata	0000000d aSubindexDesc
00023828 g     F .text	000000b0 MBX_Init
000298e2 g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel80x80B0
00020180 g     F .text	0000003c _start
00026894 g     F .text	0000010c adc_init_spi_transmit_receive
00029b4c g     O .rwdata	00000024 AnalogOutputPulseWidthLimitChannelOrGroup0x8048
0002ca77 g     O .bss	00000001 bSdoInWork
00027f9e g     O .rodata	0000000c asEntryDesc0x8080
00020848 g     F .text	00000004 HW_SYNC0_IRQHandler
000283ec g     O .rodata	0000000c asEntryDesc0x8010
0002ca2a g     O .bss	00000002 u16SmSync0Value
0002ca97 g     O .bss	00000001 bStoreCompleteAccess
0002b060 g     O .rwdata	00000004 DigitalInputGroupingStatus0x80C0
000273d4 g     F .text	000000d8 alt_avalon_spi_command
00024228 g     F .text	00000080 OBJ_CopyNumberToString
00020958 g     F .text	00000008 COE_GetObjectDictionary
000280fc g     O .rodata	0000000c asEntryDesc0x8060
00029344 g     O .rodata	00000096 aName0x1A03
000273a0 g     F .text	00000004 alt_sys_init
0002441c g     F .text	000000b8 OBJ_GetNoOfObjects
00029410 g     O .rodata	00000096 aName0x1A02
00029fe4 g     O .rwdata	00000024 CurrentChannel6MAProcessDataMapping0x1A07
00027cbc g     O .rodata	0000000c asEntryDesc0x80D0
0002c9be g     O .bss	00000004 aPdOutputData
00029b28 g     O .rwdata	00000024 AnalogOutputRetrieveOutputResetEventCounterGroup0x8050
0002ca68 g     O .bss	00000001 bSdoSegLastToggle
00023ad4 g     F .text	0000014c MBX_CopyToSendMailbox
00027dd6 g     O .rodata	0000000c asEntryDesc0x80B0
00028e46 g     O .rodata	00000036 asEntryDesc0x1A0A
0002266c g     F .text	0000081c AL_ControlInd
00028528 g     O .rodata	00000019 aName0x6080
00026b54 g     F .text	00000028 .hidden __mulsi3
00029820 g       *ABS*	00000000 __ram_rwdata_start
00027570 g       *ABS*	00000000 __ram_rodata_start
00028780 g     O .rodata	00000019 aName0x6008
0002ca76 g     O .bss	00000001 nSdoSegService
0002b096 g     O .rwdata	00000006 sEntryDesc0x10F8
00027a98 g     O .rodata	0000001e aName0x8108
00020d64 g     F .text	00000090 ECAT_CheckTimer
000235ec g     F .text	000001a8 ECAT_Main
0002ca5b g     O .bss	00000001 bReceiveMbxIsLocked
0002ca50 g     O .bss	00000002 u16EscAddrSendMbx
00029b94 g     O .rwdata	00000024 AnalogOutputActiveFlagGroup0x8030
0002ca04 g     O .bss	00000002 nMaxEscAddress
0002ca34 g     O .bss	00000001 bEcatFirstOutputsReceived
000274ac g     F .text	00000090 alt_busy_sleep
0002ca48 g     O .bss	00000004 psWriteMbx
0002879a g     O .rodata	0000000c asEntryDesc0x6008
0002c9b4 g     O .bss	00000008 u64Timestamp
0002786e g     O .rodata	0000000c asEntryDesc0x1C00
000201e8 g     F .text	00000008 APPL_StartMailboxHandler
0002ca4e g     O .bss	00000001 u8MbxWriteCounter
000207ac g     F .text	00000090 HW_Init
00028394 g     O .rodata	0000000c asEntryDesc0x8018
0002cd40 g       *ABS*	00000000 __alt_stack_base
0002813c g     O .rodata	0000003c aName0x8050
00028772 g     O .rodata	0000000c asEntryDesc0x6010
00029782 g     O .rodata	00000020 cBitMask
0002c9f6 g     O .bss	00000001 SMActivate
0002b04e g     O .rwdata	00000002 FirmwareRevision0x8110
0002c9b0 g     O .bss	00000004 u32LastDc32Value
00023ab4 g     F .text	00000020 MailboxServiceInd
00023794 g     F .text	00000050 PutInMbxQueue
0002b058 g     O .rwdata	00000004 NumberOfConnectedLightSource0x80F0
000242a8 g     F .text	00000138 OBJ_GetDesc
00029d34 g     O .rwdata	00000024 CurrentChannel7MA0x6040
0002c9ac g     O .bss	00000004 u32CheckForDcOverrunCnt
00027c34 g     O .rodata	0000003e aName0x80D8
00027b44 g     O .rodata	00000044 aName0x80F0
00023cc0 g     F .text	00000068 MBX_MailboxRepeatReq
0002ca4c g     O .bss	00000001 u8MailboxSendReqStored
00021864 g     F .text	0000000c COE_Init
00020a48 g     F .text	00000054 COE_RemoveDicEntry
00020e5c g     F .text	000000b0 PDO_InputMapping
0002b0a4 g     O .rwdata	00000006 acSoftwareversion
0002c9a8 g     O .bss	00000002 u16ErrorRegister
000272cc g     F .text	00000004 __malloc_lock
000272d4 g     F .text	0000004c sbrk
0002c9dc g     O .bss	00000004 pAPPL_CoeWriteInd
00027cc8 g     O .rodata	00000036 aName0x80C8
00027cfe g     O .rodata	0000000c asEntryDesc0x80C8
00028fde g     O .rodata	00000036 asEntryDesc0x1A08
00026090 g     F .text	00000110 SDOS_SdoRes
0002ca7c g     O .bss	00000004 pSdoInfoObjEntry
0002159c g     F .text	00000218 ESC_EepromAccess
00029d7c g     O .rwdata	00000024 CurrentChannel5MA0x6030
00027030 g     F .text	000000a8 __sfvwrite_small_dev
0002ca28 g     O .bss	00000001 bSmSyncSequenceValid
0002ca82 g     O .bss	00000002 nSdoInfoFragmentsLeft
00028b4c g     O .rodata	00000096 aName0x1A0D
00022e88 g     F .text	00000308 AL_ControlRes
0002c9a0 g       *ABS*	00000000 __bss_start
00026eac g     F .text	00000020 memset
00024efc g     F .text	00000740 OBJ_Write
000201bc g     F .text	00000028 main
00020000 g       *ABS*	00000000 __alt_mem_RAM
00028308 g     O .rodata	00000028 aName0x8020
0002665c g     F .text	00000020 delay_ms
00028810 g     O .rodata	0000000c asEntryDesc0x1C12
00027d4a g     O .rodata	0000000c asEntryDesc0x80C0
00028592 g     O .rodata	0000000c asEntryDesc0x6070
0002cab0 g     O .bss	00000004 alt_envp
00028708 g     O .rodata	00000019 aName0x6020
0002b0bc g     O .rwdata	00000006 sEntryDesc0x1001
00020218 g     F .text	000001bc APPL_GenerateMapping
000206c8 g     F .text	00000028 HW_GetALEventRegister_Isr
0002ca30 g     O .bss	00000002 EsmTimeoutCounter
00020c98 g     F .text	000000cc COE_Main
00029924 g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel70x80A8
0002b054 g     O .rwdata	00000004 SetTargetedLightSourceIndex0x80F8
0002a104 g     O .rwdata	00000024 MLControlChannelProcessDataMapping0x1600
00034000 g       *ABS*	00000000 __alt_heap_limit
000298c4 g     O .rwdata	0000000a DigitalInputGroupAndOutputGroupMappingOutputGroup0x80D8
000217b4 g     F .text	000000b0 ESC_EepromWriteCRC
00026c28 g     F .text	000001cc _malloc_r
000208c0 g     F .text	00000098 Read0x10F8
0002c9a2 g     O .bss	00000002 EscALEvent
0002ca54 g     O .bss	00000002 u16ReceiveMbxSize
00029242 g     O .rodata	00000036 asEntryDesc0x1A05
0002c9a4 g     O .bss	00000004 ObjDicList
0002b0dc g     O .rwdata	00000004 alt_errno
00028ce4 g     O .rodata	00000096 aName0x1A0B
0002b0aa g     O .rwdata	00000006 sEntryDesc0x1009
0002ca78 g     O .bss	00000004 pSdoResStored
0002b088 g     O .rwdata	00000008 DeviceIDProcessDataMapping0x1A00
0002829c g     O .rodata	0000000c asEntryDesc0x8038
0002ca90 g     O .bss	00000004 u32StoreDataSize
000269a0 g     F .text	00000080 .hidden __divsi3
0002824e g     O .rodata	0000000c asEntryDesc0x8040
00023190 g     F .text	000000c0 DC_CheckWatchdog
0002ca84 g     O .bss	00000004 pSdoSegData
00029f0c g     O .rwdata	00000024 VoltageChannel4MVProcessDataMapping0x1A0D
00027570 g       *ABS*	00000000 __flash_rodata_start
00029682 g     O .rodata	00000036 asEntryDesc0x1601
00021a20 g     F .text	00000060 DisableSyncManChannel
0002ca32 g     O .bss	00000001 bDcSyncActive
00029af2 g     O .rwdata	00000012 AnalogOutputChannelConfigMaxIntensityChannel0x8070
0002ca36 g     O .bss	00000001 bEcatOutputUpdateRunning
00028690 g     O .rodata	00000019 aName0x6038
00028be2 g     O .rodata	00000036 asEntryDesc0x1A0D
000285f0 g     O .rodata	00000019 aName0x6058
00027380 g     F .text	00000020 alt_irq_init
000281ba g     O .rodata	0000000c asEntryDesc0x8048
00028030 g     O .rodata	0000000c asEntryDesc0x8070
000214c8 g     F .text	000000d4 MainLoop
000286b8 g     O .rodata	00000019 aName0x6030
00023d28 g     F .text	000000e0 MBX_MailboxSendReq
0002c9d8 g     O .bss	00000004 pAPPL_MainLoop
00027eba g     O .rodata	0000000c asEntryDesc0x8098
0002b06c g     O .rwdata	00000004 AnalogOutputPulseWidthLimitClearOutputResetEventCounter0x8040
00029b70 g     O .rwdata	00000024 AnalogOutputMinimumTriggerPulseWidthChannelOrGroup0x8038
0002b064 g     O .rwdata	00000004 AnalogOutputChannelConfigSaveSetting0x8068
00021084 g     F .text	000000e8 MainInit
000285e2 g     O .rodata	0000000c asEntryDesc0x6060
000209bc g     F .text	0000008c COE_AddObjectToDic
000270d8 g     F .text	00000050 _write_r
0002cbec g     O .bss	00000044 sSyncManOutPar
0002b070 g     O .rwdata	00000004 AnalogOutputChannelSaveGroupSetting0x8018
00028330 g     O .rodata	0000000c asEntryDesc0x8020
0002ca1e g     O .bss	00000002 Sync1WdCounter
0002b0cc g     O .rwdata	00000004 _impure_ptr
0002cab8 g     O .bss	00000004 alt_argc
0002667c g     F .text	00000168 adc_init
0002930e g     O .rodata	00000036 asEntryDesc0x1A04
000286e0 g     O .rodata	00000019 aName0x6028
000219f0 g     F .text	00000030 GetSyncMan
000291ac g     O .rodata	00000096 aName0x1A05
00021870 g     F .text	00000048 COE_ServiceInd
000278d0 g     O .rodata	00000012 asEntryDesc0x10F1
000287cc g     O .rodata	0000001b aName0x1C13
00028682 g     O .rodata	0000000c asEntryDesc0x6040
00020020 g       .exceptions	00000000 alt_irq_entry
000287e8 g     O .rodata	0000000c asEntryDesc0x1C13
00029a2c g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel30x8088
000225c8 g     F .text	000000a4 SetALStatus
00029ee8 g     O .rwdata	00000024 VoltageChannel5MVProcessDataMapping0x1A0E
000280a0 g     O .rodata	0000005c aName0x8060
000211a8 g     F .text	00000160 Sync0_Isr
00029f78 g     O .rwdata	00000024 VoltageChannel1MVProcessDataMapping0x1A0A
00028a4a g     O .rodata	00000036 asEntryDesc0x1A0F
0002ca00 g     O .bss	00000002 EcatWdValue
00028178 g     O .rodata	0000000c asEntryDesc0x8050
00029d10 g     O .rwdata	00000024 VoltageChannel0MV0x6048
00029e7c g     O .rwdata	00000024 MLInferenceChannelProcessDataMapping0x1A11
0002c9e5 g     O .bss	00000001 bEtherCATErrorLed
00029176 g     O .rodata	00000036 asEntryDesc0x1A06
00020854 g     F .text	0000006c COE_SyncTimeStamp
00020020 g       *ABS*	00000000 __ram_exceptions_start
00027af4 g     O .rodata	00000042 aName0x80F8
000289b4 g     O .rodata	00000096 aName0x1A0F
00027c26 g     O .rodata	0000000c asEntryDesc0x80E0
00020728 g     F .text	00000040 HW_GetALEventRegister
0002c9d0 g     O .bss	00000004 u32MinCycleTimeStartValue
000298d8 g     O .rwdata	0000000a AnalogOutputChannelConfigLightModeChannel0x80B8
00027128 g     F .text	00000004 alt_ic_isr_register
0002785c g     O .rodata	00000012 aName0x1C00
00027f52 g     O .rodata	0000000c asEntryDesc0x8088
00029c80 g     O .rwdata	00000024 VoltageChannel4MV0x6068
0002849a g     O .rodata	00000012 asEntryDesc0x8000
0002b0e0 g       *ABS*	00000000 _edata
0002196c g     F .text	0000004c SetALEventMask
0002874a g     O .rodata	0000000c asEntryDesc0x6018
0002897e g     O .rodata	00000036 asEntryDesc0x1A10
0002ca5e g     O .bss	00000001 bSyncSetByUser
0002cd40 g       *ABS*	00000000 _end
0002ca58 g     O .bss	00000001 bMbxRepeatToggle
0002794c g     O .rodata	0000001e aName0x100A
0002ca35 g     O .bss	00000001 bEcatInputUpdateRunning
000219b8 g     F .text	00000038 UpdateEEPROMLoadedState
0002982c g     O .rwdata	00000084 ReadTargetedLightSourceInfo0x8100
00021030 g     F .text	00000054 Sync1_Isr
00020180 g       *ABS*	00000000 __ram_exceptions_end
0002ca15 g     O .bss	00000001 bEscIntEnabled
0002ca40 g     O .bss	00000004 psRepeatMbx
0002b050 g     O .rwdata	00000004 FactoryReset0x8108
0002042c g     F .text	00000008 APPL_GetDeviceID
00029c5c g     O .rwdata	00000024 VoltageChannel5MV0x6070
000293da g     O .rodata	00000036 asEntryDesc0x1A03
00027794 g     O .rodata	000000c6 asEntryDesc0x1C3x
000240e0 g     F .text	0000003c OBJ_GetObjectHandle
00028450 g     O .rodata	00000018 asEntryDesc0x8008
00029bcc g     O .rwdata	0000000c ADCParameterSetting0x8008
0002ca72 g     O .bss	00000002 nSdoSegIndex
0002cc30 g     O .bss	00000010 aSdoInfoHeader
00027f60 g     O .rodata	0000003d aName0x8080
00027164 g     F .text	00000038 alt_ic_irq_disable
000295a8 g     O .rodata	0000002e aName0x1A00
00020208 g     F .text	00000008 APPL_StartOutputHandler
0002ca60 g     O .bss	00000004 pSdoSegObjEntry
000295d6 g     O .rodata	0000000c asEntryDesc0x1A00
0002856a g     O .rodata	0000000c asEntryDesc0x6078
00024624 g     F .text	000001bc OBJ_GetEntryOffset
00020b28 g     F .text	00000040 COE_ObjDictionaryInit
0002a02c g     O .rwdata	00000024 CurrentChannel4MAProcessDataMapping0x1A05
00028468 g     O .rodata	00000031 aName0x8000
00028758 g     O .rodata	00000019 aName0x6010
00023ee8 g     F .text	00000134 MBX_CheckAndCopyMailbox
00028618 g     O .rodata	00000019 aName0x6050
00020b68 g     F .text	00000130 COE_ObjInit
0002cad8 g     O .bss	00000068 aPdInputData
00020a9c g     F .text	0000003c COE_ClearObjDictionary
0002ca33 g     O .bss	00000001 bWdTrigger
00026a20 g     F .text	00000074 .hidden __modsi3
00020f78 g     F .text	000000b8 PDO_OutputMapping
00028632 g     O .rodata	0000000c asEntryDesc0x6050
0002b068 g     O .rwdata	00000004 AnalogOutputChannelConfigIntensityUnits0x8060
0002ca70 g     O .bss	00000001 nSdoSegSubindex
0002aff0 g     O .rwdata	00000054 _impure_data
00034000 g       *ABS*	00000000 __alt_data_end
00020020 g     F .exceptions	00000000 alt_exception
0002563c g     F .text	00000160 SdoRes
000206f0 g     F .text	00000038 HW_EscRead
00027b94 g     O .rodata	00000042 aName0x80E8
00028500 g     O .rodata	00000019 aName0x6088
0002ca94 g     O .bss	00000002 u16StoreIndex
0002c9e6 g     O .bss	00000001 bEtherCATRunLed
00029966 g     O .rwdata	00000042 AnalogOutputChannelConfigOperatingIntensityChannel60x80A0
00023250 g     F .text	000000d8 CheckIfEcatError
0002851a g     O .rodata	0000000c asEntryDesc0x6088
000244d4 g     F .text	00000148 OBJ_GetObjectList
000287be g     O .rodata	0000000c asEntryDesc0x6000
0002000c g       .entry	00000000 _exit
0002ca2c g     O .bss	00000002 u16SmSync0Counter
0002ca06 g     O .bss	00000001 nMaxSyncMan
00028722 g     O .rodata	0000000c asEntryDesc0x6020
00026ecc g     F .text	0000001c strlen
000203d4 g     F .text	00000050 APPL_InputMapping
00020428 g     F .text	00000004 APPL_Application
0002b0c8 g     O .rwdata	00000004 u32Devicetype
0002b04c g     O .rwdata	00000002 FirmwareSemanticVersion0x8118
0002caa0 g     O .bss	00000004 __malloc_sbrk_start
0002ca96 g     O .bss	00000001 u8StoreSubindex
0002a008 g     O .rwdata	00000024 CurrentChannel5MAProcessDataMapping0x1A06
00027584 g     O .rodata	00000107 aName0x1C33
000225c0 g     F .text	00000008 BackToInitTransition
00028542 g     O .rodata	0000000c asEntryDesc0x6080
0002411c g     F .text	0000010c OBJ_GetObjectLength
000237e4 g     F .text	00000044 GetOutOfMbxQueue
00027540 g     F .text	00000004 alt_icache_flush_all
000286fa g     O .rodata	0000000c asEntryDesc0x6028
0002833c g     O .rodata	00000058 aName0x8018
0002b0d0 g     O .rwdata	00000004 alt_priority_mask
000283a0 g     O .rodata	0000004c aName0x8010
0002caa4 g     O .bss	00000004 __malloc_free_list
0002712c g     F .text	00000038 alt_ic_irq_enable
00020ad8 g     F .text	00000050 AddObjectsToObjDictionary
0002cacc g     O .bss	0000000c spiTxBuf
0002ca5c g     O .bss	00000002 sCycleDiag
000285ba g     O .rodata	0000000c asEntryDesc0x6068
00028d7a g     O .rodata	00000036 asEntryDesc0x1A0B
0002116c g     F .text	0000003c ECAT_Application
00028e7c g     O .rodata	00000096 aName0x1A09
00029278 g     O .rodata	00000096 aName0x1A04
0002825c g     O .rodata	0000003f aName0x8038
00027fea g     O .rodata	0000000c asEntryDesc0x8078
00027f14 g     O .rodata	0000003d aName0x8088
0002798c g     O .rodata	0000000c aName0x1008
00029dc4 g     O .rwdata	00000024 CurrentChannel3MA0x6020
000283f8 g     O .rodata	00000057 aName0x8008
00029ec4 g     O .rwdata	00000024 VoltageChannel6MVProcessDataMapping0x1A0F
00027a56 g     O .rodata	0000000c asEntryDesc0x8118
0002350c g     F .text	000000e0 ECAT_Init
00028db0 g     O .rodata	00000096 aName0x1A0A
0002721c g     F .text	00000084 alt_load
00027e7c g     O .rodata	0000003d aName0x8098
00029bc2 g     O .rwdata	0000000a AnalogOutputGroupMappingChannel0x8020
00027e30 g     O .rodata	0000003d aName0x80A0
00029e30 g     O .rwdata	00000024 CurrentChannel0MA0x6008
0002c9fc g     O .bss	00000002 nEscAddrInputData
00026b8c g     F .text	00000010 free
00027d98 g     O .rodata	0000003d aName0x80B0
000265f0 g     F .text	00000024 exti0_isr
000206c4 g     F .text	00000004 HW_Release



Disassembly of section .entry:

00020000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   20000:	004000b4 	movhi	at,2
    ori r1, r1, %lo(_start)
   20004:	08406014 	ori	at,at,384
    jmp r1
   20008:	0800683a 	jmp	at

0002000c <_exit>:
	...

Disassembly of section .exceptions:

00020020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   20020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   20024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   20028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   2002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   20030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   20034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   20038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   2003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   20040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   20044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   20048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   2004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   20050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   20054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   20058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   2005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   20060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   20064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   20068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   2006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   20070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   20074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   20078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   2007c:	10000326 	beq	r2,zero,2008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   20080:	20000226 	beq	r4,zero,2008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   20084:	00200fc0 	call	200fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   20088:	00000706 	br	200a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   2008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   20090:	e8bfff17 	ldw	r2,-4(ea)
   20094:	e93fff04 	addi	r4,ea,-4
   20098:	002015c0 	call	2015c <alt_instruction_exception_entry>
   2009c:	1000021e 	bne	r2,zero,200a8 <alt_exception+0x88>
   200a0:	ebffff04 	addi	r15,ea,-4
   200a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   200a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   200ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   200b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   200b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   200b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   200bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   200c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   200c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   200c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   200cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   200d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   200d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   200d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   200dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   200e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   200e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   200e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   200ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   200f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   200f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   200f8:	ef80083a 	eret

000200fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   200fc:	defffe04 	addi	sp,sp,-8
   20100:	dfc00115 	stw	ra,4(sp)
   20104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   20108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   2010c:	040000f4 	movhi	r16,3
   20110:	84331004 	addi	r16,r16,-13248
    i = 0;
   20114:	0005883a 	mov	r2,zero
    mask = 1;
   20118:	00c00044 	movi	r3,1
      if (active & mask)
   2011c:	20ca703a 	and	r5,r4,r3
   20120:	28000b26 	beq	r5,zero,20150 <alt_irq_handler+0x54>
        alt_irq[i].handler(alt_irq[i].context); 
   20124:	100490fa 	slli	r2,r2,3
   20128:	8085883a 	add	r2,r16,r2
   2012c:	10c00017 	ldw	r3,0(r2)
   20130:	11000117 	ldw	r4,4(r2)
   20134:	183ee83a 	callr	r3
   20138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   2013c:	203ff51e 	bne	r4,zero,20114 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   20140:	dfc00117 	ldw	ra,4(sp)
   20144:	dc000017 	ldw	r16,0(sp)
   20148:	dec00204 	addi	sp,sp,8
   2014c:	f800283a 	ret
      mask <<= 1;
   20150:	1806907a 	slli	r3,r3,1
      i++;
   20154:	10800044 	addi	r2,r2,1
      if (active & mask)
   20158:	003ff006 	br	2011c <alt_irq_handler+0x20>

0002015c <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   2015c:	d0a69e17 	ldw	r2,-25992(gp)
{
   20160:	200b883a 	mov	r5,r4
  if(alt_instruction_exception_handler) {
   20164:	10000326 	beq	r2,zero,20174 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   20168:	000d883a 	mov	r6,zero
   2016c:	013fffc4 	movi	r4,-1
   20170:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   20174:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
   20178:	0005883a 	mov	r2,zero
   2017c:	f800283a 	ret

Disassembly of section .text:

00020180 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   20180:	06c000f4 	movhi	sp,3
    ori sp, sp, %lo(__alt_stack_pointer)
   20184:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
   20188:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
   2018c:	d68c1114 	ori	gp,gp,12356
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   20190:	008000b4 	movhi	r2,2
    ori r2, r2, %lo(__bss_start)
   20194:	10b26814 	ori	r2,r2,51616

    movhi r3, %hi(__bss_end)
   20198:	00c000b4 	movhi	r3,2
    ori r3, r3, %lo(__bss_end)
   2019c:	18f35014 	ori	r3,r3,52544

    beq r2, r3, 1f
   201a0:	10c00326 	beq	r2,r3,201b0 <_start+0x30>

0:
    stw zero, (r2)
   201a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   201a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   201ac:	10fffd36 	bltu	r2,r3,201a4 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   201b0:	002721c0 	call	2721c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   201b4:	00272a00 	call	272a0 <alt_main>

000201b8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   201b8:	003fff06 	br	201b8 <alt_after_alt_main>

000201bc <main>:
#include "imported_source/ax58100_hw.h"

int main()
{

  printf("Hello from Nios II!\n");
   201bc:	010000b4 	movhi	r4,2
{
   201c0:	deffff04 	addi	sp,sp,-4
  printf("Hello from Nios II!\n");
   201c4:	211d5c04 	addi	r4,r4,30064
{
   201c8:	dfc00015 	stw	ra,0(sp)
  printf("Hello from Nios II!\n");
   201cc:	0026e740 	call	26e74 <puts>
  	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, invert_me);
  	  delay_ms(1000);
  	  invert_me = ~invert_me;
  }*/

  main_initial();
   201d0:	00204340 	call	20434 <main_initial>

  return 0;
}
   201d4:	0005883a 	mov	r2,zero
   201d8:	dfc00017 	ldw	ra,0(sp)
   201dc:	dec00104 	addi	sp,sp,4
   201e0:	f800283a 	ret

000201e4 <APPL_AckErrorInd>:
*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{

}
   201e4:	f800283a 	ret

000201e8 <APPL_StartMailboxHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}
   201e8:	0005883a 	mov	r2,zero
   201ec:	f800283a 	ret

000201f0 <APPL_StopMailboxHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
   201f0:	0005883a 	mov	r2,zero
   201f4:	f800283a 	ret

000201f8 <APPL_StartInputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
    return ALSTATUSCODE_NOERROR;
}
   201f8:	0005883a 	mov	r2,zero
   201fc:	f800283a 	ret

00020200 <APPL_StopInputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
   20200:	0005883a 	mov	r2,zero
   20204:	f800283a 	ret

00020208 <APPL_StartOutputHandler>:
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
   20208:	0005883a 	mov	r2,zero
   2020c:	f800283a 	ret

00020210 <APPL_StopOutputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
   20210:	0005883a 	mov	r2,zero
   20214:	f800283a 	ret

00020218 <APPL_GenerateMapping>:

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
{
   20218:	defff504 	addi	sp,sp,-44
   2021c:	dd800715 	stw	r22,28(sp)
   20220:	dd400615 	stw	r21,24(sp)
   20224:	dd000515 	stw	r20,20(sp)
   20228:	dcc00415 	stw	r19,16(sp)
   2022c:	dc000115 	stw	r16,4(sp)
   20230:	dfc00a15 	stw	ra,40(sp)
   20234:	df000915 	stw	fp,36(sp)
   20238:	ddc00815 	stw	r23,32(sp)
   2023c:	dc800315 	stw	r18,12(sp)
   20240:	dc400215 	stw	r17,8(sp)
   20244:	2029883a 	mov	r20,r4
   20248:	2827883a 	mov	r19,r5
    UINT32 *pPDOEntry = NULL;
    UINT16 PDOEntryCnt = 0;
   
#if MAX_PD_OUTPUT_SIZE > 0
    /*Scan object 0x1C12 RXPDO assign*/
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   2024c:	002d883a 	mov	r22,zero
    UINT16 OutputSize = 0;
   20250:	0021883a 	mov	r16,zero
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20254:	d5600f04 	addi	r21,gp,-32708
   20258:	d0e00f0b 	ldhu	r3,-32708(gp)
   2025c:	b0bfffcc 	andi	r2,r22,65535
   20260:	10c01a36 	bltu	r2,r3,202cc <APPL_GenerateMapping+0xb4>
    UINT16 result = ALSTATUSCODE_NOERROR;
   20264:	0023883a 	mov	r17,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
            break;
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
   20268:	84bfffcc 	andi	r18,r16,65535
   2026c:	948001c4 	addi	r18,r18,7
#endif

#if MAX_PD_INPUT_SIZE > 0
    if(result == 0)
   20270:	88bfffcc 	andi	r2,r17,65535
    OutputSize = (OutputSize + 7) >> 3;
   20274:	9025d0fa 	srai	r18,r18,3
    if(result == 0)
   20278:	10005026 	beq	r2,zero,203bc <APPL_GenerateMapping+0x1a4>
    UINT16 InputSize = 0;
   2027c:	0021883a 	mov	r16,zero
   20280:	04400944 	movi	r17,37
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
                break;
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
   20284:	843fffcc 	andi	r16,r16,65535
   20288:	840001c4 	addi	r16,r16,7
   2028c:	8021d0fa 	srai	r16,r16,3
#endif

    *pInputSize = InputSize;
    *pOutputSize = OutputSize;
    return result;
}
   20290:	8805883a 	mov	r2,r17
    InputSize = (InputSize + 7) >> 3;
   20294:	a400000d 	sth	r16,0(r20)
    *pOutputSize = OutputSize;
   20298:	9c80000d 	sth	r18,0(r19)
}
   2029c:	dfc00a17 	ldw	ra,40(sp)
   202a0:	df000917 	ldw	fp,36(sp)
   202a4:	ddc00817 	ldw	r23,32(sp)
   202a8:	dd800717 	ldw	r22,28(sp)
   202ac:	dd400617 	ldw	r21,24(sp)
   202b0:	dd000517 	ldw	r20,20(sp)
   202b4:	dcc00417 	ldw	r19,16(sp)
   202b8:	dc800317 	ldw	r18,12(sp)
   202bc:	dc400217 	ldw	r17,8(sp)
   202c0:	dc000117 	ldw	r16,4(sp)
   202c4:	dec00b04 	addi	sp,sp,44
   202c8:	f800283a 	ret
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
   202cc:	1004907a 	slli	r2,r2,1
   202d0:	a885883a 	add	r2,r21,r2
   202d4:	1100008b 	ldhu	r4,2(r2)
   202d8:	00240e00 	call	240e0 <OBJ_GetObjectHandle>
   202dc:	1025883a 	mov	r18,r2
        if(pPDO != NULL)
   202e0:	10001326 	beq	r2,zero,20330 <APPL_GenerateMapping+0x118>
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   202e4:	10800617 	ldw	r2,24(r2)
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   202e8:	0007883a 	mov	r3,zero
   202ec:	1700000b 	ldhu	fp,0(r2)
   202f0:	18bfffcc 	andi	r2,r3,65535
   202f4:	1700021e 	bne	r2,fp,20300 <APPL_GenerateMapping+0xe8>
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   202f8:	b5800044 	addi	r22,r22,1
   202fc:	003fd606 	br	20258 <APPL_GenerateMapping+0x40>
                pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   20300:	1c400044 	addi	r17,r3,1
   20304:	900b883a 	mov	r5,r18
   20308:	89003fcc 	andi	r4,r17,255
   2030c:	95c00617 	ldw	r23,24(r18)
   20310:	00246240 	call	24624 <OBJ_GetEntryOffset>
   20314:	1004d0fa 	srli	r2,r2,3
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20318:	8807883a 	mov	r3,r17
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   2031c:	1087ff8c 	andi	r2,r2,8190
   20320:	b8af883a 	add	r23,r23,r2
   20324:	b8800003 	ldbu	r2,0(r23)
   20328:	1421883a 	add	r16,r2,r16
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   2032c:	003ff006 	br	202f0 <APPL_GenerateMapping+0xd8>
            OutputSize = 0;
   20330:	0021883a 	mov	r16,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
   20334:	04400944 	movi	r17,37
   20338:	003fcb06 	br	20268 <APPL_GenerateMapping+0x50>
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
   2033c:	1004907a 	slli	r2,r2,1
   20340:	00c000f4 	movhi	r3,3
   20344:	10c7883a 	add	r3,r2,r3
   20348:	1927958b 	ldhu	r4,-25002(r3)
   2034c:	00240e00 	call	240e0 <OBJ_GetObjectHandle>
   20350:	102d883a 	mov	r22,r2
            if(pPDO != NULL)
   20354:	10001c26 	beq	r2,zero,203c8 <APPL_GenerateMapping+0x1b0>
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   20358:	10800617 	ldw	r2,24(r2)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   2035c:	8807883a 	mov	r3,r17
   20360:	1180000b 	ldhu	r6,0(r2)
   20364:	18bfffcc 	andi	r2,r3,65535
   20368:	1180061e 	bne	r2,r6,20384 <APPL_GenerateMapping+0x16c>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   2036c:	bdc00044 	addi	r23,r23,1
   20370:	008000f4 	movhi	r2,3
   20374:	10e7950b 	ldhu	r3,-25004(r2)
   20378:	b8bfffcc 	andi	r2,r23,65535
   2037c:	10ffef36 	bltu	r2,r3,2033c <APPL_GenerateMapping+0x124>
   20380:	003fc006 	br	20284 <APPL_GenerateMapping+0x6c>
                    pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   20384:	1d400044 	addi	r21,r3,1
   20388:	b00b883a 	mov	r5,r22
   2038c:	a9003fcc 	andi	r4,r21,255
   20390:	b7000617 	ldw	fp,24(r22)
   20394:	d9800015 	stw	r6,0(sp)
   20398:	00246240 	call	24624 <OBJ_GetEntryOffset>
   2039c:	1004d0fa 	srli	r2,r2,3
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203a0:	d9800017 	ldw	r6,0(sp)
   203a4:	a807883a 	mov	r3,r21
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   203a8:	1087ff8c 	andi	r2,r2,8190
   203ac:	e0b9883a 	add	fp,fp,r2
   203b0:	e0800003 	ldbu	r2,0(fp)
   203b4:	1421883a 	add	r16,r2,r16
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203b8:	003fea06 	br	20364 <APPL_GenerateMapping+0x14c>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   203bc:	882f883a 	mov	r23,r17
    UINT16 InputSize = 0;
   203c0:	8821883a 	mov	r16,r17
   203c4:	003fea06 	br	20370 <APPL_GenerateMapping+0x158>
                InputSize = 0;
   203c8:	8821883a 	mov	r16,r17
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
   203cc:	04400904 	movi	r17,36
   203d0:	003fac06 	br	20284 <APPL_GenerateMapping+0x6c>

000203d4 <APPL_InputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   203d4:	0005883a 	mov	r2,zero
   203d8:	014000f4 	movhi	r5,3
   203dc:	2967950b 	ldhu	r5,-25004(r5)
   203e0:	10c03fcc 	andi	r3,r2,255
   203e4:	19400136 	bltu	r3,r5,203ec <APPL_InputMapping+0x18>
					   sizeof(MLInferenceChannel0x6088.aEntries));
				pTmpData += sizeof(MLInferenceChannel0x6088.aEntries);
				break; */
		}
	}
}
   203e8:	f800283a 	ret
		switch (sTxPDOassign.aEntries[j]) {
   203ec:	11403fcc 	andi	r5,r2,255
   203f0:	280a907a 	slli	r5,r5,1
   203f4:	00c000f4 	movhi	r3,3
   203f8:	28c7883a 	add	r3,r5,r3
   203fc:	18e7958b 	ldhu	r3,-25002(r3)
   20400:	18c68018 	cmpnei	r3,r3,6656
   20404:	1800051e 	bne	r3,zero,2041c <APPL_InputMapping+0x48>
				memcpy(pTmpData, &DeviceID0x6000.DeviceID,
   20408:	d0e00e83 	ldbu	r3,-32710(gp)
				pTmpData += sizeof(DeviceID0x6000.DeviceID);
   2040c:	21000084 	addi	r4,r4,2
				memcpy(pTmpData, &DeviceID0x6000.DeviceID,
   20410:	20ffff85 	stb	r3,-2(r4)
   20414:	d0e00ec3 	ldbu	r3,-32709(gp)
   20418:	20ffffc5 	stb	r3,-1(r4)
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   2041c:	10800044 	addi	r2,r2,1
   20420:	003fed06 	br	203d8 <APPL_InputMapping+0x4>

00020424 <APPL_OutputMapping>:
						   sizeof(OnOffContinuousModeGroup0x7008.aEntries));
					pTmpData += sizeof(OnOffContinuousModeGroup0x7008.aEntries);
					break;
	        }
	    }*/
}
   20424:	f800283a 	ret

00020428 <APPL_Application>:
void APPL_Application(void)
{
	//static uint32_t haha = 0;
	//DeviceID0x6000.DeviceID = 0x78; //haha++;

}
   20428:	f800283a 	ret

0002042c <APPL_GetDeviceID>:
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GetDeviceID()
{
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    return 0x5;
}
   2042c:	00800144 	movi	r2,5
   20430:	f800283a 	ret

00020434 <main_initial>:
/**

 \brief    This is the main function

*////////////////////////////////////////////////////////////////////////////////////////
void main_initial(void) {
   20434:	deffff04 	addi	sp,sp,-4
   20438:	dfc00015 	stw	ra,0(sp)
    /* initialize the Hardware and the EtherCAT Slave Controller */
    HW_Init();
   2043c:	00207ac0 	call	207ac <HW_Init>
    MainInit();
   20440:	00210840 	call	21084 <MainInit>

    bRunApplication = TRUE;
   20444:	00800044 	movi	r2,1
   20448:	d0a66805 	stb	r2,-26208(gp)
    do {
        MainLoop();
   2044c:	00214c80 	call	214c8 <MainLoop>
    } while (bRunApplication == TRUE);
   20450:	d0a66803 	ldbu	r2,-26208(gp)
   20454:	10800060 	cmpeqi	r2,r2,1
   20458:	103ffc1e 	bne	r2,zero,2044c <main_initial+0x18>

    HW_Release();
}
   2045c:	dfc00017 	ldw	ra,0(sp)
   20460:	dec00104 	addi	sp,sp,4
    HW_Release();
   20464:	00206c41 	jmpi	206c4 <HW_Release>

00020468 <HW_SPI_Read>:
 * @param pBuf
 * @param Addr
 * @param ByteLen
 */

static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   20468:	defff504 	addi	sp,sp,-44
   2046c:	ddc00915 	stw	r23,36(sp)
   20470:	dd000615 	stw	r20,24(sp)

        /* Set dummy byte */
        spiTxBuf[DataOffset] = 0xff;

        /* Set read terminal byte */
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20474:	05c000f4 	movhi	r23,3
        spiTxBuf[0] = ptr[1];
   20478:	050000f4 	movhi	r20,3
static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   2047c:	dd400715 	stw	r21,28(sp)
   20480:	dc800415 	stw	r18,16(sp)
   20484:	dc400315 	stw	r17,12(sp)
   20488:	dc000215 	stw	r16,8(sp)
   2048c:	dfc00a15 	stw	ra,40(sp)
   20490:	dd800815 	stw	r22,32(sp)
   20494:	dcc00515 	stw	r19,20(sp)
   20498:	2023883a 	mov	r17,r4
   2049c:	2825883a 	mov	r18,r5
   204a0:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   204a4:	a532b304 	addi	r20,r20,-13620
        spiTxBuf[DataOffset] = 0xff;
   204a8:	057fffc4 	movi	r21,-1
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   204ac:	bdf2b3c4 	addi	r23,r23,-13617
    while (ByteLen) {
   204b0:	80bfffcc 	andi	r2,r16,65535
   204b4:	10000b1e 	bne	r2,zero,204e4 <HW_SPI_Read+0x7c>
        /* Next section */
        Addr += XferLen;
        pBuf += XferLen;
        ByteLen -= XferLen;
    }
}
   204b8:	dfc00a17 	ldw	ra,40(sp)
   204bc:	ddc00917 	ldw	r23,36(sp)
   204c0:	dd800817 	ldw	r22,32(sp)
   204c4:	dd400717 	ldw	r21,28(sp)
   204c8:	dd000617 	ldw	r20,24(sp)
   204cc:	dcc00517 	ldw	r19,20(sp)
   204d0:	dc800417 	ldw	r18,16(sp)
   204d4:	dc400317 	ldw	r17,12(sp)
   204d8:	dc000217 	ldw	r16,8(sp)
   204dc:	dec00b04 	addi	sp,sp,44
   204e0:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   204e4:	10800270 	cmpltui	r2,r2,9
   204e8:	802d883a 	mov	r22,r16
   204ec:	1000011e 	bne	r2,zero,204f4 <HW_SPI_Read+0x8c>
   204f0:	05800204 	movi	r22,8
        AddrTmp = AddrTmp << 3;
   204f4:	900490fa 	slli	r2,r18,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   204f8:	b4ffffcc 	andi	r19,r22,65535
        spiTxBuf[0] = ptr[1];
   204fc:	010000f4 	movhi	r4,3
   20500:	10ffffcc 	andi	r3,r2,65535
   20504:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   20508:	108000d4 	ori	r2,r2,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2050c:	980d883a 	mov	r6,r19
        spiTxBuf[0] = ptr[1];
   20510:	20f2b305 	stb	r3,-13620(r4)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20514:	000b883a 	mov	r5,zero
   20518:	b809883a 	mov	r4,r23
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   2051c:	a0800045 	stb	r2,1(r20)
        spiTxBuf[DataOffset] = 0xff;
   20520:	a5400085 	stb	r21,2(r20)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20524:	0026eac0 	call	26eac <memset>
        spiTxBuf[DataOffset + XferLen] = 0xff;
   20528:	008000f4 	movhi	r2,3
   2052c:	9885883a 	add	r2,r19,r2
   20530:	1572b385 	stb	r21,-13618(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   20534:	00800134 	movhi	r2,4
   20538:	10041435 	stwio	zero,4176(r2)
													DataOffset + XferLen, 0);
   2053c:	988000c4 	addi	r2,r19,3
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20540:	01c000f4 	movhi	r7,3
   20544:	018000f4 	movhi	r6,3
   20548:	01000134 	movhi	r4,4
   2054c:	d8000115 	stw	zero,4(sp)
   20550:	d8800015 	stw	r2,0(sp)
   20554:	39f2b004 	addi	r7,r7,-13632
   20558:	31b2b304 	addi	r6,r6,-13620
   2055c:	000b883a 	mov	r5,zero
   20560:	21040004 	addi	r4,r4,4096
   20564:	00267e40 	call	267e4 <spi_transmit_receive>
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20568:	00c00044 	movi	r3,1
   2056c:	00800134 	movhi	r2,4
   20570:	10c41435 	stwio	r3,4176(r2)
        for (i = 0; i < XferLen; i++) {
   20574:	008000f4 	movhi	r2,3
   20578:	10b2b004 	addi	r2,r2,-13632
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   2057c:	0007883a 	mov	r3,zero
            pBuf[i] = spiRxBuf[DataOffset + i];
   20580:	114000c3 	ldbu	r5,3(r2)
   20584:	88c9883a 	add	r4,r17,r3
        for (i = 0; i < XferLen; i++) {
   20588:	18c00044 	addi	r3,r3,1
            pBuf[i] = spiRxBuf[DataOffset + i];
   2058c:	21400005 	stb	r5,0(r4)
        for (i = 0; i < XferLen; i++) {
   20590:	193fffcc 	andi	r4,r3,65535
   20594:	10800044 	addi	r2,r2,1
   20598:	24fff936 	bltu	r4,r19,20580 <HW_SPI_Read+0x118>
        Addr += XferLen;
   2059c:	b4a5883a 	add	r18,r22,r18
        pBuf += XferLen;
   205a0:	8ce3883a 	add	r17,r17,r19
        ByteLen -= XferLen;
   205a4:	85a1c83a 	sub	r16,r16,r22
   205a8:	003fc106 	br	204b0 <HW_SPI_Read+0x48>

000205ac <HW_SPI_Write>:
 *
 * @param pData
 * @param Addr
 * @param ByteLen
 */
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   205ac:	defff604 	addi	sp,sp,-40
   205b0:	dd400715 	stw	r21,28(sp)
   205b4:	dd000615 	stw	r20,24(sp)
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
        DataOffset = 2;
#endif

        /* Set transmit data bytes */
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   205b8:	054000f4 	movhi	r21,3
        spiTxBuf[0] = ptr[1];
   205bc:	050000f4 	movhi	r20,3
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   205c0:	dcc00515 	stw	r19,20(sp)
   205c4:	dc800415 	stw	r18,16(sp)
   205c8:	dc000215 	stw	r16,8(sp)
   205cc:	dfc00915 	stw	ra,36(sp)
   205d0:	dd800815 	stw	r22,32(sp)
   205d4:	dc400315 	stw	r17,12(sp)
   205d8:	2025883a 	mov	r18,r4
   205dc:	2827883a 	mov	r19,r5
   205e0:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   205e4:	a532b304 	addi	r20,r20,-13620
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   205e8:	ad72b384 	addi	r21,r21,-13618
    while (ByteLen) {
   205ec:	80bfffcc 	andi	r2,r16,65535
   205f0:	10000a1e 	bne	r2,zero,2061c <HW_SPI_Write+0x70>

        Addr += XferLen;
        pData += XferLen;
        ByteLen -= XferLen;
    }
}
   205f4:	dfc00917 	ldw	ra,36(sp)
   205f8:	dd800817 	ldw	r22,32(sp)
   205fc:	dd400717 	ldw	r21,28(sp)
   20600:	dd000617 	ldw	r20,24(sp)
   20604:	dcc00517 	ldw	r19,20(sp)
   20608:	dc800417 	ldw	r18,16(sp)
   2060c:	dc400317 	ldw	r17,12(sp)
   20610:	dc000217 	ldw	r16,8(sp)
   20614:	dec00a04 	addi	sp,sp,40
   20618:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   2061c:	10c00268 	cmpgeui	r3,r2,9
   20620:	1800241e 	bne	r3,zero,206b4 <HW_SPI_Write+0x108>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   20624:	108000e0 	cmpeqi	r2,r2,3
   20628:	1000241e 	bne	r2,zero,206bc <HW_SPI_Write+0x110>
   2062c:	8023883a 	mov	r17,r16
        AddrTmp = AddrTmp << 3;
   20630:	980490fa 	slli	r2,r19,3
        spiTxBuf[0] = ptr[1];
   20634:	010000f4 	movhi	r4,3
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20638:	8dbfffcc 	andi	r22,r17,65535
        spiTxBuf[0] = ptr[1];
   2063c:	10ffffcc 	andi	r3,r2,65535
   20640:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   20644:	10800114 	ori	r2,r2,4
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20648:	b00d883a 	mov	r6,r22
        spiTxBuf[0] = ptr[1];
   2064c:	20f2b305 	stb	r3,-13620(r4)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20650:	900b883a 	mov	r5,r18
   20654:	a809883a 	mov	r4,r21
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   20658:	a0800045 	stb	r2,1(r20)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   2065c:	0026e840 	call	26e84 <memcpy>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   20660:	00800134 	movhi	r2,4
   20664:	10041435 	stwio	zero,4176(r2)
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20668:	88800084 	addi	r2,r17,2
   2066c:	10bfffcc 	andi	r2,r2,65535
   20670:	01c000f4 	movhi	r7,3
   20674:	018000f4 	movhi	r6,3
   20678:	01000134 	movhi	r4,4
   2067c:	d8000115 	stw	zero,4(sp)
   20680:	d8800015 	stw	r2,0(sp)
   20684:	39f2b004 	addi	r7,r7,-13632
   20688:	31b2b304 	addi	r6,r6,-13620
   2068c:	000b883a 	mov	r5,zero
   20690:	21040004 	addi	r4,r4,4096
   20694:	00267e40 	call	267e4 <spi_transmit_receive>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20698:	00c00044 	movi	r3,1
   2069c:	00800134 	movhi	r2,4
   206a0:	10c41435 	stwio	r3,4176(r2)
        Addr += XferLen;
   206a4:	9c67883a 	add	r19,r19,r17
        pData += XferLen;
   206a8:	95a5883a 	add	r18,r18,r22
        ByteLen -= XferLen;
   206ac:	8461c83a 	sub	r16,r16,r17
   206b0:	003fce06 	br	205ec <HW_SPI_Write+0x40>
            XferLen = HW_SPI_MAX_DATA_FRAGMENT_SIZE;
   206b4:	04400204 	movi	r17,8
   206b8:	003fdd06 	br	20630 <HW_SPI_Write+0x84>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   206bc:	04400084 	movi	r17,2
   206c0:	003fdb06 	br	20630 <HW_SPI_Write+0x84>

000206c4 <HW_Release>:
 * @brief  This function shall be implemented if hardware resources need to be
 * release when the sample application stops.
 * @param  None
 * @retval None
 */
void HW_Release(void) {}
   206c4:	f800283a 	ret

000206c8 <HW_GetALEventRegister_Isr>:
 * interrupts service routines. The behaviour is equal to
 * "HW_GetALEventRegister()"
 * @param  None
 * @retval First two Bytes of ALEvent register (0x220)
 */
uint16_t HW_GetALEventRegister_Isr(void) {
   206c8:	deffff04 	addi	sp,sp,-4
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscReadIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   206cc:	01800084 	movi	r6,2
   206d0:	01408804 	movi	r5,544
   206d4:	d1265784 	addi	r4,gp,-26274
uint16_t HW_GetALEventRegister_Isr(void) {
   206d8:	dfc00015 	stw	ra,0(sp)
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   206dc:	00204680 	call	20468 <HW_SPI_Read>
}
   206e0:	d0a6578b 	ldhu	r2,-26274(gp)
   206e4:	dfc00017 	ldw	ra,0(sp)
   206e8:	dec00104 	addi	sp,sp,4
   206ec:	f800283a 	ret

000206f0 <HW_EscRead>:
void HW_EscRead(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   206f0:	deffff04 	addi	sp,sp,-4
   206f4:	dfc00015 	stw	ra,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   206f8:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   206fc:	00ffff84 	movi	r3,-2
   20700:	10c4703a 	and	r2,r2,r3
   20704:	1001703a 	wrctl	status,r2
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20708:	31bfffcc 	andi	r6,r6,65535
   2070c:	297fffcc 	andi	r5,r5,65535
   20710:	00204680 	call	20468 <HW_SPI_Read>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   20714:	00800044 	movi	r2,1
   20718:	1001703a 	wrctl	status,r2
}
   2071c:	dfc00017 	ldw	ra,0(sp)
   20720:	dec00104 	addi	sp,sp,4
   20724:	f800283a 	ret

00020728 <HW_GetALEventRegister>:
uint16_t HW_GetALEventRegister(void) {
   20728:	deffff04 	addi	sp,sp,-4
   2072c:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   20730:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20734:	00ffff84 	movi	r3,-2
   20738:	10c4703a 	and	r2,r2,r3
   2073c:	1001703a 	wrctl	status,r2
    HW_EscRead((MEM_ADDR*)EscALEvent.Byte, ESC_AL_EVENT_OFFSET, 2);
   20740:	01800084 	movi	r6,2
   20744:	01408804 	movi	r5,544
   20748:	d1265784 	addi	r4,gp,-26274
   2074c:	00206f00 	call	206f0 <HW_EscRead>
  NIOS2_WRITE_STATUS (context);
   20750:	00800044 	movi	r2,1
   20754:	1001703a 	wrctl	status,r2
}
   20758:	d0a6578b 	ldhu	r2,-26274(gp)
   2075c:	dfc00017 	ldw	ra,0(sp)
   20760:	dec00104 	addi	sp,sp,4
   20764:	f800283a 	ret

00020768 <HW_EscReadIsr>:
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20768:	31bfffcc 	andi	r6,r6,65535
   2076c:	297fffcc 	andi	r5,r5,65535
   20770:	00204681 	jmpi	20468 <HW_SPI_Read>

00020774 <HW_EscWrite>:
 * @param  Address     EtherCAT ASIC address ( upper limit is 0x1FFF ) for
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWrite(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   20774:	deffff04 	addi	sp,sp,-4
   20778:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   2077c:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20780:	00ffff84 	movi	r3,-2
   20784:	10c4703a 	and	r2,r2,r3
   20788:	1001703a 	wrctl	status,r2

#if AL_EVENT_ENABLED
    DISABLE_AL_EVENT_INT;
#endif
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   2078c:	31bfffcc 	andi	r6,r6,65535
   20790:	297fffcc 	andi	r5,r5,65535
   20794:	00205ac0 	call	205ac <HW_SPI_Write>
  NIOS2_WRITE_STATUS (context);
   20798:	00800044 	movi	r2,1
   2079c:	1001703a 	wrctl	status,r2
#if AL_EVENT_ENABLED
    ENABLE_AL_EVENT_INT;
#endif
}
   207a0:	dfc00017 	ldw	ra,0(sp)
   207a4:	dec00104 	addi	sp,sp,4
   207a8:	f800283a 	ret

000207ac <HW_Init>:
uint8_t HW_Init(void) {
   207ac:	defffd04 	addi	sp,sp,-12
   207b0:	dc000115 	stw	r16,4(sp)
   207b4:	dfc00215 	stw	ra,8(sp)
        intMask = 0x93;
   207b8:	040024c4 	movi	r16,147
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   207bc:	01800104 	movi	r6,4
   207c0:	01408104 	movi	r5,516
   207c4:	d809883a 	mov	r4,sp
        intMask = 0x93;
   207c8:	dc000015 	stw	r16,0(sp)
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   207cc:	00207740 	call	20774 <HW_EscWrite>
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   207d0:	01800104 	movi	r6,4
   207d4:	01408104 	movi	r5,516
   207d8:	d809883a 	mov	r4,sp
        intMask = 0;
   207dc:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   207e0:	00206f00 	call	206f0 <HW_EscRead>
    } while (intMask != 0x93);
   207e4:	d8800017 	ldw	r2,0(sp)
   207e8:	108024d8 	cmpnei	r2,r2,147
   207ec:	103ff31e 	bne	r2,zero,207bc <HW_Init+0x10>
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   207f0:	01800104 	movi	r6,4
   207f4:	01408104 	movi	r5,516
   207f8:	d809883a 	mov	r4,sp
    intMask = 0x00;
   207fc:	d8000015 	stw	zero,0(sp)
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20800:	00207740 	call	20774 <HW_EscWrite>
	init_exti0_it();
   20804:	00266140 	call	26614 <init_exti0_it>
   20808:	00800044 	movi	r2,1
   2080c:	1001703a 	wrctl	status,r2
    if (bootSwitchID) {
   20810:	d0a6570b 	ldhu	r2,-26276(gp)
   20814:	10000426 	beq	r2,zero,20828 <HW_Init+0x7c>
        HW_EscWriteWord(bootSwitchID, ESC_ALIAS_ADDRESS_OFFSET);
   20818:	01800084 	movi	r6,2
   2081c:	01400484 	movi	r5,18
   20820:	d1265704 	addi	r4,gp,-26276
   20824:	00207740 	call	20774 <HW_EscWrite>
}
   20828:	0005883a 	mov	r2,zero
   2082c:	dfc00217 	ldw	ra,8(sp)
   20830:	dc000117 	ldw	r16,4(sp)
   20834:	dec00304 	addi	sp,sp,12
   20838:	f800283a 	ret

0002083c <HW_EscWriteIsr>:
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWriteIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   2083c:	31bfffcc 	andi	r6,r6,65535
   20840:	297fffcc 	andi	r5,r5,65535
   20844:	00205ac1 	jmpi	205ac <HW_SPI_Write>

00020848 <HW_SYNC0_IRQHandler>:
 */
void HW_SYNC0_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC0_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC0_PIN);
        Sync0_Isr();
   20848:	00211a81 	jmpi	211a8 <Sync0_Isr>

0002084c <HW_SYNC1_IRQHandler>:

void HW_SYNC1_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC1_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC1_PIN);
        Sync1_Isr();
   2084c:	00210301 	jmpi	21030 <Sync1_Isr>

00020850 <HW_TIMETASK_IRQHandler>:
	if ((__HAL_TIM_GET_IT_SOURCE(&HW_TIMETASK_INSTANCE_H, TIM_IT_UPDATE) ==
		 SET) &&
		(__HAL_TIM_GET_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE) != 0)) {
		__HAL_TIM_CLEAR_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE);
		*/
		ECAT_CheckTimer();
   20850:	0020d641 	jmpi	20d64 <ECAT_CheckTimer>

00020854 <COE_SyncTimeStamp>:
          Called from the Timer handler 
*////////////////////////////////////////////////////////////////////////////////////////
void COE_SyncTimeStamp(void)
{

    if (b32BitDc)
   20854:	d0a67483 	ldbu	r2,-26158(gp)
{
   20858:	defffe04 	addi	sp,sp,-8
   2085c:	dfc00115 	stw	ra,4(sp)
    if (b32BitDc)
   20860:	10001226 	beq	r2,zero,208ac <COE_SyncTimeStamp+0x58>
    {
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   20864:	d0a65c17 	ldw	r2,-26256(gp)


        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   20868:	d809883a 	mov	r4,sp
   2086c:	01800104 	movi	r6,4
   20870:	01424404 	movi	r5,2320
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   20874:	d8800015 	stw	r2,0(sp)
        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   20878:	00206f00 	call	206f0 <HW_EscRead>

        /*update the lower 32Bit*/
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   2087c:	d8800017 	ldw	r2,0(sp)

        if (DcTime < u32LastDc32Value)
   20880:	d1265b17 	ldw	r4,-26260(gp)
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   20884:	d0e65d17 	ldw	r3,-26252(gp)
   20888:	d0a65c15 	stw	r2,-26256(gp)
        if (DcTime < u32LastDc32Value)
   2088c:	1100022e 	bgeu	r2,r4,20898 <COE_SyncTimeStamp+0x44>
        {
            /*32Bit overrun*/
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
   20890:	18c00044 	addi	r3,r3,1
   20894:	d0e65d15 	stw	r3,-26252(gp)
        }
        
        u32LastDc32Value = DcTime;
   20898:	d0a65b15 	stw	r2,-26260(gp)
        /*The DC unit supports 64Bit => update the complete object*/
        
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
    }

    u32CheckForDcOverrunCnt = 0;
   2089c:	d0265a15 	stw	zero,-26264(gp)

}
   208a0:	dfc00117 	ldw	ra,4(sp)
   208a4:	dec00204 	addi	sp,sp,8
   208a8:	f800283a 	ret
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
   208ac:	01800204 	movi	r6,8
   208b0:	01424404 	movi	r5,2320
   208b4:	d1265c04 	addi	r4,gp,-26256
   208b8:	00206f00 	call	206f0 <HW_EscRead>
   208bc:	003ff706 	br	2089c <COE_SyncTimeStamp+0x48>

000208c0 <Read0x10F8>:
{
   208c0:	defffc04 	addi	sp,sp,-16
    if (index != 0x10F8)
   208c4:	20bfffcc 	andi	r2,r4,65535
{
   208c8:	dfc00315 	stw	ra,12(sp)
   208cc:	dc800215 	stw	r18,8(sp)
   208d0:	dc400115 	stw	r17,4(sp)
   208d4:	dc000015 	stw	r16,0(sp)
    if (index != 0x10F8)
   208d8:	10843e18 	cmpnei	r2,r2,4344
{
   208dc:	d8c00403 	ldbu	r3,16(sp)
    if (index != 0x10F8)
   208e0:	1000151e 	bne	r2,zero,20938 <Read0x10F8+0x78>
    if (bCompleteAccess)
   208e4:	18c03fcc 	andi	r3,r3,255
   208e8:	1800151e 	bne	r3,zero,20940 <Read0x10F8+0x80>
   208ec:	2821883a 	mov	r16,r5
    if (subindex > 0)
   208f0:	29403fcc 	andi	r5,r5,255
   208f4:	2800141e 	bne	r5,zero,20948 <Read0x10F8+0x88>
    if (dataSize > 8)
   208f8:	30800268 	cmpgeui	r2,r6,9
   208fc:	3023883a 	mov	r17,r6
   20900:	1000131e 	bne	r2,zero,20950 <Read0x10F8+0x90>
   20904:	3825883a 	mov	r18,r7
    COE_SyncTimeStamp();
   20908:	00208540 	call	20854 <COE_SyncTimeStamp>
    MEMCPY(pData, &u64Timestamp, dataSize);
   2090c:	880d883a 	mov	r6,r17
   20910:	d1665c04 	addi	r5,gp,-26256
   20914:	9009883a 	mov	r4,r18
   20918:	0026e840 	call	26e84 <memcpy>
}
   2091c:	8005883a 	mov	r2,r16
   20920:	dfc00317 	ldw	ra,12(sp)
   20924:	dc800217 	ldw	r18,8(sp)
   20928:	dc400117 	ldw	r17,4(sp)
   2092c:	dc000017 	ldw	r16,0(sp)
   20930:	dec00404 	addi	sp,sp,16
   20934:	f800283a 	ret
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
   20938:	040002c4 	movi	r16,11
   2093c:	003ff706 	br	2091c <Read0x10F8+0x5c>
        return ABORTIDX_UNSUPPORTED_ACCESS;
   20940:	04000144 	movi	r16,5
   20944:	003ff506 	br	2091c <Read0x10F8+0x5c>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   20948:	04000444 	movi	r16,17
   2094c:	003ff306 	br	2091c <Read0x10F8+0x5c>
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
   20950:	040003c4 	movi	r16,15
   20954:	003ff106 	br	2091c <Read0x10F8+0x5c>

00020958 <COE_GetObjectDictionary>:
 \brief    returns the pointer to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
OBJCONST TOBJECT OBJMEM * COE_GetObjectDictionary(void)
{
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
}
   20958:	d0a65817 	ldw	r2,-26272(gp)
   2095c:	f800283a 	ret

00020960 <COE_UpdateSyncErrorStatus>:
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   20960:	00c000f4 	movhi	r3,3
   20964:	18f2fb04 	addi	r3,r3,-13332
   20968:	18800a8b 	ldhu	r2,42(r3)
   2096c:	10000f1e 	bne	r2,zero,209ac <COE_UpdateSyncErrorStatus+0x4c>
   20970:	008000f4 	movhi	r2,3
   20974:	19000a0b 	ldhu	r4,40(r3)
   20978:	10abfb0b 	ldhu	r2,-20500(r2)
   2097c:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManOutPar.u8SyncError = 1;
   20980:	18801005 	stb	r2,64(r3)
    {
        sSyncManOutPar.u8SyncError = 0;
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   20984:	00c000f4 	movhi	r3,3
   20988:	18f2ea04 	addi	r3,r3,-13400
   2098c:	18800a8b 	ldhu	r2,42(r3)
   20990:	1000081e 	bne	r2,zero,209b4 <COE_UpdateSyncErrorStatus+0x54>
   20994:	008000f4 	movhi	r2,3
   20998:	19000a0b 	ldhu	r4,40(r3)
   2099c:	10abfb0b 	ldhu	r2,-20500(r2)
   209a0:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManInPar.u8SyncError = 1;
   209a4:	18801005 	stb	r2,64(r3)
    else
    {
        sSyncManInPar.u8SyncError = 0;
    }

}
   209a8:	f800283a 	ret
   209ac:	00800044 	movi	r2,1
   209b0:	003ff306 	br	20980 <COE_UpdateSyncErrorStatus+0x20>
   209b4:	00800044 	movi	r2,1
   209b8:	003ffa06 	br	209a4 <COE_UpdateSyncErrorStatus+0x44>

000209bc <COE_AddObjectToDic>:

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
    if(pNewObjEntry != NULL)
   209bc:	20002026 	beq	r4,zero,20a40 <COE_AddObjectToDic+0x84>
    {
        if(ObjDicList == NULL)
   209c0:	d0a65817 	ldw	r2,-26272(gp)
   209c4:	1000051e 	bne	r2,zero,209dc <COE_AddObjectToDic+0x20>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
   209c8:	d1265815 	stw	r4,-26272(gp)
            ObjDicList->pNext = NULL;
   209cc:	20000115 	stw	zero,4(r4)
            ObjDicList->pPrev = NULL;
   209d0:	20000015 	stw	zero,0(r4)
            return 0;
   209d4:	0005883a 	mov	r2,zero
   209d8:	f800283a 	ret
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
   209dc:	1140020b 	ldhu	r5,8(r2)
   209e0:	20c0020b 	ldhu	r3,8(r4)
   209e4:	1940142e 	bgeu	r3,r5,20a38 <COE_AddObjectToDic+0x7c>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
   209e8:	20000015 	stw	zero,0(r4)
            pNewObjEntry->pNext = ObjDicList;
   209ec:	20800115 	stw	r2,4(r4)
            ObjDicList->pPrev = pNewObjEntry;
   209f0:	11000015 	stw	r4,0(r2)
            ObjDicList = pNewObjEntry;
   209f4:	d1265815 	stw	r4,-26272(gp)
            return 0;
   209f8:	003ff606 	br	209d4 <COE_AddObjectToDic+0x18>
                if(pDicEntry->Index == pNewObjEntry->Index)
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
   209fc:	1940072e 	bgeu	r3,r5,20a1c <COE_AddObjectToDic+0x60>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20a00:	10c00017 	ldw	r3,0(r2)
                    pNewObjEntry->pNext = pDicEntry;
   20a04:	20800115 	stw	r2,4(r4)
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20a08:	20c00015 	stw	r3,0(r4)

                    if(pDicEntry->pPrev != NULL)
   20a0c:	18000126 	beq	r3,zero,20a14 <COE_AddObjectToDic+0x58>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
   20a10:	19000115 	stw	r4,4(r3)

                    pDicEntry->pPrev = pNewObjEntry;
   20a14:	11000015 	stw	r4,0(r2)

                    return 0;
   20a18:	003fee06 	br	209d4 <COE_AddObjectToDic+0x18>
                }
                else if(pDicEntry->pNext == NULL)
   20a1c:	11400117 	ldw	r5,4(r2)
   20a20:	2800041e 	bne	r5,zero,20a34 <COE_AddObjectToDic+0x78>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
   20a24:	11000115 	stw	r4,4(r2)
                    pNewObjEntry->pPrev = pDicEntry;
   20a28:	20800015 	stw	r2,0(r4)
                    pNewObjEntry->pNext = NULL;
   20a2c:	20000115 	stw	zero,4(r4)
                    return 0;
   20a30:	003fe806 	br	209d4 <COE_AddObjectToDic+0x18>
   20a34:	2805883a 	mov	r2,r5
                if(pDicEntry->Index == pNewObjEntry->Index)
   20a38:	1140020b 	ldhu	r5,8(r2)
   20a3c:	197fef1e 	bne	r3,r5,209fc <COE_AddObjectToDic+0x40>
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
   20a40:	00800044 	movi	r2,1
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
}
   20a44:	f800283a 	ret

00020a48 <COE_RemoveDicEntry>:

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20a48:	d1665817 	ldw	r5,-26272(gp)

    while(pDicEntry != NULL)
    {
        if(pDicEntry->Index == index)
   20a4c:	213fffcc 	andi	r4,r4,65535
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20a50:	2805883a 	mov	r2,r5
    while(pDicEntry != NULL)
   20a54:	1000011e 	bne	r2,zero,20a5c <COE_RemoveDicEntry+0x14>
            return;
        }

        pDicEntry = pDicEntry->pNext;
    }
}
   20a58:	f800283a 	ret
        if(pDicEntry->Index == index)
   20a5c:	1180020b 	ldhu	r6,8(r2)
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20a60:	10c00117 	ldw	r3,4(r2)
        if(pDicEntry->Index == index)
   20a64:	31000b1e 	bne	r6,r4,20a94 <COE_RemoveDicEntry+0x4c>
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
   20a68:	11000017 	ldw	r4,0(r2)
            if(pPrevEntry != NULL)
   20a6c:	20000126 	beq	r4,zero,20a74 <COE_RemoveDicEntry+0x2c>
                pPrevEntry->pNext = pNextEntry;
   20a70:	20c00115 	stw	r3,4(r4)
            if(pNextEntry != NULL)
   20a74:	18000126 	beq	r3,zero,20a7c <COE_RemoveDicEntry+0x34>
                pNextEntry->pPrev = pPrevEntry;
   20a78:	19000015 	stw	r4,0(r3)
            pDicEntry->pPrev = NULL;
   20a7c:	10000015 	stw	zero,0(r2)
            pDicEntry->pNext = NULL;
   20a80:	10000115 	stw	zero,4(r2)
            if(pDicEntry->Index == ObjDicList->Index)
   20a84:	2880020b 	ldhu	r2,8(r5)
   20a88:	30bff31e 	bne	r6,r2,20a58 <COE_RemoveDicEntry+0x10>
                ObjDicList = pNextEntry;
   20a8c:	d0e65815 	stw	r3,-26272(gp)
   20a90:	f800283a 	ret
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20a94:	1805883a 	mov	r2,r3
   20a98:	003fee06 	br	20a54 <COE_RemoveDicEntry+0xc>

00020a9c <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
   20a9c:	defffe04 	addi	sp,sp,-8
   20aa0:	dc000015 	stw	r16,0(sp)
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
   20aa4:	d4265817 	ldw	r16,-26272(gp)
{
   20aa8:	dfc00115 	stw	ra,4(sp)
    UINT16 Index = 0;

    while(pObjEntry != NULL)
   20aac:	8000051e 	bne	r16,zero,20ac4 <COE_ClearObjDictionary+0x28>
        Index = pObjEntry->Index;
        pObjEntry = pObjEntry->pNext;

        COE_RemoveDicEntry(Index);
    }
    ObjDicList = NULL;
   20ab0:	d0265815 	stw	zero,-26272(gp)
}
   20ab4:	dfc00117 	ldw	ra,4(sp)
   20ab8:	dc000017 	ldw	r16,0(sp)
   20abc:	dec00204 	addi	sp,sp,8
   20ac0:	f800283a 	ret
        Index = pObjEntry->Index;
   20ac4:	8100020b 	ldhu	r4,8(r16)
        pObjEntry = pObjEntry->pNext;
   20ac8:	84000117 	ldw	r16,4(r16)
        COE_RemoveDicEntry(Index);
   20acc:	213fffcc 	andi	r4,r4,65535
   20ad0:	0020a480 	call	20a48 <COE_RemoveDicEntry>
   20ad4:	003ff506 	br	20aac <COE_ClearObjDictionary+0x10>

00020ad8 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
   20ad8:	defffd04 	addi	sp,sp,-12
   20adc:	dc400115 	stw	r17,4(sp)
   20ae0:	dc000015 	stw	r16,0(sp)
   20ae4:	dfc00215 	stw	ra,8(sp)
   20ae8:	2021883a 	mov	r16,r4
    UINT16 result = 0;
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;

    while(pEntry->Index != 0xFFFF)
   20aec:	047fffd4 	movui	r17,65535
   20af0:	8080020b 	ldhu	r2,8(r16)
   20af4:	1440061e 	bne	r2,r17,20b10 <AddObjectsToObjDictionary+0x38>
        }

        pEntry++;
    }

    return result;
   20af8:	0005883a 	mov	r2,zero

}
   20afc:	dfc00217 	ldw	ra,8(sp)
   20b00:	dc400117 	ldw	r17,4(sp)
   20b04:	dc000017 	ldw	r16,0(sp)
   20b08:	dec00304 	addi	sp,sp,12
   20b0c:	f800283a 	ret
        result = COE_AddObjectToDic(pEntry);
   20b10:	8009883a 	mov	r4,r16
   20b14:	00209bc0 	call	209bc <COE_AddObjectToDic>
        if(result != 0)
   20b18:	10ffffcc 	andi	r3,r2,65535
   20b1c:	183ff71e 	bne	r3,zero,20afc <AddObjectsToObjDictionary+0x24>
        pEntry++;
   20b20:	84000a04 	addi	r16,r16,40
   20b24:	003ff206 	br	20af0 <AddObjectsToObjDictionary+0x18>

00020b28 <COE_ObjDictionaryInit>:
    UINT16 result = 0;

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20b28:	010000f4 	movhi	r4,3
{
   20b2c:	deffff04 	addi	sp,sp,-4
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20b30:	21284a04 	addi	r4,r4,-24280
{
   20b34:	dfc00015 	stw	ra,0(sp)
    ObjDicList = NULL;
   20b38:	d0265815 	stw	zero,-26272(gp)
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20b3c:	0020ad80 	call	20ad8 <AddObjectsToObjDictionary>

    if(result != 0)
   20b40:	10ffffcc 	andi	r3,r2,65535
   20b44:	1800051e 	bne	r3,zero,20b5c <COE_ObjDictionaryInit+0x34>
        return result;
    }
    
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20b48:	010000f4 	movhi	r4,3
   20b4c:	2128cb04 	addi	r4,r4,-23764
    }



    return result;
}
   20b50:	dfc00017 	ldw	ra,0(sp)
   20b54:	dec00104 	addi	sp,sp,4
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20b58:	0020ad81 	jmpi	20ad8 <AddObjectsToObjDictionary>
}
   20b5c:	dfc00017 	ldw	ra,0(sp)
   20b60:	dec00104 	addi	sp,sp,4
   20b64:	f800283a 	ret

00020b68 <COE_ObjInit>:
    sSyncManOutPar.subindex0         = 32;
   20b68:	01400804 	movi	r5,32
   20b6c:	00c000f4 	movhi	r3,3
   20b70:	1972fb15 	stw	r5,-13332(r3)
    sSyncManOutPar.u32CycleTime     = 0;
   20b74:	00c000f4 	movhi	r3,3
{
   20b78:	defffe04 	addi	sp,sp,-8
    sSyncManOutPar.u32CycleTime     = 0;
   20b7c:	1832fc15 	stw	zero,-13328(r3)
    sSyncManOutPar.subindex0         = 32;
   20b80:	008000f4 	movhi	r2,3
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20b84:	00c000b4 	movhi	r3,2
{
   20b88:	dfc00115 	stw	ra,4(sp)
    sSyncManOutPar.subindex0         = 32;
   20b8c:	10b2fb04 	addi	r2,r2,-13332
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20b90:	011007c4 	movi	r4,16415
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20b94:	18e1a804 	addi	r3,r3,-31072
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20b98:	1100030d 	sth	r4,12(r2)
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20b9c:	10c00415 	stw	r3,16(r2)
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   20ba0:	008000f4 	movhi	r2,3
   20ba4:	10330015 	stw	zero,-13312(r2)
    sSyncManOutPar.u16GetCycleTime = 0;
   20ba8:	008000f4 	movhi	r2,3
   20bac:	1033020d 	sth	zero,-13304(r2)
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
   20bb0:	008000f4 	movhi	r2,3
   20bb4:	10330315 	stw	zero,-13300(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   20bb8:	008000f4 	movhi	r2,3
   20bbc:	10330515 	stw	zero,-13292(r2)
    sSyncManOutPar.u8SyncError = 0;
   20bc0:	008000f4 	movhi	r2,3
   20bc4:	10330b05 	stb	zero,-13268(r2)
    sSyncManInPar.subindex0         = 32;
   20bc8:	008000f4 	movhi	r2,3
   20bcc:	10b2ea04 	addi	r2,r2,-13400
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
   20bd0:	1100030d 	sth	r4,12(r2)
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20bd4:	10c00415 	stw	r3,16(r2)
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   20bd8:	008000f4 	movhi	r2,3
   20bdc:	1032ef15 	stw	zero,-13380(r2)
    sSyncManInPar.u16GetCycleTime = 0;
   20be0:	008000f4 	movhi	r2,3
   20be4:	1032f10d 	sth	zero,-13372(r2)
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20be8:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20bec:	018000f4 	movhi	r6,3
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20bf0:	1032f215 	stw	zero,-13368(r2)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20bf4:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20bf8:	3172ea15 	stw	r5,-13400(r6)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20bfc:	1032f415 	stw	zero,-13360(r2)
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20c00:	014000f4 	movhi	r5,3
    sSyncManInPar.u8SyncError = 0;
   20c04:	008000f4 	movhi	r2,3
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20c08:	2832eb15 	stw	zero,-13396(r5)
    sSyncManInPar.u8SyncError = 0;
   20c0c:	1032fa05 	stb	zero,-13336(r2)
    bSyncSetByUser = FALSE;
   20c10:	d0268685 	stb	zero,-26086(gp)
    UINT16 result = COE_ObjDictionaryInit();
   20c14:	0020b280 	call	20b28 <COE_ObjDictionaryInit>
    if(result != 0)
   20c18:	10bfffcc 	andi	r2,r2,65535
   20c1c:	10000126 	beq	r2,zero,20c24 <COE_ObjInit+0xbc>
        COE_ClearObjDictionary();
   20c20:	0020a9c0 	call	20a9c <COE_ClearObjDictionary>
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20c24:	01800104 	movi	r6,4
   20c28:	01400204 	movi	r5,8
   20c2c:	d809883a 	mov	r4,sp
    u8PendingSdo = 0;
   20c30:	d0269505 	stb	zero,-26028(gp)
    bStoreCompleteAccess = FALSE;
   20c34:	d02694c5 	stb	zero,-26029(gp)
    u16StoreIndex   =   0;
   20c38:	d026940d 	sth	zero,-26032(gp)
    u8StoreSubindex = 0;
   20c3c:	d0269485 	stb	zero,-26030(gp)
    u32StoreDataSize = 0;
   20c40:	d0269315 	stw	zero,-26036(gp)
    pStoreData = NULL;
   20c44:	d0269215 	stw	zero,-26040(gp)
    pSdoPendFunc    = NULL;
   20c48:	d0269115 	stw	zero,-26044(gp)
    pSdoSegData = NULL;
   20c4c:	d0269015 	stw	zero,-26048(gp)
        UINT32 EscFeature = 0;
   20c50:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20c54:	00206f00 	call	206f0 <HW_EscRead>
        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
   20c58:	d8800017 	ldw	r2,0(sp)
   20c5c:	1080020c 	andi	r2,r2,8
   20c60:	10000626 	beq	r2,zero,20c7c <COE_ObjInit+0x114>
            b32BitDc = FALSE;
   20c64:	d0267485 	stb	zero,-26158(gp)
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20c68:	0083e804 	movi	r2,4000
   20c6c:	d0a65a15 	stw	r2,-26264(gp)
}
   20c70:	dfc00117 	ldw	ra,4(sp)
   20c74:	dec00204 	addi	sp,sp,8
   20c78:	f800283a 	ret
            b32BitDc = TRUE;
   20c7c:	00800044 	movi	r2,1
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20c80:	01800104 	movi	r6,4
   20c84:	01424404 	movi	r5,2320
   20c88:	d1265b04 	addi	r4,gp,-26260
            b32BitDc = TRUE;
   20c8c:	d0a67485 	stb	r2,-26158(gp)
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20c90:	00206f00 	call	206f0 <HW_EscRead>
   20c94:	003ff406 	br	20c68 <COE_ObjInit+0x100>

00020c98 <COE_Main>:

void COE_Main(void)
{
     UINT8 abort = 0;
     
    if(pSdoPendFunc != NULL)
   20c98:	d0a69117 	ldw	r2,-26044(gp)
   20c9c:	10003026 	beq	r2,zero,20d60 <COE_Main+0xc8>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20ca0:	d0e694c3 	ldbu	r3,-26029(gp)
   20ca4:	d1e69217 	ldw	r7,-26040(gp)
   20ca8:	d1a69317 	ldw	r6,-26036(gp)
   20cac:	d1669483 	ldbu	r5,-26030(gp)
   20cb0:	d126940b 	ldhu	r4,-26032(gp)
{
   20cb4:	defffd04 	addi	sp,sp,-12
   20cb8:	dc000115 	stw	r16,4(sp)
   20cbc:	dfc00215 	stw	ra,8(sp)
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20cc0:	d8c00015 	stw	r3,0(sp)
   20cc4:	103ee83a 	callr	r2

        if(abort != ABORTIDX_WORKING)
   20cc8:	14003fcc 	andi	r16,r2,255
   20ccc:	80803fe0 	cmpeqi	r2,r16,255
   20cd0:	10000f1e 	bne	r2,zero,20d10 <COE_Main+0x78>
        {
            switch(u8PendingSdo)
   20cd4:	d0e69503 	ldbu	r3,-26028(gp)
   20cd8:	18803fcc 	andi	r2,r3,255
   20cdc:	110000a0 	cmpeqi	r4,r2,2
   20ce0:	2000161e 	bne	r4,zero,20d3c <COE_Main+0xa4>
   20ce4:	110000e8 	cmpgeui	r4,r2,3
   20ce8:	20000d1e 	bne	r4,zero,20d20 <COE_Main+0x88>
   20cec:	10800060 	cmpeqi	r2,r2,1
   20cf0:	1000161e 	bne	r2,zero,20d4c <COE_Main+0xb4>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
                    break;

            }

            u8PendingSdo = 0;
   20cf4:	d0269505 	stb	zero,-26028(gp)
            u16StoreIndex = 0;
   20cf8:	d026940d 	sth	zero,-26032(gp)
            u8StoreSubindex = 0;
   20cfc:	d0269485 	stb	zero,-26030(gp)
            u32StoreDataSize = 0;
   20d00:	d0269315 	stw	zero,-26036(gp)
            pStoreData = NULL;
   20d04:	d0269215 	stw	zero,-26040(gp)
            bStoreCompleteAccess = 0;
   20d08:	d02694c5 	stb	zero,-26029(gp)
            pSdoPendFunc = NULL;
   20d0c:	d0269115 	stw	zero,-26044(gp)
        }
    }
}
   20d10:	dfc00217 	ldw	ra,8(sp)
   20d14:	dc000117 	ldw	r16,4(sp)
   20d18:	dec00304 	addi	sp,sp,12
   20d1c:	f800283a 	ret
            switch(u8PendingSdo)
   20d20:	18ffff44 	addi	r3,r3,-3
   20d24:	18c03fcc 	andi	r3,r3,255
   20d28:	18c000a8 	cmpgeui	r3,r3,2
   20d2c:	183ff11e 	bne	r3,zero,20cf4 <COE_Main+0x5c>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20d30:	d1a69217 	ldw	r6,-26040(gp)
   20d34:	d1669317 	ldw	r5,-26036(gp)
   20d38:	00000606 	br	20d54 <COE_Main+0xbc>
                    if(pSdoSegData)
   20d3c:	d1269017 	ldw	r4,-26048(gp)
   20d40:	20000226 	beq	r4,zero,20d4c <COE_Main+0xb4>
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
   20d44:	0026b8c0 	call	26b8c <free>
                        pSdoSegData = NULL;
   20d48:	d0269015 	stw	zero,-26048(gp)
                    SDOS_SdoRes(abort, 0, NULL);
   20d4c:	000d883a 	mov	r6,zero
   20d50:	000b883a 	mov	r5,zero
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20d54:	8009883a 	mov	r4,r16
   20d58:	00260900 	call	26090 <SDOS_SdoRes>
                    break;
   20d5c:	003fe506 	br	20cf4 <COE_Main+0x5c>
   20d60:	f800283a 	ret

00020d64 <ECAT_CheckTimer>:

void ECAT_CheckTimer(void)
{

    /*decrement the state transition timeout counter*/
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20d64:	d0a67283 	ldbu	r2,-26166(gp)
{
   20d68:	deffff04 	addi	sp,sp,-4
   20d6c:	dfc00015 	stw	ra,0(sp)
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20d70:	10000726 	beq	r2,zero,20d90 <ECAT_CheckTimer+0x2c>
   20d74:	d0a67b0b 	ldhu	r2,-26132(gp)
   20d78:	10ffffcc 	andi	r3,r2,65535
   20d7c:	18e0001c 	xori	r3,r3,32768
   20d80:	18e00004 	addi	r3,r3,-32768
   20d84:	00c0020e 	bge	zero,r3,20d90 <ECAT_CheckTimer+0x2c>
    {
        EsmTimeoutCounter--;
   20d88:	10bfffc4 	addi	r2,r2,-1
   20d8c:	d0a67b0d 	sth	r2,-26132(gp)
    }



    DC_CheckWatchdog();
   20d90:	00231900 	call	23190 <DC_CheckWatchdog>



/*ECATCHANGE_START(V5.13) */
    /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
   20d94:	d0a67483 	ldbu	r2,-26158(gp)
   20d98:	10000426 	beq	r2,zero,20dac <ECAT_CheckTimer+0x48>
   20d9c:	d0e65c17 	ldw	r3,-26256(gp)
   20da0:	00bff8b4 	movhi	r2,65506
   20da4:	10bed004 	addi	r2,r2,-1216
   20da8:	10c00f36 	bltu	r2,r3,20de8 <ECAT_CheckTimer+0x84>
/*ECATCHANGE_END(V5.13) */
    {

        /* the timestamp is stored in ns */
        u64Timestamp = u64Timestamp + 1000000;
   20dac:	d0a65c17 	ldw	r2,-26256(gp)
   20db0:	00c003f4 	movhi	r3,15
   20db4:	d1265d17 	ldw	r4,-26252(gp)
   20db8:	18d09004 	addi	r3,r3,16960
   20dbc:	10c7883a 	add	r3,r2,r3
   20dc0:	1885803a 	cmpltu	r2,r3,r2
   20dc4:	1105883a 	add	r2,r2,r4
   20dc8:	d0e65c15 	stw	r3,-26256(gp)
   20dcc:	d0a65d15 	stw	r2,-26252(gp)
    {
        /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
    }

    u32CheckForDcOverrunCnt++;
   20dd0:	d0a65a17 	ldw	r2,-26264(gp)
   20dd4:	10800044 	addi	r2,r2,1
   20dd8:	d0a65a15 	stw	r2,-26264(gp)


}
   20ddc:	dfc00017 	ldw	ra,0(sp)
   20de0:	dec00104 	addi	sp,sp,4
   20de4:	f800283a 	ret
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20de8:	0083e804 	movi	r2,4000
   20dec:	d0a65a15 	stw	r2,-26264(gp)
   20df0:	003ff706 	br	20dd0 <ECAT_CheckTimer+0x6c>

00020df4 <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
   20df4:	defffd04 	addi	sp,sp,-12
   20df8:	dc000115 	stw	r16,4(sp)
   UINT32 u32CurValue = 0;
   UINT32 u32Delta = 0;

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20dfc:	01800104 	movi	r6,4
{
   20e00:	2021883a 	mov	r16,r4
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e04:	01424404 	movi	r5,2320
   20e08:	d809883a 	mov	r4,sp
{
   20e0c:	dfc00215 	stw	ra,8(sp)
   UINT32 u32CurValue = 0;
   20e10:	d8000015 	stw	zero,0(sp)
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e14:	00207680 	call	20768 <HW_EscReadIsr>

   if (u32CurValue > 0)
   20e18:	d8800017 	ldw	r2,0(sp)
   20e1c:	10000626 	beq	r2,zero,20e38 <GetSystemTimeDelay+0x44>
   {
      if (u32StartTime <= u32CurValue)
   20e20:	14000936 	bltu	r2,r16,20e48 <GetSystemTimeDelay+0x54>
      {
         u32Delta = u32CurValue - u32StartTime;
   20e24:	1405c83a 	sub	r2,r2,r16
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
      }
   }// current value successfully read out

   if (u32StartTime > 0)
   20e28:	80000326 	beq	r16,zero,20e38 <GetSystemTimeDelay+0x44>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
   20e2c:	d0e66217 	ldw	r3,-26232(gp)
   20e30:	1880082e 	bgeu	r3,r2,20e54 <GetSystemTimeDelay+0x60>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
   20e34:	10c5c83a 	sub	r2,r2,r3
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
       }
   }
   return u32Delta;
}
   20e38:	dfc00217 	ldw	ra,8(sp)
   20e3c:	dc000117 	ldw	r16,4(sp)
   20e40:	dec00304 	addi	sp,sp,12
   20e44:	f800283a 	ret
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
   20e48:	10bfffc4 	addi	r2,r2,-1
   20e4c:	1405c83a 	sub	r2,r2,r16
   if (u32StartTime > 0)
   20e50:	003ff606 	br	20e2c <GetSystemTimeDelay+0x38>
   UINT32 u32Delta = 0;
   20e54:	0005883a 	mov	r2,zero
   return u32Delta;
   20e58:	003ff706 	br	20e38 <GetSystemTimeDelay+0x44>

00020e5c <PDO_InputMapping>:
{
   20e5c:	defffc04 	addi	sp,sp,-16
   20e60:	dc800215 	stw	r18,8(sp)
   20e64:	dc000015 	stw	r16,0(sp)
    if (MEASUREMENT_ACTIVE)
   20e68:	048000f4 	movhi	r18,3
   20e6c:	040000f4 	movhi	r16,3
{
   20e70:	dfc00315 	stw	ra,12(sp)
   20e74:	dc400115 	stw	r17,4(sp)
    if (MEASUREMENT_ACTIVE)
   20e78:	94b2fb04 	addi	r18,r18,-13332
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
   20e7c:	00206c80 	call	206c8 <HW_GetALEventRegister_Isr>
    if (MEASUREMENT_ACTIVE)
   20e80:	8432ea04 	addi	r16,r16,-13400
   20e84:	9080070b 	ldhu	r2,28(r18)
   20e88:	80c0070b 	ldhu	r3,28(r16)
   20e8c:	10c4b03a 	or	r2,r2,r3
   20e90:	1080004c 	andi	r2,r2,1
   20e94:	10001b26 	beq	r2,zero,20f04 <PDO_InputMapping+0xa8>
        u32TimeValue = GetSystemTimeDelay(0);
   20e98:	0009883a 	mov	r4,zero
   20e9c:	0020df40 	call	20df4 <GetSystemTimeDelay>
   20ea0:	1023883a 	mov	r17,r2
    APPL_InputMapping((UINT16*)aPdInputData);
   20ea4:	010000f4 	movhi	r4,3
   20ea8:	2132b604 	addi	r4,r4,-13608
   20eac:	00203d40 	call	203d4 <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
   20eb0:	d1a6718b 	ldhu	r6,-26170(gp)
   20eb4:	d1666e0b 	ldhu	r5,-26184(gp)
   20eb8:	010000f4 	movhi	r4,3
   20ebc:	2132b604 	addi	r4,r4,-13608
   20ec0:	002083c0 	call	2083c <HW_EscWriteIsr>
    if (MEASUREMENT_ACTIVE)
   20ec4:	90c0070b 	ldhu	r3,28(r18)
   20ec8:	8080070b 	ldhu	r2,28(r16)
   20ecc:	1886b03a 	or	r3,r3,r2
   20ed0:	18c0004c 	andi	r3,r3,1
   20ed4:	18000526 	beq	r3,zero,20eec <PDO_InputMapping+0x90>
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20ed8:	8809883a 	mov	r4,r17
   20edc:	0020df40 	call	20df4 <GetSystemTimeDelay>
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
   20ee0:	80c00517 	ldw	r3,20(r16)
   20ee4:	1880012e 	bgeu	r3,r2,20eec <PDO_InputMapping+0x90>
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
   20ee8:	80800515 	stw	r2,20(r16)
}
   20eec:	dfc00317 	ldw	ra,12(sp)
   20ef0:	dc800217 	ldw	r18,8(sp)
   20ef4:	dc400117 	ldw	r17,4(sp)
   20ef8:	dc000017 	ldw	r16,0(sp)
   20efc:	dec00404 	addi	sp,sp,16
   20f00:	f800283a 	ret
    UINT32 u32TimeValue = 0;
   20f04:	0023883a 	mov	r17,zero
   20f08:	003fe606 	br	20ea4 <PDO_InputMapping+0x48>

00020f0c <HandleCycleTimeMeasurement>:
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
   20f0c:	d0a67b83 	ldbu	r2,-26130(gp)
   20f10:	1000181e 	bne	r2,zero,20f74 <HandleCycleTimeMeasurement+0x68>
        if (u32CycleTimeStartValue > 0)
   20f14:	d1266417 	ldw	r4,-26224(gp)
{
   20f18:	deffff04 	addi	sp,sp,-4
   20f1c:	dfc00015 	stw	ra,0(sp)
        if (u32CycleTimeStartValue > 0)
   20f20:	20000e26 	beq	r4,zero,20f5c <HandleCycleTimeMeasurement+0x50>
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20f24:	0020df40 	call	20df4 <GetSystemTimeDelay>
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20f28:	00c000f4 	movhi	r3,3
   20f2c:	18f2fb04 	addi	r3,r3,-13332
   20f30:	19000117 	ldw	r4,4(r3)
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20f34:	d0a66415 	stw	r2,-26224(gp)
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20f38:	20000126 	beq	r4,zero,20f40 <HandleCycleTimeMeasurement+0x34>
   20f3c:	1100012e 	bgeu	r2,r4,20f44 <HandleCycleTimeMeasurement+0x38>
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
   20f40:	18800115 	stw	r2,4(r3)
            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
   20f44:	00c000f4 	movhi	r3,3
   20f48:	18f2ea04 	addi	r3,r3,-13400
   20f4c:	19000117 	ldw	r4,4(r3)
   20f50:	20000126 	beq	r4,zero,20f58 <HandleCycleTimeMeasurement+0x4c>
   20f54:	1100012e 	bgeu	r2,r4,20f5c <HandleCycleTimeMeasurement+0x50>
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
   20f58:	18800115 	stw	r2,4(r3)
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
   20f5c:	0009883a 	mov	r4,zero
   20f60:	0020df40 	call	20df4 <GetSystemTimeDelay>
   20f64:	d0a66415 	stw	r2,-26224(gp)
}
   20f68:	dfc00017 	ldw	ra,0(sp)
   20f6c:	dec00104 	addi	sp,sp,4
   20f70:	f800283a 	ret
   20f74:	f800283a 	ret

00020f78 <PDO_OutputMapping>:
{
   20f78:	defffc04 	addi	sp,sp,-16
   20f7c:	dc800215 	stw	r18,8(sp)
   20f80:	dc000015 	stw	r16,0(sp)
   if (MEASUREMENT_ACTIVE)
   20f84:	048000f4 	movhi	r18,3
   20f88:	040000f4 	movhi	r16,3
   20f8c:	8432fb04 	addi	r16,r16,-13332
   20f90:	94b2ea04 	addi	r18,r18,-13400
   20f94:	8080070b 	ldhu	r2,28(r16)
   20f98:	90c0070b 	ldhu	r3,28(r18)
{
   20f9c:	dfc00315 	stw	ra,12(sp)
   20fa0:	dc400115 	stw	r17,4(sp)
   if (MEASUREMENT_ACTIVE)
   20fa4:	10c4b03a 	or	r2,r2,r3
   20fa8:	1080004c 	andi	r2,r2,1
   20fac:	10001e26 	beq	r2,zero,21028 <PDO_OutputMapping+0xb0>
      u32TimeValue = GetSystemTimeDelay(0);
   20fb0:	0009883a 	mov	r4,zero
   20fb4:	0020df40 	call	20df4 <GetSystemTimeDelay>
   20fb8:	1023883a 	mov	r17,r2
      u32MinCycleTimeStartValue = u32TimeValue;
   20fbc:	d0a66315 	stw	r2,-26228(gp)
      bMinCycleTimeMeasurementStarted = TRUE;
   20fc0:	00800044 	movi	r2,1
   20fc4:	d0a66105 	stb	r2,-26236(gp)
      u32MinCycleTimeValue = 0;
   20fc8:	d0266015 	stw	zero,-26240(gp)
      HandleCycleTimeMeasurement();
   20fcc:	0020f0c0 	call	20f0c <HandleCycleTimeMeasurement>
    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
   20fd0:	d1a6710b 	ldhu	r6,-26172(gp)
   20fd4:	d1666e8b 	ldhu	r5,-26182(gp)
   20fd8:	d1265e84 	addi	r4,gp,-26246
   20fdc:	00207680 	call	20768 <HW_EscReadIsr>
    APPL_OutputMapping((UINT16*) aPdOutputData);
   20fe0:	d1265e84 	addi	r4,gp,-26246
   20fe4:	00204240 	call	20424 <APPL_OutputMapping>
    if (MEASUREMENT_ACTIVE)
   20fe8:	8080070b 	ldhu	r2,28(r16)
   20fec:	90c0070b 	ldhu	r3,28(r18)
   20ff0:	10c4b03a 	or	r2,r2,r3
   20ff4:	1080004c 	andi	r2,r2,1
   20ff8:	10000526 	beq	r2,zero,21010 <PDO_OutputMapping+0x98>
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20ffc:	8809883a 	mov	r4,r17
   21000:	0020df40 	call	20df4 <GetSystemTimeDelay>
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
   21004:	80c00517 	ldw	r3,20(r16)
   21008:	1880012e 	bgeu	r3,r2,21010 <PDO_OutputMapping+0x98>
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
   2100c:	80800515 	stw	r2,20(r16)
}
   21010:	dfc00317 	ldw	ra,12(sp)
   21014:	dc800217 	ldw	r18,8(sp)
   21018:	dc400117 	ldw	r17,4(sp)
   2101c:	dc000017 	ldw	r16,0(sp)
   21020:	dec00404 	addi	sp,sp,16
   21024:	f800283a 	ret
   UINT32 u32TimeValue = 0;
   21028:	0023883a 	mov	r17,zero
   2102c:	003fe806 	br	20fd0 <PDO_OutputMapping+0x58>

00021030 <Sync1_Isr>:
void Sync1_Isr(void)
{
    Sync1WdCounter = 0;

    /*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21030:	d0a67c43 	ldbu	r2,-26127(gp)
    Sync1WdCounter = 0;
   21034:	d026768d 	sth	zero,-26150(gp)
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21038:	10800058 	cmpnei	r2,r2,1
   2103c:	10000f1e 	bne	r2,zero,2107c <Sync1_Isr+0x4c>
   21040:	d0a6718b 	ldhu	r2,-26170(gp)
   21044:	10000d26 	beq	r2,zero,2107c <Sync1_Isr+0x4c>
/*ECATCHANGE_END(V5.13) ECAT 5*/
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
   21048:	008000f4 	movhi	r2,3
   2104c:	10b2ea8b 	ldhu	r2,-13398(r2)
   21050:	108000d8 	cmpnei	r2,r2,3
   21054:	1000091e 	bne	r2,zero,2107c <Sync1_Isr+0x4c>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
   21058:	d0a6758b 	ldhu	r2,-26154(gp)
   2105c:	1000071e 	bne	r2,zero,2107c <Sync1_Isr+0x4c>
{
   21060:	deffff04 	addi	sp,sp,-4
   21064:	dfc00015 	stw	ra,0(sp)
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
   21068:	0020e5c0 	call	20e5c <PDO_InputMapping>
        }

        /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
        LatchInputSync0Counter = 0;
   2106c:	d026750d 	sth	zero,-26156(gp)
}
   21070:	dfc00017 	ldw	ra,0(sp)
   21074:	dec00104 	addi	sp,sp,4
   21078:	f800283a 	ret
        LatchInputSync0Counter = 0;
   2107c:	d026750d 	sth	zero,-26156(gp)
   21080:	f800283a 	ret

00021084 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
   21084:	defffc04 	addi	sp,sp,-16
   21088:	dfc00315 	stw	ra,12(sp)
   2108c:	dc000215 	stw	r16,8(sp)




    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
   21090:	d0266715 	stw	zero,-26212(gp)
    pAPPL_CoeWriteInd = NULL;
   21094:	d0266615 	stw	zero,-26216(gp)
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
   21098:	d0266515 	stw	zero,-26220(gp)

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
   2109c:	002350c0 	call	2350c <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
   210a0:	0020b680 	call	20b68 <COE_ObjInit>

    /*Reset PDI Access*/
    {
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values

    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   210a4:	01800084 	movi	r6,2
   210a8:	01414004 	movi	r5,1280
   210ac:	d9000104 	addi	r4,sp,4
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values
   210b0:	d800010d 	sth	zero,4(sp)
    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   210b4:	00206f00 	call	206f0 <HW_EscRead>
    eepromConfigControl = SWAPWORD(eepromConfigControl);
   210b8:	d880010b 	ldhu	r2,4(sp)

    if((eepromConfigControl & ESC_EEPROM_ASSIGN_TO_PDI_MASK) > 0)
   210bc:	10c0004c 	andi	r3,r2,1
   210c0:	18000626 	beq	r3,zero,210dc <MainInit+0x58>
    {
        /*Clear access register(0x0501.1)*/
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   210c4:	10bfbfcc 	andi	r2,r2,65279

        eepromConfigControl = SWAPWORD(eepromConfigControl);
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   210c8:	01800084 	movi	r6,2
   210cc:	01414004 	movi	r5,1280
   210d0:	d9000104 	addi	r4,sp,4
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   210d4:	d880010d 	sth	r2,4(sp)
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   210d8:	00207740 	call	20774 <HW_EscWrite>
    }
    }
    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
   210dc:	00800044 	movi	r2,1
   210e0:	d0a65e05 	stb	r2,-26248(gp)


    bMinCycleTimeMeasurementStarted = FALSE;
   210e4:	d0266105 	stb	zero,-26236(gp)
    u32CycleTimeStartValue = 0;
   210e8:	d0266415 	stw	zero,-26224(gp)
    u32MinCycleTimeStartValue = 0;
   210ec:	d0266315 	stw	zero,-26228(gp)

    u32SystemTimeReadFailure = 0;
   210f0:	d0266215 	stw	zero,-26232(gp)

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
   210f4:	d8000015 	stw	zero,0(sp)
       UINT32 u32Cnt = 0;
       UINT32 u32Delta = 0;
   210f8:	d8000115 	stw	zero,4(sp)
   210fc:	0400fa04 	movi	r16,1000

       while (u32Cnt < 1000)
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
   21100:	01800104 	movi	r6,4
   21104:	01424404 	movi	r5,2320
   21108:	d809883a 	mov	r4,sp
   2110c:	00207680 	call	20768 <HW_EscReadIsr>
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
   21110:	01800104 	movi	r6,4
   21114:	01424404 	movi	r5,2320
   21118:	d9000104 	addi	r4,sp,4
   2111c:	00207680 	call	20768 <HW_EscReadIsr>

            if (u32TimeValue <= u32Delta)
   21120:	d8800017 	ldw	r2,0(sp)
   21124:	d8c00117 	ldw	r3,4(sp)
   21128:	18800636 	bltu	r3,r2,21144 <MainInit+0xc0>
                    u32Delta = u32Delta - u32TimeValue;
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   2112c:	1885c83a 	sub	r2,r3,r2
            }


            if (u32SystemTimeReadFailure == 0)
   21130:	d0e66217 	ldw	r3,-26232(gp)
                    u32Delta = u32Delta - u32TimeValue;
   21134:	d8800115 	stw	r2,4(sp)
            if (u32SystemTimeReadFailure == 0)
   21138:	1800041e 	bne	r3,zero,2114c <MainInit+0xc8>
            {
                u32SystemTimeReadFailure = u32Delta;
            }
            else if (u32SystemTimeReadFailure > u32Delta)
            {
                u32SystemTimeReadFailure = u32Delta;
   2113c:	d0a66215 	stw	r2,-26232(gp)
   21140:	00000306 	br	21150 <MainInit+0xcc>
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   21144:	18ffffc4 	addi	r3,r3,-1
   21148:	003ff806 	br	2112c <MainInit+0xa8>
            else if (u32SystemTimeReadFailure > u32Delta)
   2114c:	10fffb36 	bltu	r2,r3,2113c <MainInit+0xb8>
       while (u32Cnt < 1000)
   21150:	843fffc4 	addi	r16,r16,-1
   21154:	803fea1e 	bne	r16,zero,21100 <MainInit+0x7c>



/*Application Init need to be called from the application layer*/
     return Error;
}
   21158:	0005883a 	mov	r2,zero
   2115c:	dfc00317 	ldw	ra,12(sp)
   21160:	dc000217 	ldw	r16,8(sp)
   21164:	dec00404 	addi	sp,sp,16
   21168:	f800283a 	ret

0002116c <ECAT_Application>:
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
   2116c:	008000f4 	movhi	r2,3
   21170:	00c000f4 	movhi	r3,3
   21174:	10b3020b 	ldhu	r2,-13304(r2)
   21178:	18f2f10b 	ldhu	r3,-13372(r3)
   2117c:	10c4b03a 	or	r2,r2,r3
   21180:	1080004c 	andi	r2,r2,1
   21184:	10000726 	beq	r2,zero,211a4 <ECAT_Application+0x38>
    {
        if (nPdOutputSize == 0)
   21188:	d0a6710b 	ldhu	r2,-26172(gp)
   2118c:	1000051e 	bne	r2,zero,211a4 <ECAT_Application+0x38>
{
   21190:	deffff04 	addi	sp,sp,-4
   21194:	dfc00015 	stw	ra,0(sp)
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
   21198:	0020f0c0 	call	20f0c <HandleCycleTimeMeasurement>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
   2119c:	dfc00017 	ldw	ra,0(sp)
   211a0:	dec00104 	addi	sp,sp,4
    APPL_Application();
   211a4:	00204281 	jmpi	20428 <APPL_Application>

000211a8 <Sync0_Isr>:
    if(bDcSyncActive)
   211a8:	d0a67b83 	ldbu	r2,-26130(gp)
     Sync0WdCounter = 0;
   211ac:	d026778d 	sth	zero,-26146(gp)
    if(bDcSyncActive)
   211b0:	10000d26 	beq	r2,zero,211e8 <Sync0_Isr+0x40>
{
   211b4:	defffe04 	addi	sp,sp,-8
   211b8:	dc000015 	stw	r16,0(sp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   211bc:	d4267c43 	ldbu	r16,-26127(gp)
{
   211c0:	dfc00115 	stw	ra,4(sp)
   211c4:	d0a6798b 	ldhu	r2,-26138(gp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   211c8:	80c03fcc 	andi	r3,r16,255
   211cc:	18c00060 	cmpeqi	r3,r3,1
   211d0:	1800061e 	bne	r3,zero,211ec <Sync0_Isr+0x44>
        if(u16SmSync0Value > 0)
   211d4:	1000181e 	bne	r2,zero,21238 <Sync0_Isr+0x90>
        ECAT_Application();
   211d8:	002116c0 	call	2116c <ECAT_Application>
}
   211dc:	dfc00117 	ldw	ra,4(sp)
   211e0:	dc000017 	ldw	r16,0(sp)
   211e4:	dec00204 	addi	sp,sp,8
    COE_UpdateSyncErrorStatus();
   211e8:	00209601 	jmpi	20960 <COE_UpdateSyncErrorStatus>
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   211ec:	d126758b 	ldhu	r4,-26154(gp)
   211f0:	203ff826 	beq	r4,zero,211d4 <Sync0_Isr+0x2c>
   211f4:	d0e6718b 	ldhu	r3,-26170(gp)
   211f8:	183ff626 	beq	r3,zero,211d4 <Sync0_Isr+0x2c>
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
   211fc:	d0e6750b 	ldhu	r3,-26156(gp)
   21200:	197fffcc 	andi	r5,r3,65535
   21204:	2900022e 	bgeu	r5,r4,21210 <Sync0_Isr+0x68>
                LatchInputSync0Counter++;
   21208:	18c00044 	addi	r3,r3,1
   2120c:	d0e6750d 	sth	r3,-26156(gp)
            if (LatchInputSync0Value == LatchInputSync0Counter)
   21210:	d0e6750b 	ldhu	r3,-26156(gp)
   21214:	20ffef1e 	bne	r4,r3,211d4 <Sync0_Isr+0x2c>
        if(u16SmSync0Value > 0)
   21218:	1000081e 	bne	r2,zero,2123c <Sync0_Isr+0x94>
        ECAT_Application();
   2121c:	002116c0 	call	2116c <ECAT_Application>
            PDO_InputMapping();
   21220:	0020e5c0 	call	20e5c <PDO_InputMapping>
            if(LatchInputSync0Value == 1)
   21224:	d0a6758b 	ldhu	r2,-26154(gp)
   21228:	10800058 	cmpnei	r2,r2,1
   2122c:	103feb1e 	bne	r2,zero,211dc <Sync0_Isr+0x34>
                LatchInputSync0Counter = 0;
   21230:	d026750d 	sth	zero,-26156(gp)
   21234:	003fe906 	br	211dc <Sync0_Isr+0x34>
        BOOL bCallInputMapping = FALSE;
   21238:	0021883a 	mov	r16,zero
           if (u16SmSync0Counter > u16SmSync0Value)
   2123c:	d0e67a0b 	ldhu	r3,-26136(gp)
   21240:	d126710b 	ldhu	r4,-26172(gp)
   21244:	197fffcc 	andi	r5,r3,65535
   21248:	11400a36 	bltu	r2,r5,21274 <Sync0_Isr+0xcc>
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   2124c:	20002b1e 	bne	r4,zero,212fc <Sync0_Isr+0x154>
   21250:	d0a6718b 	ldhu	r2,-26170(gp)
   21254:	10002926 	beq	r2,zero,212fc <Sync0_Isr+0x154>
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
   21258:	00206c80 	call	206c8 <HW_GetALEventRegister_Isr>
              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
   2125c:	1082000c 	andi	r2,r2,2048
   21260:	10001f26 	beq	r2,zero,212e0 <Sync0_Isr+0x138>
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   21264:	008000f4 	movhi	r2,3
                 u16SmSync0Counter = 0;
   21268:	d0267a0d 	sth	zero,-26136(gp)
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   2126c:	1032f40d 	sth	zero,-13360(r2)
   21270:	00001606 	br	212cc <Sync0_Isr+0x124>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   21274:	20000c1e 	bne	r4,zero,212a8 <Sync0_Isr+0x100>
               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   21278:	d0a6718b 	ldhu	r2,-26170(gp)
   2127c:	10001326 	beq	r2,zero,212cc <Sync0_Isr+0x124>
   21280:	008000f4 	movhi	r2,3
   21284:	10b2ea04 	addi	r2,r2,-13400
   21288:	10c00a0b 	ldhu	r3,40(r2)
   2128c:	014000f4 	movhi	r5,3
   21290:	296bfb0b 	ldhu	r5,-20500(r5)
   21294:	193fffcc 	andi	r4,r3,65535
   21298:	293fef36 	bltu	r5,r4,21258 <Sync0_Isr+0xb0>
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
   2129c:	18c000c4 	addi	r3,r3,3
   212a0:	10c00a0d 	sth	r3,40(r2)
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   212a4:	003fec06 	br	21258 <Sync0_Isr+0xb0>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   212a8:	008000f4 	movhi	r2,3
   212ac:	10b2fb04 	addi	r2,r2,-13332
   212b0:	010000f4 	movhi	r4,3
   212b4:	10c00a0b 	ldhu	r3,40(r2)
   212b8:	216bfb0b 	ldhu	r5,-20500(r4)
   212bc:	193fffcc 	andi	r4,r3,65535
   212c0:	29000236 	bltu	r5,r4,212cc <Sync0_Isr+0x124>
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
   212c4:	18c000c4 	addi	r3,r3,3
   212c8:	10c00a0d 	sth	r3,40(r2)
        if (bCallInputMapping == TRUE)
   212cc:	84003fcc 	andi	r16,r16,255
   212d0:	84000058 	cmpnei	r16,r16,1
        ECAT_Application();
   212d4:	002116c0 	call	2116c <ECAT_Application>
        if (bCallInputMapping == TRUE)
   212d8:	803fd126 	beq	r16,zero,21220 <Sync0_Isr+0x78>
   212dc:	003fbf06 	br	211dc <Sync0_Isr+0x34>
                if (u16SmSync0Counter <= u16SmSync0Value)
   212e0:	d0a67a0b 	ldhu	r2,-26136(gp)
   212e4:	d126798b 	ldhu	r4,-26138(gp)
   212e8:	10ffffcc 	andi	r3,r2,65535
   212ec:	20fff736 	bltu	r4,r3,212cc <Sync0_Isr+0x124>
                    u16SmSync0Counter++;
   212f0:	10800044 	addi	r2,r2,1
   212f4:	d0a67a0d 	sth	r2,-26136(gp)
   212f8:	003ff406 	br	212cc <Sync0_Isr+0x124>
               u16SmSync0Counter++;
   212fc:	18c00044 	addi	r3,r3,1
   21300:	d0e67a0d 	sth	r3,-26136(gp)
   21304:	003ff106 	br	212cc <Sync0_Isr+0x124>

00021308 <PDI_Isr>:
{
   21308:	defffb04 	addi	sp,sp,-20
   2130c:	dc000115 	stw	r16,4(sp)
   21310:	dfc00415 	stw	ra,16(sp)
   21314:	dc800315 	stw	r18,12(sp)
   21318:	dc400215 	stw	r17,8(sp)
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
   2131c:	00206c80 	call	206c8 <HW_GetALEventRegister_Isr>
   21320:	1021883a 	mov	r16,r2
    if (ALEvent & SYNC1_EVENT)
   21324:	8080020c 	andi	r2,r16,8
   21328:	10000b1e 	bne	r2,zero,21358 <PDI_Isr+0x50>
    if(bEscIntEnabled)
   2132c:	d0a67443 	ldbu	r2,-26159(gp)
   21330:	10000f1e 	bne	r2,zero,21370 <PDI_Isr+0x68>
    if (ALEvent & SYNC0_EVENT)
   21334:	8400010c 	andi	r16,r16,4
   21338:	80004d26 	beq	r16,zero,21470 <PDI_Isr+0x168>
        Sync0_Isr();
   2133c:	00211a80 	call	211a8 <Sync0_Isr>
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   21340:	01800104 	movi	r6,4
   21344:	01426304 	movi	r5,2444
   21348:	d809883a 	mov	r4,sp
        volatile UINT32 SyncState = 0;
   2134c:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   21350:	00206f00 	call	206f0 <HW_EscRead>
   21354:	00004606 	br	21470 <PDI_Isr+0x168>
        Sync1_Isr();
   21358:	00210300 	call	21030 <Sync1_Isr>
    if(bEscIntEnabled)
   2135c:	d0a67443 	ldbu	r2,-26159(gp)
   21360:	10004a1e 	bne	r2,zero,2148c <PDI_Isr+0x184>
    if (ALEvent & SYNC0_EVENT)
   21364:	8400010c 	andi	r16,r16,4
   21368:	803ff526 	beq	r16,zero,21340 <PDI_Isr+0x38>
   2136c:	003ff306 	br	2133c <PDI_Isr+0x34>
    BOOL SyncAcknowledgePending = FALSE;
   21370:	0025883a 	mov	r18,zero
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21374:	044000f4 	movhi	r17,3
   21378:	8401000c 	andi	r16,r16,1024
   2137c:	8c72fb04 	addi	r17,r17,-13332
   21380:	80001226 	beq	r16,zero,213cc <PDI_Isr+0xc4>
            if(bDcRunning && bDcSyncActive)
   21384:	d0a67a83 	ldbu	r2,-26134(gp)
   21388:	10000326 	beq	r2,zero,21398 <PDI_Isr+0x90>
   2138c:	d0a67b83 	ldbu	r2,-26130(gp)
   21390:	10000126 	beq	r2,zero,21398 <PDI_Isr+0x90>
                u16SmSync0Counter = 0;
   21394:	d0267a0d 	sth	zero,-26136(gp)
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
   21398:	88800a0b 	ldhu	r2,40(r17)
   2139c:	10ffffcc 	andi	r3,r2,65535
   213a0:	18000226 	beq	r3,zero,213ac <PDI_Isr+0xa4>
                sSyncManOutPar.u16SmEventMissedCounter--;
   213a4:	10bfffc4 	addi	r2,r2,-1
   213a8:	88800a0d 	sth	r2,40(r17)
            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
   213ac:	88c00a0b 	ldhu	r3,40(r17)
   213b0:	008000f4 	movhi	r2,3
   213b4:	10f2f40d 	sth	r3,-13360(r2)
        bEcatFirstOutputsReceived = TRUE;
   213b8:	00800044 	movi	r2,1
   213bc:	d0a67c05 	stb	r2,-26128(gp)
        if ( bEcatOutputUpdateRunning )
   213c0:	d0a67c83 	ldbu	r2,-26126(gp)
   213c4:	10003326 	beq	r2,zero,21494 <PDI_Isr+0x18c>
            PDO_OutputMapping();
   213c8:	0020f780 	call	20f78 <PDO_OutputMapping>
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
   213cc:	8880008b 	ldhu	r2,2(r17)
   213d0:	10800058 	cmpnei	r2,r2,1
   213d4:	1000011e 	bne	r2,zero,213dc <PDI_Isr+0xd4>
            ECAT_Application();
   213d8:	002116c0 	call	2116c <ECAT_Application>
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   213dc:	d0a67c43 	ldbu	r2,-26127(gp)
   213e0:	10800058 	cmpnei	r2,r2,1
   213e4:	1000091e 	bne	r2,zero,2140c <PDI_Isr+0x104>
   213e8:	d0a6718b 	ldhu	r2,-26170(gp)
   213ec:	10000726 	beq	r2,zero,2140c <PDI_Isr+0x104>
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
   213f0:	008000f4 	movhi	r2,3
   213f4:	10b2ea8b 	ldhu	r2,-13398(r2)
   213f8:	10c00060 	cmpeqi	r3,r2,1
   213fc:	1800021e 	bne	r3,zero,21408 <PDI_Isr+0x100>
   21400:	10800898 	cmpnei	r2,r2,34
   21404:	1000011e 	bne	r2,zero,2140c <PDI_Isr+0x104>
        PDO_InputMapping();
   21408:	0020e5c0 	call	20e5c <PDO_InputMapping>
    ALEvent = HW_GetALEventRegister_Isr();
   2140c:	00206c80 	call	206c8 <HW_GetALEventRegister_Isr>
   21410:	1021883a 	mov	r16,r2
    if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21414:	8081000c 	andi	r2,r16,1024
   21418:	10001126 	beq	r2,zero,21460 <PDI_Isr+0x158>
        sSyncManOutPar.u16CycleExceededCounter++;
   2141c:	88800a8b 	ldhu	r2,42(r17)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21420:	d1666e8b 	ldhu	r5,-26182(gp)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21424:	00c000f4 	movhi	r3,3
        sSyncManOutPar.u16CycleExceededCounter++;
   21428:	10800044 	addi	r2,r2,1
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   2142c:	01800044 	movi	r6,1
   21430:	d1266cc4 	addi	r4,gp,-26189
        sSyncManOutPar.u16CycleExceededCounter++;
   21434:	88800a8d 	sth	r2,42(r17)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21438:	18b2f48d 	sth	r2,-13358(r3)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   2143c:	00207680 	call	20768 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   21440:	d1666e8b 	ldhu	r5,-26182(gp)
   21444:	d0a6710b 	ldhu	r2,-26172(gp)
   21448:	01800044 	movi	r6,1
   2144c:	d1266cc4 	addi	r4,gp,-26189
   21450:	288b883a 	add	r5,r5,r2
   21454:	297fffc4 	addi	r5,r5,-1
   21458:	297fffcc 	andi	r5,r5,65535
   2145c:	00207680 	call	20768 <HW_EscReadIsr>
    if (ALEvent & SYNC0_EVENT)
   21460:	8400010c 	andi	r16,r16,4
   21464:	803fb51e 	bne	r16,zero,2133c <PDI_Isr+0x34>
    if (SyncAcknowledgePending)
   21468:	94803fcc 	andi	r18,r18,255
   2146c:	903fb41e 	bne	r18,zero,21340 <PDI_Isr+0x38>
    COE_UpdateSyncErrorStatus();
   21470:	00209600 	call	20960 <COE_UpdateSyncErrorStatus>
}
   21474:	dfc00417 	ldw	ra,16(sp)
   21478:	dc800317 	ldw	r18,12(sp)
   2147c:	dc400217 	ldw	r17,8(sp)
   21480:	dc000117 	ldw	r16,4(sp)
   21484:	dec00504 	addi	sp,sp,20
   21488:	f800283a 	ret
        SyncAcknowledgePending = TRUE;
   2148c:	04800044 	movi	r18,1
   21490:	003fb806 	br	21374 <PDI_Isr+0x6c>
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21494:	d1666e8b 	ldhu	r5,-26182(gp)
   21498:	01800044 	movi	r6,1
   2149c:	d1266cc4 	addi	r4,gp,-26189
   214a0:	00207680 	call	20768 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   214a4:	d0a6710b 	ldhu	r2,-26172(gp)
   214a8:	d1666e8b 	ldhu	r5,-26182(gp)
   214ac:	01800044 	movi	r6,1
   214b0:	d1266cc4 	addi	r4,gp,-26189
   214b4:	288b883a 	add	r5,r5,r2
   214b8:	297fffc4 	addi	r5,r5,-1
   214bc:	297fffcc 	andi	r5,r5,65535
   214c0:	00207680 	call	20768 <HW_EscReadIsr>
   214c4:	003fc106 	br	213cc <PDI_Isr+0xc4>

000214c8 <MainLoop>:
    if(bInitFinished == FALSE)
   214c8:	d0a65e03 	ldbu	r2,-26248(gp)
   214cc:	10003226 	beq	r2,zero,21598 <MainLoop+0xd0>
        if (
   214d0:	d0a67443 	ldbu	r2,-26159(gp)
{
   214d4:	deffff04 	addi	sp,sp,-4
   214d8:	dfc00015 	stw	ra,0(sp)
          && !bDcSyncActive                                               /* DC-Synchronous */
   214dc:	d0e67b83 	ldbu	r3,-26130(gp)
        if (
   214e0:	10000e1e 	bne	r2,zero,2151c <MainLoop+0x54>
          && !bDcSyncActive                                               /* DC-Synchronous */
   214e4:	18c03fcc 	andi	r3,r3,255
   214e8:	18001826 	beq	r3,zero,2154c <MainLoop+0x84>
        if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
   214ec:	d0a65a17 	ldw	r2,-26264(gp)
   214f0:	1083e830 	cmpltui	r2,r2,4000
   214f4:	1000011e 	bne	r2,zero,214fc <MainLoop+0x34>
            COE_SyncTimeStamp();
   214f8:	00208540 	call	20854 <COE_SyncTimeStamp>
        ECAT_Main();
   214fc:	00235ec0 	call	235ec <ECAT_Main>
       COE_Main();
   21500:	0020c980 	call	20c98 <COE_Main>
       CheckIfEcatError();
   21504:	00232500 	call	23250 <CheckIfEcatError>
    if (pAPPL_MainLoop != NULL)
   21508:	d0a66517 	ldw	r2,-26220(gp)
   2150c:	10001f26 	beq	r2,zero,2158c <MainLoop+0xc4>
}
   21510:	dfc00017 	ldw	ra,0(sp)
   21514:	dec00104 	addi	sp,sp,4
        pAPPL_MainLoop();
   21518:	1000683a 	jmp	r2
          && !bDcSyncActive                                               /* DC-Synchronous */
   2151c:	d0a67c03 	ldbu	r2,-26128(gp)
   21520:	10c4b03a 	or	r2,r2,r3
   21524:	10803fcc 	andi	r2,r2,255
   21528:	103ff01e 	bne	r2,zero,214ec <MainLoop+0x24>
             ECAT_Application();
   2152c:	002116c0 	call	2116c <ECAT_Application>
             if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
   21530:	d0a67c43 	ldbu	r2,-26127(gp)
   21534:	10800058 	cmpnei	r2,r2,1
   21538:	103fec1e 	bne	r2,zero,214ec <MainLoop+0x24>
   2153c:	d0a6718b 	ldhu	r2,-26170(gp)
   21540:	103fea26 	beq	r2,zero,214ec <MainLoop+0x24>
                PDO_InputMapping();
   21544:	0020e5c0 	call	20e5c <PDO_InputMapping>
   21548:	003fe806 	br	214ec <MainLoop+0x24>
                UINT16 ALEvent = HW_GetALEventRegister();
   2154c:	00207280 	call	20728 <HW_GetALEventRegister>
                if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21550:	10c1000c 	andi	r3,r2,1024
   21554:	18000626 	beq	r3,zero,21570 <MainLoop+0xa8>
                    bEcatFirstOutputsReceived = TRUE;
   21558:	00800044 	movi	r2,1
   2155c:	d0a67c05 	stb	r2,-26128(gp)
                    if ( bEcatOutputUpdateRunning )
   21560:	d0a67c83 	ldbu	r2,-26126(gp)
   21564:	103ff126 	beq	r2,zero,2152c <MainLoop+0x64>
                        PDO_OutputMapping();
   21568:	0020f780 	call	20f78 <PDO_OutputMapping>
   2156c:	003fef06 	br	2152c <MainLoop+0x64>
                else if ( nPdOutputSize == 0 )
   21570:	d0e6710b 	ldhu	r3,-26172(gp)
   21574:	183fed1e 	bne	r3,zero,2152c <MainLoop+0x64>
                    if ( ALEvent & PROCESS_INPUT_EVENT )
   21578:	1082000c 	andi	r2,r2,2048
   2157c:	103feb26 	beq	r2,zero,2152c <MainLoop+0x64>
                        bEcatFirstOutputsReceived = TRUE;
   21580:	00800044 	movi	r2,1
   21584:	d0a67c05 	stb	r2,-26128(gp)
   21588:	003fe806 	br	2152c <MainLoop+0x64>
}
   2158c:	dfc00017 	ldw	ra,0(sp)
   21590:	dec00104 	addi	sp,sp,4
   21594:	f800283a 	ret
   21598:	f800283a 	ret

0002159c <ESC_EepromAccess>:
 \brief        Controller (switch BIG_ENDIAN_FORMAT set) the data has to be swapped outside
 \brief        of this function)
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access)
{
   2159c:	defff404 	addi	sp,sp,-48
   215a0:	dd000615 	stw	r20,24(sp)
   215a4:	dcc00515 	stw	r19,20(sp)
   215a8:	d9000015 	stw	r4,0(sp)
   215ac:	3029883a 	mov	r20,r6
    UINT8 RetryCnt = MAX_CMD_RETIRES; //Maximum number of retries (evaluated in case of an Acknowledge Error)

    UINT16 nConfig;
    VARVOLATILE UINT16 nControl;

    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   215b0:	d9000104 	addi	r4,sp,4
   215b4:	01800084 	movi	r6,2
{
   215b8:	2827883a 	mov	r19,r5
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   215bc:	01414004 	movi	r5,1280
{
   215c0:	dfc00b15 	stw	ra,44(sp)
   215c4:	dd800815 	stw	r22,32(sp)
   215c8:	dc000215 	stw	r16,8(sp)
   215cc:	382d883a 	mov	r22,r7
   215d0:	3821883a 	mov	r16,r7
   215d4:	df000a15 	stw	fp,40(sp)
   215d8:	ddc00915 	stw	r23,36(sp)
   215dc:	dd400715 	stw	r21,28(sp)
   215e0:	dc800415 	stw	r18,16(sp)
   215e4:	dc400315 	stw	r17,12(sp)
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   215e8:	00206f00 	call	206f0 <HW_EscRead>
    HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   215ec:	01800084 	movi	r6,2
   215f0:	01414084 	movi	r5,1282
   215f4:	d9000184 	addi	r4,sp,6
   215f8:	00206f00 	call	206f0 <HW_EscRead>



    if ( nConfig & ESC_EEPROM_ASSIGN_TO_PDI_MASK )
   215fc:	d880010b 	ldhu	r2,4(sp)
   21600:	1080004c 	andi	r2,r2,1
   21604:	10006926 	beq	r2,zero,217ac <ESC_EepromAccess+0x210>
    {
        /* register 0x500.0 is set (should be written by the master before sending
        the state transition request to PREOP),we have access to the EEPROM */
        UINT16 step = 1; /* we write always only 1 word with one write access */

        if ( access == ESC_RD )
   21608:	84003fcc 	andi	r16,r16,255
   2160c:	84000098 	cmpnei	r16,r16,2
   21610:	1023883a 	mov	r17,r2
   21614:	8000041e 	bne	r16,zero,21628 <ESC_EepromAccess+0x8c>
        {
            /* read access requested, we have to check if we read 2 (register 0x502.6=0)
            or 4 words (register 0x502.6=1) with one access */
            if ( nControl & ESC_EEPROM_SUPPORTED_READBYTES_MASK )
   21618:	d880018b 	ldhu	r2,6(sp)
   2161c:	1080100c 	andi	r2,r2,64
   21620:	10002126 	beq	r2,zero,216a8 <ESC_EepromAccess+0x10c>
            {
                step = 4; /* we get 4 words with one read access */
   21624:	04400104 	movi	r17,4
            }
            else
            {
                if ( access == ESC_RD )
                {
                    UINT16 u16BytesToCopy = (step << 1);
   21628:	882e907a 	slli	r23,r17,1
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   2162c:	00804004 	movi	r2,256
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21630:	01800084 	movi	r6,2
   21634:	01414004 	movi	r5,1280
   21638:	d9000104 	addi	r4,sp,4
            if ( access == ESC_RD )
   2163c:	b5803fcc 	andi	r22,r22,255
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21640:	d880010d 	sth	r2,4(sp)
        for (i = 0; i < wordsize;)
   21644:	0025883a 	mov	r18,zero
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21648:	00207740 	call	20774 <HW_EscWrite>
        for (i = 0; i < wordsize;)
   2164c:	9d7fffcc 	andi	r21,r19,65535
                if ( access == ESC_RD )
   21650:	b7000098 	cmpnei	fp,r22,2
        for (i = 0; i < wordsize;)
   21654:	943fffcc 	andi	r16,r18,65535
   21658:	85401536 	bltu	r16,r21,216b0 <ESC_EepromAccess+0x114>
    UINT16 u16RetErr = 0;
   2165c:	0021883a 	mov	r16,zero
    }

    /* clear EEPROM control register 0x500 */
    nConfig = 0;

    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   21660:	01800084 	movi	r6,2
   21664:	01414004 	movi	r5,1280
   21668:	d9000104 	addi	r4,sp,4
    nConfig = 0;
   2166c:	d800010d 	sth	zero,4(sp)
    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   21670:	00207740 	call	20774 <HW_EscWrite>
    return u16RetErr;
}
   21674:	8005883a 	mov	r2,r16
   21678:	dfc00b17 	ldw	ra,44(sp)
   2167c:	df000a17 	ldw	fp,40(sp)
   21680:	ddc00917 	ldw	r23,36(sp)
   21684:	dd800817 	ldw	r22,32(sp)
   21688:	dd400717 	ldw	r21,28(sp)
   2168c:	dd000617 	ldw	r20,24(sp)
   21690:	dcc00517 	ldw	r19,20(sp)
   21694:	dc800417 	ldw	r18,16(sp)
   21698:	dc400317 	ldw	r17,12(sp)
   2169c:	dc000217 	ldw	r16,8(sp)
   216a0:	dec00c04 	addi	sp,sp,48
   216a4:	f800283a 	ret
                step = 2; /* we get 2 words with one read access */
   216a8:	04400084 	movi	r17,2
   216ac:	003fde06 	br	21628 <ESC_EepromAccess+0x8c>
            HW_EscWrite((MEM_ADDR *) &wordaddress, ESC_EEPROM_ADDRESS_OFFSET, 4);
   216b0:	01800104 	movi	r6,4
   216b4:	01414104 	movi	r5,1284
   216b8:	d809883a 	mov	r4,sp
   216bc:	00207740 	call	20774 <HW_EscWrite>
            if ( access == ESC_RD )
   216c0:	b0800098 	cmpnei	r2,r22,2
   216c4:	10001b1e 	bne	r2,zero,21734 <ESC_EepromAccess+0x198>
                nControl = ESC_EEPROM_CMD_READ_MASK;
   216c8:	00804004 	movi	r2,256
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   216cc:	01800084 	movi	r6,2
   216d0:	01414084 	movi	r5,1282
   216d4:	d9000184 	addi	r4,sp,6
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   216d8:	d880018d 	sth	r2,6(sp)
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   216dc:	00207740 	call	20774 <HW_EscWrite>
                HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   216e0:	01800084 	movi	r6,2
   216e4:	01414084 	movi	r5,1282
   216e8:	d9000184 	addi	r4,sp,6
   216ec:	00206f00 	call	206f0 <HW_EscRead>
            while ( nControl & (ESC_EEPROM_BUSY_MASK));
   216f0:	d880018b 	ldhu	r2,6(sp)
   216f4:	10bfffcc 	andi	r2,r2,65535
   216f8:	10a0001c 	xori	r2,r2,32768
   216fc:	10a00004 	addi	r2,r2,-32768
   21700:	103ff716 	blt	r2,zero,216e0 <ESC_EepromAccess+0x144>
            HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21704:	01800084 	movi	r6,2
   21708:	01414084 	movi	r5,1282
   2170c:	d9000184 	addi	r4,sp,6
   21710:	00206f00 	call	206f0 <HW_EscRead>
            if ( nControl & ESC_EEPROM_ERROR_MASK )
   21714:	d880018b 	ldhu	r2,6(sp)
   21718:	109e000c 	andi	r2,r2,30720
   2171c:	10000c26 	beq	r2,zero,21750 <ESC_EepromAccess+0x1b4>
                if(!(nControl & ESC_EEPROM_ERROR_CMD_ACK) && (RetryCnt != 0))
   21720:	d880018b 	ldhu	r2,6(sp)
   21724:	1088000c 	andi	r2,r2,8192
   21728:	1000141e 	bne	r2,zero,2177c <ESC_EepromAccess+0x1e0>
                    u16RetErr =  ALSTATUSCODE_EE_ERROR;
   2172c:	04001444 	movi	r16,81
   21730:	003fcb06 	br	21660 <ESC_EepromAccess+0xc4>
                HW_EscWriteWord(pData[i],ESC_EEPROM_DATA_OFFSET);
   21734:	8008907a 	slli	r4,r16,1
   21738:	01800084 	movi	r6,2
   2173c:	01414204 	movi	r5,1288
   21740:	a109883a 	add	r4,r20,r4
   21744:	00207740 	call	20774 <HW_EscWrite>
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   21748:	00808004 	movi	r2,512
   2174c:	003fdf06 	br	216cc <ESC_EepromAccess+0x130>
                if ( access == ESC_RD )
   21750:	e0000a1e 	bne	fp,zero,2177c <ESC_EepromAccess+0x1e0>
                    if((u16WordOffset + step) > wordsize)
   21754:	88bfffcc 	andi	r2,r17,65535
   21758:	8085883a 	add	r2,r16,r2
   2175c:	a880100e 	bge	r21,r2,217a0 <ESC_EepromAccess+0x204>
                        u16BytesToCopy = (wordsize - u16WordOffset) << 1;
   21760:	9c8dc83a 	sub	r6,r19,r18
   21764:	300c907a 	slli	r6,r6,1
                    HW_EscRead((MEM_ADDR *) &pData[i], ESC_EEPROM_DATA_OFFSET, u16BytesToCopy);
   21768:	8008907a 	slli	r4,r16,1
   2176c:	31bfffcc 	andi	r6,r6,65535
   21770:	01414204 	movi	r5,1288
   21774:	a109883a 	add	r4,r20,r4
   21778:	00206f00 	call	206f0 <HW_EscRead>
            if(!(nControl & ESC_EEPROM_ERROR_MASK))
   2177c:	d880018b 	ldhu	r2,6(sp)
   21780:	109e000c 	andi	r2,r2,30720
   21784:	1000081e 	bne	r2,zero,217a8 <ESC_EepromAccess+0x20c>
                wordaddress += step;
   21788:	d8800017 	ldw	r2,0(sp)
   2178c:	88ffffcc 	andi	r3,r17,65535
                u16WordOffset +=step;
   21790:	9465883a 	add	r18,r18,r17
                wordaddress += step;
   21794:	10c5883a 	add	r2,r2,r3
   21798:	d8800015 	stw	r2,0(sp)
                i += step;
   2179c:	003fad06 	br	21654 <ESC_EepromAccess+0xb8>
                    UINT16 u16BytesToCopy = (step << 1);
   217a0:	b80d883a 	mov	r6,r23
   217a4:	003ff006 	br	21768 <ESC_EepromAccess+0x1cc>
                    while(i32TimeoutTicks > 0)
   217a8:	003fff06 	br	217a8 <ESC_EepromAccess+0x20c>
        u16RetErr = ALSTATUSCODE_EE_NOACCESS;
   217ac:	04001404 	movi	r16,80
   217b0:	003fab06 	br	21660 <ESC_EepromAccess+0xc4>

000217b4 <ESC_EepromWriteCRC>:

 \brief        This function recalculates the EEPROM CRC and writes the updated value to EEPROM.
            After writing the ESC Config Area a device restart is required!
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 ESC_EepromWriteCRC(void)
{
   217b4:	defffa04 	addi	sp,sp,-24
    UINT16 u16Return = ALSTATUSCODE_UNSPECIFIEDERROR;
    UINT16 EscCfgData[8];
    UINT16 u16Crc = 0x00FF;
   217b8:	00803fc4 	movi	r2,255
    UINT16 i,j;

    
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   217bc:	01c00084 	movi	r7,2
   217c0:	d9800104 	addi	r6,sp,4
   217c4:	014001c4 	movi	r5,7
   217c8:	0009883a 	mov	r4,zero
{
   217cc:	dfc00515 	stw	ra,20(sp)
    UINT16 u16Crc = 0x00FF;
   217d0:	d880008d 	sth	r2,2(sp)
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   217d4:	002159c0 	call	2159c <ESC_EepromAccess>
    if(u16Return == 0)
   217d8:	10ffffcc 	andi	r3,r2,65535
   217dc:	18001c1e 	bne	r3,zero,21850 <ESC_EepromWriteCRC+0x9c>
   217e0:	d880008b 	ldhu	r2,2(sp)
    {
        UINT8 *pData = (UINT8 *)EscCfgData;

        for(i = 0; i < 14; i++ )
        {
            u16Crc ^= pData[i];
   217e4:	d9000104 	addi	r4,sp,4
   217e8:	20c9883a 	add	r4,r4,r3
   217ec:	21000003 	ldbu	r4,0(r4)
   217f0:	01400204 	movi	r5,8
   217f4:	2084f03a 	xor	r2,r4,r2

            for(j=0; j<8; j++ )
            {
                if( u16Crc & 0x80 )
   217f8:	1100200c 	andi	r4,r2,128
   217fc:	20001726 	beq	r4,zero,2185c <ESC_EepromWriteCRC+0xa8>
   21800:	10bfffcc 	andi	r2,r2,65535
                {
                    u16Crc = (u16Crc<<1) ^ 0x07;
   21804:	1004907a 	slli	r2,r2,1
   21808:	108001dc 	xori	r2,r2,7
            for(j=0; j<8; j++ )
   2180c:	293fffc4 	addi	r4,r5,-1
   21810:	200b883a 	mov	r5,r4
   21814:	213fffcc 	andi	r4,r4,65535
   21818:	203ff71e 	bne	r4,zero,217f8 <ESC_EepromWriteCRC+0x44>
        for(i = 0; i < 14; i++ )
   2181c:	18c00044 	addi	r3,r3,1
   21820:	19000398 	cmpnei	r4,r3,14
   21824:	203fef1e 	bne	r4,zero,217e4 <ESC_EepromWriteCRC+0x30>
                }
            }
        }

        /*only low Byte shall be written*/
        u16Crc &= 0x00FF;
   21828:	10803fcc 	andi	r2,r2,255

        /*write new calculated Crc to Esc Config area*/
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   2182c:	01c00104 	movi	r7,4
   21830:	d9800084 	addi	r6,sp,2
   21834:	01400044 	movi	r5,1
   21838:	010001c4 	movi	r4,7
        u16Crc &= 0x00FF;
   2183c:	d880008d 	sth	r2,2(sp)
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   21840:	002159c0 	call	2159c <ESC_EepromAccess>
        if(u16Return == 0)
   21844:	10ffffcc 	andi	r3,r2,65535
   21848:	1800011e 	bne	r3,zero,21850 <ESC_EepromWriteCRC+0x9c>
        {
            u16Return =  ALSTATUSCODE_WAITFORCOLDSTART;
   2184c:	00800804 	movi	r2,32
        }
    }

    return u16Return;
}
   21850:	dfc00517 	ldw	ra,20(sp)
   21854:	dec00604 	addi	sp,sp,24
   21858:	f800283a 	ret
                    u16Crc <<= 1;
   2185c:	1004907a 	slli	r2,r2,1
   21860:	003fea06 	br	2180c <ESC_EepromWriteCRC+0x58>

00021864 <COE_Init>:
 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
    pCoeSendStored = 0;
   21864:	d0266915 	stw	zero,-26204(gp)
    nSdoInfoFragmentsLeft = 0;
   21868:	d0268f8d 	sth	zero,-26050(gp)
}
   2186c:	f800283a 	ret

00021870 <COE_ServiceInd>:

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
    UINT8 result = 0;

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
   21870:	2080018b 	ldhu	r2,6(r4)
   21874:	1004d33a 	srli	r2,r2,12
   21878:	10c00228 	cmpgeui	r3,r2,8
   2187c:	1800081e 	bne	r3,zero,218a0 <COE_ServiceInd+0x30>
   21880:	10c000e8 	cmpgeui	r3,r2,3
   21884:	18000a1e 	bne	r3,zero,218b0 <COE_ServiceInd+0x40>
   21888:	10c00060 	cmpeqi	r3,r2,1
   2188c:	1800081e 	bne	r3,zero,218b0 <COE_ServiceInd+0x40>
   21890:	108000a0 	cmpeqi	r2,r2,2
   21894:	1000051e 	bne	r2,zero,218ac <COE_ServiceInd+0x3c>
   21898:	00800144 	movi	r2,5
   2189c:	f800283a 	ret
   218a0:	10800220 	cmpeqi	r2,r2,8
   218a4:	103ffc26 	beq	r2,zero,21898 <COE_ServiceInd+0x28>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
        break;

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
   218a8:	00262181 	jmpi	26218 <SDOS_SdoInfoInd>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
   218ac:	002579c1 	jmpi	2579c <SDOS_SdoInd>
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
   218b0:	00800104 	movi	r2,4
    default:
        result = MBXERR_INVALIDHEADER;
        break;
    }
    return result;
}
   218b4:	f800283a 	ret

000218b8 <COE_ContinueInd>:
 \brief  be put in the send mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if (pCoeSendStored)
   218b8:	d1266917 	ldw	r4,-26204(gp)
{
   218bc:	deffff04 	addi	sp,sp,-4
   218c0:	dfc00015 	stw	ra,0(sp)
    if (pCoeSendStored)
   218c4:	20000926 	beq	r4,zero,218ec <COE_ContinueInd+0x34>
    {
        /* send the stored CoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) COE8*/
        if (MBX_MailboxSendReq(pCoeSendStored, COE_SERVICE) == 0)
   218c8:	01400084 	movi	r5,2
   218cc:	0023d280 	call	23d28 <MBX_MailboxSendReq>
   218d0:	10803fcc 	andi	r2,r2,255
   218d4:	1000011e 	bne	r2,zero,218dc <COE_ContinueInd+0x24>
        {
            pCoeSendStored = 0;
   218d8:	d0266915 	stw	zero,-26204(gp)
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
        }
    }

    return 0;
   218dc:	0005883a 	mov	r2,zero
}
   218e0:	dfc00017 	ldw	ra,0(sp)
   218e4:	dec00104 	addi	sp,sp,4
   218e8:	f800283a 	ret
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
   218ec:	01002004 	movi	r4,128
   218f0:	0026b7c0 	call	26b7c <malloc>
   218f4:	1009883a 	mov	r4,r2
        if (pMbx == NULL)
   218f8:	10000726 	beq	r2,zero,21918 <COE_ContinueInd+0x60>
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
   218fc:	014000f4 	movhi	r5,3
   21900:	01800384 	movi	r6,14
   21904:	29730c04 	addi	r5,r5,-13264
   21908:	0026e840 	call	26e84 <memcpy>
   2190c:	1009883a 	mov	r4,r2
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
   21910:	00262180 	call	26218 <SDOS_SdoInfoInd>
   21914:	003ff106 	br	218dc <COE_ContinueInd+0x24>
            return MBXERR_NOMOREMEMORY;
   21918:	008001c4 	movi	r2,7
   2191c:	003ff006 	br	218e0 <COE_ContinueInd+0x28>

00021920 <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
   21920:	defffd04 	addi	sp,sp,-12
   21924:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21928:	01800084 	movi	r6,2
{
   2192c:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21930:	01408104 	movi	r5,516
   21934:	d9000084 	addi	r4,sp,2
{
   21938:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   2193c:	00206f00 	call	206f0 <HW_EscRead>
    
    mask &= intMask;
   21940:	d880008b 	ldhu	r2,2(sp)


    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21944:	01800084 	movi	r6,2
   21948:	01408104 	movi	r5,516
    mask &= intMask;
   2194c:	80a0703a 	and	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21950:	d9000084 	addi	r4,sp,2
    mask &= intMask;
   21954:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21958:	00207740 	call	20774 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   2195c:	dfc00217 	ldw	ra,8(sp)
   21960:	dc000117 	ldw	r16,4(sp)
   21964:	dec00304 	addi	sp,sp,12
   21968:	f800283a 	ret

0002196c <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
   2196c:	defffd04 	addi	sp,sp,-12
   21970:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21974:	01800084 	movi	r6,2
{
   21978:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   2197c:	01408104 	movi	r5,516
   21980:	d9000084 	addi	r4,sp,2
{
   21984:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21988:	00206f00 	call	206f0 <HW_EscRead>
    

    mask |= intMask;
   2198c:	d880008b 	ldhu	r2,2(sp)

    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21990:	01800084 	movi	r6,2
   21994:	01408104 	movi	r5,516
    mask |= intMask;
   21998:	80a0b03a 	or	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   2199c:	d9000084 	addi	r4,sp,2
    mask |= intMask;
   219a0:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219a4:	00207740 	call	20774 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   219a8:	dfc00217 	ldw	ra,8(sp)
   219ac:	dc000117 	ldw	r16,4(sp)
   219b0:	dec00304 	addi	sp,sp,12
   219b4:	f800283a 	ret

000219b8 <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
   219b8:	defffe04 	addi	sp,sp,-8
    UINT16 TmpVar = 0;
    //read EEPROM loaded information
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   219bc:	01800084 	movi	r6,2
   219c0:	01414084 	movi	r5,1282
   219c4:	d9000084 	addi	r4,sp,2
{
   219c8:	dfc00115 	stw	ra,4(sp)
    UINT16 TmpVar = 0;
   219cc:	d800008d 	sth	zero,2(sp)
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   219d0:	00206f00 	call	206f0 <HW_EscRead>
    TmpVar = SWAPWORD(TmpVar);


    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
   219d4:	d880008b 	ldhu	r2,2(sp)
   219d8:	1086000c 	andi	r2,r2,6144
   219dc:	1005003a 	cmpeq	r2,r2,zero
   219e0:	d0a66a05 	stb	r2,-26200(gp)
    }
    else
    {
        EepromLoaded = TRUE;
    }
}
   219e4:	dfc00117 	ldw	ra,4(sp)
   219e8:	dec00204 	addi	sp,sp,8
   219ec:	f800283a 	ret

000219f0 <GetSyncMan>:
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   219f0:	21403fcc 	andi	r5,r4,255
   219f4:	29404004 	addi	r5,r5,256
   219f8:	280a90fa 	slli	r5,r5,3
{
   219fc:	deffff04 	addi	sp,sp,-4
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a00:	01800204 	movi	r6,8
   21a04:	d1266a84 	addi	r4,gp,-26198
{
   21a08:	dfc00015 	stw	ra,0(sp)
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a0c:	00206f00 	call	206f0 <HW_EscRead>



    return &SyncManInfo;
}
   21a10:	d0a66a84 	addi	r2,gp,-26198
   21a14:	dfc00017 	ldw	ra,0(sp)
   21a18:	dec00104 	addi	sp,sp,4
   21a1c:	f800283a 	ret

00021a20 <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
   21a20:	defffd04 	addi	sp,sp,-12
   21a24:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21a28:	24003fcc 	andi	r16,r4,255
   21a2c:	802090fa 	slli	r16,r16,3
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21a30:	00800044 	movi	r2,1

    HW_EscWriteByte(smStatus,Offset);
   21a34:	01800044 	movi	r6,1
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21a38:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21a3c:	843fffcc 	andi	r16,r16,65535
   21a40:	800b883a 	mov	r5,r16
   21a44:	d90000c4 	addi	r4,sp,3
{
   21a48:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21a4c:	d88000c5 	stb	r2,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21a50:	00207740 	call	20774 <HW_EscWrite>
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadByte(smStatus, Offset);
   21a54:	01800044 	movi	r6,1
   21a58:	800b883a 	mov	r5,r16
   21a5c:	d90000c4 	addi	r4,sp,3
   21a60:	00206f00 	call	206f0 <HW_EscRead>
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
   21a64:	d88000c3 	ldbu	r2,3(sp)
   21a68:	1080004c 	andi	r2,r2,1
   21a6c:	103ff926 	beq	r2,zero,21a54 <DisableSyncManChannel+0x34>
}
   21a70:	dfc00217 	ldw	ra,8(sp)
   21a74:	dc000117 	ldw	r16,4(sp)
   21a78:	dec00304 	addi	sp,sp,12
   21a7c:	f800283a 	ret

00021a80 <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
   21a80:	defffd04 	addi	sp,sp,-12
   21a84:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = 0x00;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21a88:	24003fcc 	andi	r16,r4,255
   21a8c:	802090fa 	slli	r16,r16,3

    HW_EscWriteByte(smStatus,Offset);
   21a90:	01800044 	movi	r6,1
   21a94:	d90000c4 	addi	r4,sp,3
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21a98:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21a9c:	843fffcc 	andi	r16,r16,65535
   21aa0:	800b883a 	mov	r5,r16
{
   21aa4:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = 0x00;
   21aa8:	d80000c5 	stb	zero,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21aac:	00207740 	call	20774 <HW_EscWrite>
    
    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadByte(smStatus,Offset);
   21ab0:	01800044 	movi	r6,1
   21ab4:	800b883a 	mov	r5,r16
   21ab8:	d90000c4 	addi	r4,sp,3
   21abc:	00206f00 	call	206f0 <HW_EscRead>
    }while((smStatus & SM_SETTING_PDI_DISABLE));
   21ac0:	d88000c3 	ldbu	r2,3(sp)
   21ac4:	1080004c 	andi	r2,r2,1
   21ac8:	103ff91e 	bne	r2,zero,21ab0 <EnableSyncManChannel+0x30>
}
   21acc:	dfc00217 	ldw	ra,8(sp)
   21ad0:	dc000117 	ldw	r16,4(sp)
   21ad4:	dec00304 	addi	sp,sp,12
   21ad8:	f800283a 	ret

00021adc <CheckSmSettings>:
    UINT16 SMLength = 0;
    UINT16 SMAddress = 0;


        //Check if max address defines are within the available ESC address range
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21adc:	d0a6700b 	ldhu	r2,-26176(gp)
{
   21ae0:	defffc04 	addi	sp,sp,-16
   21ae4:	dfc00315 	stw	ra,12(sp)
   21ae8:	dc800215 	stw	r18,8(sp)
   21aec:	dc400115 	stw	r17,4(sp)
   21af0:	dc000015 	stw	r16,0(sp)
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21af4:	108bfff0 	cmpltui	r2,r2,12287
   21af8:	1000921e 	bne	r2,zero,21d44 <CheckSmSettings+0x268>
   21afc:	2025883a 	mov	r18,r4
   21b00:	2023883a 	mov	r17,r4

                return ALSTATUSCODE_NOVALIDFIRMWARE;
        }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
   21b04:	0009883a 	mov	r4,zero
   21b08:	00219f00 	call	219f0 <GetSyncMan>
    SMLength = pSyncMan->Length;
    SMAddress = pSyncMan->PhysicalStartAddress;



    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b0c:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21b10:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21b14:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b18:	2940004c 	andi	r5,r5,1
   21b1c:	2800081e 	bne	r5,zero,21b40 <CheckSmSettings+0x64>
            result = SYNCMANCHSIZE + 1;
        }

        if ( result != 0 )
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21b20:	04000584 	movi	r16,22
            pSyncMan = GetSyncMan(i);
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
        }
    }
    return result;
}
   21b24:	8005883a 	mov	r2,r16
   21b28:	dfc00317 	ldw	ra,12(sp)
   21b2c:	dc800217 	ldw	r18,8(sp)
   21b30:	dc400117 	ldw	r17,4(sp)
   21b34:	dc000017 	ldw	r16,0(sp)
   21b38:	dec00404 	addi	sp,sp,16
   21b3c:	f800283a 	ret
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
   21b40:	10800103 	ldbu	r2,4(r2)
   21b44:	1140030c 	andi	r5,r2,12
   21b48:	29400118 	cmpnei	r5,r5,4
   21b4c:	283ff41e 	bne	r5,zero,21b20 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21b50:	1080008c 	andi	r2,r2,2
   21b54:	103ff226 	beq	r2,zero,21b20 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21b58:	20bff704 	addi	r2,r4,-36
   21b5c:	10bfffcc 	andi	r2,r2,65535
   21b60:	10801768 	cmpgeui	r2,r2,93
   21b64:	103fee1e 	bne	r2,zero,21b20 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
   21b68:	18bc0004 	addi	r2,r3,-4096
   21b6c:	10bfffcc 	andi	r2,r2,65535
   21b70:	10880028 	cmpgeui	r2,r2,8192
   21b74:	103fea1e 	bne	r2,zero,21b20 <CheckSmSettings+0x44>
        pSyncMan = GetSyncMan(MAILBOX_READ);
   21b78:	01000044 	movi	r4,1
   21b7c:	00219f00 	call	219f0 <GetSyncMan>
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b80:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21b84:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21b88:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b8c:	2940004c 	andi	r5,r5,1
   21b90:	283fe326 	beq	r5,zero,21b20 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
   21b94:	10800103 	ldbu	r2,4(r2)
   21b98:	1140030c 	andi	r5,r2,12
   21b9c:	2821883a 	mov	r16,r5
   21ba0:	283fdf1e 	bne	r5,zero,21b20 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21ba4:	1080008c 	andi	r2,r2,2
   21ba8:	103fdd26 	beq	r2,zero,21b20 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21bac:	20bff704 	addi	r2,r4,-36
   21bb0:	10bfffcc 	andi	r2,r2,65535
   21bb4:	10801768 	cmpgeui	r2,r2,93
   21bb8:	103fd91e 	bne	r2,zero,21b20 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_READ_ADDRESS)
   21bbc:	18bc0004 	addi	r2,r3,-4096
   21bc0:	10bfffcc 	andi	r2,r2,65535
   21bc4:	10880028 	cmpgeui	r2,r2,8192
   21bc8:	103fd51e 	bne	r2,zero,21b20 <CheckSmSettings+0x44>
    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
   21bcc:	94803fcc 	andi	r18,r18,255
   21bd0:	90800130 	cmpltui	r2,r18,4
   21bd4:	1000421e 	bne	r2,zero,21ce0 <CheckSmSettings+0x204>
        b3BufferMode = TRUE;
   21bd8:	00800044 	movi	r2,1
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21bdc:	010000c4 	movi	r4,3
        b3BufferMode = TRUE;
   21be0:	d0a67405 	stb	r2,-26160(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21be4:	00219f00 	call	219f0 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21be8:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21bec:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21bf0:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21bf4:	2940004c 	andi	r5,r5,1
   21bf8:	28003426 	beq	r5,zero,21ccc <CheckSmSettings+0x1f0>
   21bfc:	217fffc4 	addi	r5,r4,-1
   21c00:	297fffcc 	andi	r5,r5,65535
   21c04:	29401a28 	cmpgeui	r5,r5,104
   21c08:	28000d1e 	bne	r5,zero,21c40 <CheckSmSettings+0x164>
                if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
   21c0c:	d166718b 	ldhu	r5,-26170(gp)
   21c10:	213fffcc 	andi	r4,r4,65535
   21c14:	21400a1e 	bne	r4,r5,21c40 <CheckSmSettings+0x164>
                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
   21c18:	10800103 	ldbu	r2,4(r2)
   21c1c:	1100030c 	andi	r4,r2,12
   21c20:	2000071e 	bne	r4,zero,21c40 <CheckSmSettings+0x164>
                        if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
   21c24:	d1266fc3 	ldbu	r4,-26177(gp)
   21c28:	21000098 	cmpnei	r4,r4,2
   21c2c:	2000061e 	bne	r4,zero,21c48 <CheckSmSettings+0x16c>
   21c30:	18fc0004 	addi	r3,r3,-4096
   21c34:	18ffffcc 	andi	r3,r3,65535
   21c38:	18c80030 	cmpltui	r3,r3,8192
   21c3c:	1800051e 	bne	r3,zero,21c54 <CheckSmSettings+0x178>
            result = ALSTATUSCODE_INVALIDSMINCFG;
   21c40:	04000784 	movi	r16,30
   21c44:	003fb706 	br	21b24 <CheckSmSettings+0x48>
                            || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
   21c48:	d1266e0b 	ldhu	r4,-26184(gp)
   21c4c:	18ffffcc 	andi	r3,r3,65535
   21c50:	193ffb1e 	bne	r3,r4,21c40 <CheckSmSettings+0x164>
                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21c54:	1080008c 	andi	r2,r2,2
   21c58:	10000126 	beq	r2,zero,21c60 <CheckSmSettings+0x184>
                                    b3BufferMode = FALSE;
   21c5c:	d0267405 	stb	zero,-26160(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21c60:	01000084 	movi	r4,2
   21c64:	00219f00 	call	219f0 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21c68:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21c6c:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21c70:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21c74:	2940004c 	andi	r5,r5,1
   21c78:	28002d26 	beq	r5,zero,21d30 <CheckSmSettings+0x254>
   21c7c:	217fffc4 	addi	r5,r4,-1
   21c80:	297fffcc 	andi	r5,r5,65535
   21c84:	29400128 	cmpgeui	r5,r5,4
   21c88:	28000e1e 	bne	r5,zero,21cc4 <CheckSmSettings+0x1e8>
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
   21c8c:	d166710b 	ldhu	r5,-26172(gp)
   21c90:	213fffcc 	andi	r4,r4,65535
   21c94:	21400b1e 	bne	r4,r5,21cc4 <CheckSmSettings+0x1e8>
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
   21c98:	10800103 	ldbu	r2,4(r2)
   21c9c:	1100030c 	andi	r4,r2,12
   21ca0:	21000118 	cmpnei	r4,r4,4
   21ca4:	2000071e 	bne	r4,zero,21cc4 <CheckSmSettings+0x1e8>
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
   21ca8:	d1266fc3 	ldbu	r4,-26177(gp)
   21cac:	21000098 	cmpnei	r4,r4,2
   21cb0:	2000151e 	bne	r4,zero,21d08 <CheckSmSettings+0x22c>
   21cb4:	18fc0004 	addi	r3,r3,-4096
   21cb8:	18ffffcc 	andi	r3,r3,65535
   21cbc:	18c80030 	cmpltui	r3,r3,8192
   21cc0:	1800141e 	bne	r3,zero,21d14 <CheckSmSettings+0x238>
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21cc4:	04000744 	movi	r16,29
   21cc8:	003f9606 	br	21b24 <CheckSmSettings+0x48>
        else if (SMLength != 0 || nPdInputSize != 0)
   21ccc:	d0a6718b 	ldhu	r2,-26170(gp)
   21cd0:	1104b03a 	or	r2,r2,r4
   21cd4:	10bfffcc 	andi	r2,r2,65535
   21cd8:	103fe126 	beq	r2,zero,21c60 <CheckSmSettings+0x184>
   21cdc:	003fd806 	br	21c40 <CheckSmSettings+0x164>
    if (result == 0 && maxChannel > PROCESS_DATA_OUT)
   21ce0:	948000e0 	cmpeqi	r18,r18,3
   21ce4:	903fde1e 	bne	r18,zero,21c60 <CheckSmSettings+0x184>
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21ce8:	d0a67083 	ldbu	r2,-26174(gp)
   21cec:	89003fcc 	andi	r4,r17,255
   21cf0:	20bf8c2e 	bgeu	r4,r2,21b24 <CheckSmSettings+0x48>
            pSyncMan = GetSyncMan(i);
   21cf4:	00219f00 	call	219f0 <GetSyncMan>
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21cf8:	10800183 	ldbu	r2,6(r2)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21cfc:	8c400044 	addi	r17,r17,1
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21d00:	d0a66c85 	stb	r2,-26190(gp)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d04:	003ff806 	br	21ce8 <CheckSmSettings+0x20c>
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
   21d08:	d1266e8b 	ldhu	r4,-26182(gp)
   21d0c:	18ffffcc 	andi	r3,r3,65535
   21d10:	193fec1e 	bne	r3,r4,21cc4 <CheckSmSettings+0x1e8>
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   21d14:	1006d1ba 	srli	r3,r2,6
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21d18:	1080008c 	andi	r2,r2,2
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   21d1c:	18c0004c 	andi	r3,r3,1
                                bWdTrigger = TRUE;
   21d20:	d0e67bc5 	stb	r3,-26129(gp)
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21d24:	103ff026 	beq	r2,zero,21ce8 <CheckSmSettings+0x20c>
                                b3BufferMode = FALSE;
   21d28:	d0267405 	stb	zero,-26160(gp)
   21d2c:	003fee06 	br	21ce8 <CheckSmSettings+0x20c>
        else if (SMLength != 0 || nPdOutputSize != 0)
   21d30:	d0a6710b 	ldhu	r2,-26172(gp)
   21d34:	1104b03a 	or	r2,r2,r4
   21d38:	10bfffcc 	andi	r2,r2,65535
   21d3c:	103fea26 	beq	r2,zero,21ce8 <CheckSmSettings+0x20c>
   21d40:	003fe006 	br	21cc4 <CheckSmSettings+0x1e8>
                return ALSTATUSCODE_NOVALIDFIRMWARE;
   21d44:	04000504 	movi	r16,20
   21d48:	003f7606 	br	21b24 <CheckSmSettings+0x48>

00021d4c <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
   21d4c:	defff104 	addi	sp,sp,-60
   21d50:	dc800715 	stw	r18,28(sp)
   21d54:	dc000515 	stw	r16,20(sp)
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21d58:	048000f4 	movhi	r18,3
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   21d5c:	040000f4 	movhi	r16,3
   21d60:	8432fb04 	addi	r16,r16,-13332
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21d64:	94b2ea04 	addi	r18,r18,-13400
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21d68:	01000084 	movi	r4,2
{
   21d6c:	dd000915 	stw	r20,36(sp)
   21d70:	dcc00815 	stw	r19,32(sp)
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21d74:	9500030b 	ldhu	r20,12(r18)
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   21d78:	84c0030b 	ldhu	r19,12(r16)
{
   21d7c:	dfc00e15 	stw	ra,56(sp)
   21d80:	df000d15 	stw	fp,52(sp)
   21d84:	ddc00c15 	stw	r23,48(sp)
   21d88:	dd800b15 	stw	r22,44(sp)
   21d8c:	dd400a15 	stw	r21,40(sp)
   21d90:	dc400615 	stw	r17,24(sp)
    UINT16     wdiv = 0;
   21d94:	d800020d 	sth	zero,8(sp)
    UINT16     wd = 0;
   21d98:	d800028d 	sth	zero,10(sp)
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
   21d9c:	d8000315 	stw	zero,12(sp)
    UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
   21da0:	d8000415 	stw	zero,16(sp)
    u16ALEventMask = 0;
   21da4:	d0266d8d 	sth	zero,-26186(gp)
    bEcatFirstOutputsReceived = FALSE;
   21da8:	d0267c05 	stb	zero,-26128(gp)
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21dac:	00219f00 	call	219f0 <GetSyncMan>
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   21db0:	10c0000b 	ldhu	r3,0(r2)
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21db4:	10800103 	ldbu	r2,4(r2)
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   21db8:	d0e66e8d 	sth	r3,-26182(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21dbc:	1080008c 	andi	r2,r2,2
   21dc0:	1000491e 	bne	r2,zero,21ee8 <StartInputHandler+0x19c>
    UINT16    nPdOutputBuffer = 3;
   21dc4:	070000c4 	movi	fp,3
       nPdOutputBuffer = 1;
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21dc8:	010000c4 	movi	r4,3
   21dcc:	00219f00 	call	219f0 <GetSyncMan>
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   21dd0:	1440000b 	ldhu	r17,0(r2)


    /* get the number of input buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21dd4:	10800103 	ldbu	r2,4(r2)
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   21dd8:	d4666e0d 	sth	r17,-26184(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21ddc:	1080008c 	andi	r2,r2,2
   21de0:	1000431e 	bne	r2,zero,21ef0 <StartInputHandler+0x1a4>
    UINT16    nPdInputBuffer = 3;
   21de4:	010000c4 	movi	r4,3
        nPdInputBuffer = 1;
    }
    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21de8:	d5a6718b 	ldhu	r22,-26170(gp)
   21dec:	210000cc 	andi	r4,r4,3
   21df0:	8c7fffcc 	andi	r17,r17,65535
   21df4:	b00b883a 	mov	r5,r22
   21df8:	0026b540 	call	26b54 <__mulsi3>
   21dfc:	d0e6830b 	ldhu	r3,-26100(gp)
   21e00:	1445883a 	add	r2,r2,r17
   21e04:	1880030e 	bge	r3,r2,21e14 <StartInputHandler+0xc8>
   21e08:	d126848b 	ldhu	r4,-26094(gp)
   21e0c:	20c9883a 	add	r4,r4,r3
   21e10:	8901a316 	blt	r17,r4,224a0 <StartInputHandler+0x754>
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   21e14:	d5e6838b 	ldhu	r23,-26098(gp)
   21e18:	b880030e 	bge	r23,r2,21e28 <StartInputHandler+0xdc>
   21e1c:	d0a6840b 	ldhu	r2,-26096(gp)
   21e20:	15c5883a 	add	r2,r2,r23
   21e24:	88819e16 	blt	r17,r2,224a0 <StartInputHandler+0x754>
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e28:	d126710b 	ldhu	r4,-26172(gp)
   21e2c:	e14000cc 	andi	r5,fp,3
   21e30:	d8c00015 	stw	r3,0(sp)
   21e34:	d5666e8b 	ldhu	r21,-26182(gp)
   21e38:	0026b540 	call	26b54 <__mulsi3>
    if (
   21e3c:	d8c00017 	ldw	r3,0(sp)
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e40:	1545883a 	add	r2,r2,r21
    if (
   21e44:	1880030e 	bge	r3,r2,21e54 <StartInputHandler+0x108>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e48:	d126848b 	ldhu	r4,-26094(gp)
   21e4c:	20c7883a 	add	r3,r4,r3
   21e50:	a8c19516 	blt	r21,r3,224a8 <StartInputHandler+0x75c>
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   21e54:	b880030e 	bge	r23,r2,21e64 <StartInputHandler+0x118>
   21e58:	d0e6840b 	ldhu	r3,-26096(gp)
   21e5c:	1dc7883a 	add	r3,r3,r23
   21e60:	a8c19116 	blt	r21,r3,224a8 <StartInputHandler+0x75c>
        ||
   21e64:	8880020e 	bge	r17,r2,21e70 <StartInputHandler+0x124>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
   21e68:	8da3883a 	add	r17,r17,r22
   21e6c:	ac418e16 	blt	r21,r17,224a8 <StartInputHandler+0x75c>
        --- Check configured synchronization ---
    */

    /* Get the DC Control/Activation register value*/
    /*Read register 0x981 (corresponding masks are adapted)*/
    HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
   21e70:	01800044 	movi	r6,1
   21e74:	01426044 	movi	r5,2433
   21e78:	d9000184 	addi	r4,sp,6
   21e7c:	00206f00 	call	206f0 <HW_EscRead>

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
   21e80:	01800104 	movi	r6,4
   21e84:	01426804 	movi	r5,2464
   21e88:	d9000304 	addi	r4,sp,12
   21e8c:	00206f00 	call	206f0 <HW_EscRead>
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);

    // Cycle time for Sync1
        HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
   21e90:	01800104 	movi	r6,4
   21e94:	01426904 	movi	r5,2468
   21e98:	d9000404 	addi	r4,sp,16
   21e9c:	00206f00 	call	206f0 <HW_EscRead>
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   21ea0:	d9400183 	ldbu	r5,6(sp)
        shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
   21ea4:	dd400417 	ldw	r21,16(sp)
    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
   21ea8:	80c0008b 	ldhu	r3,2(r16)
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
   21eac:	2980024c 	andi	r6,r5,9
   21eb0:	9080008b 	ldhu	r2,2(r18)
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   21eb4:	3000101e 	bne	r6,zero,21ef8 <StartInputHandler+0x1ac>


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
   21eb8:	d1268683 	ldbu	r4,-26086(gp)
   21ebc:	21403fcc 	andi	r5,r4,255
   21ec0:	28003f1e 	bne	r5,zero,21fc0 <StartInputHandler+0x274>
            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
                
                if (nPdInputSize > 0)
   21ec4:	d0a6718b 	ldhu	r2,-26170(gp)
            if (nPdOutputSize > 0)
   21ec8:	d166710b 	ldhu	r5,-26172(gp)
   21ecc:	10ffffcc 	andi	r3,r2,65535
   21ed0:	28005826 	beq	r5,zero,22034 <StartInputHandler+0x2e8>
                if (nPdInputSize > 0)
   21ed4:	1800c21e 	bne	r3,zero,221e0 <StartInputHandler+0x494>
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
   21ed8:	d0e67403 	ldbu	r3,-26160(gp)
   21edc:	1800a426 	beq	r3,zero,22170 <StartInputHandler+0x424>
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
   21ee0:	00c00044 	movi	r3,1
   21ee4:	00007d06 	br	220dc <StartInputHandler+0x390>
       nPdOutputBuffer = 1;
   21ee8:	07000044 	movi	fp,1
   21eec:	003fb606 	br	21dc8 <StartInputHandler+0x7c>
        nPdInputBuffer = 1;
   21ef0:	01000044 	movi	r4,1
   21ef4:	003fbc06 	br	21de8 <StartInputHandler+0x9c>
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
   21ef8:	2900008c 	andi	r4,r5,2
   21efc:	20004926 	beq	r4,zero,22024 <StartInputHandler+0x2d8>
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21f00:	9d08703a 	and	r4,r19,r20
        if(u16MinSuppSyncType != 0)
   21f04:	21bfffcc 	andi	r6,r4,65535
   21f08:	30000626 	beq	r6,zero,21f24 <StartInputHandler+0x1d8>
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
   21f0c:	2180010c 	andi	r6,r4,4
   21f10:	30004426 	beq	r6,zero,22024 <StartInputHandler+0x2d8>
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
   21f14:	2180020c 	andi	r6,r4,8
   21f18:	3000021e 	bne	r6,zero,21f24 <StartInputHandler+0x1d8>
   21f1c:	2980010c 	andi	r6,r5,4
   21f20:	3000401e 	bne	r6,zero,22024 <StartInputHandler+0x2d8>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21f24:	d9c00317 	ldw	r7,12(sp)
            curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
   21f28:	82000417 	ldw	r8,16(r16)
   21f2c:	2980018c 	andi	r6,r5,6
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21f30:	3800131e 	bne	r7,zero,21f80 <StartInputHandler+0x234>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   21f34:	31800198 	cmpnei	r6,r6,6
   21f38:	3000011e 	bne	r6,zero,21f40 <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   21f3c:	a800171e 	bne	r21,zero,21f9c <StartInputHandler+0x250>
    if(bSyncSetByUser)
   21f40:	d1268683 	ldbu	r4,-26086(gp)
   21f44:	2000391e 	bne	r4,zero,2202c <StartInputHandler+0x2e0>
            if (nPdOutputSize > 0)
   21f48:	d0a6710b 	ldhu	r2,-26172(gp)
   21f4c:	1000701e 	bne	r2,zero,22110 <StartInputHandler+0x3c4>
   21f50:	0009883a 	mov	r4,zero
            if (nPdInputSize > 0)
   21f54:	d0e6718b 	ldhu	r3,-26170(gp)
   21f58:	d0a67403 	ldbu	r2,-26160(gp)
   21f5c:	18003726 	beq	r3,zero,2203c <StartInputHandler+0x2f0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   21f60:	2940010c 	andi	r5,r5,4
   21f64:	2800911e 	bne	r5,zero,221ac <StartInputHandler+0x460>
    if ( !b3BufferMode )
   21f68:	10008126 	beq	r2,zero,22170 <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   21f6c:	00800084 	movi	r2,2

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
   21f70:	00c00044 	movi	r3,1
   21f74:	d0e67445 	stb	r3,-26159(gp)
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
   21f78:	0007883a 	mov	r3,zero
   21f7c:	00005906 	br	220e4 <StartInputHandler+0x398>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21f80:	3a014b36 	bltu	r7,r8,224b0 <StartInputHandler+0x764>
   21f84:	0230d434 	movhi	r8,50000
   21f88:	41c14936 	bltu	r8,r7,224b0 <StartInputHandler+0x764>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   21f8c:	318001a0 	cmpeqi	r6,r6,6
   21f90:	303feb26 	beq	r6,zero,21f40 <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   21f94:	a83fea26 	beq	r21,zero,21f40 <StartInputHandler+0x1f4>
   21f98:	a9ffe936 	bltu	r21,r7,21f40 <StartInputHandler+0x1f4>
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
   21f9c:	2100040c 	andi	r4,r4,16
   21fa0:	20002026 	beq	r4,zero,22024 <StartInputHandler+0x2d8>
    if(bSyncSetByUser)
   21fa4:	d1268683 	ldbu	r4,-26086(gp)
   21fa8:	2000151e 	bne	r4,zero,22000 <StartInputHandler+0x2b4>
            if (nPdOutputSize > 0)
   21fac:	d0e6710b 	ldhu	r3,-26172(gp)
                if (nPdInputSize > 0)
   21fb0:	d0a6718b 	ldhu	r2,-26170(gp)
            if (nPdOutputSize > 0)
   21fb4:	18003c1e 	bne	r3,zero,220a8 <StartInputHandler+0x35c>
                bSubordinatedCycles = TRUE;
   21fb8:	01000044 	movi	r4,1
   21fbc:	003fe506 	br	21f54 <StartInputHandler+0x208>
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   21fc0:	193fff84 	addi	r4,r3,-2
   21fc4:	213fffcc 	andi	r4,r4,65535
   21fc8:	210000b0 	cmpltui	r4,r4,2
   21fcc:	2000151e 	bne	r4,zero,22024 <StartInputHandler+0x2d8>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
   21fd0:	113fff84 	addi	r4,r2,-2
   21fd4:	213fffcc 	andi	r4,r4,65535
   21fd8:	210000b0 	cmpltui	r4,r4,2
   21fdc:	2000111e 	bne	r4,zero,22024 <StartInputHandler+0x2d8>
   21fe0:	3009883a 	mov	r4,r6
    if ( !b3BufferMode )
   21fe4:	d1a67403 	ldbu	r6,-26160(gp)
   21fe8:	197fffcc 	andi	r5,r3,65535
   21fec:	3000761e 	bne	r6,zero,221c8 <StartInputHandler+0x47c>
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
   21ff0:	28005f26 	beq	r5,zero,22170 <StartInputHandler+0x424>
   21ff4:	117fffcc 	andi	r5,r2,65535
   21ff8:	2800381e 	bne	r5,zero,220dc <StartInputHandler+0x390>
   21ffc:	00005c06 	br	22170 <StartInputHandler+0x424>
                bSubordinatedCycles = TRUE;
   22000:	01000044 	movi	r4,1
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
   22004:	2940010c 	andi	r5,r5,4
   22008:	19bfffcc 	andi	r6,r3,65535
   2200c:	2800491e 	bne	r5,zero,22134 <StartInputHandler+0x3e8>
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
   22010:	314000e0 	cmpeqi	r5,r6,3
   22014:	2800031e 	bne	r5,zero,22024 <StartInputHandler+0x2d8>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
   22018:	117fffcc 	andi	r5,r2,65535
   2201c:	294000e0 	cmpeqi	r5,r5,3
   22020:	28004626 	beq	r5,zero,2213c <StartInputHandler+0x3f0>
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
   22024:	00800c04 	movi	r2,48
   22028:	00005206 	br	22174 <StartInputHandler+0x428>
    BOOL bSubordinatedCycles = FALSE;
   2202c:	0009883a 	mov	r4,zero
   22030:	003ff406 	br	22004 <StartInputHandler+0x2b8>
            else if (nPdInputSize > 0)
   22034:	d0a67403 	ldbu	r2,-26160(gp)
   22038:	18004c1e 	bne	r3,zero,2216c <StartInputHandler+0x420>
    if ( !b3BufferMode )
   2203c:	10004c26 	beq	r2,zero,22170 <StartInputHandler+0x424>
        if(bEscIntEnabled)
   22040:	d0a67443 	ldbu	r2,-26159(gp)
   22044:	1000681e 	bne	r2,zero,221e8 <StartInputHandler+0x49c>
   22048:	0007883a 	mov	r3,zero
            }
        }



    sSyncManOutPar.u16SyncType = SyncType0x1C32;
   2204c:	80c0008d 	sth	r3,2(r16)
    LatchInputSync0Counter = 0;
    u16SmSync0Value = 0;
    u16SmSync0Counter = 0;


    if(bSubordinatedCycles == TRUE)
   22050:	24003fcc 	andi	r16,r4,255
    sSyncManInPar.u16SyncType = SyncType0x1C33;
   22054:	9080008d 	sth	r2,2(r18)
    LatchInputSync0Value = 0;
   22058:	d026758d 	sth	zero,-26154(gp)
    LatchInputSync0Counter = 0;
   2205c:	d026750d 	sth	zero,-26156(gp)
    u16SmSync0Value = 0;
   22060:	d026798d 	sth	zero,-26138(gp)
    u16SmSync0Counter = 0;
   22064:	d0267a0d 	sth	zero,-26136(gp)
    if(bSubordinatedCycles == TRUE)
   22068:	81000058 	cmpnei	r4,r16,1
   2206c:	2000d31e 	bne	r4,zero,223bc <StartInputHandler+0x670>
    {
        
        UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
   22070:	dc800317 	ldw	r18,12(sp)
   22074:	aca7883a 	add	r19,r21,r18

        /* get the number of Sync0 event within on SM cycle */
        if(shiftTimeSync1 >= cycleTimeSync0)
        {

            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   22078:	900b883a 	mov	r5,r18
   2207c:	9809883a 	mov	r4,r19
   22080:	0026a940 	call	26a94 <__udivsi3>
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22084:	900b883a 	mov	r5,r18
   22088:	9809883a 	mov	r4,r19
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   2208c:	1023883a 	mov	r17,r2
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22090:	0026af80 	call	26af8 <__umodsi3>
        if(shiftTimeSync1 >= cycleTimeSync0)
   22094:	ac80c636 	bltu	r21,r18,223b0 <StartInputHandler+0x664>
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22098:	10006c26 	beq	r2,zero,2224c <StartInputHandler+0x500>
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   2209c:	d466798d 	sth	r17,-26138(gp)
        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);

        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
        {
            LatchInputSync0Value++;
   220a0:	8c400044 	addi	r17,r17,1
   220a4:	00006b06 	br	22254 <StartInputHandler+0x508>
            if (nPdInputSize > 0)
   220a8:	10ffffcc 	andi	r3,r2,65535
   220ac:	18000326 	beq	r3,zero,220bc <StartInputHandler+0x370>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   220b0:	2940010c 	andi	r5,r5,4
   220b4:	28002b26 	beq	r5,zero,22164 <StartInputHandler+0x418>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   220b8:	008000c4 	movi	r2,3
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   220bc:	01000044 	movi	r4,1
    if ( !b3BufferMode )
   220c0:	d0e67403 	ldbu	r3,-26160(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   220c4:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   220c8:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   220cc:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   220d0:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   220d4:	18003826 	beq	r3,zero,221b8 <StartInputHandler+0x46c>
   220d8:	00c000c4 	movi	r3,3
        bEscIntEnabled = TRUE;
   220dc:	01400044 	movi	r5,1
   220e0:	d1667445 	stb	r5,-26159(gp)
            if(nPdOutputSize > 0)
   220e4:	d1a6710b 	ldhu	r6,-26172(gp)
   220e8:	197fff84 	addi	r5,r3,-2
   220ec:	30004026 	beq	r6,zero,221f0 <StartInputHandler+0x4a4>
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   220f0:	01810004 	movi	r6,1024
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   220f4:	297fffcc 	andi	r5,r5,65535
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   220f8:	d1a66d8d 	sth	r6,-26186(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   220fc:	294000a8 	cmpgeui	r5,r5,2
   22100:	2800461e 	bne	r5,zero,2221c <StartInputHandler+0x4d0>
            bDcSyncActive = TRUE;
   22104:	01400044 	movi	r5,1
   22108:	d1667b85 	stb	r5,-26130(gp)
            if (nPdOutputSize == 0)
   2210c:	003fcf06 	br	2204c <StartInputHandler+0x300>
            if (nPdInputSize > 0)
   22110:	d0a6718b 	ldhu	r2,-26170(gp)
   22114:	10ffffcc 	andi	r3,r2,65535
   22118:	18000426 	beq	r3,zero,2212c <StartInputHandler+0x3e0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   2211c:	2940010c 	andi	r5,r5,4
   22120:	2809883a 	mov	r4,r5
   22124:	28001f26 	beq	r5,zero,221a4 <StartInputHandler+0x458>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   22128:	008000c4 	movi	r2,3
            if (nPdInputSize > 0)
   2212c:	0009883a 	mov	r4,zero
   22130:	00000406 	br	22144 <StartInputHandler+0x3f8>
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22134:	314000d8 	cmpnei	r5,r6,3
   22138:	283fe126 	beq	r5,zero,220c0 <StartInputHandler+0x374>
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   2213c:	31800098 	cmpnei	r6,r6,2
   22140:	303fa81e 	bne	r6,zero,21fe4 <StartInputHandler+0x298>
    if ( !b3BufferMode )
   22144:	d0e67403 	ldbu	r3,-26160(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22148:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   2214c:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22150:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22154:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   22158:	18001926 	beq	r3,zero,221c0 <StartInputHandler+0x474>
   2215c:	00c00084 	movi	r3,2
   22160:	003fde06 	br	220dc <StartInputHandler+0x390>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   22164:	00800084 	movi	r2,2
   22168:	003fd406 	br	220bc <StartInputHandler+0x370>
    if ( !b3BufferMode )
   2216c:	10001a1e 	bne	r2,zero,221d8 <StartInputHandler+0x48c>
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
   22170:	00800a44 	movi	r2,41

    /*write initial input data*/
    PDO_InputMapping();

    return ALSTATUSCODE_NOERROR;
}
   22174:	dfc00e17 	ldw	ra,56(sp)
   22178:	df000d17 	ldw	fp,52(sp)
   2217c:	ddc00c17 	ldw	r23,48(sp)
   22180:	dd800b17 	ldw	r22,44(sp)
   22184:	dd400a17 	ldw	r21,40(sp)
   22188:	dd000917 	ldw	r20,36(sp)
   2218c:	dcc00817 	ldw	r19,32(sp)
   22190:	dc800717 	ldw	r18,28(sp)
   22194:	dc400617 	ldw	r17,24(sp)
   22198:	dc000517 	ldw	r16,20(sp)
   2219c:	dec00f04 	addi	sp,sp,60
   221a0:	f800283a 	ret
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   221a4:	00800084 	movi	r2,2
   221a8:	003fe606 	br	22144 <StartInputHandler+0x3f8>
    if ( !b3BufferMode )
   221ac:	103ff026 	beq	r2,zero,22170 <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   221b0:	008000c4 	movi	r2,3
   221b4:	003f6e06 	br	21f70 <StartInputHandler+0x224>
    if ( !b3BufferMode )
   221b8:	00c000c4 	movi	r3,3
   221bc:	003f8d06 	br	21ff4 <StartInputHandler+0x2a8>
   221c0:	00c00084 	movi	r3,2
   221c4:	003f8b06 	br	21ff4 <StartInputHandler+0x2a8>
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
   221c8:	283fc41e 	bne	r5,zero,220dc <StartInputHandler+0x390>
   221cc:	10ffffcc 	andi	r3,r2,65535
   221d0:	183f9b26 	beq	r3,zero,22040 <StartInputHandler+0x2f4>
   221d4:	003f6606 	br	21f70 <StartInputHandler+0x224>
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
   221d8:	00800044 	movi	r2,1
   221dc:	003f6406 	br	21f70 <StartInputHandler+0x224>
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
   221e0:	00800884 	movi	r2,34
   221e4:	003f3e06 	br	21ee0 <StartInputHandler+0x194>
        if(bEscIntEnabled)
   221e8:	0005883a 	mov	r2,zero
   221ec:	003f6206 	br	21f78 <StartInputHandler+0x22c>
            else if(nPdInputSize > 0)
   221f0:	d1a6718b 	ldhu	r6,-26170(gp)
   221f4:	30000226 	beq	r6,zero,22200 <StartInputHandler+0x4b4>
                u16ALEventMask = PROCESS_INPUT_EVENT;
   221f8:	01820004 	movi	r6,2048
   221fc:	d1a66d8d 	sth	r6,-26186(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22200:	297fffcc 	andi	r5,r5,65535
   22204:	294000b0 	cmpltui	r5,r5,2
   22208:	28000a26 	beq	r5,zero,22234 <StartInputHandler+0x4e8>
            bDcSyncActive = TRUE;
   2220c:	01400044 	movi	r5,1
   22210:	d1667b85 	stb	r5,-26130(gp)
               u16ALEventMask = 0;
   22214:	d0266d8d 	sth	zero,-26186(gp)
   22218:	003f8c06 	br	2204c <StartInputHandler+0x300>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
   2221c:	117fffcc 	andi	r5,r2,65535
   22220:	29800098 	cmpnei	r6,r5,2
   22224:	303fb726 	beq	r6,zero,22104 <StartInputHandler+0x3b8>
   22228:	294000d8 	cmpnei	r5,r5,3
   2222c:	283fb526 	beq	r5,zero,22104 <StartInputHandler+0x3b8>
   22230:	003f8606 	br	2204c <StartInputHandler+0x300>
   22234:	117fffcc 	andi	r5,r2,65535
   22238:	298000a0 	cmpeqi	r6,r5,2
   2223c:	303ff31e 	bne	r6,zero,2220c <StartInputHandler+0x4c0>
   22240:	294000d8 	cmpnei	r5,r5,3
   22244:	283ff126 	beq	r5,zero,2220c <StartInputHandler+0x4c0>
   22248:	003f8006 	br	2204c <StartInputHandler+0x300>
                u16SmSync0Value ++;
   2224c:	88800044 	addi	r2,r17,1
   22250:	d0a6798d 	sth	r2,-26138(gp)
            LatchInputSync0Value++;
   22254:	d466758d 	sth	r17,-26154(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   22258:	01800084 	movi	r6,2
   2225c:	01410804 	movi	r5,1056
   22260:	d9000284 	addi	r4,sp,10
    sCycleDiag.syncFailedCounter = 0;
   22264:	d026860d 	sth	zero,-26088(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   22268:	00206f00 	call	206f0 <HW_EscRead>
    if (nPdOutputSize > 0 &&  wd != 0 )
   2226c:	d0e6710b 	ldhu	r3,-26172(gp)
    wd = SWAPWORD(wd);
   22270:	d880028b 	ldhu	r2,10(sp)
    if (nPdOutputSize > 0 &&  wd != 0 )
   22274:	18005f26 	beq	r3,zero,223f4 <StartInputHandler+0x6a8>
   22278:	10bfffcc 	andi	r2,r2,65535
   2227c:	10005d26 	beq	r2,zero,223f4 <StartInputHandler+0x6a8>
    HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
   22280:	01410004 	movi	r5,1024
   22284:	01800084 	movi	r6,2
   22288:	d9000204 	addi	r4,sp,8
   2228c:	00206f00 	call	206f0 <HW_EscRead>
        if ( wdiv != 0 )
   22290:	d940020b 	ldhu	r5,8(sp)
   22294:	28005426 	beq	r5,zero,223e8 <StartInputHandler+0x69c>
            d *= wd;
   22298:	d900028b 	ldhu	r4,10(sp)
   2229c:	29400084 	addi	r5,r5,2
   222a0:	0026b540 	call	26b54 <__mulsi3>
            d /= 25000;
   222a4:	01586a04 	movi	r5,25000
   222a8:	111869c4 	addi	r4,r2,24999
   222ac:	0026a940 	call	26a94 <__udivsi3>
            EcatWdValue = (UINT16) d;
   222b0:	d0a66f0d 	sth	r2,-26180(gp)
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   222b4:	10bfffcc 	andi	r2,r2,65535
   222b8:	d0e67bc3 	ldbu	r3,-26129(gp)
   222bc:	10004f1e 	bne	r2,zero,223fc <StartInputHandler+0x6b0>
   222c0:	d0a67bc3 	ldbu	r2,-26129(gp)
   222c4:	10004f1e 	bne	r2,zero,22404 <StartInputHandler+0x6b8>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   222c8:	d0a67443 	ldbu	r2,-26159(gp)
   222cc:	10004f1e 	bne	r2,zero,2240c <StartInputHandler+0x6c0>
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   222d0:	01800044 	movi	r6,1
   222d4:	01405444 	movi	r5,337
   222d8:	d90001c4 	addi	r4,sp,7
    Sync0WdValue = 0;
   222dc:	d026770d 	sth	zero,-26148(gp)
    Sync0WdCounter = 0;
   222e0:	d026778d 	sth	zero,-26146(gp)
    Sync1WdCounter = 0;
   222e4:	d026768d 	sth	zero,-26150(gp)
    Sync1WdValue = 0;
   222e8:	d026760d 	sth	zero,-26152(gp)
    bDcRunning = FALSE;
   222ec:	d0267a85 	stb	zero,-26134(gp)
    bSmSyncSequenceValid = FALSE;
   222f0:	d0267905 	stb	zero,-26140(gp)
    i16WaitForPllRunningTimeout = 0;
   222f4:	d026788d 	sth	zero,-26142(gp)
        UINT8 u8TmpVar = 0;
   222f8:	d80001c5 	stb	zero,7(sp)
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   222fc:	00206f00 	call	206f0 <HW_EscRead>
        if ((u8TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
   22300:	d88001c3 	ldbu	r2,7(sp)
   22304:	10c0020c 	andi	r3,r2,8
   22308:	18000326 	beq	r3,zero,22318 <StartInputHandler+0x5cc>
            u16ALEventMask |= SYNC0_EVENT;
   2230c:	d0e66d8b 	ldhu	r3,-26186(gp)
   22310:	18c00114 	ori	r3,r3,4
   22314:	d0e66d8d 	sth	r3,-26186(gp)
        if ((u8TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
   22318:	10803fcc 	andi	r2,r2,255
   2231c:	1080201c 	xori	r2,r2,128
   22320:	10bfe004 	addi	r2,r2,-128
   22324:	1000030e 	bge	r2,zero,22334 <StartInputHandler+0x5e8>
            u16ALEventMask |= SYNC1_EVENT;
   22328:	d0a66d8b 	ldhu	r2,-26186(gp)
   2232c:	10800214 	ori	r2,r2,8
   22330:	d0a66d8d 	sth	r2,-26186(gp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22334:	008000f4 	movhi	r2,3
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   22338:	dc400183 	ldbu	r17,6(sp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   2233c:	1032f415 	stw	zero,-13360(r2)
    sSyncManInPar.u8SyncError = 0;
   22340:	008000f4 	movhi	r2,3
   22344:	1032fa05 	stb	zero,-13336(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   22348:	008000f4 	movhi	r2,3
   2234c:	10330515 	stw	zero,-13292(r2)
    sSyncManOutPar.u8SyncError = 0;
   22350:	008000f4 	movhi	r2,3
   22354:	10330b05 	stb	zero,-13268(r2)
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   22358:	8880008c 	andi	r2,r17,2
   2235c:	10004126 	beq	r2,zero,22464 <StartInputHandler+0x718>
        if(cycleTimeSync0 == 0)
   22360:	dc000317 	ldw	r16,12(sp)
   22364:	8c40010c 	andi	r17,r17,4
   22368:	80002e1e 	bne	r16,zero,22424 <StartInputHandler+0x6d8>
            Sync0WdValue = 0;
   2236c:	d026770d 	sth	zero,-26148(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   22370:	88003c26 	beq	r17,zero,22464 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   22374:	d8c00417 	ldw	r3,16(sp)
                if(Sync1Cycle < 5)
   22378:	00800234 	movhi	r2,8
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   2237c:	80c9883a 	add	r4,r16,r3
                if(Sync1Cycle < 5)
   22380:	10a847c4 	addi	r2,r2,-24289
   22384:	1100442e 	bgeu	r2,r4,22498 <StartInputHandler+0x74c>
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   22388:	014000b4 	movhi	r5,2
   2238c:	2961a804 	addi	r5,r5,-31072
   22390:	0026a940 	call	26a94 <__udivsi3>
                    Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
   22394:	1008907a 	slli	r4,r2,1
   22398:	01400284 	movi	r5,10
   2239c:	0026a940 	call	26a94 <__udivsi3>
                Sync1WdValue += Sync0WdValue/2;
   223a0:	d0e6770b 	ldhu	r3,-26148(gp)
   223a4:	1806d07a 	srli	r3,r3,1
   223a8:	1885883a 	add	r2,r3,r2
   223ac:	00002c06 	br	22460 <StartInputHandler+0x714>
            u16SmSync0Value = 1;
   223b0:	d426798d 	sth	r16,-26138(gp)
        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
   223b4:	103f3a1e 	bne	r2,zero,220a0 <StartInputHandler+0x354>
   223b8:	003fa606 	br	22254 <StartInputHandler+0x508>
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   223bc:	18ffffcc 	andi	r3,r3,65535
   223c0:	18c00098 	cmpnei	r3,r3,2
   223c4:	1800021e 	bne	r3,zero,223d0 <StartInputHandler+0x684>
            u16SmSync0Value = 1;
   223c8:	00c00044 	movi	r3,1
   223cc:	d0e6798d 	sth	r3,-26138(gp)
        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
   223d0:	10bfffcc 	andi	r2,r2,65535
   223d4:	108000e0 	cmpeqi	r2,r2,3
   223d8:	103f9f1e 	bne	r2,zero,22258 <StartInputHandler+0x50c>
            LatchInputSync0Value = 1;
   223dc:	00800044 	movi	r2,1
   223e0:	d0a6758d 	sth	r2,-26154(gp)
   223e4:	003f9c06 	br	22258 <StartInputHandler+0x50c>
            wd = 0;
   223e8:	d800028d 	sth	zero,10(sp)
        EcatWdValue = 0;
   223ec:	d0266f0d 	sth	zero,-26180(gp)
   223f0:	003fb306 	br	222c0 <StartInputHandler+0x574>
        wdiv = 0;
   223f4:	d800020d 	sth	zero,8(sp)
   223f8:	003ffc06 	br	223ec <StartInputHandler+0x6a0>
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   223fc:	18803fcc 	andi	r2,r3,255
   22400:	103fb11e 	bne	r2,zero,222c8 <StartInputHandler+0x57c>
        return ALSTATUSCODE_INVALIDWDCFG;
   22404:	008007c4 	movi	r2,31
   22408:	003f5a06 	br	22174 <StartInputHandler+0x428>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   2240c:	d0a6710b 	ldhu	r2,-26172(gp)
   22410:	103faf26 	beq	r2,zero,222d0 <StartInputHandler+0x584>
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
   22414:	d0a66d8b 	ldhu	r2,-26186(gp)
   22418:	10810014 	ori	r2,r2,1024
   2241c:	d0a66d8d 	sth	r2,-26186(gp)
   22420:	003fab06 	br	222d0 <StartInputHandler+0x584>
            if(Sync0Cycle < 5)
   22424:	00800234 	movhi	r2,8
   22428:	10a847c4 	addi	r2,r2,-24289
   2242c:	1400182e 	bgeu	r2,r16,22490 <StartInputHandler+0x744>
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
   22430:	014000b4 	movhi	r5,2
   22434:	2961a804 	addi	r5,r5,-31072
   22438:	8009883a 	mov	r4,r16
   2243c:	0026a940 	call	26a94 <__udivsi3>
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
   22440:	1008907a 	slli	r4,r2,1
   22444:	01400284 	movi	r5,10
   22448:	213fff8c 	andi	r4,r4,65534
   2244c:	0026a940 	call	26a94 <__udivsi3>
   22450:	d0a6770d 	sth	r2,-26148(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   22454:	88000326 	beq	r17,zero,22464 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   22458:	d8c00417 	ldw	r3,16(sp)
   2245c:	1c3fc62e 	bgeu	r3,r16,22378 <StartInputHandler+0x62c>
                Sync1WdValue += Sync0WdValue/2;
   22460:	d0a6760d 	sth	r2,-26152(gp)
    if(nPdOutputSize > 0)
   22464:	d0a6710b 	ldhu	r2,-26172(gp)
   22468:	10000226 	beq	r2,zero,22474 <StartInputHandler+0x728>
        EnableSyncManChannel(PROCESS_DATA_OUT);
   2246c:	01000084 	movi	r4,2
   22470:	0021a800 	call	21a80 <EnableSyncManChannel>
    if(nPdInputSize > 0)
   22474:	d0a6718b 	ldhu	r2,-26170(gp)
   22478:	10000226 	beq	r2,zero,22484 <StartInputHandler+0x738>
        EnableSyncManChannel(PROCESS_DATA_IN);
   2247c:	010000c4 	movi	r4,3
   22480:	0021a800 	call	21a80 <EnableSyncManChannel>
    PDO_InputMapping();
   22484:	0020e5c0 	call	20e5c <PDO_InputMapping>
    return ALSTATUSCODE_NOERROR;
   22488:	0005883a 	mov	r2,zero
   2248c:	003f3906 	br	22174 <StartInputHandler+0x428>
   22490:	00800044 	movi	r2,1
   22494:	003fee06 	br	22450 <StartInputHandler+0x704>
   22498:	00800044 	movi	r2,1
   2249c:	003fc006 	br	223a0 <StartInputHandler+0x654>
        return ALSTATUSCODE_INVALIDSMINCFG;
   224a0:	00800784 	movi	r2,30
   224a4:	003f3306 	br	22174 <StartInputHandler+0x428>
        return ALSTATUSCODE_INVALIDSMOUTCFG;
   224a8:	00800744 	movi	r2,29
   224ac:	003f3106 	br	22174 <StartInputHandler+0x428>
                    return ALSTATUSCODE_DCSYNC0CYCLETIME;
   224b0:	00800d84 	movi	r2,54
   224b4:	003f2f06 	br	22174 <StartInputHandler+0x428>

000224b8 <StartOutputHandler>:
    /* by default the SO transition should be completed in AlControlRes().
       required to support also masters which starts to send process data after the SO transition was triggered
       (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
    UINT16 result = NOERROR_INWORK;
    /*ECATCHANGE_START(V5.13) ESM1*/
    if(STATE_VALID(u8LocalErrorState))
   224b8:	d0e67303 	ldbu	r3,-26164(gp)
   224bc:	00804584 	movi	r2,278
   224c0:	18c003cc 	andi	r3,r3,15
   224c4:	10c4d83a 	srl	r2,r2,r3
   224c8:	1080004c 	andi	r2,r2,1
   224cc:	10000226 	beq	r2,zero,224d8 <StartOutputHandler+0x20>
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
        return u16LocalErrorCode;
   224d0:	d0a6738b 	ldhu	r2,-26162(gp)
   224d4:	f800283a 	ret
    }
/*The application ESM function is separated from this function to handle pending transitions*/


    /*DC synchronisation is active wait until pll is valid*/
    if(bDcSyncActive)
   224d8:	d0a67b83 	ldbu	r2,-26130(gp)
   224dc:	10000326 	beq	r2,zero,224ec <StartOutputHandler+0x34>
    {
        i16WaitForPllRunningTimeout = 200;
   224e0:	00803204 	movi	r2,200
   224e4:	d0a6788d 	sth	r2,-26142(gp)

        i16WaitForPllRunningCnt = 0;
   224e8:	d026780d 	sth	zero,-26144(gp)
    }



    sSyncManOutPar.u16SmEventMissedCounter = 0;
   224ec:	008000f4 	movhi	r2,3
   224f0:	1033050d 	sth	zero,-13292(r2)
    sSyncManOutPar.u8SyncError = 0;
   224f4:	008000f4 	movhi	r2,3
   224f8:	10330b05 	stb	zero,-13268(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   224fc:	008000f4 	movhi	r2,3
   22500:	1032f40d 	sth	zero,-13360(r2)
    sSyncManInPar.u8SyncError = 0;
   22504:	008000f4 	movhi	r2,3
   22508:	1032fa05 	stb	zero,-13336(r2)
   2250c:	00803fc4 	movi	r2,255


    return result;
}
   22510:	f800283a 	ret

00022514 <StopOutputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

void StopOutputHandler(void)
{
    /* reset the flags that outputs were received and that the slave is in OP */
    bEcatFirstOutputsReceived = FALSE;
   22514:	d0267c05 	stb	zero,-26128(gp)
    bEcatOutputUpdateRunning = FALSE;
   22518:	d0267c85 	stb	zero,-26126(gp)
}
   2251c:	f800283a 	ret

00022520 <StopInputHandler>:

*////////////////////////////////////////////////////////////////////////////////////////

void StopInputHandler(void)
{
    if(nPdOutputSize > 0)
   22520:	d0a6710b 	ldhu	r2,-26172(gp)
{
   22524:	deffff04 	addi	sp,sp,-4
   22528:	dfc00015 	stw	ra,0(sp)
    if(nPdOutputSize > 0)
   2252c:	10000226 	beq	r2,zero,22538 <StopInputHandler+0x18>
    {
        /* disable the Sync Manager Channel 2 (outputs) */
        DisableSyncManChannel(PROCESS_DATA_OUT);
   22530:	01000084 	movi	r4,2
   22534:	0021a200 	call	21a20 <DisableSyncManChannel>
    }

    if(nPdInputSize > 0)
   22538:	d0a6718b 	ldhu	r2,-26170(gp)
   2253c:	10000226 	beq	r2,zero,22548 <StopInputHandler+0x28>
    {
        /*disable Sync Manager 3 (inputs) if no outputs available*/
        DisableSyncManChannel(PROCESS_DATA_IN);
   22540:	010000c4 	movi	r4,3
   22544:	0021a200 	call	21a20 <DisableSyncManChannel>
    {
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
        ResetMask |= PROCESS_OUTPUT_EVENT;
        ResetMask |= PROCESS_INPUT_EVENT;

    ResetALEventMask( ~(ResetMask) );
   22548:	013cfcd4 	movui	r4,62451
   2254c:	00219200 	call	21920 <ResetALEventMask>
    Sync1WdValue = 0;
    LatchInputSync0Value = 0;
    LatchInputSync0Counter = 0;


    sSyncManOutPar.u16SmEventMissedCounter = 0;
   22550:	008000f4 	movhi	r2,3
   22554:	10330515 	stw	zero,-13292(r2)
    sSyncManOutPar.u16CycleExceededCounter = 0;
    sSyncManOutPar.u8SyncError = 0;
   22558:	008000f4 	movhi	r2,3
   2255c:	10330b05 	stb	zero,-13268(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   22560:	008000f4 	movhi	r2,3
   22564:	1032f415 	stw	zero,-13360(r2)
    sSyncManInPar.u16CycleExceededCounter = 0;
    sSyncManInPar.u8SyncError = 0;
   22568:	008000f4 	movhi	r2,3
    bEcatFirstOutputsReceived = FALSE;
   2256c:	d0267c05 	stb	zero,-26128(gp)
    bEscIntEnabled = FALSE;
   22570:	d0267445 	stb	zero,-26159(gp)
    bDcSyncActive = FALSE;
   22574:	d0267b85 	stb	zero,-26130(gp)
    bDcRunning = FALSE;
   22578:	d0267a85 	stb	zero,-26134(gp)
    bSmSyncSequenceValid = FALSE;
   2257c:	d0267905 	stb	zero,-26140(gp)
    u16SmSync0Value = 0;
   22580:	d026798d 	sth	zero,-26138(gp)
    u16SmSync0Counter = 0;
   22584:	d0267a0d 	sth	zero,-26136(gp)
    Sync0WdValue = 0;
   22588:	d026770d 	sth	zero,-26148(gp)
    Sync0WdCounter = 0;
   2258c:	d026778d 	sth	zero,-26146(gp)
    Sync1WdCounter = 0;
   22590:	d026768d 	sth	zero,-26150(gp)
    Sync1WdValue = 0;
   22594:	d026760d 	sth	zero,-26152(gp)
    LatchInputSync0Value = 0;
   22598:	d026758d 	sth	zero,-26154(gp)
    LatchInputSync0Counter = 0;
   2259c:	d026750d 	sth	zero,-26156(gp)
    sSyncManInPar.u8SyncError = 0;
   225a0:	1032fa05 	stb	zero,-13336(r2)

    i16WaitForPllRunningTimeout = 0;
   225a4:	d026788d 	sth	zero,-26142(gp)

    bWdTrigger = FALSE;
   225a8:	d0267bc5 	stb	zero,-26129(gp)
    bEcatInputUpdateRunning = FALSE;
   225ac:	d0267c45 	stb	zero,-26127(gp)

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
   225b0:	d0268685 	stb	zero,-26086(gp)
}
   225b4:	dfc00017 	ldw	ra,0(sp)
   225b8:	dec00104 	addi	sp,sp,4
   225bc:	f800283a 	ret

000225c0 <BackToInitTransition>:
*////////////////////////////////////////////////////////////////////////////////////////

void BackToInitTransition(void)
{
    /* Reset indication that the user has written a sync mode*/
    bSyncSetByUser = FALSE;
   225c0:	d0268685 	stb	zero,-26086(gp)
}
   225c4:	f800283a 	ret

000225c8 <SetALStatus>:
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
    UINT16 Value = alStatusCode;

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
   225c8:	d0e66fc3 	ldbu	r3,-26177(gp)
{
   225cc:	defffe04 	addi	sp,sp,-8
   225d0:	dfc00115 	stw	ra,4(sp)
    UINT16 Value = alStatusCode;
   225d4:	d940008d 	sth	r5,2(sp)
    if(nAlStatus != alStatus)
   225d8:	20803fcc 	andi	r2,r4,255
   225dc:	18800126 	beq	r3,r2,225e4 <SetALStatus+0x1c>
    {
        nAlStatus = alStatus;
   225e0:	d1266fc5 	stb	r4,-26177(gp)
    }

    /*Handle Explicit Device ID is requested*/
    if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
   225e4:	d0e66f83 	ldbu	r3,-26178(gp)
   225e8:	d0a66fc3 	ldbu	r2,-26177(gp)
   225ec:	297fffcc 	andi	r5,r5,65535
   225f0:	18001126 	beq	r3,zero,22638 <SetALStatus+0x70>
   225f4:	10c0040c 	andi	r3,r2,16
   225f8:	18000f1e 	bne	r3,zero,22638 <SetALStatus+0x70>
   225fc:	28000e1e 	bne	r5,zero,22638 <SetALStatus+0x70>
   22600:	10c003cc 	andi	r3,r2,15
   22604:	18c000e0 	cmpeqi	r3,r3,3
   22608:	1800091e 	bne	r3,zero,22630 <SetALStatus+0x68>
    {
/*ECATCHANGE_START(V5.13) ECAT2*/
        Value = u16IdValue;
   2260c:	d0e66d0b 	ldhu	r3,-26188(gp)
/*ECATCHANGE_END(V5.13) ECAT2*/
        nAlStatus |= STATE_DEVID;
   22610:	10800814 	ori	r2,r2,32
        Value = u16IdValue;
   22614:	d8c0008d 	sth	r3,2(sp)
    }
    else
    {
        nAlStatus &= ~STATE_DEVID;
   22618:	d0a66fc5 	stb	r2,-26177(gp)

    if (alStatusCode != 0xFFFF)
    {
        Value = SWAPWORD(Value);

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
   2261c:	01800084 	movi	r6,2
   22620:	01404d04 	movi	r5,308
   22624:	d9000084 	addi	r4,sp,2
   22628:	00207740 	call	20774 <HW_EscWrite>
   2262c:	00000606 	br	22648 <SetALStatus+0x80>
        nAlStatus &= ~STATE_DEVID;
   22630:	108037cc 	andi	r2,r2,223
   22634:	003ff806 	br	22618 <SetALStatus+0x50>
   22638:	108037cc 	andi	r2,r2,223
   2263c:	d0a66fc5 	stb	r2,-26177(gp)
    if (alStatusCode != 0xFFFF)
   22640:	00bfffd4 	movui	r2,65535
   22644:	28bff51e 	bne	r5,r2,2261c <SetALStatus+0x54>
    }

    Value = nAlStatus;
   22648:	d0a66fc3 	ldbu	r2,-26177(gp)
    Value = SWAPWORD(Value);
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   2264c:	01800084 	movi	r6,2
   22650:	01404c04 	movi	r5,304
   22654:	d9000084 	addi	r4,sp,2
    Value = nAlStatus;
   22658:	d880008d 	sth	r2,2(sp)
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   2265c:	00207740 	call	20774 <HW_EscWrite>

}
   22660:	dfc00117 	ldw	ra,4(sp)
   22664:	dec00204 	addi	sp,sp,8
   22668:	f800283a 	ret

0002266c <AL_ControlInd>:
{
    UINT16        result = 0;
    UINT8            bErrAck = 0;
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
   2266c:	00bfffc4 	movi	r2,-1
{
   22670:	defff704 	addi	sp,sp,-36
    EsmTimeoutCounter = -1;
   22674:	d0a67b0d 	sth	r2,-26132(gp)
    bApplEsmPending = TRUE;
   22678:	00800044 	movi	r2,1
{
   2267c:	dd800615 	stw	r22,24(sp)
   22680:	dd400515 	stw	r21,20(sp)
   22684:	dd000415 	stw	r20,16(sp)
   22688:	dcc00315 	stw	r19,12(sp)
   2268c:	dc400115 	stw	r17,4(sp)
    bApplEsmPending = TRUE;
   22690:	d0a672c5 	stb	r2,-26165(gp)
   22694:	24c003cc 	andi	r19,r4,15
{
   22698:	dfc00815 	stw	ra,32(sp)
   2269c:	ddc00715 	stw	r23,28(sp)
   226a0:	dc800215 	stw	r18,8(sp)
   226a4:	dc000015 	stw	r16,0(sp)
   226a8:	2080040c 	andi	r2,r4,16

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
    {
        bErrAck = 1;
        nAlStatus &= ~STATE_CHANGE;
   226ac:	d4666fc3 	ldbu	r17,-26177(gp)
{
   226b0:	2829883a 	mov	r20,r5
   226b4:	282d883a 	mov	r22,r5
   226b8:	982b883a 	mov	r21,r19
    if ( alControl & STATE_CHANGE )
   226bc:	10005126 	beq	r2,zero,22804 <AL_ControlInd+0x198>
        nAlStatus &= ~STATE_CHANGE;
   226c0:	00bffbc4 	movi	r2,-17
   226c4:	1462703a 	and	r17,r2,r17
        bErrAck = 1;
   226c8:	05c00044 	movi	r23,1
        nAlStatus &= ~STATE_CHANGE;
   226cc:	d4666fc5 	stb	r17,-26177(gp)

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
    stateTrans = nAlStatus;
    stateTrans <<= 4;
   226d0:	8822913a 	slli	r17,r17,4
    stateTrans += alControl;
   226d4:	9c63883a 	add	r17,r19,r17

    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
   226d8:	8c803fcc 	andi	r18,r17,255
   226dc:	908010a0 	cmpeqi	r2,r18,66
   226e0:	1000931e 	bne	r2,zero,22930 <AL_ControlInd+0x2c4>
   226e4:	908010e8 	cmpgeui	r2,r18,67
   226e8:	1000551e 	bne	r2,zero,22840 <AL_ControlInd+0x1d4>
   226ec:	90800920 	cmpeqi	r2,r18,36
   226f0:	1000ae1e 	bne	r2,zero,229ac <AL_ControlInd+0x340>
   226f4:	90800970 	cmpltui	r2,r18,37
   226f8:	1000491e 	bne	r2,zero,22820 <AL_ControlInd+0x1b4>
    }

    if ( result == 0 )
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
   226fc:	d026720d 	sth	zero,-26168(gp)
        switch ( stateTrans )
   22700:	8c7ffbc4 	addi	r17,r17,-17
   22704:	8c403fcc 	andi	r17,r17,255
   22708:	88800e28 	cmpgeui	r2,r17,56
   2270c:	10005b1e 	bne	r2,zero,2287c <AL_ControlInd+0x210>
   22710:	882290ba 	slli	r17,r17,2
   22714:	008000b4 	movhi	r2,2
   22718:	8885883a 	add	r2,r17,r2
   2271c:	1089c917 	ldw	r2,10020(r2)
   22720:	1000683a 	jmp	r2
   22724:	00022cbc 	xorhi	zero,zero,2226
   22728:	00022a00 	call	22a0 <__reset-0x1dd60>
   2272c:	000229ec 	andhi	zero,zero,2215
   22730:	00022db4 	movhi	zero,2230
   22734:	0002287c 	xorhi	zero,zero,2209
   22738:	0002287c 	xorhi	zero,zero,2209
   2273c:	0002287c 	xorhi	zero,zero,2209
   22740:	00022db4 	movhi	zero,2230
   22744:	0002287c 	xorhi	zero,zero,2209
   22748:	0002287c 	xorhi	zero,zero,2209
   2274c:	0002287c 	xorhi	zero,zero,2209
   22750:	0002287c 	xorhi	zero,zero,2209
   22754:	0002287c 	xorhi	zero,zero,2209
   22758:	0002287c 	xorhi	zero,zero,2209
   2275c:	0002287c 	xorhi	zero,zero,2209
   22760:	0002287c 	xorhi	zero,zero,2209
   22764:	00022c90 	cmplti	zero,zero,2226
   22768:	00022cc0 	call	22cc <__reset-0x1dd34>
   2276c:	00022db4 	movhi	zero,2230
   22770:	00022b14 	movui	zero,2220
   22774:	0002287c 	xorhi	zero,zero,2209
   22778:	0002287c 	xorhi	zero,zero,2209
   2277c:	0002287c 	xorhi	zero,zero,2209
   22780:	00022db4 	movhi	zero,2230
   22784:	0002287c 	xorhi	zero,zero,2209
   22788:	0002287c 	xorhi	zero,zero,2209
   2278c:	0002287c 	xorhi	zero,zero,2209
   22790:	0002287c 	xorhi	zero,zero,2209
   22794:	0002287c 	xorhi	zero,zero,2209
   22798:	0002287c 	xorhi	zero,zero,2209
   2279c:	0002287c 	xorhi	zero,zero,2209
   227a0:	0002287c 	xorhi	zero,zero,2209
   227a4:	000229e8 	cmpgeui	zero,zero,2215
   227a8:	00022db4 	movhi	zero,2230
   227ac:	0002287c 	xorhi	zero,zero,2209
   227b0:	00022db4 	movhi	zero,2230
   227b4:	0002287c 	xorhi	zero,zero,2209
   227b8:	0002287c 	xorhi	zero,zero,2209
   227bc:	0002287c 	xorhi	zero,zero,2209
   227c0:	00022db4 	movhi	zero,2230
   227c4:	0002287c 	xorhi	zero,zero,2209
   227c8:	0002287c 	xorhi	zero,zero,2209
   227cc:	0002287c 	xorhi	zero,zero,2209
   227d0:	0002287c 	xorhi	zero,zero,2209
   227d4:	0002287c 	xorhi	zero,zero,2209
   227d8:	0002287c 	xorhi	zero,zero,2209
   227dc:	0002287c 	xorhi	zero,zero,2209
   227e0:	0002287c 	xorhi	zero,zero,2209
   227e4:	00022c60 	cmpeqi	zero,zero,2225
   227e8:	0002287c 	xorhi	zero,zero,2209
   227ec:	00022db4 	movhi	zero,2230
   227f0:	00022cc0 	call	22cc <__reset-0x1dd34>
   227f4:	0002287c 	xorhi	zero,zero,2209
   227f8:	0002287c 	xorhi	zero,zero,2209
   227fc:	0002287c 	xorhi	zero,zero,2209
   22800:	00022b8c 	andi	zero,zero,2222
   22804:	102f883a 	mov	r23,r2
    else if ((nAlStatus & STATE_CHANGE)
   22808:	8880040c 	andi	r2,r17,16
   2280c:	10000226 	beq	r2,zero,22818 <AL_ControlInd+0x1ac>
        && (alControl & STATE_MASK) != STATE_INIT)
   22810:	98800058 	cmpnei	r2,r19,1
   22814:	1000a11e 	bne	r2,zero,22a9c <AL_ControlInd+0x430>
        nAlStatus &= STATE_MASK;
   22818:	8c4003cc 	andi	r17,r17,15
   2281c:	003fab06 	br	226cc <AL_ControlInd+0x60>
    switch ( stateTrans )
   22820:	908004a0 	cmpeqi	r2,r18,18
   22824:	10004b1e 	bne	r2,zero,22954 <AL_ControlInd+0x2e8>
   22828:	908008a0 	cmpeqi	r2,r18,34
   2282c:	1000491e 	bne	r2,zero,22954 <AL_ControlInd+0x2e8>
        nEcatStateTrans = 0;
   22830:	d026720d 	sth	zero,-26168(gp)
        switch ( stateTrans )
   22834:	90800468 	cmpgeui	r2,r18,17
   22838:	10001026 	beq	r2,zero,2287c <AL_ControlInd+0x210>
   2283c:	003fb006 	br	22700 <AL_ControlInd+0x94>
    switch ( stateTrans )
   22840:	908020a0 	cmpeqi	r2,r18,130
   22844:	1000281e 	bne	r2,zero,228e8 <AL_ControlInd+0x27c>
   22848:	908020e8 	cmpgeui	r2,r18,131
   2284c:	1000101e 	bne	r2,zero,22890 <AL_ControlInd+0x224>
   22850:	90801120 	cmpeqi	r2,r18,68
   22854:	10005b1e 	bne	r2,zero,229c4 <AL_ControlInd+0x358>
   22858:	90801220 	cmpeqi	r2,r18,72
   2285c:	1000591e 	bne	r2,zero,229c4 <AL_ControlInd+0x358>
        nEcatStateTrans = 0;
   22860:	d026720d 	sth	zero,-26168(gp)
        switch ( stateTrans )
   22864:	90801270 	cmpltui	r2,r18,73
   22868:	103fa51e 	bne	r2,zero,22700 <AL_ControlInd+0x94>
   2286c:	8c401fc4 	addi	r17,r17,127
   22870:	8c403fcc 	andi	r17,r17,255
   22874:	8c400228 	cmpgeui	r17,r17,8
   22878:	8800eb26 	beq	r17,zero,22c28 <AL_ControlInd+0x5bc>
                break;
        }
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
   2287c:	d1266fc3 	ldbu	r4,-26177(gp)
   22880:	208003cc 	andi	r2,r4,15
   22884:	98806426 	beq	r19,r2,22a18 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
   22888:	04000484 	movi	r16,18
   2288c:	00009506 	br	22ae4 <AL_ControlInd+0x478>
    switch ( stateTrans )
   22890:	90802120 	cmpeqi	r2,r18,132
   22894:	10004b1e 	bne	r2,zero,229c4 <AL_ControlInd+0x358>
   22898:	90802220 	cmpeqi	r2,r18,136
   2289c:	1000491e 	bne	r2,zero,229c4 <AL_ControlInd+0x358>
        nEcatStateTrans = 0;
   228a0:	d026720d 	sth	zero,-26168(gp)
        switch ( stateTrans )
   228a4:	8c401fc4 	addi	r17,r17,127
   228a8:	8c403fcc 	andi	r17,r17,255
   228ac:	88800228 	cmpgeui	r2,r17,8
   228b0:	103ff21e 	bne	r2,zero,2287c <AL_ControlInd+0x210>
   228b4:	882290ba 	slli	r17,r17,2
   228b8:	008000b4 	movhi	r2,2
   228bc:	8885883a 	add	r2,r17,r2
   228c0:	108a3217 	ldw	r2,10440(r2)
   228c4:	1000683a 	jmp	r2
   228c8:	00022c28 	cmpgeui	zero,zero,2224
   228cc:	00022900 	call	2290 <__reset-0x1dd70>
   228d0:	00022db4 	movhi	zero,2230
   228d4:	00022c18 	cmpnei	zero,zero,2224
   228d8:	0002287c 	xorhi	zero,zero,2209
   228dc:	0002287c 	xorhi	zero,zero,2209
   228e0:	0002287c 	xorhi	zero,zero,2209
   228e4:	00022cc0 	call	22cc <__reset-0x1dd34>
        result = CheckSmSettings(MAILBOX_READ+1);
   228e8:	01000084 	movi	r4,2
   228ec:	0021adc0 	call	21adc <CheckSmSettings>
   228f0:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   228f4:	10803fcc 	andi	r2,r2,255
   228f8:	10001b1e 	bne	r2,zero,22968 <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   228fc:	d026720d 	sth	zero,-26168(gp)
            result = APPL_StopOutputHandler();
   22900:	00202100 	call	20210 <APPL_StopOutputHandler>
   22904:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22908:	00225140 	call	22514 <StopOutputHandler>
            if (result != 0)
   2290c:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22910:	d02672c5 	stb	zero,-26165(gp)
            if (result != 0)
   22914:	10000c26 	beq	r2,zero,22948 <AL_ControlInd+0x2dc>
    if ( result == NOERROR_INWORK )
   22918:	10803fd8 	cmpnei	r2,r2,255
   2291c:	10006e1e 	bne	r2,zero,22ad8 <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22920:	00800044 	movi	r2,1
   22924:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22928:	00802084 	movi	r2,130
   2292c:	0000c906 	br	22c54 <AL_ControlInd+0x5e8>
        result = CheckSmSettings(MAILBOX_READ+1);
   22930:	01000084 	movi	r4,2
   22934:	0021adc0 	call	21adc <CheckSmSettings>
   22938:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   2293c:	10803fcc 	andi	r2,r2,255
   22940:	1000091e 	bne	r2,zero,22968 <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   22944:	d026720d 	sth	zero,-26168(gp)
            APPL_StopInputHandler();
   22948:	00202000 	call	20200 <APPL_StopInputHandler>
            StopInputHandler();
   2294c:	00225200 	call	22520 <StopInputHandler>
   22950:	0000b306 	br	22c20 <AL_ControlInd+0x5b4>
        result = CheckSmSettings(MAILBOX_READ+1);
   22954:	01000084 	movi	r4,2
   22958:	0021adc0 	call	21adc <CheckSmSettings>
   2295c:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22960:	10803fcc 	andi	r2,r2,255
   22964:	103fb226 	beq	r2,zero,22830 <AL_ControlInd+0x1c4>
        switch (nAlStatus)
   22968:	d1266fc3 	ldbu	r4,-26177(gp)
   2296c:	85ffffcc 	andi	r23,r16,65535
   22970:	20803fcc 	andi	r2,r4,255
   22974:	10c00120 	cmpeqi	r3,r2,4
   22978:	1800e81e 	bne	r3,zero,22d1c <AL_ControlInd+0x6b0>
   2297c:	10c00220 	cmpeqi	r3,r2,8
   22980:	1800e41e 	bne	r3,zero,22d14 <AL_ControlInd+0x6a8>
   22984:	10c000a0 	cmpeqi	r3,r2,2
   22988:	1800e61e 	bne	r3,zero,22d24 <AL_ControlInd+0x6b8>
    if ( result == NOERROR_INWORK )
   2298c:	bdc03fe0 	cmpeqi	r23,r23,255
   22990:	b800fa1e 	bne	r23,zero,22d7c <AL_ControlInd+0x710>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22994:	20c003cc 	andi	r3,r4,15
   22998:	98c0521e 	bne	r19,r3,22ae4 <AL_ControlInd+0x478>
   2299c:	1009883a 	mov	r4,r2
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
   229a0:	d0267285 	stb	zero,-26166(gp)

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
   229a4:	000b883a 	mov	r5,zero
   229a8:	00011a06 	br	22e14 <AL_ControlInd+0x7a8>
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
   229ac:	d1667104 	addi	r5,gp,-26172
   229b0:	d1267184 	addi	r4,gp,-26170
   229b4:	00202180 	call	20218 <APPL_GenerateMapping>
   229b8:	1021883a 	mov	r16,r2
            if (result != 0)
   229bc:	10bfffcc 	andi	r2,r2,65535
   229c0:	103fe91e 	bne	r2,zero,22968 <AL_ControlInd+0x2fc>
        result = CheckSmSettings(nMaxSyncMan);
   229c4:	d1267083 	ldbu	r4,-26174(gp)
   229c8:	0021adc0 	call	21adc <CheckSmSettings>
   229cc:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   229d0:	10803fcc 	andi	r2,r2,255
   229d4:	103fe41e 	bne	r2,zero,22968 <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   229d8:	d026720d 	sth	zero,-26168(gp)
        switch ( stateTrans )
   229dc:	90801268 	cmpgeui	r2,r18,73
   229e0:	103f9426 	beq	r2,zero,22834 <AL_ControlInd+0x1c8>
   229e4:	003faf06 	br	228a4 <AL_ControlInd+0x238>
    bSyncSetByUser = FALSE;
   229e8:	d0268685 	stb	zero,-26086(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   229ec:	d1266fc3 	ldbu	r4,-26177(gp)
   229f0:	208003cc 	andi	r2,r4,15
   229f4:	98800826 	beq	r19,r2,22a18 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_BOOTNOTSUPP;
   229f8:	040004c4 	movi	r16,19
   229fc:	00003906 	br	22ae4 <AL_ControlInd+0x478>
           UpdateEEPROMLoadedState();
   22a00:	00219b80 	call	219b8 <UpdateEEPROMLoadedState>
            if (EepromLoaded == FALSE)
   22a04:	d0a66a03 	ldbu	r2,-26200(gp)
   22a08:	1000051e 	bne	r2,zero,22a20 <AL_ControlInd+0x3b4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a0c:	d1266fc3 	ldbu	r4,-26177(gp)
   22a10:	208003cc 	andi	r2,r4,15
   22a14:	9880f11e 	bne	r19,r2,22ddc <AL_ControlInd+0x770>
   22a18:	21003fcc 	andi	r4,r4,255
   22a1c:	003fe006 	br	229a0 <AL_ControlInd+0x334>
            result = MBX_StartMailboxHandler();
   22a20:	00238d80 	call	238d8 <MBX_StartMailboxHandler>
   22a24:	1021883a 	mov	r16,r2
            if (result == 0)
   22a28:	10bfffcc 	andi	r2,r2,65535
   22a2c:	10000e1e 	bne	r2,zero,22a68 <AL_ControlInd+0x3fc>
                bApplEsmPending = FALSE;
   22a30:	d02672c5 	stb	zero,-26165(gp)
                result = APPL_StartMailboxHandler();
   22a34:	00201e80 	call	201e8 <APPL_StartMailboxHandler>
   22a38:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22a3c:	10bfffcc 	andi	r2,r2,65535
   22a40:	1000091e 	bne	r2,zero,22a68 <AL_ControlInd+0x3fc>
                    bMbxRunning = TRUE;
   22a44:	00800044 	movi	r2,1
   22a48:	d0a68545 	stb	r2,-26091(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a4c:	d1266fc3 	ldbu	r4,-26177(gp)
   22a50:	208003cc 	andi	r2,r4,15
   22a54:	98bff026 	beq	r19,r2,22a18 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22a58:	a0bfffcc 	andi	r2,r20,65535
   22a5c:	1000e51e 	bne	r2,zero,22df4 <AL_ControlInd+0x788>
   22a60:	002d883a 	mov	r22,zero
            nAlStatus = alControl;
   22a64:	0000e706 	br	22e04 <AL_ControlInd+0x798>
            if(result != 0 && result != NOERROR_INWORK)
   22a68:	80bfffcc 	andi	r2,r16,65535
   22a6c:	10803fd8 	cmpnei	r2,r2,255
   22a70:	1000151e 	bne	r2,zero,22ac8 <AL_ControlInd+0x45c>
        bEcatWaitForAlControlRes = TRUE;
   22a74:	00800044 	movi	r2,1
   22a78:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22a7c:	00800484 	movi	r2,18
   22a80:	d0a6720d 	sth	r2,-26168(gp)
            break;
   22a84:	0401f404 	movi	r16,2000
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
   22a88:	813fffcc 	andi	r4,r16,65535
   22a8c:	01400284 	movi	r5,10
   22a90:	0026a940 	call	26a94 <__udivsi3>
   22a94:	80a1c83a 	sub	r16,r16,r2
   22a98:	d4267b0d 	sth	r16,-26132(gp)
    }
    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 state machine from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/

}
   22a9c:	dfc00817 	ldw	ra,32(sp)
   22aa0:	ddc00717 	ldw	r23,28(sp)
   22aa4:	dd800617 	ldw	r22,24(sp)
   22aa8:	dd400517 	ldw	r21,20(sp)
   22aac:	dd000417 	ldw	r20,16(sp)
   22ab0:	dcc00317 	ldw	r19,12(sp)
   22ab4:	dc800217 	ldw	r18,8(sp)
   22ab8:	dc400117 	ldw	r17,4(sp)
   22abc:	dc000017 	ldw	r16,0(sp)
   22ac0:	dec00904 	addi	sp,sp,36
   22ac4:	f800283a 	ret
                    if (!bApplEsmPending)
   22ac8:	d0a672c3 	ldbu	r2,-26165(gp)
   22acc:	1000011e 	bne	r2,zero,22ad4 <AL_ControlInd+0x468>
                        APPL_StopMailboxHandler();
   22ad0:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                 MBX_StopMailboxHandler();
   22ad4:	00239ac0 	call	239ac <MBX_StopMailboxHandler>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ad8:	d1266fc3 	ldbu	r4,-26177(gp)
   22adc:	208003cc 	andi	r2,r4,15
   22ae0:	98bfcd26 	beq	r19,r2,22a18 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22ae4:	9908b03a 	or	r4,r19,r4
   22ae8:	2100020c 	andi	r4,r4,8
   22aec:	2000d51e 	bne	r4,zero,22e44 <AL_ControlInd+0x7d8>
                if (nAlStatus == STATE_OP)
   22af0:	d0a66fc3 	ldbu	r2,-26177(gp)
   22af4:	10800218 	cmpnei	r2,r2,8
   22af8:	1000021e 	bne	r2,zero,22b04 <AL_ControlInd+0x498>
                    nAlStatus = STATE_SAFEOP;
   22afc:	00800104 	movi	r2,4
   22b00:	d0a66fc5 	stb	r2,-26177(gp)
            nAlStatus |= STATE_CHANGE;
   22b04:	d5666fc3 	ldbu	r21,-26177(gp)
   22b08:	802d883a 	mov	r22,r16
   22b0c:	ad400414 	ori	r21,r21,16
   22b10:	0000bc06 	br	22e04 <AL_ControlInd+0x798>
            result = StartInputHandler();
   22b14:	0021d4c0 	call	21d4c <StartInputHandler>
   22b18:	1021883a 	mov	r16,r2
            if ( result == 0 )
   22b1c:	10bfffcc 	andi	r2,r2,65535
   22b20:	10000b1e 	bne	r2,zero,22b50 <AL_ControlInd+0x4e4>
                result = APPL_StartInputHandler(&u16ALEventMask);
   22b24:	d1266d84 	addi	r4,gp,-26186
                bApplEsmPending = FALSE;
   22b28:	d02672c5 	stb	zero,-26165(gp)
                result = APPL_StartInputHandler(&u16ALEventMask);
   22b2c:	00201f80 	call	201f8 <APPL_StartInputHandler>
   22b30:	1021883a 	mov	r16,r2
                if(result == 0)
   22b34:	10bfffcc 	andi	r2,r2,65535
   22b38:	1000051e 	bne	r2,zero,22b50 <AL_ControlInd+0x4e4>
                    SetALEventMask( u16ALEventMask );
   22b3c:	d1266d8b 	ldhu	r4,-26186(gp)
   22b40:	002196c0 	call	2196c <SetALEventMask>
                    bEcatInputUpdateRunning = TRUE;
   22b44:	00800044 	movi	r2,1
   22b48:	d0a67c45 	stb	r2,-26127(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22b4c:	003fbf06 	br	22a4c <AL_ControlInd+0x3e0>
            if(result != 0 && result != NOERROR_INWORK)
   22b50:	80bfffcc 	andi	r2,r16,65535
   22b54:	10803fd8 	cmpnei	r2,r2,255
   22b58:	1000061e 	bne	r2,zero,22b74 <AL_ControlInd+0x508>
        bEcatWaitForAlControlRes = TRUE;
   22b5c:	00800044 	movi	r2,1
   22b60:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22b64:	00800904 	movi	r2,36
   22b68:	d0a6720d 	sth	r2,-26168(gp)
                break;
   22b6c:	0408ca04 	movi	r16,9000
   22b70:	003fc506 	br	22a88 <AL_ControlInd+0x41c>
                if(!bApplEsmPending)
   22b74:	d0a672c3 	ldbu	r2,-26165(gp)
   22b78:	10000226 	beq	r2,zero,22b84 <AL_ControlInd+0x518>
                StopInputHandler();
   22b7c:	00225200 	call	22520 <StopInputHandler>
   22b80:	003fd506 	br	22ad8 <AL_ControlInd+0x46c>
                    APPL_StopInputHandler();
   22b84:	00202000 	call	20200 <APPL_StopInputHandler>
   22b88:	003ffc06 	br	22b7c <AL_ControlInd+0x510>
            if (bErrAck)
   22b8c:	bdc03fcc 	andi	r23,r23,255
   22b90:	b8000426 	beq	r23,zero,22ba4 <AL_ControlInd+0x538>
                if (nPdOutputSize > 0)
   22b94:	d0a6710b 	ldhu	r2,-26172(gp)
   22b98:	10000e26 	beq	r2,zero,22bd4 <AL_ControlInd+0x568>
                    EnableSyncManChannel(PROCESS_DATA_OUT);
   22b9c:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22ba0:	0021a800 	call	21a80 <EnableSyncManChannel>
            result = StartOutputHandler();
   22ba4:	00224b80 	call	224b8 <StartOutputHandler>
   22ba8:	1021883a 	mov	r16,r2
            if(result == 0)
   22bac:	10bfffcc 	andi	r2,r2,65535
   22bb0:	10000c1e 	bne	r2,zero,22be4 <AL_ControlInd+0x578>
                bApplEsmPending = FALSE;
   22bb4:	d02672c5 	stb	zero,-26165(gp)
                result = APPL_StartOutputHandler();
   22bb8:	00202080 	call	20208 <APPL_StartOutputHandler>
   22bbc:	1021883a 	mov	r16,r2
                if(result == 0)
   22bc0:	10bfffcc 	andi	r2,r2,65535
   22bc4:	1000071e 	bne	r2,zero,22be4 <AL_ControlInd+0x578>
                    bEcatOutputUpdateRunning = TRUE;
   22bc8:	00800044 	movi	r2,1
   22bcc:	d0a67c85 	stb	r2,-26126(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22bd0:	003f9e06 	br	22a4c <AL_ControlInd+0x3e0>
                    if (nPdInputSize > 0)
   22bd4:	d0a6718b 	ldhu	r2,-26170(gp)
   22bd8:	103ff226 	beq	r2,zero,22ba4 <AL_ControlInd+0x538>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22bdc:	010000c4 	movi	r4,3
   22be0:	003fef06 	br	22ba0 <AL_ControlInd+0x534>
            if ( result != 0 && result != NOERROR_INWORK)
   22be4:	80bfffcc 	andi	r2,r16,65535
   22be8:	10803fd8 	cmpnei	r2,r2,255
   22bec:	1000041e 	bne	r2,zero,22c00 <AL_ControlInd+0x594>
        bEcatWaitForAlControlRes = TRUE;
   22bf0:	00800044 	movi	r2,1
   22bf4:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22bf8:	00801204 	movi	r2,72
   22bfc:	003fda06 	br	22b68 <AL_ControlInd+0x4fc>
                    if (!bApplEsmPending)
   22c00:	d0a672c3 	ldbu	r2,-26165(gp)
   22c04:	10000226 	beq	r2,zero,22c10 <AL_ControlInd+0x5a4>
                StopOutputHandler();
   22c08:	00225140 	call	22514 <StopOutputHandler>
    if ( result == NOERROR_INWORK )
   22c0c:	003fb206 	br	22ad8 <AL_ControlInd+0x46c>
                        APPL_StopOutputHandler();
   22c10:	00202100 	call	20210 <APPL_StopOutputHandler>
   22c14:	003ffc06 	br	22c08 <AL_ControlInd+0x59c>
            APPL_StopOutputHandler();
   22c18:	00202100 	call	20210 <APPL_StopOutputHandler>
            StopOutputHandler();
   22c1c:	00225140 	call	22514 <StopOutputHandler>
            bApplEsmPending = FALSE;
   22c20:	d02672c5 	stb	zero,-26165(gp)
   22c24:	003f8906 	br	22a4c <AL_ControlInd+0x3e0>
            result = APPL_StopOutputHandler();
   22c28:	00202100 	call	20210 <APPL_StopOutputHandler>
   22c2c:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22c30:	00225140 	call	22514 <StopOutputHandler>
            if (result != 0)
   22c34:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22c38:	d02672c5 	stb	zero,-26165(gp)
            if (result != 0)
   22c3c:	10000826 	beq	r2,zero,22c60 <AL_ControlInd+0x5f4>
    if ( result == NOERROR_INWORK )
   22c40:	10803fd8 	cmpnei	r2,r2,255
   22c44:	103fa41e 	bne	r2,zero,22ad8 <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22c48:	00800044 	movi	r2,1
   22c4c:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22c50:	00802044 	movi	r2,129
   22c54:	d0a6720d 	sth	r2,-26168(gp)
                break;
   22c58:	04003204 	movi	r16,200
   22c5c:	003f8a06 	br	22a88 <AL_ControlInd+0x41c>
            result = APPL_StopInputHandler();
   22c60:	00202000 	call	20200 <APPL_StopInputHandler>
   22c64:	1021883a 	mov	r16,r2
            StopInputHandler();
   22c68:	00225200 	call	22520 <StopInputHandler>
            if (result != 0)
   22c6c:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22c70:	d02672c5 	stb	zero,-26165(gp)
            if (result != 0)
   22c74:	10000626 	beq	r2,zero,22c90 <AL_ControlInd+0x624>
    if ( result == NOERROR_INWORK )
   22c78:	10803fd8 	cmpnei	r2,r2,255
   22c7c:	103f961e 	bne	r2,zero,22ad8 <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22c80:	00800044 	movi	r2,1
   22c84:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22c88:	00801044 	movi	r2,65
   22c8c:	003ff106 	br	22c54 <AL_ControlInd+0x5e8>
            MBX_StopMailboxHandler();
   22c90:	00239ac0 	call	239ac <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
   22c94:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
   22c98:	1021883a 	mov	r16,r2
    if ( result == NOERROR_INWORK )
   22c9c:	10bfffcc 	andi	r2,r2,65535
    bSyncSetByUser = FALSE;
   22ca0:	d0268685 	stb	zero,-26086(gp)
    if ( result == NOERROR_INWORK )
   22ca4:	10c03fe0 	cmpeqi	r3,r2,255
   22ca8:	18004726 	beq	r3,zero,22dc8 <AL_ControlInd+0x75c>
        bEcatWaitForAlControlRes = TRUE;
   22cac:	00800044 	movi	r2,1
   22cb0:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22cb4:	00800844 	movi	r2,33
   22cb8:	003fe606 	br	22c54 <AL_ControlInd+0x5e8>
    bSyncSetByUser = FALSE;
   22cbc:	d0268685 	stb	zero,-26086(gp)
            if(bErrAck)
   22cc0:	bdc03fcc 	andi	r23,r23,255
   22cc4:	b8000226 	beq	r23,zero,22cd0 <AL_ControlInd+0x664>
                APPL_AckErrorInd(stateTrans);
   22cc8:	9009883a 	mov	r4,r18
   22ccc:	00201e40 	call	201e4 <APPL_AckErrorInd>
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
   22cd0:	d1266fc3 	ldbu	r4,-26177(gp)
   22cd4:	9c003fcc 	andi	r16,r19,255
   22cd8:	2080030c 	andi	r2,r4,12
   22cdc:	10000526 	beq	r2,zero,22cf4 <AL_ControlInd+0x688>
                    if(nPdOutputSize > 0)
   22ce0:	d0a6710b 	ldhu	r2,-26172(gp)
   22ce4:	10000726 	beq	r2,zero,22d04 <AL_ControlInd+0x698>
                        EnableSyncManChannel(PROCESS_DATA_OUT);
   22ce8:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22cec:	0021a800 	call	21a80 <EnableSyncManChannel>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22cf0:	d1266fc3 	ldbu	r4,-26177(gp)
   22cf4:	208003cc 	andi	r2,r4,15
   22cf8:	80bf4726 	beq	r16,r2,22a18 <AL_ControlInd+0x3ac>
            result = NOERROR_NOSTATECHANGE;
   22cfc:	04003f84 	movi	r16,254
   22d00:	003f7806 	br	22ae4 <AL_ControlInd+0x478>
                    if(nPdInputSize > 0)
   22d04:	d0a6718b 	ldhu	r2,-26170(gp)
   22d08:	103ffa26 	beq	r2,zero,22cf4 <AL_ControlInd+0x688>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22d0c:	010000c4 	movi	r4,3
   22d10:	003ff606 	br	22cec <AL_ControlInd+0x680>
            APPL_StopOutputHandler();
   22d14:	00202100 	call	20210 <APPL_StopOutputHandler>
            StopOutputHandler();
   22d18:	00225140 	call	22514 <StopOutputHandler>
            APPL_StopInputHandler();
   22d1c:	00202000 	call	20200 <APPL_StopInputHandler>
            StopInputHandler();
   22d20:	00225200 	call	22520 <StopInputHandler>
            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
   22d24:	b8800598 	cmpnei	r2,r23,22
   22d28:	10000c1e 	bne	r2,zero,22d5c <AL_ControlInd+0x6f0>
                MBX_StopMailboxHandler();
   22d2c:	00239ac0 	call	239ac <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
   22d30:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                DisableSyncManChannel(MAILBOX_WRITE);
   22d34:	0009883a 	mov	r4,zero
   22d38:	0021a200 	call	21a20 <DisableSyncManChannel>
                DisableSyncManChannel(MAILBOX_READ);
   22d3c:	01000044 	movi	r4,1
   22d40:	0021a200 	call	21a20 <DisableSyncManChannel>
                nAlStatus = STATE_INIT;
   22d44:	00800044 	movi	r2,1
   22d48:	d0a66fc5 	stb	r2,-26177(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d4c:	98800058 	cmpnei	r2,r19,1
   22d50:	1000241e 	bne	r2,zero,22de4 <AL_ControlInd+0x778>
   22d54:	01000044 	movi	r4,1
   22d58:	003f1106 	br	229a0 <AL_ControlInd+0x334>
                nAlStatus = STATE_PREOP;
   22d5c:	00800084 	movi	r2,2
   22d60:	d0a66fc5 	stb	r2,-26177(gp)
    if ( result == NOERROR_INWORK )
   22d64:	bdc03fe0 	cmpeqi	r23,r23,255
   22d68:	b800041e 	bne	r23,zero,22d7c <AL_ControlInd+0x710>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d6c:	98800098 	cmpnei	r2,r19,2
   22d70:	10001e1e 	bne	r2,zero,22dec <AL_ControlInd+0x780>
   22d74:	01000084 	movi	r4,2
   22d78:	003f0906 	br	229a0 <AL_ControlInd+0x334>
        bEcatWaitForAlControlRes = TRUE;
   22d7c:	00800044 	movi	r2,1
        nEcatStateTrans = stateTrans;
   22d80:	8c403fcc 	andi	r17,r17,255
        bEcatWaitForAlControlRes = TRUE;
   22d84:	d0a67285 	stb	r2,-26166(gp)
        nEcatStateTrans = stateTrans;
   22d88:	d466720d 	sth	r17,-26168(gp)
        switch(nEcatStateTrans)
   22d8c:	90800528 	cmpgeui	r2,r18,20
   22d90:	1000031e 	bne	r2,zero,22da0 <AL_ControlInd+0x734>
   22d94:	948004a8 	cmpgeui	r18,r18,18
   22d98:	903f3a1e 	bne	r18,zero,22a84 <AL_ControlInd+0x418>
   22d9c:	003fae06 	br	22c58 <AL_ControlInd+0x5ec>
   22da0:	90800920 	cmpeqi	r2,r18,36
   22da4:	103f711e 	bne	r2,zero,22b6c <AL_ControlInd+0x500>
   22da8:	94801220 	cmpeqi	r18,r18,72
   22dac:	903f6f1e 	bne	r18,zero,22b6c <AL_ControlInd+0x500>
   22db0:	003fa906 	br	22c58 <AL_ControlInd+0x5ec>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22db4:	d1266fc3 	ldbu	r4,-26177(gp)
   22db8:	208003cc 	andi	r2,r4,15
   22dbc:	98bf1626 	beq	r19,r2,22a18 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_INVALIDALCONTROL;
   22dc0:	04000444 	movi	r16,17
   22dc4:	003f4706 	br	22ae4 <AL_ControlInd+0x478>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22dc8:	d1266fc3 	ldbu	r4,-26177(gp)
   22dcc:	20c003cc 	andi	r3,r4,15
   22dd0:	98ff1126 	beq	r19,r3,22a18 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22dd4:	103f2026 	beq	r2,zero,22a58 <AL_ControlInd+0x3ec>
   22dd8:	003f4206 	br	22ae4 <AL_ControlInd+0x478>
                result = ALSTATUSCODE_EE_ERROR;
   22ddc:	04001444 	movi	r16,81
   22de0:	003f4006 	br	22ae4 <AL_ControlInd+0x478>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22de4:	01000044 	movi	r4,1
   22de8:	003f3e06 	br	22ae4 <AL_ControlInd+0x478>
   22dec:	01000084 	movi	r4,2
   22df0:	003f3c06 	br	22ae4 <AL_ControlInd+0x478>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22df4:	9908b03a 	or	r4,r19,r4
   22df8:	2100020c 	andi	r4,r4,8
   22dfc:	2000101e 	bne	r4,zero,22e40 <AL_ControlInd+0x7d4>
                alControl |= STATE_CHANGE;
   22e00:	9d400414 	ori	r21,r19,16
            nAlStatus |= STATE_CHANGE;
   22e04:	d5666fc5 	stb	r21,-26177(gp)
        bEcatWaitForAlControlRes = FALSE;
   22e08:	d0267285 	stb	zero,-26166(gp)
        SetALStatus(nAlStatus, result);
   22e0c:	b17fffcc 	andi	r5,r22,65535
   22e10:	a9003fcc 	andi	r4,r21,255
}
   22e14:	dfc00817 	ldw	ra,32(sp)
   22e18:	ddc00717 	ldw	r23,28(sp)
   22e1c:	dd800617 	ldw	r22,24(sp)
   22e20:	dd400517 	ldw	r21,20(sp)
   22e24:	dd000417 	ldw	r20,16(sp)
   22e28:	dcc00317 	ldw	r19,12(sp)
   22e2c:	dc800217 	ldw	r18,8(sp)
   22e30:	dc400117 	ldw	r17,4(sp)
   22e34:	dc000017 	ldw	r16,0(sp)
   22e38:	dec00904 	addi	sp,sp,36
        SetALStatus(nAlStatus, 0);
   22e3c:	00225c81 	jmpi	225c8 <SetALStatus>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22e40:	0021883a 	mov	r16,zero
            if(bEcatOutputUpdateRunning)
   22e44:	d0a67c83 	ldbu	r2,-26126(gp)
   22e48:	10000226 	beq	r2,zero,22e54 <AL_ControlInd+0x7e8>
                APPL_StopOutputHandler();
   22e4c:	00202100 	call	20210 <APPL_StopOutputHandler>
                StopOutputHandler();
   22e50:	00225140 	call	22514 <StopOutputHandler>
            if(nPdOutputSize > 0)
   22e54:	d0a6710b 	ldhu	r2,-26172(gp)
   22e58:	10000726 	beq	r2,zero,22e78 <AL_ControlInd+0x80c>
                DisableSyncManChannel(PROCESS_DATA_OUT);
   22e5c:	01000084 	movi	r4,2
                DisableSyncManChannel(PROCESS_DATA_IN);
   22e60:	0021a200 	call	21a20 <DisableSyncManChannel>
        if ( result != 0 )
   22e64:	80bfffcc 	andi	r2,r16,65535
   22e68:	103f211e 	bne	r2,zero,22af0 <AL_ControlInd+0x484>
            if ( alStatusCode != 0 )
   22e6c:	a53fffcc 	andi	r20,r20,65535
   22e70:	a03fe31e 	bne	r20,zero,22e00 <AL_ControlInd+0x794>
   22e74:	003efa06 	br	22a60 <AL_ControlInd+0x3f4>
                if(nPdInputSize > 0)
   22e78:	d0a6718b 	ldhu	r2,-26170(gp)
   22e7c:	103ff926 	beq	r2,zero,22e64 <AL_ControlInd+0x7f8>
                DisableSyncManChannel(PROCESS_DATA_IN);
   22e80:	010000c4 	movi	r4,3
   22e84:	003ff606 	br	22e60 <AL_ControlInd+0x7f4>

00022e88 <AL_ControlRes>:
 \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the application specific state transition function is called.
 \brief    If the pending state transition is triggered by the application the transition need to be completed by the application (ECAT_StateChange())
  *////////////////////////////////////////////////////////////////////////////////////////
void AL_ControlRes(void)
{
    if(bEcatWaitForAlControlRes)
   22e88:	d0a67283 	ldbu	r2,-26166(gp)
   22e8c:	1000bf26 	beq	r2,zero,2318c <AL_ControlRes+0x304>
        UINT8 Status = 0;
        UINT16 StatusCode = 0;

        if(EsmTimeoutCounter == 0)
        {
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22e90:	d0a6720b 	ldhu	r2,-26168(gp)
        if(EsmTimeoutCounter == 0)
   22e94:	d1267b0f 	ldh	r4,-26132(gp)
{
   22e98:	defffc04 	addi	sp,sp,-16
   22e9c:	dfc00315 	stw	ra,12(sp)
   22ea0:	dc800215 	stw	r18,8(sp)
   22ea4:	dc400115 	stw	r17,4(sp)
   22ea8:	dc000015 	stw	r16,0(sp)
   22eac:	10ffffcc 	andi	r3,r2,65535
        if(EsmTimeoutCounter == 0)
   22eb0:	2000551e 	bne	r4,zero,23008 <AL_ControlRes+0x180>
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22eb4:	1822d13a 	srli	r17,r3,4

            /* ESM timeout expired*/
            switch(nEcatStateTrans)
   22eb8:	19000920 	cmpeqi	r4,r3,36
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22ebc:	8825883a 	mov	r18,r17
            switch(nEcatStateTrans)
   22ec0:	2000331e 	bne	r4,zero,22f90 <AL_ControlRes+0x108>
   22ec4:	19000968 	cmpgeui	r4,r3,37
   22ec8:	2000091e 	bne	r4,zero,22ef0 <AL_ControlRes+0x68>
   22ecc:	10bffb84 	addi	r2,r2,-18
   22ed0:	10bfffcc 	andi	r2,r2,65535
   22ed4:	108000a8 	cmpgeui	r2,r2,2
   22ed8:	10001e26 	beq	r2,zero,22f54 <AL_ControlRes+0xcc>
                    }             
                break;
            }//Switch - transition
        }

        if(Status != 0)
   22edc:	8c403fcc 	andi	r17,r17,255
   22ee0:	88005126 	beq	r17,zero,23028 <AL_ControlRes+0x1a0>
        {
            /*Pending state transition finished => write AL Status and AL Status Code*/
            bEcatWaitForAlControlRes = FALSE;
   22ee4:	d0267285 	stb	zero,-26166(gp)
        UINT16 StatusCode = 0;
   22ee8:	0021883a 	mov	r16,zero
   22eec:	00001106 	br	22f34 <AL_ControlRes+0xac>
            switch(nEcatStateTrans)
   22ef0:	18c01220 	cmpeqi	r3,r3,72
   22ef4:	183ff926 	beq	r3,zero,22edc <AL_ControlRes+0x54>
                    if(bDcSyncActive)
   22ef8:	d0a67b83 	ldbu	r2,-26130(gp)
   22efc:	10002c26 	beq	r2,zero,22fb0 <AL_ControlRes+0x128>
                        if(!bDcRunning)
   22f00:	d0a67a83 	ldbu	r2,-26134(gp)
   22f04:	10003a26 	beq	r2,zero,22ff0 <AL_ControlRes+0x168>
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
   22f08:	d0a67c03 	ldbu	r2,-26128(gp)
   22f0c:	1000021e 	bne	r2,zero,22f18 <AL_ControlRes+0x90>
   22f10:	d0a6710b 	ldhu	r2,-26172(gp)
   22f14:	1000381e 	bne	r2,zero,22ff8 <AL_ControlRes+0x170>
                        else if (!bSmSyncSequenceValid)
   22f18:	d0a67903 	ldbu	r2,-26140(gp)
   22f1c:	10003826 	beq	r2,zero,23000 <AL_ControlRes+0x178>
                            bEcatOutputUpdateRunning = TRUE;
   22f20:	00800044 	movi	r2,1
   22f24:	d0a67c85 	stb	r2,-26126(gp)
            bEcatWaitForAlControlRes = FALSE;
   22f28:	d0267285 	stb	zero,-26166(gp)
                            StatusCode = 0;
   22f2c:	0021883a 	mov	r16,zero
                            Status = STATE_OP;
   22f30:	04800204 	movi	r18,8
            if (StatusCode != 0)
            {
                Status |= STATE_CHANGE;
            }

            SetALStatus(Status,StatusCode);
   22f34:	817fffcc 	andi	r5,r16,65535
   22f38:	91003fcc 	andi	r4,r18,255
        }
    }// Pending state transition (bEcatWaitForAlControlRes == true)
}
   22f3c:	dfc00317 	ldw	ra,12(sp)
   22f40:	dc800217 	ldw	r18,8(sp)
   22f44:	dc400117 	ldw	r17,4(sp)
   22f48:	dc000017 	ldw	r16,0(sp)
   22f4c:	dec00404 	addi	sp,sp,16
            SetALStatus(Status,StatusCode);
   22f50:	00225c81 	jmpi	225c8 <SetALStatus>
                        if (!bApplEsmPending)
   22f54:	d0a672c3 	ldbu	r2,-26165(gp)
   22f58:	1000011e 	bne	r2,zero,22f60 <AL_ControlRes+0xd8>
                            APPL_StopMailboxHandler();
   22f5c:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                    MBX_StopMailboxHandler();
   22f60:	00239ac0 	call	239ac <MBX_StopMailboxHandler>
                    if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
   22f64:	d0a67303 	ldbu	r2,-26164(gp)
   22f68:	108003cc 	andi	r2,r2,15
   22f6c:	10800058 	cmpnei	r2,r2,1
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   22f70:	1000811e 	bne	r2,zero,23178 <AL_ControlRes+0x2f0>
        if(Status != 0)
   22f74:	88803fcc 	andi	r2,r17,255
                        StatusCode = u16LocalErrorCode;
   22f78:	d426738b 	ldhu	r16,-26162(gp)
        if(Status != 0)
   22f7c:	10002a26 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   22f80:	d0267285 	stb	zero,-26166(gp)
            if (StatusCode != 0)
   22f84:	80bfffcc 	andi	r2,r16,65535
   22f88:	1000171e 	bne	r2,zero,22fe8 <AL_ControlRes+0x160>
   22f8c:	003fe906 	br	22f34 <AL_ControlRes+0xac>
                        if (!bApplEsmPending)
   22f90:	d0a672c3 	ldbu	r2,-26165(gp)
   22f94:	1000011e 	bne	r2,zero,22f9c <AL_ControlRes+0x114>
                            APPL_StopInputHandler();
   22f98:	00202000 	call	20200 <APPL_StopInputHandler>
                    StopInputHandler();
   22f9c:	00225200 	call	22520 <StopInputHandler>
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   22fa0:	d0a67303 	ldbu	r2,-26164(gp)
   22fa4:	108003cc 	andi	r2,r2,15
   22fa8:	10800098 	cmpnei	r2,r2,2
   22fac:	003ff006 	br	22f70 <AL_ControlRes+0xe8>
                            if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
   22fb0:	d0a67303 	ldbu	r2,-26164(gp)
   22fb4:	108003cc 	andi	r2,r2,15
   22fb8:	10800118 	cmpnei	r2,r2,4
   22fbc:	103fd81e 	bne	r2,zero,22f20 <AL_ControlRes+0x98>
                                StatusCode = u16LocalErrorCode;
   22fc0:	d426738b 	ldhu	r16,-26162(gp)
                    if(StatusCode != 0)
   22fc4:	80bfffcc 	andi	r2,r16,65535
   22fc8:	103fc426 	beq	r2,zero,22edc <AL_ControlRes+0x54>
                            if (!bApplEsmPending)
   22fcc:	d0a672c3 	ldbu	r2,-26165(gp)
   22fd0:	1000011e 	bne	r2,zero,22fd8 <AL_ControlRes+0x150>
                                APPL_StopOutputHandler();
   22fd4:	00202100 	call	20210 <APPL_StopOutputHandler>
                        StopOutputHandler();
   22fd8:	00225140 	call	22514 <StopOutputHandler>
        if(Status != 0)
   22fdc:	88803fcc 	andi	r2,r17,255
   22fe0:	10001126 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   22fe4:	d0267285 	stb	zero,-26166(gp)
                Status |= STATE_CHANGE;
   22fe8:	8c800414 	ori	r18,r17,16
   22fec:	003fd106 	br	22f34 <AL_ControlRes+0xac>
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
   22ff0:	04000b44 	movi	r16,45
   22ff4:	003ff506 	br	22fcc <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
   22ff8:	040006c4 	movi	r16,27
   22ffc:	003ff306 	br	22fcc <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SYNCERROR;
   23000:	04000684 	movi	r16,26
   23004:	003ff106 	br	22fcc <AL_ControlRes+0x144>
            switch(nEcatStateTrans)
   23008:	19000920 	cmpeqi	r4,r3,36
   2300c:	20003d1e 	bne	r4,zero,23104 <AL_ControlRes+0x27c>
   23010:	19000968 	cmpgeui	r4,r3,37
   23014:	20000a1e 	bne	r4,zero,23040 <AL_ControlRes+0x1b8>
   23018:	10bffb84 	addi	r2,r2,-18
   2301c:	10bfffcc 	andi	r2,r2,65535
   23020:	108000a8 	cmpgeui	r2,r2,2
   23024:	10001f26 	beq	r2,zero,230a4 <AL_ControlRes+0x21c>
}
   23028:	dfc00317 	ldw	ra,12(sp)
   2302c:	dc800217 	ldw	r18,8(sp)
   23030:	dc400117 	ldw	r17,4(sp)
   23034:	dc000017 	ldw	r16,0(sp)
   23038:	dec00404 	addi	sp,sp,16
   2303c:	f800283a 	ret
            switch(nEcatStateTrans)
   23040:	18c01220 	cmpeqi	r3,r3,72
   23044:	183ff826 	beq	r3,zero,23028 <AL_ControlRes+0x1a0>
                   if(bApplEsmPending)
   23048:	d0a672c3 	ldbu	r2,-26165(gp)
   2304c:	103ff626 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
                        if(bDcSyncActive)
   23050:	d0a67b83 	ldbu	r2,-26130(gp)
   23054:	10004126 	beq	r2,zero,2315c <AL_ControlRes+0x2d4>
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
   23058:	d0a6788f 	ldh	r2,-26142(gp)
   2305c:	00bff20e 	bge	zero,r2,23028 <AL_ControlRes+0x1a0>
   23060:	d0e6780f 	ldh	r3,-26144(gp)
   23064:	18bff016 	blt	r3,r2,23028 <AL_ControlRes+0x1a0>
                                i16WaitForPllRunningTimeout = 0;
   23068:	d026788d 	sth	zero,-26142(gp)
                                i16WaitForPllRunningCnt = 0;
   2306c:	d026780d 	sth	zero,-26144(gp)
                                bApplEsmPending = FALSE;
   23070:	d02672c5 	stb	zero,-26165(gp)
                                result = APPL_StartOutputHandler();
   23074:	00202080 	call	20208 <APPL_StartOutputHandler>
                                if(result == 0)
   23078:	10bfffcc 	andi	r2,r2,65535
   2307c:	103fa826 	beq	r2,zero,22f20 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   23080:	10803fe0 	cmpeqi	r2,r2,255
   23084:	103fe81e 	bne	r2,zero,23028 <AL_ControlRes+0x1a0>
                                        APPL_StopOutputHandler();
   23088:	00202100 	call	20210 <APPL_StopOutputHandler>
}
   2308c:	dfc00317 	ldw	ra,12(sp)
   23090:	dc800217 	ldw	r18,8(sp)
   23094:	dc400117 	ldw	r17,4(sp)
   23098:	dc000017 	ldw	r16,0(sp)
   2309c:	dec00404 	addi	sp,sp,16
                                        StopOutputHandler();
   230a0:	00225141 	jmpi	22514 <StopOutputHandler>
                    if(bApplEsmPending)
   230a4:	d0a672c3 	ldbu	r2,-26165(gp)
   230a8:	103fdf26 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
                        bApplEsmPending = FALSE;
   230ac:	d02672c5 	stb	zero,-26165(gp)
                        result = APPL_StartMailboxHandler();
   230b0:	00201e80 	call	201e8 <APPL_StartMailboxHandler>
   230b4:	1021883a 	mov	r16,r2
                        if(result == 0)
   230b8:	10bfffcc 	andi	r2,r2,65535
   230bc:	1000081e 	bne	r2,zero,230e0 <AL_ControlRes+0x258>
                            bMbxRunning = TRUE;
   230c0:	00800044 	movi	r2,1
   230c4:	d0a68545 	stb	r2,-26091(gp)
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   230c8:	d0a67203 	ldbu	r2,-26168(gp)
   230cc:	108003cc 	andi	r2,r2,15
   230d0:	1025883a 	mov	r18,r2
        if(Status != 0)
   230d4:	103fd426 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   230d8:	d0267285 	stb	zero,-26166(gp)
            if (StatusCode != 0)
   230dc:	003f9506 	br	22f34 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   230e0:	10803fe0 	cmpeqi	r2,r2,255
   230e4:	103fd01e 	bne	r2,zero,23028 <AL_ControlRes+0x1a0>
                                APPL_StopMailboxHandler();
   230e8:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
}
   230ec:	dfc00317 	ldw	ra,12(sp)
   230f0:	dc800217 	ldw	r18,8(sp)
   230f4:	dc400117 	ldw	r17,4(sp)
   230f8:	dc000017 	ldw	r16,0(sp)
   230fc:	dec00404 	addi	sp,sp,16
                                MBX_StopMailboxHandler();
   23100:	00239ac1 	jmpi	239ac <MBX_StopMailboxHandler>
                    if(bApplEsmPending)
   23104:	d0a672c3 	ldbu	r2,-26165(gp)
   23108:	103fc726 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
                        result = APPL_StartInputHandler(&u16ALEventMask);
   2310c:	d1266d84 	addi	r4,gp,-26186
                        bApplEsmPending = FALSE;
   23110:	d02672c5 	stb	zero,-26165(gp)
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23114:	00201f80 	call	201f8 <APPL_StartInputHandler>
   23118:	1021883a 	mov	r16,r2
                        if(result == 0)
   2311c:	10bfffcc 	andi	r2,r2,65535
   23120:	1000051e 	bne	r2,zero,23138 <AL_ControlRes+0x2b0>
                            bEcatInputUpdateRunning = TRUE;
   23124:	00800044 	movi	r2,1
   23128:	d0a67c45 	stb	r2,-26127(gp)
            bEcatWaitForAlControlRes = FALSE;
   2312c:	d0267285 	stb	zero,-26166(gp)
                            Status = STATE_SAFEOP;
   23130:	04800104 	movi	r18,4
   23134:	003f7f06 	br	22f34 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   23138:	10803fe0 	cmpeqi	r2,r2,255
   2313c:	103fba1e 	bne	r2,zero,23028 <AL_ControlRes+0x1a0>
                                APPL_StopInputHandler();
   23140:	00202000 	call	20200 <APPL_StopInputHandler>
}
   23144:	dfc00317 	ldw	ra,12(sp)
   23148:	dc800217 	ldw	r18,8(sp)
   2314c:	dc400117 	ldw	r17,4(sp)
   23150:	dc000017 	ldw	r16,0(sp)
   23154:	dec00404 	addi	sp,sp,16
                                StopInputHandler();
   23158:	00225201 	jmpi	22520 <StopInputHandler>
                                bApplEsmPending = FALSE;  
   2315c:	d02672c5 	stb	zero,-26165(gp)
                                result = APPL_StartOutputHandler();
   23160:	00202080 	call	20208 <APPL_StartOutputHandler>
                                if(result == 0)
   23164:	10bfffcc 	andi	r2,r2,65535
   23168:	103f6d26 	beq	r2,zero,22f20 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   2316c:	10803fd8 	cmpnei	r2,r2,255
   23170:	103fad26 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
   23174:	003fc406 	br	23088 <AL_ControlRes+0x200>
        if(Status != 0)
   23178:	88803fcc 	andi	r2,r17,255
   2317c:	103faa26 	beq	r2,zero,23028 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   23180:	d0267285 	stb	zero,-26166(gp)
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
   23184:	04000044 	movi	r16,1
   23188:	003f9706 	br	22fe8 <AL_ControlRes+0x160>
   2318c:	f800283a 	ret

00023190 <DC_CheckWatchdog>:

*////////////////////////////////////////////////////////////////////////////////////////
void DC_CheckWatchdog(void)
{

    if(bDcSyncActive && bEcatInputUpdateRunning)
   23190:	d0a67b83 	ldbu	r2,-26130(gp)
   23194:	10002d26 	beq	r2,zero,2324c <DC_CheckWatchdog+0xbc>
   23198:	d0a67c43 	ldbu	r2,-26127(gp)
   2319c:	10002b26 	beq	r2,zero,2324c <DC_CheckWatchdog+0xbc>
    {
        /*If Sync0 watchdog is enabled and expired*/
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
   231a0:	d0e6770b 	ldhu	r3,-26148(gp)
   231a4:	18000926 	beq	r3,zero,231cc <DC_CheckWatchdog+0x3c>
   231a8:	d0a6778b 	ldhu	r2,-26146(gp)
   231ac:	113fffcc 	andi	r4,r2,65535
   231b0:	20c00436 	bltu	r4,r3,231c4 <DC_CheckWatchdog+0x34>
                {
                    i16WaitForPllRunningCnt = 0;
                }
            }
        }
        else if(bSmSyncSequenceValid)
   231b4:	d0a67903 	ldbu	r2,-26140(gp)
                bDcRunning = FALSE;        
   231b8:	d0267a85 	stb	zero,-26134(gp)
        else if(bSmSyncSequenceValid)
   231bc:	1000211e 	bne	r2,zero,23244 <DC_CheckWatchdog+0xb4>
   231c0:	f800283a 	ret
                Sync0WdCounter ++;
   231c4:	10800044 	addi	r2,r2,1
   231c8:	d0a6778d 	sth	r2,-26146(gp)
            if(Sync1WdValue > 0)
   231cc:	d0e6760b 	ldhu	r3,-26152(gp)
            bDcRunning = TRUE;
   231d0:	00800044 	movi	r2,1
   231d4:	d0a67a85 	stb	r2,-26134(gp)
            if(Sync1WdValue > 0)
   231d8:	18000526 	beq	r3,zero,231f0 <DC_CheckWatchdog+0x60>
                if(Sync1WdCounter < Sync1WdValue)
   231dc:	d0a6768b 	ldhu	r2,-26150(gp)
   231e0:	113fffcc 	andi	r4,r2,65535
   231e4:	20fff32e 	bgeu	r4,r3,231b4 <DC_CheckWatchdog+0x24>
                    Sync1WdCounter ++;
   231e8:	10800044 	addi	r2,r2,1
   231ec:	d0a6768d 	sth	r2,-26150(gp)
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
   231f0:	008000f4 	movhi	r2,3
   231f4:	10abfb0b 	ldhu	r2,-20500(r2)
   231f8:	10000326 	beq	r2,zero,23208 <DC_CheckWatchdog+0x78>
   231fc:	00c000f4 	movhi	r3,3
   23200:	18f3050b 	ldhu	r3,-13292(r3)
   23204:	1880082e 	bgeu	r3,r2,23228 <DC_CheckWatchdog+0x98>
                bSmSyncSequenceValid = TRUE;
   23208:	00800044 	movi	r2,1
   2320c:	d0a67905 	stb	r2,-26140(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23210:	d0a6788f 	ldh	r2,-26142(gp)
   23214:	00800d0e 	bge	zero,r2,2324c <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt++;
   23218:	d0a6780b 	ldhu	r2,-26144(gp)
   2321c:	10800044 	addi	r2,r2,1
   23220:	d0a6780d 	sth	r2,-26144(gp)
   23224:	f800283a 	ret
            else if (bSmSyncSequenceValid)
   23228:	d0a67903 	ldbu	r2,-26140(gp)
   2322c:	10000726 	beq	r2,zero,2324c <DC_CheckWatchdog+0xbc>
                if (i16WaitForPllRunningTimeout > 0)
   23230:	d0a6788f 	ldh	r2,-26142(gp)
                    bSmSyncSequenceValid = FALSE;
   23234:	d0267905 	stb	zero,-26140(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23238:	0080040e 	bge	zero,r2,2324c <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt = 0;
   2323c:	d026780d 	sth	zero,-26144(gp)
   23240:	f800283a 	ret
        {
           bSmSyncSequenceValid = FALSE;
   23244:	d0267905 	stb	zero,-26140(gp)
        }
    }
}
   23248:	f800283a 	ret
   2324c:	f800283a 	ret

00023250 <CheckIfEcatError>:
*////////////////////////////////////////////////////////////////////////////////////////
void CheckIfEcatError(void)
{
   /*if the watchdog is enabled check the process data watchdog in the ESC
   and set the AL status code 0x1B if the watchdog expired*/
   if (EcatWdValue != 0)
   23250:	d0a66f0b 	ldhu	r2,-26180(gp)
   23254:	10002626 	beq	r2,zero,232f0 <CheckIfEcatError+0xa0>
{
   23258:	defffe04 	addi	sp,sp,-8
   {
      /*watchdog time is set => watchdog is active*/
      UINT16 WdStatusOK = 0;

      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   2325c:	01800084 	movi	r6,2
   23260:	01411004 	movi	r5,1088
   23264:	d9000084 	addi	r4,sp,2
{
   23268:	dfc00115 	stw	ra,4(sp)
      UINT16 WdStatusOK = 0;
   2326c:	d800008d 	sth	zero,2(sp)
      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   23270:	00206f00 	call	206f0 <HW_EscRead>
      WdStatusOK = SWAPWORD(WdStatusOK);

      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
   23274:	d880008b 	ldhu	r2,2(sp)
   23278:	1080004c 	andi	r2,r2,1
   2327c:	10000d1e 	bne	r2,zero,232b4 <CheckIfEcatError+0x64>
   23280:	d0a6710b 	ldhu	r2,-26172(gp)
   23284:	10000b26 	beq	r2,zero,232b4 <CheckIfEcatError+0x64>
      {
         /*The device is in OP state*/

         if (bEcatOutputUpdateRunning
   23288:	d0a67c83 	ldbu	r2,-26126(gp)
   2328c:	10000826 	beq	r2,zero,232b0 <CheckIfEcatError+0x60>
            && bEcatFirstOutputsReceived
   23290:	d0a67c03 	ldbu	r2,-26128(gp)
   23294:	10000626 	beq	r2,zero,232b0 <CheckIfEcatError+0x60>
            )
         {
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
   23298:	014006c4 	movi	r5,27
   2329c:	01000104 	movi	r4,4
   232a0:	002266c0 	call	2266c <AL_ControlInd>
               return;
           }
        
       }
   }
}
   232a4:	dfc00117 	ldw	ra,4(sp)
   232a8:	dec00204 	addi	sp,sp,8
   232ac:	f800283a 	ret
            bEcatFirstOutputsReceived = FALSE;
   232b0:	d0267c05 	stb	zero,-26128(gp)
   if(bDcSyncActive)
   232b4:	d0a67b83 	ldbu	r2,-26130(gp)
   232b8:	103ffa26 	beq	r2,zero,232a4 <CheckIfEcatError+0x54>
       if(bEcatOutputUpdateRunning)
   232bc:	d0a67c83 	ldbu	r2,-26126(gp)
   232c0:	103ff826 	beq	r2,zero,232a4 <CheckIfEcatError+0x54>
           if(!bDcRunning)
   232c4:	d0a67a83 	ldbu	r2,-26134(gp)
   232c8:	1000051e 	bne	r2,zero,232e0 <CheckIfEcatError+0x90>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   232cc:	01400b04 	movi	r5,44
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   232d0:	01000104 	movi	r4,4
}
   232d4:	dfc00117 	ldw	ra,4(sp)
   232d8:	dec00204 	addi	sp,sp,8
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   232dc:	002266c1 	jmpi	2266c <AL_ControlInd>
           else if(!bSmSyncSequenceValid)
   232e0:	d0a67903 	ldbu	r2,-26140(gp)
   232e4:	103fef1e 	bne	r2,zero,232a4 <CheckIfEcatError+0x54>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   232e8:	01400684 	movi	r5,26
   232ec:	003ff806 	br	232d0 <CheckIfEcatError+0x80>
   if(bDcSyncActive)
   232f0:	d0a67b83 	ldbu	r2,-26130(gp)
   232f4:	10000b26 	beq	r2,zero,23324 <CheckIfEcatError+0xd4>
       if(bEcatOutputUpdateRunning)
   232f8:	d0a67c83 	ldbu	r2,-26126(gp)
   232fc:	10000926 	beq	r2,zero,23324 <CheckIfEcatError+0xd4>
           if(!bDcRunning)
   23300:	d0a67a83 	ldbu	r2,-26134(gp)
   23304:	1000031e 	bne	r2,zero,23314 <CheckIfEcatError+0xc4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   23308:	01400b04 	movi	r5,44
   2330c:	01000104 	movi	r4,4
   23310:	003ff206 	br	232dc <CheckIfEcatError+0x8c>
           else if(!bSmSyncSequenceValid)
   23314:	d0a67903 	ldbu	r2,-26140(gp)
   23318:	1000021e 	bne	r2,zero,23324 <CheckIfEcatError+0xd4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   2331c:	01400684 	movi	r5,26
   23320:	003ffa06 	br	2330c <CheckIfEcatError+0xbc>
   23324:	f800283a 	ret

00023328 <ECAT_StateChange>:
 \brief    This function changes the state of the EtherCAT slave if the requested state
             is lower than the actual state, otherwise the error condition will be reset.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
{
   23328:	defffe04 	addi	sp,sp,-8
   2332c:	dc000015 	stw	r16,0(sp)
   23330:	dfc00115 	stw	ra,4(sp)
    UINT8 Status = alStatus;

    /*ECATCHANGE_START(V5.13) ESM1*/
    /*return in case of invalid parameters*/
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23334:	2c3fffcc 	andi	r16,r5,65535
   23338:	8000201e 	bne	r16,zero,233bc <ECAT_StateChange+0x94>
    {
        return;
    }

    /* call the application requested state transition only once*/
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   2333c:	d0a67283 	ldbu	r2,-26166(gp)
   23340:	10000a1e 	bne	r2,zero,2336c <ECAT_StateChange+0x44>
   23344:	d0a67303 	ldbu	r2,-26164(gp)
   23348:	21003fcc 	andi	r4,r4,255
   2334c:	2080021e 	bne	r4,r2,23358 <ECAT_StateChange+0x30>
   23350:	d0a6738b 	ldhu	r2,-26162(gp)
   23354:	10002526 	beq	r2,zero,233ec <ECAT_StateChange+0xc4>
               /* no error pending and the target state is lower than the current one*/
                AL_ControlInd(alStatus, alStatusCode);
            }
        }
        /*ECATCHANGE_START(V5.13) ESM1*/
        else if (u8LocalErrorState != 0)
   23358:	d0a67303 	ldbu	r2,-26164(gp)
   2335c:	10002326 	beq	r2,zero,233ec <ECAT_StateChange+0xc4>
                u8LocalErrorState = 0;
   23360:	d0267305 	stb	zero,-26164(gp)
                u16LocalErrorCode = alStatusCode;
   23364:	d026738d 	sth	zero,-26162(gp)
   23368:	00002006 	br	233ec <ECAT_StateChange+0xc4>
        if(bApplEsmPending)
   2336c:	d0a672c3 	ldbu	r2,-26165(gp)
   23370:	103ffb1e 	bne	r2,zero,23360 <ECAT_StateChange+0x38>
                switch(nEcatStateTrans)
   23374:	d0a6720b 	ldhu	r2,-26168(gp)
   23378:	10ffffcc 	andi	r3,r2,65535
   2337c:	19000920 	cmpeqi	r4,r3,36
   23380:	20004b1e 	bne	r4,zero,234b0 <ECAT_StateChange+0x188>
   23384:	19000968 	cmpgeui	r4,r3,37
   23388:	2000411e 	bne	r4,zero,23490 <ECAT_StateChange+0x168>
   2338c:	10bffb84 	addi	r2,r2,-18
   23390:	10bfffcc 	andi	r2,r2,65535
   23394:	108000a8 	cmpgeui	r2,r2,2
   23398:	10004226 	beq	r2,zero,234a4 <ECAT_StateChange+0x17c>
                else if (u8LocalErrorState != 0)
   2339c:	d0a67303 	ldbu	r2,-26164(gp)
                bEcatWaitForAlControlRes = FALSE;
   233a0:	d0267285 	stb	zero,-26166(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   233a4:	d126720b 	ldhu	r4,-26168(gp)
                else if (u8LocalErrorState != 0)
   233a8:	10000226 	beq	r2,zero,233b4 <ECAT_StateChange+0x8c>
                    u8LocalErrorState = 0;
   233ac:	d0267305 	stb	zero,-26164(gp)
                    u16LocalErrorCode = 0x00;
   233b0:	d026738d 	sth	zero,-26162(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   233b4:	210003cc 	andi	r4,r4,15
   233b8:	00002406 	br	2344c <ECAT_StateChange+0x124>
   233bc:	208003cc 	andi	r2,r4,15
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   233c0:	00c04584 	movi	r3,278
   233c4:	1886d83a 	srl	r3,r3,r2
   233c8:	18c0004c 	andi	r3,r3,1
   233cc:	18000726 	beq	r3,zero,233ec <ECAT_StateChange+0xc4>
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   233d0:	d0e67283 	ldbu	r3,-26166(gp)
   233d4:	1800091e 	bne	r3,zero,233fc <ECAT_StateChange+0xd4>
   233d8:	d0e67303 	ldbu	r3,-26164(gp)
   233dc:	21003fcc 	andi	r4,r4,255
   233e0:	1900381e 	bne	r3,r4,234c4 <ECAT_StateChange+0x19c>
   233e4:	d0e6738b 	ldhu	r3,-26162(gp)
   233e8:	80c0361e 	bne	r16,r3,234c4 <ECAT_StateChange+0x19c>
            u8LocalErrorState = 0;
            u16LocalErrorCode = 0x00;
        }
        /*ECATCHANGE_END(V5.13) ESM1*/
    }
}
   233ec:	dfc00117 	ldw	ra,4(sp)
   233f0:	dc000017 	ldw	r16,0(sp)
   233f4:	dec00204 	addi	sp,sp,8
   233f8:	f800283a 	ret
        if(bApplEsmPending)
   233fc:	d0e672c3 	ldbu	r3,-26165(gp)
                u8LocalErrorState = (alStatus & STATE_MASK);
   23400:	d0a67305 	stb	r2,-26164(gp)
                u16LocalErrorCode = alStatusCode;
   23404:	d166738d 	sth	r5,-26162(gp)
        if(bApplEsmPending)
   23408:	18000226 	beq	r3,zero,23414 <ECAT_StateChange+0xec>
                EsmTimeoutCounter = 0;
   2340c:	d0267b0d 	sth	zero,-26132(gp)
   23410:	003ff606 	br	233ec <ECAT_StateChange+0xc4>
                switch(nEcatStateTrans)
   23414:	d0a6720b 	ldhu	r2,-26168(gp)
   23418:	10ffffcc 	andi	r3,r2,65535
   2341c:	19000920 	cmpeqi	r4,r3,36
   23420:	2000181e 	bne	r4,zero,23484 <ECAT_StateChange+0x15c>
   23424:	19000968 	cmpgeui	r4,r3,37
   23428:	20000e1e 	bne	r4,zero,23464 <ECAT_StateChange+0x13c>
   2342c:	10bffb84 	addi	r2,r2,-18
   23430:	10bfffcc 	andi	r2,r2,65535
   23434:	108000a8 	cmpgeui	r2,r2,2
   23438:	10000f26 	beq	r2,zero,23478 <ECAT_StateChange+0x150>
                Status =  (UINT8)(nEcatStateTrans >> 4);
   2343c:	d126720b 	ldhu	r4,-26168(gp)
                bEcatWaitForAlControlRes = FALSE;
   23440:	d0267285 	stb	zero,-26166(gp)
                Status =  (UINT8)(nEcatStateTrans >> 4);
   23444:	2008d13a 	srli	r4,r4,4
                    Status |= STATE_CHANGE;
   23448:	21000414 	ori	r4,r4,16
                SetALStatus(Status,alStatusCode);
   2344c:	800b883a 	mov	r5,r16
   23450:	21003fcc 	andi	r4,r4,255
}
   23454:	dfc00117 	ldw	ra,4(sp)
   23458:	dc000017 	ldw	r16,0(sp)
   2345c:	dec00204 	addi	sp,sp,8
                SetALStatus(Status,alStatusCode);
   23460:	00225c81 	jmpi	225c8 <SetALStatus>
                switch(nEcatStateTrans)
   23464:	18c01220 	cmpeqi	r3,r3,72
   23468:	183ff426 	beq	r3,zero,2343c <ECAT_StateChange+0x114>
                          APPL_StopOutputHandler();
   2346c:	00202100 	call	20210 <APPL_StopOutputHandler>
                          StopOutputHandler();
   23470:	00225140 	call	22514 <StopOutputHandler>
                    break;
   23474:	003ff106 	br	2343c <ECAT_StateChange+0x114>
                          APPL_StopMailboxHandler();
   23478:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                          MBX_StopMailboxHandler();
   2347c:	00239ac0 	call	239ac <MBX_StopMailboxHandler>
                    break;
   23480:	003fee06 	br	2343c <ECAT_StateChange+0x114>
                          APPL_StopInputHandler();
   23484:	00202000 	call	20200 <APPL_StopInputHandler>
                          StopInputHandler();
   23488:	00225200 	call	22520 <StopInputHandler>
                    break;
   2348c:	003feb06 	br	2343c <ECAT_StateChange+0x114>
                switch(nEcatStateTrans)
   23490:	18c01220 	cmpeqi	r3,r3,72
   23494:	183fc126 	beq	r3,zero,2339c <ECAT_StateChange+0x74>
                          bEcatOutputUpdateRunning = TRUE;
   23498:	00800044 	movi	r2,1
   2349c:	d0a67c85 	stb	r2,-26126(gp)
                    break;
   234a0:	003fbe06 	br	2339c <ECAT_StateChange+0x74>
                        bMbxRunning = TRUE;
   234a4:	00800044 	movi	r2,1
   234a8:	d0a68545 	stb	r2,-26091(gp)
                    break;
   234ac:	003fbb06 	br	2339c <ECAT_StateChange+0x74>
                        SetALEventMask(u16ALEventMask);
   234b0:	d1266d8b 	ldhu	r4,-26186(gp)
   234b4:	002196c0 	call	2196c <SetALEventMask>
                        bEcatInputUpdateRunning = TRUE;
   234b8:	00800044 	movi	r2,1
   234bc:	d0a67c45 	stb	r2,-26127(gp)
                    break;
   234c0:	003fb606 	br	2339c <ECAT_StateChange+0x74>
        if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
   234c4:	10c00220 	cmpeqi	r3,r2,8
   234c8:	11803fcc 	andi	r6,r2,255
   234cc:	183fa21e 	bne	r3,zero,23358 <ECAT_StateChange+0x30>
   234d0:	00c00584 	movi	r3,22
   234d4:	1986d83a 	srl	r3,r3,r6
   234d8:	18c0004c 	andi	r3,r3,1
   234dc:	183f9e26 	beq	r3,zero,23358 <ECAT_StateChange+0x30>
            u8LocalErrorState = (alStatus & STATE_MASK);
   234e0:	d0a67305 	stb	r2,-26164(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   234e4:	d0a66fc3 	ldbu	r2,-26177(gp)
            u16LocalErrorCode = alStatusCode;
   234e8:	d166738d 	sth	r5,-26162(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   234ec:	108003cc 	andi	r2,r2,15
   234f0:	10800218 	cmpnei	r2,r2,8
   234f4:	103fbd1e 	bne	r2,zero,233ec <ECAT_StateChange+0xc4>
                AL_ControlInd(alStatus, alStatusCode);
   234f8:	800b883a 	mov	r5,r16
}
   234fc:	dfc00117 	ldw	ra,4(sp)
   23500:	dc000017 	ldw	r16,0(sp)
   23504:	dec00204 	addi	sp,sp,8
                AL_ControlInd(alStatus, alStatusCode);
   23508:	002266c1 	jmpi	2266c <AL_ControlInd>

0002350c <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
   2350c:	defffe04 	addi	sp,sp,-8
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23510:	01800044 	movi	r6,1
   23514:	01400144 	movi	r5,5
   23518:	d1267084 	addi	r4,gp,-26174
{
   2351c:	dfc00115 	stw	ra,4(sp)
   23520:	dc000015 	stw	r16,0(sp)
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23524:	00206f00 	call	206f0 <HW_EscRead>

    HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
   23528:	01800084 	movi	r6,2
   2352c:	01400184 	movi	r5,6
   23530:	d1267004 	addi	r4,gp,-26176
   23534:	00206f00 	call	206f0 <HW_EscRead>
    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23538:	d0a6700b 	ldhu	r2,-26176(gp)

/*ECATCHANGE_START(V5.13) ECAT2*/
    u16IdValue = 0;
   2353c:	d0266d0d 	sth	zero,-26188(gp)

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
   23540:	0021883a 	mov	r16,zero
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23544:	100492ba 	slli	r2,r2,10
   23548:	1083ffc4 	addi	r2,r2,4095
   2354c:	d0a6700d 	sth	r2,-26176(gp)
    UpdateEEPROMLoadedState();
   23550:	00219b80 	call	219b8 <UpdateEEPROMLoadedState>
    for (i = 0; i < nMaxSyncMan; i++)
   23554:	d0a67083 	ldbu	r2,-26174(gp)
   23558:	81003fcc 	andi	r4,r16,255
   2355c:	20802036 	bltu	r4,r2,235e0 <ECAT_Init+0xd4>
    {
        DisableSyncManChannel(i);
    }

    /* initialize the mailbox handler */
    MBX_Init();
   23560:	00238280 	call	23828 <MBX_Init>
    u16ALEventMask = 0;
    nPdOutputSize = 0;
    nPdInputSize = 0;

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
   23564:	00800044 	movi	r2,1
    SetALStatus(nAlStatus, 0);
   23568:	000b883a 	mov	r5,zero
   2356c:	01000044 	movi	r4,1
    nAlStatus    = STATE_INIT;
   23570:	d0a66fc5 	stb	r2,-26177(gp)
    bApplEsmPending = FALSE;
   23574:	d02672c5 	stb	zero,-26165(gp)
    bEcatWaitForAlControlRes = FALSE;
   23578:	d0267285 	stb	zero,-26166(gp)
    bEcatFirstOutputsReceived = FALSE;
   2357c:	d0267c05 	stb	zero,-26128(gp)
     bEcatOutputUpdateRunning = FALSE;
   23580:	d0267c85 	stb	zero,-26126(gp)
     bEcatInputUpdateRunning = FALSE;
   23584:	d0267c45 	stb	zero,-26127(gp)
     bExplicitDevIdRequested = FALSE;
   23588:	d0266f85 	stb	zero,-26178(gp)
    bWdTrigger = FALSE;
   2358c:	d0267bc5 	stb	zero,-26129(gp)
    EcatWdValue = 0;
   23590:	d0266f0d 	sth	zero,-26180(gp)
    Sync0WdCounter = 0;
   23594:	d026778d 	sth	zero,-26146(gp)
    Sync0WdValue = 0;
   23598:	d026770d 	sth	zero,-26148(gp)
    Sync1WdCounter = 0;
   2359c:	d026768d 	sth	zero,-26150(gp)
    Sync1WdValue = 0;
   235a0:	d026760d 	sth	zero,-26152(gp)
    bDcSyncActive = FALSE;
   235a4:	d0267b85 	stb	zero,-26130(gp)
    u8LocalErrorState = 0;
   235a8:	d0267305 	stb	zero,-26164(gp)
    u16LocalErrorCode = 0x00;
   235ac:	d026738d 	sth	zero,-26162(gp)
    u16ALEventMask = 0;
   235b0:	d0266d8d 	sth	zero,-26186(gp)
    nPdOutputSize = 0;
   235b4:	d026710d 	sth	zero,-26172(gp)
    nPdInputSize = 0;
   235b8:	d026718d 	sth	zero,-26170(gp)
    SetALStatus(nAlStatus, 0);
   235bc:	00225c80 	call	225c8 <SetALStatus>
    nEcatStateTrans = 0;
   235c0:	d026720d 	sth	zero,-26168(gp)

    bEscIntEnabled = FALSE;
   235c4:	d0267445 	stb	zero,-26159(gp)

    /* initialize the COE part */
    COE_Init();
   235c8:	00218640 	call	21864 <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
   235cc:	0009883a 	mov	r4,zero
}
   235d0:	dfc00117 	ldw	ra,4(sp)
   235d4:	dc000017 	ldw	r16,0(sp)
   235d8:	dec00204 	addi	sp,sp,8
    ResetALEventMask(0);
   235dc:	00219201 	jmpi	21920 <ResetALEventMask>
        DisableSyncManChannel(i);
   235e0:	0021a200 	call	21a20 <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
   235e4:	84000044 	addi	r16,r16,1
   235e8:	003fda06 	br	23554 <ECAT_Init+0x48>

000235ec <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
   235ec:	defffc04 	addi	sp,sp,-16
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
/*ECATCHANGE_START(V5.13) MBX1*/
    UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
   235f0:	00800044 	movi	r2,1
   235f4:	d8800005 	stb	r2,0(sp)
{
   235f8:	dfc00315 	stw	ra,12(sp)
   235fc:	dc400215 	stw	r17,8(sp)
   23600:	dc000115 	stw	r16,4(sp)
    UINT16 EscAlControl = 0x0000;
   23604:	d800008d 	sth	zero,2(sp)
    UINT8 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
   23608:	d8000045 	stb	zero,1(sp)
/*ECATCHANGE_END(V5.13) MBX1*/


    /* check if services are stored in the mailbox */
    MBX_Main();
   2360c:	002401c0 	call	2401c <MBX_Main>


    if ( bMbxRunning )
   23610:	d0a68543 	ldbu	r2,-26091(gp)
   23614:	10000826 	beq	r2,zero,23638 <ECAT_Main+0x4c>
    {
        /* Slave is at least in PREOP, Mailbox is running */

/*ECATCHANGE_START(V5.13) MBX1*/
        /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
        HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
   23618:	01800044 	movi	r6,1
   2361c:	01420384 	movi	r5,2062
   23620:	d809883a 	mov	r4,sp
   23624:	00206f00 	call	206f0 <HW_EscRead>

        HW_EscReadByte(sm1Status, (ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23628:	01800044 	movi	r6,1
   2362c:	01420344 	movi	r5,2061
   23630:	d9000044 	addi	r4,sp,1
   23634:	00206f00 	call	206f0 <HW_EscRead>
/*ECATCHANGE_END(V5.13) MBX1*/
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
   23638:	00207280 	call	20728 <HW_GetALEventRegister>
   2363c:	1021883a 	mov	r16,r2
    ALEventReg = SWAPWORD(ALEventReg);


    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
   23640:	8080004c 	andi	r2,r16,1
   23644:	10001526 	beq	r2,zero,2369c <ECAT_Main+0xb0>
   23648:	d4667283 	ldbu	r17,-26166(gp)
   2364c:	88803fcc 	andi	r2,r17,255
   23650:	1000121e 	bne	r2,zero,2369c <ECAT_Main+0xb0>
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */

        HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
   23654:	01800044 	movi	r6,1
   23658:	01404804 	movi	r5,288
   2365c:	d9000084 	addi	r4,sp,2
   23660:	00206f00 	call	206f0 <HW_EscRead>
        EscAlControl = SWAPWORD(EscAlControl);


            /*ECATCHANGE_START(V5.13) ECAT2*/
                /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
            if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
   23664:	d880008b 	ldhu	r2,2(sp)
   23668:	1080080c 	andi	r2,r2,32
   2366c:	10000526 	beq	r2,zero,23684 <ECAT_Main+0x98>
            {
                if (bExplicitDevIdRequested == FALSE)
   23670:	d0a66f83 	ldbu	r2,-26178(gp)
   23674:	1000021e 	bne	r2,zero,23680 <ECAT_Main+0x94>
                {
                    u16IdValue = APPL_GetDeviceID();
   23678:	002042c0 	call	2042c <APPL_GetDeviceID>
   2367c:	d0a66d0d 	sth	r2,-26188(gp)
                }

                bExplicitDevIdRequested = TRUE;
   23680:	04400044 	movi	r17,1

        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));

            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23684:	d9000083 	ldbu	r4,2(sp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   23688:	00bffb84 	movi	r2,-18
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   2368c:	000b883a 	mov	r5,zero
                bExplicitDevIdRequested = TRUE;
   23690:	d4666f85 	stb	r17,-26178(gp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   23694:	1420703a 	and	r16,r2,r16
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23698:	002266c0 	call	2266c <AL_ControlInd>

            /* SM-Change-Event was handled too */

    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   2369c:	8400040c 	andi	r16,r16,16
   236a0:	d0a67283 	ldbu	r2,-26166(gp)
   236a4:	80002e26 	beq	r16,zero,23760 <ECAT_Main+0x174>
   236a8:	10803fcc 	andi	r2,r2,255
   236ac:	10002326 	beq	r2,zero,2373c <ECAT_Main+0x150>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
    }

    if(bEcatWaitForAlControlRes)
    {
        AL_ControlRes();
   236b0:	0022e880 	call	22e88 <AL_ControlRes>
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
   236b4:	d0a68543 	ldbu	r2,-26091(gp)
   236b8:	10001b26 	beq	r2,zero,23728 <ECAT_Main+0x13c>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
            if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
   236bc:	d8800003 	ldbu	r2,0(sp)
   236c0:	1080004c 	andi	r2,r2,1
   236c4:	1000041e 	bne	r2,zero,236d8 <ECAT_Main+0xec>
            {
                AL_ControlInd(nAlStatus & STATE_MASK, 0);
   236c8:	d1266fc3 	ldbu	r4,-26177(gp)
   236cc:	000b883a 	mov	r5,zero
   236d0:	210003cc 	andi	r4,r4,15
   236d4:	002266c0 	call	2266c <AL_ControlInd>
            }

/*ECATCHANGE_START(V5.13) MBX1*/
        if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
   236d8:	d8800043 	ldbu	r2,1(sp)
   236dc:	1080020c 	andi	r2,r2,8
   236e0:	1000081e 	bne	r2,zero,23704 <ECAT_Main+0x118>
            && bSendMbxIsFull) 
   236e4:	d0a68583 	ldbu	r2,-26090(gp)
   236e8:	10000626 	beq	r2,zero,23704 <ECAT_Main+0x118>
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u8dummy = 0;
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   236ec:	d166830b 	ldhu	r5,-26100(gp)
   236f0:	01800044 	movi	r6,1
   236f4:	d1266cc4 	addi	r4,gp,-26189
            u8dummy = 0;
   236f8:	d0266cc5 	stb	zero,-26189(gp)
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   236fc:	00207740 	call	20774 <HW_EscWrite>

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
            MBX_MailboxReadInd();
   23700:	0023c200 	call	23c20 <MBX_MailboxReadInd>
        }

            /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

            if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
   23704:	d8800003 	ldbu	r2,0(sp)
   23708:	d0e68503 	ldbu	r3,-26092(gp)
   2370c:	1080008c 	andi	r2,r2,2
   23710:	10001626 	beq	r2,zero,2376c <ECAT_Main+0x180>
   23714:	18001626 	beq	r3,zero,23770 <ECAT_Main+0x184>
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
            }


        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
   23718:	00207280 	call	20728 <HW_GetALEventRegister>
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
   2371c:	1080400c 	andi	r2,r2,256
   23720:	10000126 	beq	r2,zero,23728 <ECAT_Main+0x13c>
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
            MBX_CheckAndCopyMailbox();
   23724:	0023ee80 	call	23ee8 <MBX_CheckAndCopyMailbox>

        }
    }
}
   23728:	dfc00317 	ldw	ra,12(sp)
   2372c:	dc400217 	ldw	r17,8(sp)
   23730:	dc000117 	ldw	r16,4(sp)
   23734:	dec00404 	addi	sp,sp,16
   23738:	f800283a 	ret
    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   2373c:	d1266fc3 	ldbu	r4,-26177(gp)
   23740:	2080040c 	andi	r2,r4,16
   23744:	103fdb1e 	bne	r2,zero,236b4 <ECAT_Main+0xc8>
   23748:	20803bcc 	andi	r2,r4,239
   2374c:	10800060 	cmpeqi	r2,r2,1
   23750:	103fd81e 	bne	r2,zero,236b4 <ECAT_Main+0xc8>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
   23754:	000b883a 	mov	r5,zero
   23758:	210003cc 	andi	r4,r4,15
   2375c:	002266c0 	call	2266c <AL_ControlInd>
    if(bEcatWaitForAlControlRes)
   23760:	d0a67283 	ldbu	r2,-26166(gp)
   23764:	103fd326 	beq	r2,zero,236b4 <ECAT_Main+0xc8>
   23768:	003fd106 	br	236b0 <ECAT_Main+0xc4>
                || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
   2376c:	183fea26 	beq	r3,zero,23718 <ECAT_Main+0x12c>
                MBX_MailboxRepeatReq();
   23770:	0023cc00 	call	23cc0 <MBX_MailboxRepeatReq>
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23774:	d8800003 	ldbu	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23778:	01800044 	movi	r6,1
   2377c:	014203c4 	movi	r5,2063
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23780:	1080008c 	andi	r2,r2,2
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23784:	d809883a 	mov	r4,sp
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23788:	d8800005 	stb	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   2378c:	00207740 	call	20774 <HW_EscWrite>
   23790:	003fe106 	br	23718 <ECAT_Main+0x12c>

00023794 <PutInMbxQueue>:
{
    UINT16 lastInQueue;
    ENTER_MBX_CRITICAL;


    lastInQueue = pQueue->lastInQueue+1;
   23794:	2880008b 	ldhu	r2,2(r5)
    if (lastInQueue == pQueue->maxQueueSize)
   23798:	29c0010b 	ldhu	r7,4(r5)
    lastInQueue = pQueue->lastInQueue+1;
   2379c:	10c00044 	addi	r3,r2,1
   237a0:	180d883a 	mov	r6,r3
    if (lastInQueue == pQueue->maxQueueSize)
   237a4:	18ffffcc 	andi	r3,r3,65535
   237a8:	38c0011e 	bne	r7,r3,237b0 <PutInMbxQueue+0x1c>
    {
        // Umbruch der Queue
        lastInQueue = 0;
   237ac:	000d883a 	mov	r6,zero
    }

    if (pQueue->firstInQueue == lastInQueue)
   237b0:	29c0000b 	ldhu	r7,0(r5)
   237b4:	30ffffcc 	andi	r3,r6,65535
   237b8:	38c00826 	beq	r7,r3,237dc <PutInMbxQueue+0x48>
        // Ueberlauf der Queue -> letztes Element wieder herausnehmen
        LEAVE_MBX_CRITICAL;
        return MBXERR_NOMOREMEMORY;
    }

    pQueue->queue[pQueue->lastInQueue] = pMbx;
   237bc:	10bfffcc 	andi	r2,r2,65535
   237c0:	10800084 	addi	r2,r2,2
   237c4:	100490ba 	slli	r2,r2,2
   237c8:	2885883a 	add	r2,r5,r2
   237cc:	11000015 	stw	r4,0(r2)
    pQueue->lastInQueue = lastInQueue;
   237d0:	2980008d 	sth	r6,2(r5)

    LEAVE_MBX_CRITICAL;

    return 0;
   237d4:	0005883a 	mov	r2,zero
   237d8:	f800283a 	ret
        return MBXERR_NOMOREMEMORY;
   237dc:	008001c4 	movi	r2,7
}
   237e0:	f800283a 	ret

000237e4 <GetOutOfMbxQueue>:
TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
   237e4:	20c0000b 	ldhu	r3,0(r4)
   237e8:	2140008b 	ldhu	r5,2(r4)
   237ec:	18bfffcc 	andi	r2,r3,65535
   237f0:	11400b26 	beq	r2,r5,23820 <GetOutOfMbxQueue+0x3c>
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
        pMbx = pQueue->queue[firstInQueue];
   237f4:	10800084 	addi	r2,r2,2
   237f8:	100490ba 	slli	r2,r2,2
        firstInQueue++;
        pQueue->firstInQueue = firstInQueue;
        
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   237fc:	2140010b 	ldhu	r5,4(r4)
        firstInQueue++;
   23800:	18c00044 	addi	r3,r3,1
        pMbx = pQueue->queue[firstInQueue];
   23804:	2085883a 	add	r2,r4,r2
   23808:	10800017 	ldw	r2,0(r2)
        pQueue->firstInQueue = firstInQueue;
   2380c:	20c0000d 	sth	r3,0(r4)
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23810:	18ffffcc 	andi	r3,r3,65535
   23814:	28c0031e 	bne	r5,r3,23824 <GetOutOfMbxQueue+0x40>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
   23818:	2000000d 	sth	zero,0(r4)
   2381c:	f800283a 	ret
        }
    }
    else
    {
        pMbx = 0;
   23820:	0005883a 	mov	r2,zero


    LEAVE_MBX_CRITICAL;

    return pMbx;
}
   23824:	f800283a 	ret

00023828 <MBX_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
   23828:	00800904 	movi	r2,36
   2382c:	d0a6840d 	sth	r2,-26096(gp)
    u16SendMbxSize = MAX_MBX_SIZE;
   23830:	00802004 	movi	r2,128
   23834:	d0a6848d 	sth	r2,-26094(gp)
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
   23838:	00840004 	movi	r2,4096
   2383c:	d0a6838d 	sth	r2,-26098(gp)
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
   23840:	d0a6830d 	sth	r2,-26100(gp)

    sMbxReceiveQueue.firstInQueue    = 0;
   23844:	008000f4 	movhi	r2,3
   23848:	1032d015 	stw	zero,-13504(r2)
    sMbxReceiveQueue.lastInQueue     = 0;
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   2384c:	00c000f4 	movhi	r3,3
   23850:	00800284 	movi	r2,10
{
   23854:	defffe04 	addi	sp,sp,-8
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   23858:	18b2d10d 	sth	r2,-13500(r3)
    sMbxSendQueue.firstInQueue        = 0;
   2385c:	00c000f4 	movhi	r3,3

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23860:	d90000c4 	addi	r4,sp,3
    sMbxSendQueue.firstInQueue        = 0;
   23864:	1832dd15 	stw	zero,-13452(r3)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23868:	01800044 	movi	r6,1
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   2386c:	00c000f4 	movhi	r3,3
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23870:	014203c4 	movi	r5,2063
{
   23874:	dfc00115 	stw	ra,4(sp)
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   23878:	18b2de0d 	sth	r2,-13448(r3)
        UINT8 sm1Activate = 0;
   2387c:	d80000c5 	stb	zero,3(sp)
    psWriteMbx  = NULL;
   23880:	d0268115 	stw	zero,-26108(gp)
    psRepeatMbx = NULL;
   23884:	d0267f15 	stw	zero,-26116(gp)
    psReadMbx    = NULL;
   23888:	d0268015 	stw	zero,-26112(gp)
    psStoreMbx    = NULL;
   2388c:	d0267e15 	stw	zero,-26120(gp)
    bMbxRepeatToggle    = FALSE;
   23890:	d0268505 	stb	zero,-26092(gp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23894:	00206f00 	call	206f0 <HW_EscRead>
        sm1Activate &= ~0x02;
   23898:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   2389c:	01800044 	movi	r6,1
   238a0:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   238a4:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238a8:	d90000c4 	addi	r4,sp,3
        sm1Activate &= ~0x02;
   238ac:	d88000c5 	stb	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238b0:	00207740 	call	20774 <HW_EscWrite>
    }
    bMbxRunning = FALSE;
   238b4:	d0268545 	stb	zero,-26091(gp)
    bSendMbxIsFull = FALSE;
   238b8:	d0268585 	stb	zero,-26090(gp)
    bReceiveMbxIsLocked = FALSE;
   238bc:	d02685c5 	stb	zero,-26089(gp)
    u8MailboxSendReqStored    = 0;
   238c0:	d0268205 	stb	zero,-26104(gp)
    u8MbxWriteCounter = 0;
   238c4:	d0268285 	stb	zero,-26102(gp)
    u8MbxReadCounter    = 0;
   238c8:	d0268245 	stb	zero,-26103(gp)
}
   238cc:	dfc00117 	ldw	ra,4(sp)
   238d0:	dec00204 	addi	sp,sp,8
   238d4:	f800283a 	ret

000238d8 <MBX_StartMailboxHandler>:
 \brief     it is checked if the mailbox areas overlaps each other
 \brief     and the Sync Manager channels 0 and 1 are enabled.
 \brief     This function shall only be called if mailbox is supported.
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 MBX_StartMailboxHandler(void)
{
   238d8:	defffe04 	addi	sp,sp,-8
    UINT16 result = 0;
    
    /* get address of the receive mailbox sync manager (SM0) */
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   238dc:	0009883a 	mov	r4,zero
{
   238e0:	dfc00115 	stw	ra,4(sp)
   238e4:	dc000015 	stw	r16,0(sp)
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   238e8:	00219f00 	call	219f0 <GetSyncMan>

    /* store size of the receive mailbox */
    u16ReceiveMbxSize     = pSyncMan->Length;
   238ec:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the receive mailbox */
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   238f0:	1080000b 	ldhu	r2,0(r2)

    /* get address of the send mailbox sync manager (SM1) */
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   238f4:	01000044 	movi	r4,1
    u16ReceiveMbxSize     = pSyncMan->Length;
   238f8:	d0e6840d 	sth	r3,-26096(gp)
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   238fc:	d0a6838d 	sth	r2,-26098(gp)
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23900:	00219f00 	call	219f0 <GetSyncMan>

    /* store the size of the send mailbox */
    u16SendMbxSize = pSyncMan->Length;
   23904:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the send mailbox */
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;

    // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23908:	d166838b 	ldhu	r5,-26098(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   2390c:	1080000b 	ldhu	r2,0(r2)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23910:	d126840b 	ldhu	r4,-26096(gp)
    u16SendMbxSize = pSyncMan->Length;
   23914:	d0e6848d 	sth	r3,-26094(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23918:	d0a6830d 	sth	r2,-26100(gp)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   2391c:	2149883a 	add	r4,r4,r5
   23920:	10bfffcc 	andi	r2,r2,65535
   23924:	1100030e 	bge	r2,r4,23934 <MBX_StartMailboxHandler+0x5c>
   23928:	18ffffcc 	andi	r3,r3,65535
   2392c:	1887883a 	add	r3,r3,r2
   23930:	28c01c16 	blt	r5,r3,239a4 <MBX_StartMailboxHandler+0xcc>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
    }


    /* enable the receive mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_WRITE);
   23934:	0009883a 	mov	r4,zero
   23938:	0021a800 	call	21a80 <EnableSyncManChannel>
    /* enable the send mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_READ);
   2393c:	01000044 	movi	r4,1
   23940:	0021a800 	call	21a80 <EnableSyncManChannel>

        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   23944:	d126840b 	ldhu	r4,-26096(gp)
   23948:	0026b7c0 	call	26b7c <malloc>
   2394c:	d0a68115 	stw	r2,-26108(gp)
   23950:	1009883a 	mov	r4,r2
        if(psWriteMbx == NULL)
   23954:	10000e1e 	bne	r2,zero,23990 <MBX_StartMailboxHandler+0xb8>
        {
            bNoMbxMemoryAvailable = TRUE;
   23958:	00800044 	movi	r2,1

            //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   2395c:	01000284 	movi	r4,10
            bNoMbxMemoryAvailable = TRUE;
   23960:	d0a67d05 	stb	r2,-26124(gp)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23964:	0026b7c0 	call	26b7c <malloc>
            if(psWriteMbx == NULL)
   23968:	1021003a 	cmpeq	r16,r2,zero
   2396c:	8020907a 	slli	r16,r16,1
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23970:	1009883a 	mov	r4,r2
            {
                result = ALSTATUSCODE_NOMEMORY;
            }

            APPL_FreeMailboxBuffer(psWriteMbx);
   23974:	0026b8c0 	call	26b8c <free>
            psWriteMbx = NULL;
   23978:	d0268115 	stw	zero,-26108(gp)
            APPL_FreeMailboxBuffer(psWriteMbx);
            psWriteMbx = NULL;
        }

    return result;
}
   2397c:	8005883a 	mov	r2,r16
   23980:	dfc00117 	ldw	ra,4(sp)
   23984:	dc000017 	ldw	r16,0(sp)
   23988:	dec00204 	addi	sp,sp,8
   2398c:	f800283a 	ret
            bNoMbxMemoryAvailable = FALSE;
   23990:	d0267d05 	stb	zero,-26124(gp)
    UINT16 result = 0;
   23994:	0021883a 	mov	r16,zero
            APPL_FreeMailboxBuffer(psWriteMbx);
   23998:	0026b8c0 	call	26b8c <free>
            psWriteMbx = NULL;
   2399c:	d0268115 	stw	zero,-26108(gp)
   239a0:	003ff606 	br	2397c <MBX_StartMailboxHandler+0xa4>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
   239a4:	04000584 	movi	r16,22
   239a8:	003ff406 	br	2397c <MBX_StartMailboxHandler+0xa4>

000239ac <MBX_StopMailboxHandler>:
 \brief  local management service Stop Mailbox Handler
 \brief  the Sync Manager channels 0 and 1 are disabled
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_StopMailboxHandler(void)
{
   239ac:	defffd04 	addi	sp,sp,-12
    TMBX MBXMEM * pMbx;

    /* mailbox handler is stopped */
    bMbxRunning = FALSE;
    /* disable the receive mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_WRITE);
   239b0:	0009883a 	mov	r4,zero
{
   239b4:	dfc00215 	stw	ra,8(sp)
   239b8:	dc000115 	stw	r16,4(sp)
    bMbxRunning = FALSE;
   239bc:	d0268545 	stb	zero,-26091(gp)
    DisableSyncManChannel(MAILBOX_WRITE);
   239c0:	0021a200 	call	21a20 <DisableSyncManChannel>
    /* disable the send mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_READ);
   239c4:	01000044 	movi	r4,1
   239c8:	0021a200 	call	21a20 <DisableSyncManChannel>
    /* initialize variables again */


    if (psRepeatMbx != NULL)
   239cc:	d1267f17 	ldw	r4,-26116(gp)
   239d0:	20000126 	beq	r4,zero,239d8 <MBX_StopMailboxHandler+0x2c>
    {
        APPL_FreeMailboxBuffer(psRepeatMbx);
   239d4:	0026b8c0 	call	26b8c <free>
    }

    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
   239d8:	d1267e17 	ldw	r4,-26120(gp)
   239dc:	20000326 	beq	r4,zero,239ec <MBX_StopMailboxHandler+0x40>
   239e0:	d0a67f17 	ldw	r2,-26116(gp)
   239e4:	20800126 	beq	r4,r2,239ec <MBX_StopMailboxHandler+0x40>
    {
        APPL_FreeMailboxBuffer(psStoreMbx);
   239e8:	0026b8c0 	call	26b8c <free>
    }

    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
   239ec:	d1268017 	ldw	r4,-26112(gp)
   239f0:	20000526 	beq	r4,zero,23a08 <MBX_StopMailboxHandler+0x5c>
   239f4:	d0a67f17 	ldw	r2,-26116(gp)
   239f8:	20800326 	beq	r4,r2,23a08 <MBX_StopMailboxHandler+0x5c>
   239fc:	d0a67e17 	ldw	r2,-26120(gp)
   23a00:	20800126 	beq	r4,r2,23a08 <MBX_StopMailboxHandler+0x5c>
    {
        APPL_FreeMailboxBuffer(psReadMbx);
   23a04:	0026b8c0 	call	26b8c <free>
    }


    SDOS_ClearPendingResponse();
   23a08:	00261a00 	call	261a0 <SDOS_ClearPendingResponse>

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a0c:	01800044 	movi	r6,1
   23a10:	014203c4 	movi	r5,2063
   23a14:	d90000c4 	addi	r4,sp,3
    psWriteMbx = NULL;
   23a18:	d0268115 	stw	zero,-26108(gp)
    psRepeatMbx = NULL;
   23a1c:	d0267f15 	stw	zero,-26116(gp)
    psReadMbx = NULL;
   23a20:	d0268015 	stw	zero,-26112(gp)
    psStoreMbx = NULL;
   23a24:	d0267e15 	stw	zero,-26120(gp)
    bMbxRepeatToggle    = FALSE;
   23a28:	d0268505 	stb	zero,-26092(gp)
        UINT8 sm1Activate = 0;
   23a2c:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a30:	00206f00 	call	206f0 <HW_EscRead>
        sm1Activate &= ~0x02;
   23a34:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a38:	01800044 	movi	r6,1
   23a3c:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23a40:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a44:	d90000c4 	addi	r4,sp,3
    u8MbxWriteCounter         = 0;
    u8MbxReadCounter        = 0;

    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23a48:	040000f4 	movhi	r16,3
        sm1Activate &= ~0x02;
   23a4c:	d88000c5 	stb	r2,3(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23a50:	8432d004 	addi	r16,r16,-13504
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a54:	00207740 	call	20774 <HW_EscWrite>
    bSendMbxIsFull         = FALSE;
   23a58:	d0268585 	stb	zero,-26090(gp)
    bReceiveMbxIsLocked = FALSE;
   23a5c:	d02685c5 	stb	zero,-26089(gp)
    u8MailboxSendReqStored    = 0;
   23a60:	d0268205 	stb	zero,-26104(gp)
    u8MbxWriteCounter         = 0;
   23a64:	d0268285 	stb	zero,-26102(gp)
    u8MbxReadCounter        = 0;
   23a68:	d0268245 	stb	zero,-26103(gp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23a6c:	8009883a 	mov	r4,r16
   23a70:	00237e40 	call	237e4 <GetOutOfMbxQueue>
   23a74:	1009883a 	mov	r4,r2
        if (pMbx)
   23a78:	1000081e 	bne	r2,zero,23a9c <MBX_StopMailboxHandler+0xf0>
        }
    } while (pMbx != NULL);
    
    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23a7c:	040000f4 	movhi	r16,3
   23a80:	8432dd04 	addi	r16,r16,-13452
   23a84:	8009883a 	mov	r4,r16
   23a88:	00237e40 	call	237e4 <GetOutOfMbxQueue>
   23a8c:	1009883a 	mov	r4,r2
        if (pMbx)
   23a90:	10000426 	beq	r2,zero,23aa4 <MBX_StopMailboxHandler+0xf8>
        {
            APPL_FreeMailboxBuffer(pMbx);
   23a94:	0026b8c0 	call	26b8c <free>
        }
    } while (pMbx != NULL);
   23a98:	003ffa06 	br	23a84 <MBX_StopMailboxHandler+0xd8>
            APPL_FreeMailboxBuffer(pMbx);
   23a9c:	0026b8c0 	call	26b8c <free>
    } while (pMbx != NULL);
   23aa0:	003ff206 	br	23a6c <MBX_StopMailboxHandler+0xc0>

}
   23aa4:	dfc00217 	ldw	ra,8(sp)
   23aa8:	dc000117 	ldw	r16,4(sp)
   23aac:	dec00304 	addi	sp,sp,12
   23ab0:	f800283a 	ret

00023ab4 <MailboxServiceInd>:
UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
{
    UINT8 result;


    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
   23ab4:	2080010b 	ldhu	r2,4(r4)
   23ab8:	1005d23a 	srai	r2,r2,8
   23abc:	108003cc 	andi	r2,r2,15
   23ac0:	108000d8 	cmpnei	r2,r2,3
   23ac4:	1000011e 	bne	r2,zero,23acc <MailboxServiceInd+0x18>
    {
    case MBX_TYPE_COE:
        /* CoE datagram received */
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
   23ac8:	00218701 	jmpi	21870 <COE_ServiceInd>
        result = MBXERR_UNSUPPORTEDPROTOCOL;
        break;
    }

    return result;
}
   23acc:	00800084 	movi	r2,2
   23ad0:	f800283a 	ret

00023ad4 <MBX_CopyToSendMailbox>:
 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23ad4:	d0a66fc3 	ldbu	r2,-26177(gp)
{
   23ad8:	defff804 	addi	sp,sp,-32
   23adc:	dfc00715 	stw	ra,28(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23ae0:	108003cc 	andi	r2,r2,15
{
   23ae4:	dd400615 	stw	r21,24(sp)
   23ae8:	dd000515 	stw	r20,20(sp)
   23aec:	dcc00415 	stw	r19,16(sp)
   23af0:	dc800315 	stw	r18,12(sp)
   23af4:	dc400215 	stw	r17,8(sp)
   23af8:	dc000115 	stw	r16,4(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23afc:	10800060 	cmpeqi	r2,r2,1
   23b00:	1000431e 	bne	r2,zero,23c10 <MBX_CopyToSendMailbox+0x13c>
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }


    if ( !bMbxRunning )
   23b04:	d0a68543 	ldbu	r2,-26091(gp)
   23b08:	10004126 	beq	r2,zero,23c10 <MBX_CopyToSendMailbox+0x13c>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }

    if ( bSendMbxIsFull )
   23b0c:	d4e68583 	ldbu	r19,-26090(gp)
   23b10:	98803fcc 	andi	r2,r19,255
   23b14:	1000401e 	bne	r2,zero,23c18 <MBX_CopyToSendMailbox+0x144>
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
/*ECATCHANGE_START(V5.13) MBX2*/
        /*Reset the not used mailbox memory*/
        {
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b18:	d426830b 	ldhu	r16,-26100(gp)
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   23b1c:	d526848b 	ldhu	r20,-26094(gp)
        UINT16 mbxSize = pMbx->MbxHeader.Length;
   23b20:	2440000b 	ldhu	r17,0(r4)
   23b24:	2025883a 	mov	r18,r4
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   23b28:	a429883a 	add	r20,r20,r16
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b2c:	84000184 	addi	r16,r16,6
            LastAddrToReset = LastAddrToReset - 1;
   23b30:	a53fffc4 	addi	r20,r20,-1
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b34:	8461883a 	add	r16,r16,r17
            u8dummy = 0;
   23b38:	d0266cc5 	stb	zero,-26189(gp)

            /*clear all unused bytes*/
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   23b3c:	843fffcc 	andi	r16,r16,65535
   23b40:	a53fffcc 	andi	r20,r20,65535
            {
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   23b44:	d5666cc4 	addi	r21,gp,-26189
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   23b48:	80bfffcc 	andi	r2,r16,65535
   23b4c:	15002a36 	bltu	r2,r20,23bf8 <MBX_CopyToSendMailbox+0x124>
                LastUsedAddr = LastUsedAddr + 1;
            }
        }
/*ECATCHANGE_END(V5.13) MBX2*/

        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
   23b50:	d166830b 	ldhu	r5,-26100(gp)
   23b54:	89800184 	addi	r6,r17,6
   23b58:	31bfffcc 	andi	r6,r6,65535
   23b5c:	9009883a 	mov	r4,r18
   23b60:	00207740 	call	20774 <HW_EscWrite>


        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT8 smstate = 0x00;
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23b64:	01800044 	movi	r6,1
   23b68:	01420344 	movi	r5,2061
   23b6c:	d90000c4 	addi	r4,sp,3
        VARVOLATILE UINT8 smstate = 0x00;
   23b70:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23b74:	00206f00 	call	206f0 <HW_EscRead>

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
   23b78:	d88000c3 	ldbu	r2,3(sp)
   23b7c:	1080020c 	andi	r2,r2,8
   23b80:	10000d1e 	bne	r2,zero,23bb8 <MBX_CopyToSendMailbox+0xe4>
        {
            UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
   23b84:	d0a6848b 	ldhu	r2,-26094(gp)
   23b88:	1463c83a 	sub	r17,r2,r17

            /*in case of a slow ESC the buffer status may not indicate 'full' even if the complete buffer was written, trigger an additional write access only if not the complete buffer was written*/
            if (BytesLeft > 0)
   23b8c:	8c7fffcc 	andi	r17,r17,65535
   23b90:	8c4001a0 	cmpeqi	r17,r17,6
   23b94:	8800081e 	bne	r17,zero,23bb8 <MBX_CopyToSendMailbox+0xe4>
            {
                /*Write last Byte to trigger mailbox full flag*/
            u8dummy = 0;
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   23b98:	d166830b 	ldhu	r5,-26100(gp)
   23b9c:	01800044 	movi	r6,1
   23ba0:	d1266cc4 	addi	r4,gp,-26189
   23ba4:	288b883a 	add	r5,r5,r2
   23ba8:	297fffc4 	addi	r5,r5,-1
   23bac:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   23bb0:	d0266cc5 	stb	zero,-26189(gp)
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   23bb4:	00207740 	call	20774 <HW_EscWrite>
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
   23bb8:	d0a68017 	ldw	r2,-26112(gp)
   23bbc:	10000126 	beq	r2,zero,23bc4 <MBX_CopyToSendMailbox+0xf0>
        {
            psWriteMbx = NULL;
   23bc0:	d0268115 	stw	zero,-26108(gp)
        }
        psReadMbx = pMbx;

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
   23bc4:	00800044 	movi	r2,1
        psReadMbx = pMbx;
   23bc8:	d4a68015 	stw	r18,-26112(gp)
        bSendMbxIsFull = TRUE;
   23bcc:	d0a68585 	stb	r2,-26090(gp)


        return 0;
    }
}
   23bd0:	9805883a 	mov	r2,r19
   23bd4:	dfc00717 	ldw	ra,28(sp)
   23bd8:	dd400617 	ldw	r21,24(sp)
   23bdc:	dd000517 	ldw	r20,20(sp)
   23be0:	dcc00417 	ldw	r19,16(sp)
   23be4:	dc800317 	ldw	r18,12(sp)
   23be8:	dc400217 	ldw	r17,8(sp)
   23bec:	dc000117 	ldw	r16,4(sp)
   23bf0:	dec00804 	addi	sp,sp,32
   23bf4:	f800283a 	ret
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   23bf8:	800b883a 	mov	r5,r16
   23bfc:	01800044 	movi	r6,1
   23c00:	a809883a 	mov	r4,r21
   23c04:	00207740 	call	20774 <HW_EscWrite>
                LastUsedAddr = LastUsedAddr + 1;
   23c08:	84000044 	addi	r16,r16,1
   23c0c:	003fce06 	br	23b48 <MBX_CopyToSendMailbox+0x74>
        return( ERROR_INVALIDSTATE );
   23c10:	04fffc04 	movi	r19,-16
   23c14:	003fee06 	br	23bd0 <MBX_CopyToSendMailbox+0xfc>
        return MBXERR_NOMOREMEMORY;
   23c18:	04c001c4 	movi	r19,7
   23c1c:	003fec06 	br	23bd0 <MBX_CopyToSendMailbox+0xfc>

00023c20 <MBX_MailboxReadInd>:
    if (psRepeatMbx && psStoreMbx == NULL)
   23c20:	d1267f17 	ldw	r4,-26116(gp)
{
   23c24:	deffff04 	addi	sp,sp,-4
   23c28:	dfc00015 	stw	ra,0(sp)
    bSendMbxIsFull = FALSE;
   23c2c:	d0268585 	stb	zero,-26090(gp)
    if (psRepeatMbx && psStoreMbx == NULL)
   23c30:	20000526 	beq	r4,zero,23c48 <MBX_MailboxReadInd+0x28>
   23c34:	d0a67e17 	ldw	r2,-26120(gp)
   23c38:	1000031e 	bne	r2,zero,23c48 <MBX_MailboxReadInd+0x28>
        if (psReadMbx != psRepeatMbx)
   23c3c:	d0a68017 	ldw	r2,-26112(gp)
   23c40:	20800126 	beq	r4,r2,23c48 <MBX_MailboxReadInd+0x28>
            APPL_FreeMailboxBuffer(psRepeatMbx);
   23c44:	0026b8c0 	call	26b8c <free>
    psRepeatMbx = psReadMbx;
   23c48:	d0a68017 	ldw	r2,-26112(gp)
      if ( psStoreMbx )
   23c4c:	d1267e17 	ldw	r4,-26120(gp)
    psRepeatMbx = psReadMbx;
   23c50:	d0a67f15 	stw	r2,-26116(gp)
      if ( psStoreMbx )
   23c54:	20001326 	beq	r4,zero,23ca4 <MBX_MailboxReadInd+0x84>
        MBX_CopyToSendMailbox(psStoreMbx);
   23c58:	0023ad40 	call	23ad4 <MBX_CopyToSendMailbox>
        psStoreMbx = NULL;
   23c5c:	d0267e15 	stw	zero,-26120(gp)
      if ( u8MailboxSendReqStored )
   23c60:	d0a68203 	ldbu	r2,-26104(gp)
   23c64:	10c03fcc 	andi	r3,r2,255
   23c68:	18000b26 	beq	r3,zero,23c98 <MBX_MailboxReadInd+0x78>
        if ( u8MailboxSendReqStored & COE_SERVICE )
   23c6c:	10c0008c 	andi	r3,r2,2
   23c70:	18000926 	beq	r3,zero,23c98 <MBX_MailboxReadInd+0x78>
            result = COE_ContinueInd(psWriteMbx);
   23c74:	d1268117 	ldw	r4,-26108(gp)
            u8MailboxSendReqStored &= ~COE_SERVICE;
   23c78:	10803f4c 	andi	r2,r2,253
   23c7c:	d0a68205 	stb	r2,-26104(gp)
            result = COE_ContinueInd(psWriteMbx);
   23c80:	00218b80 	call	218b8 <COE_ContinueInd>
            if (result != 0)
   23c84:	10803fcc 	andi	r2,r2,255
   23c88:	10000326 	beq	r2,zero,23c98 <MBX_MailboxReadInd+0x78>
                u8MailboxSendReqStored |= COE_SERVICE;
   23c8c:	d0a68203 	ldbu	r2,-26104(gp)
   23c90:	10800094 	ori	r2,r2,2
   23c94:	d0a68205 	stb	r2,-26104(gp)
}
   23c98:	dfc00017 	ldw	ra,0(sp)
   23c9c:	dec00104 	addi	sp,sp,4
   23ca0:	f800283a 	ret
        TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23ca4:	010000f4 	movhi	r4,3
   23ca8:	2132dd04 	addi	r4,r4,-13452
   23cac:	00237e40 	call	237e4 <GetOutOfMbxQueue>
   23cb0:	1009883a 	mov	r4,r2
        if (pMbx)
   23cb4:	103fea26 	beq	r2,zero,23c60 <MBX_MailboxReadInd+0x40>
            MBX_CopyToSendMailbox(pMbx);
   23cb8:	0023ad40 	call	23ad4 <MBX_CopyToSendMailbox>
   23cbc:	003fe806 	br	23c60 <MBX_MailboxReadInd+0x40>

00023cc0 <MBX_MailboxRepeatReq>:
{
   23cc0:	defffe04 	addi	sp,sp,-8
   23cc4:	dc000015 	stw	r16,0(sp)
    if (psRepeatMbx)
   23cc8:	d4267f17 	ldw	r16,-26116(gp)
{
   23ccc:	dfc00115 	stw	ra,4(sp)
    if (psRepeatMbx)
   23cd0:	80000e26 	beq	r16,zero,23d0c <MBX_MailboxRepeatReq+0x4c>
       if (bSendMbxIsFull && psStoreMbx == NULL)
   23cd4:	d0a68583 	ldbu	r2,-26090(gp)
   23cd8:	10000926 	beq	r2,zero,23d00 <MBX_MailboxRepeatReq+0x40>
   23cdc:	d0a67e17 	ldw	r2,-26120(gp)
   23ce0:	1000071e 	bne	r2,zero,23d00 <MBX_MailboxRepeatReq+0x40>
            DisableSyncManChannel(MAILBOX_READ);
   23ce4:	01000044 	movi	r4,1
   23ce8:	0021a200 	call	21a20 <DisableSyncManChannel>
            psStoreMbx = psReadMbx;
   23cec:	d0a68017 	ldw	r2,-26112(gp)
            EnableSyncManChannel(MAILBOX_READ);
   23cf0:	01000044 	movi	r4,1
            psStoreMbx = psReadMbx;
   23cf4:	d0a67e15 	stw	r2,-26120(gp)
            EnableSyncManChannel(MAILBOX_READ);
   23cf8:	0021a800 	call	21a80 <EnableSyncManChannel>
            bSendMbxIsFull = FALSE;
   23cfc:	d0268585 	stb	zero,-26090(gp)
        MBX_CopyToSendMailbox(pMbx);
   23d00:	8009883a 	mov	r4,r16
   23d04:	0023ad40 	call	23ad4 <MBX_CopyToSendMailbox>
        psRepeatMbx = NULL;
   23d08:	d0267f15 	stw	zero,-26116(gp)
    bMbxRepeatToggle = !bMbxRepeatToggle;
   23d0c:	d0a68503 	ldbu	r2,-26092(gp)
   23d10:	1005003a 	cmpeq	r2,r2,zero
   23d14:	d0a68505 	stb	r2,-26092(gp)
}
   23d18:	dfc00117 	ldw	ra,4(sp)
   23d1c:	dc000017 	ldw	r16,0(sp)
   23d20:	dec00204 	addi	sp,sp,8
   23d24:	f800283a 	ret

00023d28 <MBX_MailboxSendReq>:
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
   23d28:	d0a66fc3 	ldbu	r2,-26177(gp)
   23d2c:	108003cc 	andi	r2,r2,15
   23d30:	10800060 	cmpeqi	r2,r2,1
   23d34:	1000321e 	bne	r2,zero,23e00 <MBX_MailboxSendReq+0xd8>
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23d38:	d0e68243 	ldbu	r3,-26103(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   23d3c:	2080010b 	ldhu	r2,4(r4)
{
   23d40:	defffc04 	addi	sp,sp,-16
   23d44:	dc800215 	stw	r18,8(sp)
   23d48:	dc400115 	stw	r17,4(sp)
   23d4c:	dc000015 	stw	r16,0(sp)
   23d50:	dfc00315 	stw	ra,12(sp)
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23d54:	18c001cc 	andi	r3,r3,7
   23d58:	2025883a 	mov	r18,r4
   23d5c:	2823883a 	mov	r17,r5
   23d60:	2821883a 	mov	r16,r5
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   23d64:	1083ffcc 	andi	r2,r2,4095
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23d68:	1800021e 	bne	r3,zero,23d74 <MBX_MailboxSendReq+0x4c>
        u8MbxReadCounter = 1;
   23d6c:	00c00044 	movi	r3,1
   23d70:	d0e68245 	stb	r3,-26103(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   23d74:	d0e68243 	ldbu	r3,-26103(gp)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   23d78:	9009883a 	mov	r4,r18
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   23d7c:	1806933a 	slli	r3,r3,12
   23d80:	10c4b03a 	or	r2,r2,r3
   23d84:	9080010d 	sth	r2,4(r18)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   23d88:	0023ad40 	call	23ad4 <MBX_CopyToSendMailbox>
   23d8c:	10803fcc 	andi	r2,r2,255
   23d90:	10000d26 	beq	r2,zero,23dc8 <MBX_MailboxSendReq+0xa0>
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
   23d94:	014000f4 	movhi	r5,3
   23d98:	2972dd04 	addi	r5,r5,-13452
   23d9c:	9009883a 	mov	r4,r18
   23da0:	00237940 	call	23794 <PutInMbxQueue>
        if (result != 0)
   23da4:	10c03fcc 	andi	r3,r2,255
   23da8:	18000726 	beq	r3,zero,23dc8 <MBX_MailboxSendReq+0xa0>
            flags |= FRAGMENTS_FOLLOW;
   23dac:	043fe004 	movi	r16,-128
   23db0:	8c20b03a 	or	r16,r17,r16
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
   23db4:	d0e68203 	ldbu	r3,-26104(gp)
   23db8:	84001fcc 	andi	r16,r16,127
   23dbc:	80e0b03a 	or	r16,r16,r3
   23dc0:	d4268205 	stb	r16,-26104(gp)
   23dc4:	00000806 	br	23de8 <MBX_MailboxSendReq+0xc0>
        u8MbxReadCounter++;
   23dc8:	d0a68243 	ldbu	r2,-26103(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   23dcc:	8c403fcc 	andi	r17,r17,255
   23dd0:	8c40201c 	xori	r17,r17,128
        u8MbxReadCounter++;
   23dd4:	10800044 	addi	r2,r2,1
   23dd8:	d0a68245 	stb	r2,-26103(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   23ddc:	8c7fe004 	addi	r17,r17,-128
   23de0:	0005883a 	mov	r2,zero
   23de4:	883ff316 	blt	r17,zero,23db4 <MBX_MailboxSendReq+0x8c>
}
   23de8:	dfc00317 	ldw	ra,12(sp)
   23dec:	dc800217 	ldw	r18,8(sp)
   23df0:	dc400117 	ldw	r17,4(sp)
   23df4:	dc000017 	ldw	r16,0(sp)
   23df8:	dec00404 	addi	sp,sp,16
   23dfc:	f800283a 	ret
        return ERROR_INVALIDSTATE;
   23e00:	00bffc04 	movi	r2,-16
}
   23e04:	f800283a 	ret

00023e08 <MBX_MailboxWriteInd>:
    if(MbxLen > MAX_MBX_SIZE)
   23e08:	2080000b 	ldhu	r2,0(r4)
{
   23e0c:	defffd04 	addi	sp,sp,-12
   23e10:	dc400115 	stw	r17,4(sp)
   23e14:	dc000015 	stw	r16,0(sp)
   23e18:	dfc00215 	stw	ra,8(sp)
    if(MbxLen > MAX_MBX_SIZE)
   23e1c:	10802070 	cmpltui	r2,r2,129
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   23e20:	2440010b 	ldhu	r17,4(r4)
{
   23e24:	2021883a 	mov	r16,r4
    if(MbxLen > MAX_MBX_SIZE)
   23e28:	10000e1e 	bne	r2,zero,23e64 <MBX_MailboxWriteInd+0x5c>
        pMbx->MbxHeader.Length     = 4;
   23e2c:	00800104 	movi	r2,4
   23e30:	2080000d 	sth	r2,0(r4)
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23e34:	00800044 	movi	r2,1
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23e38:	8c7c3fcc 	andi	r17,r17,61695
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23e3c:	2080018d 	sth	r2,6(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   23e40:	00800204 	movi	r2,8
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23e44:	2440010d 	sth	r17,4(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   23e48:	2080020d 	sth	r2,8(r4)
        MBX_MailboxSendReq(pMbx, 0);
   23e4c:	000b883a 	mov	r5,zero
}
   23e50:	dfc00217 	ldw	ra,8(sp)
   23e54:	dc400117 	ldw	r17,4(sp)
   23e58:	dc000017 	ldw	r16,0(sp)
   23e5c:	dec00304 	addi	sp,sp,12
            MBX_MailboxSendReq(pMbx, 0);
   23e60:	0023d281 	jmpi	23d28 <MBX_MailboxSendReq>
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   23e64:	88bfffcc 	andi	r2,r17,65535
   23e68:	1006d33a 	srli	r3,r2,12
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
   23e6c:	18000226 	beq	r3,zero,23e78 <MBX_MailboxWriteInd+0x70>
   23e70:	d0a68283 	ldbu	r2,-26102(gp)
   23e74:	10c01226 	beq	r2,r3,23ec0 <MBX_MailboxWriteInd+0xb8>
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   23e78:	014000f4 	movhi	r5,3
   23e7c:	2972d004 	addi	r5,r5,-13504
   23e80:	8009883a 	mov	r4,r16
        u8MbxWriteCounter = mbxCounter;
   23e84:	d0e68285 	stb	r3,-26102(gp)
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   23e88:	00237940 	call	23794 <PutInMbxQueue>
        if ( result != 0 )
   23e8c:	10c03fcc 	andi	r3,r2,255
   23e90:	18001026 	beq	r3,zero,23ed4 <MBX_MailboxWriteInd+0xcc>
            pMbx->MbxHeader.Length     = 4;
   23e94:	00c00104 	movi	r3,4
   23e98:	80c0000d 	sth	r3,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23e9c:	8c7c3fcc 	andi	r17,r17,61695
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23ea0:	00c00044 	movi	r3,1
            pMbx->Data[1]                        = SWAPWORD(result);
   23ea4:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23ea8:	8440010d 	sth	r17,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23eac:	80c0018d 	sth	r3,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   23eb0:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   23eb4:	000b883a 	mov	r5,zero
   23eb8:	8009883a 	mov	r4,r16
   23ebc:	003fe406 	br	23e50 <MBX_MailboxWriteInd+0x48>
}
   23ec0:	dfc00217 	ldw	ra,8(sp)
   23ec4:	dc400117 	ldw	r17,4(sp)
   23ec8:	dc000017 	ldw	r16,0(sp)
   23ecc:	dec00304 	addi	sp,sp,12
        APPL_FreeMailboxBuffer(pMbx);
   23ed0:	0026b8c1 	jmpi	26b8c <free>
}
   23ed4:	dfc00217 	ldw	ra,8(sp)
   23ed8:	dc400117 	ldw	r17,4(sp)
   23edc:	dc000017 	ldw	r16,0(sp)
   23ee0:	dec00304 	addi	sp,sp,12
   23ee4:	f800283a 	ret

00023ee8 <MBX_CheckAndCopyMailbox>:
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23ee8:	d166838b 	ldhu	r5,-26098(gp)
{
   23eec:	defffc04 	addi	sp,sp,-16
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23ef0:	01800084 	movi	r6,2
   23ef4:	d9000084 	addi	r4,sp,2
{
   23ef8:	dc400215 	stw	r17,8(sp)
   23efc:	dfc00315 	stw	ra,12(sp)
   23f00:	dc000115 	stw	r16,4(sp)
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f04:	00206f00 	call	206f0 <HW_EscRead>
    if(bNoMbxMemoryAvailable == TRUE)
   23f08:	d4667d03 	ldbu	r17,-26124(gp)
   23f0c:	88800060 	cmpeqi	r2,r17,1
   23f10:	10001226 	beq	r2,zero,23f5c <MBX_CheckAndCopyMailbox+0x74>
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23f14:	01000284 	movi	r4,10
   23f18:	0026b7c0 	call	26b7c <malloc>
   23f1c:	1021883a 	mov	r16,r2
        if(pMbx != NULL)
   23f20:	10000e26 	beq	r2,zero,23f5c <MBX_CheckAndCopyMailbox+0x74>
            HMEMSET(pMbx,0x00,10);
   23f24:	01800204 	movi	r6,8
   23f28:	000b883a 	mov	r5,zero
   23f2c:	11000084 	addi	r4,r2,2
   23f30:	0026eac0 	call	26eac <memset>
            pMbx->MbxHeader.Length     = 4;
   23f34:	00800104 	movi	r2,4
   23f38:	8080000d 	sth	r2,0(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   23f3c:	008001c4 	movi	r2,7
            MBX_MailboxSendReq(pMbx, 0);
   23f40:	8009883a 	mov	r4,r16
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23f44:	8440018d 	sth	r17,6(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   23f48:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   23f4c:	000b883a 	mov	r5,zero
   23f50:	0023d280 	call	23d28 <MBX_MailboxSendReq>
            APPL_FreeMailboxBuffer(pMbx);
   23f54:	8009883a 	mov	r4,r16
   23f58:	0026b8c0 	call	26b8c <free>
    mbxLen += MBX_HEADER_SIZE;
   23f5c:	d880008b 	ldhu	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   23f60:	d0e68583 	ldbu	r3,-26090(gp)
   23f64:	d1268203 	ldbu	r4,-26104(gp)
    mbxLen += MBX_HEADER_SIZE;
   23f68:	10800184 	addi	r2,r2,6
   23f6c:	d880008d 	sth	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   23f70:	1906b03a 	or	r3,r3,r4
   23f74:	18c03fcc 	andi	r3,r3,255
   23f78:	18000726 	beq	r3,zero,23f98 <MBX_CheckAndCopyMailbox+0xb0>
            bReceiveMbxIsLocked = TRUE;
   23f7c:	00800044 	movi	r2,1
   23f80:	d0a685c5 	stb	r2,-26089(gp)
}
   23f84:	dfc00317 	ldw	ra,12(sp)
   23f88:	dc400217 	ldw	r17,8(sp)
   23f8c:	dc000117 	ldw	r16,4(sp)
   23f90:	dec00404 	addi	sp,sp,16
   23f94:	f800283a 	ret
        if (mbxLen > u16ReceiveMbxSize)
   23f98:	d0e6840b 	ldhu	r3,-26096(gp)
        bReceiveMbxIsLocked = FALSE;
   23f9c:	d02685c5 	stb	zero,-26089(gp)
        if (mbxLen > u16ReceiveMbxSize)
   23fa0:	10bfffcc 	andi	r2,r2,65535
   23fa4:	193fffcc 	andi	r4,r3,65535
   23fa8:	2080012e 	bgeu	r4,r2,23fb0 <MBX_CheckAndCopyMailbox+0xc8>
            mbxLen = u16ReceiveMbxSize;
   23fac:	d8c0008d 	sth	r3,2(sp)
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   23fb0:	0026b7c0 	call	26b7c <malloc>
   23fb4:	d0a68115 	stw	r2,-26108(gp)
   23fb8:	1009883a 	mov	r4,r2
        if (psWriteMbx == NULL)
   23fbc:	103fef26 	beq	r2,zero,23f7c <MBX_CheckAndCopyMailbox+0x94>
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
   23fc0:	d980008b 	ldhu	r6,2(sp)
   23fc4:	d166838b 	ldhu	r5,-26098(gp)
   23fc8:	00206f00 	call	206f0 <HW_EscRead>
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   23fcc:	01800044 	movi	r6,1
   23fd0:	01420144 	movi	r5,2053
   23fd4:	d9000044 	addi	r4,sp,1
        VARVOLATILE UINT8 smstate = 0x00;
   23fd8:	d8000045 	stb	zero,1(sp)
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   23fdc:	00206f00 	call	206f0 <HW_EscRead>
        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
   23fe0:	d8800043 	ldbu	r2,1(sp)
   23fe4:	1080020c 	andi	r2,r2,8
   23fe8:	10000926 	beq	r2,zero,24010 <MBX_CheckAndCopyMailbox+0x128>
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   23fec:	d166838b 	ldhu	r5,-26098(gp)
   23ff0:	d0a6840b 	ldhu	r2,-26096(gp)
   23ff4:	01800044 	movi	r6,1
   23ff8:	d1266cc4 	addi	r4,gp,-26189
   23ffc:	288b883a 	add	r5,r5,r2
   24000:	297fffc4 	addi	r5,r5,-1
   24004:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   24008:	d0266cc5 	stb	zero,-26189(gp)
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   2400c:	00206f00 	call	206f0 <HW_EscRead>
        MBX_MailboxWriteInd( psWriteMbx );
   24010:	d1268117 	ldw	r4,-26108(gp)
   24014:	0023e080 	call	23e08 <MBX_MailboxWriteInd>
   24018:	003fda06 	br	23f84 <MBX_CheckAndCopyMailbox+0x9c>

0002401c <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
   2401c:	defffa04 	addi	sp,sp,-24
   24020:	dc400115 	stw	r17,4(sp)

    do
    {
        UINT8 result = 0;

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24024:	044000f4 	movhi	r17,3
{
   24028:	dd000415 	stw	r20,16(sp)
   2402c:	dcc00315 	stw	r19,12(sp)
   24030:	dc800215 	stw	r18,8(sp)
   24034:	dfc00515 	stw	ra,20(sp)
   24038:	dc000015 	stw	r16,0(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   2403c:	8c72d004 	addi	r17,r17,-13504
        }

        if ( result != 0 )
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
   24040:	05000104 	movi	r20,4
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   24044:	04fc3fc4 	movi	r19,-3841
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24048:	04800044 	movi	r18,1
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   2404c:	8809883a 	mov	r4,r17
   24050:	00237e40 	call	237e4 <GetOutOfMbxQueue>
   24054:	1021883a 	mov	r16,r2
        if ( pMbx )
   24058:	10000a1e 	bne	r2,zero,24084 <MBX_Main+0x68>
        }
    }
    while ( pMbx != NULL );


    if (bReceiveMbxIsLocked)
   2405c:	d0a685c3 	ldbu	r2,-26089(gp)
   24060:	10001726 	beq	r2,zero,240c0 <MBX_Main+0xa4>
    if (u8MailboxSendReqStored)
    {
        /* there are mailbox services stored to be sent */
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   24064:	dfc00517 	ldw	ra,20(sp)
   24068:	dd000417 	ldw	r20,16(sp)
   2406c:	dcc00317 	ldw	r19,12(sp)
   24070:	dc800217 	ldw	r18,8(sp)
   24074:	dc400117 	ldw	r17,4(sp)
   24078:	dc000017 	ldw	r16,0(sp)
   2407c:	dec00604 	addi	sp,sp,24
        MBX_CheckAndCopyMailbox();
   24080:	0023ee81 	jmpi	23ee8 <MBX_CheckAndCopyMailbox>
            result = MailboxServiceInd(pMbx);
   24084:	1009883a 	mov	r4,r2
   24088:	0023ab40 	call	23ab4 <MailboxServiceInd>
        if ( result != 0 )
   2408c:	10c03fcc 	andi	r3,r2,255
   24090:	183fee26 	beq	r3,zero,2404c <MBX_Main+0x30>
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   24094:	80c0010b 	ldhu	r3,4(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   24098:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Length     = 4;
   2409c:	8500000d 	sth	r20,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   240a0:	1cc6703a 	and	r3,r3,r19
   240a4:	80c0010d 	sth	r3,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   240a8:	8480018d 	sth	r18,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   240ac:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   240b0:	000b883a 	mov	r5,zero
   240b4:	8009883a 	mov	r4,r16
   240b8:	0023d280 	call	23d28 <MBX_MailboxSendReq>
   240bc:	003fe306 	br	2404c <MBX_Main+0x30>
}
   240c0:	dfc00517 	ldw	ra,20(sp)
   240c4:	dd000417 	ldw	r20,16(sp)
   240c8:	dcc00317 	ldw	r19,12(sp)
   240cc:	dc800217 	ldw	r18,8(sp)
   240d0:	dc400117 	ldw	r17,4(sp)
   240d4:	dc000017 	ldw	r16,0(sp)
   240d8:	dec00604 	addi	sp,sp,24
   240dc:	f800283a 	ret

000240e0 <OBJ_GetObjectHandle>:
             and returns a handle if found.

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
{
   240e0:	defffe04 	addi	sp,sp,-8
   240e4:	dc000015 	stw	r16,0(sp)
   240e8:	2021883a 	mov	r16,r4
   240ec:	dfc00115 	stw	ra,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();

    while (pObjEntry!= NULL)
    {
        
        if (pObjEntry->Index == index)
   240f0:	843fffcc 	andi	r16,r16,65535
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   240f4:	00209580 	call	20958 <COE_GetObjectDictionary>
    while (pObjEntry!= NULL)
   240f8:	1000041e 	bne	r2,zero,2410c <OBJ_GetObjectHandle+0x2c>
            return pObjEntry;
        }
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
    }
    return 0;
}
   240fc:	dfc00117 	ldw	ra,4(sp)
   24100:	dc000017 	ldw	r16,0(sp)
   24104:	dec00204 	addi	sp,sp,8
   24108:	f800283a 	ret
        if (pObjEntry->Index == index)
   2410c:	10c0020b 	ldhu	r3,8(r2)
   24110:	1c3ffa26 	beq	r3,r16,240fc <OBJ_GetObjectHandle+0x1c>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24114:	10800117 	ldw	r2,4(r2)
   24118:	003ff706 	br	240f8 <OBJ_GetObjectHandle+0x18>

0002411c <OBJ_GetObjectLength>:

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2411c:	30c0030b 	ldhu	r3,12(r6)
{
   24120:	defffe04 	addi	sp,sp,-8
   24124:	dc000015 	stw	r16,0(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24128:	1804d23a 	srli	r2,r3,8
{
   2412c:	dfc00115 	stw	ra,4(sp)
    
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
    UINT32 size = 0;

    if ( bCompleteAccess )
   24130:	39c03fcc 	andi	r7,r7,255
{
   24134:	2821883a 	mov	r16,r5
   24138:	108003cc 	andi	r2,r2,15
    if ( bCompleteAccess )
   2413c:	38002026 	beq	r7,zero,241c0 <OBJ_GetObjectLength+0xa4>
    {
        if ( objCode == OBJCODE_VAR )
   24140:	110001e0 	cmpeqi	r4,r2,7
   24144:	2000361e 	bne	r4,zero,24220 <OBJ_GetObjectLength+0x104>
        {
            return 0;
        }
        else if ((objCode == OBJCODE_ARR)
   24148:	10800218 	cmpnei	r2,r2,8
   2414c:	1000171e 	bne	r2,zero,241ac <OBJ_GetObjectLength+0x90>
            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   24150:	30800417 	ldw	r2,16(r6)
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   24154:	30c00617 	ldw	r3,24(r6)
            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   24158:	1100020b 	ldhu	r4,8(r2)
   2415c:	19400003 	ldbu	r5,0(r3)
   24160:	0026b540 	call	26b54 <__mulsi3>
            for (i = 1; i <= maxSubindex; i++)
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
   24164:	108001c4 	addi	r2,r2,7

            if ( subindex == 0 )
   24168:	81403fcc 	andi	r5,r16,255
            size = BIT2BYTE(size);
   2416c:	1004d0fa 	srli	r2,r2,3
            if ( subindex == 0 )
   24170:	2800011e 	bne	r5,zero,24178 <OBJ_GetObjectLength+0x5c>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
   24174:	10800084 	addi	r2,r2,2
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
                }
            }
        }
    }
}
   24178:	dfc00117 	ldw	ra,4(sp)
   2417c:	dc000017 	ldw	r16,0(sp)
   24180:	dec00204 	addi	sp,sp,8
   24184:	f800283a 	ret
                size += pObjEntry->pEntryDesc[i].BitLength;
   24188:	31c00417 	ldw	r7,16(r6)
            for (i = 1; i <= maxSubindex; i++)
   2418c:	21000044 	addi	r4,r4,1
                size += pObjEntry->pEntryDesc[i].BitLength;
   24190:	394f883a 	add	r7,r7,r5
   24194:	39c0008b 	ldhu	r7,2(r7)
   24198:	29400184 	addi	r5,r5,6
   2419c:	11c5883a 	add	r2,r2,r7
            for (i = 1; i <= maxSubindex; i++)
   241a0:	21ffffcc 	andi	r7,r4,65535
   241a4:	19fff82e 	bgeu	r3,r7,24188 <OBJ_GetObjectLength+0x6c>
   241a8:	003fee06 	br	24164 <OBJ_GetObjectLength+0x48>
   241ac:	01400184 	movi	r5,6
   241b0:	01000044 	movi	r4,1
    UINT32 size = 0;
   241b4:	0005883a 	mov	r2,zero
            for (i = 1; i <= maxSubindex; i++)
   241b8:	18c03fcc 	andi	r3,r3,255
   241bc:	003ff806 	br	241a0 <OBJ_GetObjectLength+0x84>
        if ( objCode == OBJCODE_VAR )
   241c0:	110001d8 	cmpnei	r4,r2,7
   241c4:	2000031e 	bne	r4,zero,241d4 <OBJ_GetObjectLength+0xb8>
            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
   241c8:	30800417 	ldw	r2,16(r6)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   241cc:	1080008b 	ldhu	r2,2(r2)
   241d0:	00000606 	br	241ec <OBJ_GetObjectLength+0xd0>
        else if ( subindex == 0 )
   241d4:	29403fcc 	andi	r5,r5,255
   241d8:	28000f26 	beq	r5,zero,24218 <OBJ_GetObjectLength+0xfc>
        else if((objCode == OBJCODE_ARR)
   241dc:	10800218 	cmpnei	r2,r2,8
   241e0:	1000051e 	bne	r2,zero,241f8 <OBJ_GetObjectLength+0xdc>
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
   241e4:	30800417 	ldw	r2,16(r6)
   241e8:	1080020b 	ldhu	r2,8(r2)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   241ec:	108001c4 	addi	r2,r2,7
   241f0:	1005d0fa 	srai	r2,r2,3
   241f4:	003fe006 	br	24178 <OBJ_GetObjectLength+0x5c>
                if (maxSubindex < subindex)
   241f8:	18c03fcc 	andi	r3,r3,255
   241fc:	19400836 	bltu	r3,r5,24220 <OBJ_GetObjectLength+0x104>
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24200:	2804907a 	slli	r2,r5,1
   24204:	30c00417 	ldw	r3,16(r6)
   24208:	1145883a 	add	r2,r2,r5
   2420c:	1004907a 	slli	r2,r2,1
   24210:	1885883a 	add	r2,r3,r2
   24214:	003fed06 	br	241cc <OBJ_GetObjectLength+0xb0>
            return 1;
   24218:	00800044 	movi	r2,1
   2421c:	003fd606 	br	24178 <OBJ_GetObjectLength+0x5c>
            return 0;
   24220:	0005883a 	mov	r2,zero
   24224:	003fd406 	br	24178 <OBJ_GetObjectLength+0x5c>

00024228 <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
   24228:	defffd04 	addi	sp,sp,-12
   2422c:	dc400115 	stw	r17,4(sp)
    UINT8 Modulo;

    pStr[2] = '0';
    pStr[0] += (Number / 100);
   24230:	2c403fcc 	andi	r17,r5,255
{
   24234:	dc000015 	stw	r16,0(sp)
    pStr[0] += (Number / 100);
   24238:	01401904 	movi	r5,100
{
   2423c:	2021883a 	mov	r16,r4
    pStr[0] += (Number / 100);
   24240:	8809883a 	mov	r4,r17
{
   24244:	dfc00215 	stw	ra,8(sp)
    pStr[0] += (Number / 100);
   24248:	0026a940 	call	26a94 <__udivsi3>
   2424c:	80c00003 	ldbu	r3,0(r16)
    Modulo = Number % 100;
   24250:	8809883a 	mov	r4,r17
   24254:	01401904 	movi	r5,100
    pStr[0] += (Number / 100);
   24258:	10c5883a 	add	r2,r2,r3
   2425c:	80800005 	stb	r2,0(r16)
    Modulo = Number % 100;
   24260:	0026af80 	call	26af8 <__umodsi3>
    pStr[1] += (Modulo / 10);
   24264:	14403fcc 	andi	r17,r2,255
   24268:	8809883a 	mov	r4,r17
   2426c:	01400284 	movi	r5,10
   24270:	0026a940 	call	26a94 <__udivsi3>
   24274:	80c00043 	ldbu	r3,1(r16)
    pStr[2] += (Modulo % 10);
   24278:	01400284 	movi	r5,10
   2427c:	8809883a 	mov	r4,r17
    pStr[1] += (Modulo / 10);
   24280:	10c5883a 	add	r2,r2,r3
   24284:	80800045 	stb	r2,1(r16)
    pStr[2] += (Modulo % 10);
   24288:	0026af80 	call	26af8 <__umodsi3>
   2428c:	10800c04 	addi	r2,r2,48
   24290:	80800085 	stb	r2,2(r16)
}
   24294:	dfc00217 	ldw	ra,8(sp)
   24298:	dc400117 	ldw	r17,4(sp)
   2429c:	dc000017 	ldw	r16,0(sp)
   242a0:	dec00304 	addi	sp,sp,12
   242a4:	f800283a 	ret

000242a8 <OBJ_GetDesc>:
                0xFF                                            <br>
            }
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
{
   242a8:	defff604 	addi	sp,sp,-40
   242ac:	dcc00715 	stw	r19,28(sp)
   242b0:	dc800615 	stw	r18,24(sp)
   242b4:	dc000415 	stw	r16,16(sp)
   242b8:	dfc00915 	stw	ra,36(sp)
   242bc:	dd000815 	stw	r20,32(sp)
   242c0:	dc400515 	stw	r17,20(sp)
/* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;



    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   242c4:	2cc03fcc 	andi	r19,r5,255
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
   242c8:	34000517 	ldw	r16,20(r6)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   242cc:	3080030b 	ldhu	r2,12(r6)
{
   242d0:	3825883a 	mov	r18,r7
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   242d4:	98000426 	beq	r19,zero,242e8 <OBJ_GetDesc+0x40>
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   242d8:	1004d23a 	srli	r2,r2,8
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   242dc:	108003cc 	andi	r2,r2,15
   242e0:	10c001d8 	cmpnei	r3,r2,7
   242e4:	1800091e 	bne	r3,zero,2430c <OBJ_GetDesc+0x64>
    {
        // Get object description length
       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
   242e8:	8009883a 	mov	r4,r16
   242ec:	0026ecc0 	call	26ecc <strlen>
   242f0:	1023883a 	mov	r17,r2

        // If there is a pointer given, copy data:
        if ( pData )
   242f4:	90001a26 	beq	r18,zero,24360 <OBJ_GetDesc+0xb8>
        {
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
   242f8:	11bfffcc 	andi	r6,r2,65535
                if ( i == tmpSubindex )
                {
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
                    if ( pData && strSize )
                    {
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   242fc:	800b883a 	mov	r5,r16
   24300:	9009883a 	mov	r4,r18
   24304:	0026e840 	call	26e84 <memcpy>
            }
            }
            }
        }

        if ( strSize == 0 )
   24308:	00001506 	br	24360 <OBJ_GetDesc+0xb8>
        if ( objCode == OBJCODE_REC )
   2430c:	10800258 	cmpnei	r2,r2,9
   24310:	1000251e 	bne	r2,zero,243a8 <OBJ_GetDesc+0x100>
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24314:	8009883a 	mov	r4,r16
            UINT16 tmpSubindex = subindex;
   24318:	2c403fcc 	andi	r17,r5,255
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   2431c:	0026ecc0 	call	26ecc <strlen>
   24320:	10800044 	addi	r2,r2,1
   24324:	80a1883a 	add	r16,r16,r2
            UINT16 i = 1;
   24328:	05000044 	movi	r20,1
                if ( i == tmpSubindex )
   2432c:	8c7fffcc 	andi	r17,r17,65535
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   24330:	80800003 	ldbu	r2,0(r16)
   24334:	10803fb0 	cmpltui	r2,r2,254
   24338:	10001b26 	beq	r2,zero,243a8 <OBJ_GetDesc+0x100>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   2433c:	8009883a 	mov	r4,r16
   24340:	0026ecc0 	call	26ecc <strlen>
                if ( i == tmpSubindex )
   24344:	a0ffffcc 	andi	r3,r20,65535
   24348:	88c0111e 	bne	r17,r3,24390 <OBJ_GetDesc+0xe8>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   2434c:	1023883a 	mov	r17,r2
                    if ( pData && strSize )
   24350:	10ffffcc 	andi	r3,r2,65535
   24354:	90000b1e 	bne	r18,zero,24384 <OBJ_GetDesc+0xdc>
        if ( strSize == 0 )
   24358:	1800011e 	bne	r3,zero,24360 <OBJ_GetDesc+0xb8>
        {
            // no string found for subindex x -> name is Subindex x
            strSize =    12;
   2435c:	04400304 	movi	r17,12
            }
        }
    }

    return strSize;
}
   24360:	8805883a 	mov	r2,r17
   24364:	dfc00917 	ldw	ra,36(sp)
   24368:	dd000817 	ldw	r20,32(sp)
   2436c:	dcc00717 	ldw	r19,28(sp)
   24370:	dc800617 	ldw	r18,24(sp)
   24374:	dc400517 	ldw	r17,20(sp)
   24378:	dc000417 	ldw	r16,16(sp)
   2437c:	dec00a04 	addi	sp,sp,40
   24380:	f800283a 	ret
                    if ( pData && strSize )
   24384:	18000926 	beq	r3,zero,243ac <OBJ_GetDesc+0x104>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   24388:	11bfffcc 	andi	r6,r2,65535
   2438c:	003fdb06 	br	242fc <OBJ_GetDesc+0x54>
                    i++;
   24390:	a0c00044 	addi	r3,r20,1
   24394:	1829883a 	mov	r20,r3
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   24398:	10800044 	addi	r2,r2,1
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   2439c:	18ffffcc 	andi	r3,r3,65535
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   243a0:	80a1883a 	add	r16,r16,r2
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   243a4:	88ffe22e 	bgeu	r17,r3,24330 <OBJ_GetDesc+0x88>
            if ( pData )
   243a8:	903fec26 	beq	r18,zero,2435c <OBJ_GetDesc+0xb4>
                MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
   243ac:	014000f4 	movhi	r5,3
   243b0:	01800344 	movi	r6,13
   243b4:	d90000c4 	addi	r4,sp,3
   243b8:	296bf504 	addi	r5,r5,-20524
   243bc:	0026e840 	call	26e84 <memcpy>
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
   243c0:	980b883a 	mov	r5,r19
   243c4:	d9000304 	addi	r4,sp,12
   243c8:	00242280 	call	24228 <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
   243cc:	01800344 	movi	r6,13
   243d0:	d94000c4 	addi	r5,sp,3
   243d4:	9009883a 	mov	r4,r18
   243d8:	0026e840 	call	26e84 <memcpy>
   243dc:	003fdf06 	br	2435c <OBJ_GetDesc+0xb4>

000243e0 <OBJ_GetEntryDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   243e0:	20c0030b 	ldhu	r3,12(r4)
   243e4:	20800417 	ldw	r2,16(r4)
   243e8:	29403fcc 	andi	r5,r5,255
   243ec:	1807d23a 	srai	r3,r3,8

    if ((objCode == OBJCODE_ARR)
   243f0:	18c003cc 	andi	r3,r3,15
   243f4:	18c00218 	cmpnei	r3,r3,8
   243f8:	1800031e 	bne	r3,zero,24408 <OBJ_GetEntryDesc+0x28>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
   243fc:	28000626 	beq	r5,zero,24418 <OBJ_GetEntryDesc+0x38>
            pEntry = &pObjEntry->pEntryDesc[0];
        }
        else
        {
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
   24400:	10800184 	addi	r2,r2,6
   24404:	f800283a 	ret
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
   24408:	2806907a 	slli	r3,r5,1
   2440c:	1947883a 	add	r3,r3,r5
   24410:	1806907a 	slli	r3,r3,1
   24414:	10c5883a 	add	r2,r2,r3
        }
    }

    return pEntry;
}
   24418:	f800283a 	ret

0002441c <OBJ_GetNoOfObjects>:
{
   2441c:	defff904 	addi	sp,sp,-28
   24420:	dd000415 	stw	r20,16(sp)
   24424:	dcc00315 	stw	r19,12(sp)
   24428:	2029883a 	mov	r20,r4
    UINT16 listFlags = 0x0020 << listType;
   2442c:	04c00804 	movi	r19,32
   24430:	21003fcc 	andi	r4,r4,255
{
   24434:	dc800215 	stw	r18,8(sp)
   24438:	dc000015 	stw	r16,0(sp)
    UINT16 listFlags = 0x0020 << listType;
   2443c:	9926983a 	sll	r19,r19,r4
{
   24440:	dfc00615 	stw	ra,24(sp)
   24444:	dd400515 	stw	r21,20(sp)
   24448:	dc400115 	stw	r17,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   2444c:	00209580 	call	20958 <COE_GetObjectDictionary>
   24450:	1021883a 	mov	r16,r2
    UINT16 n = 0;
   24454:	0025883a 	mov	r18,zero
            if ( t )
   24458:	a5003fcc 	andi	r20,r20,255
    while (pObjEntry != NULL)
   2445c:	80000a1e 	bne	r16,zero,24488 <OBJ_GetNoOfObjects+0x6c>
}
   24460:	9005883a 	mov	r2,r18
   24464:	dfc00617 	ldw	ra,24(sp)
   24468:	dd400517 	ldw	r21,20(sp)
   2446c:	dd000417 	ldw	r20,16(sp)
   24470:	dcc00317 	ldw	r19,12(sp)
   24474:	dc800217 	ldw	r18,8(sp)
   24478:	dc400117 	ldw	r17,4(sp)
   2447c:	dc000017 	ldw	r16,0(sp)
   24480:	dec00704 	addi	sp,sp,28
   24484:	f800283a 	ret
        if ( pObjEntry->Index >= 0x1000 )
   24488:	8080020b 	ldhu	r2,8(r16)
   2448c:	10840030 	cmpltui	r2,r2,4096
   24490:	10000c1e 	bne	r2,zero,244c4 <OBJ_GetNoOfObjects+0xa8>
            if ( t )
   24494:	a0000d26 	beq	r20,zero,244cc <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   24498:	85400303 	ldbu	r21,12(r16)
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   2449c:	0023883a 	mov	r17,zero
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
   244a0:	880b883a 	mov	r5,r17
   244a4:	8009883a 	mov	r4,r16
   244a8:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
   244ac:	1080010b 	ldhu	r2,4(r2)
   244b0:	14c4703a 	and	r2,r2,r19
   244b4:	1000051e 	bne	r2,zero,244cc <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   244b8:	8c400044 	addi	r17,r17,1
   244bc:	88bfffcc 	andi	r2,r17,65535
   244c0:	a8bff72e 	bgeu	r21,r2,244a0 <OBJ_GetNoOfObjects+0x84>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   244c4:	84000117 	ldw	r16,4(r16)
   244c8:	003fe406 	br	2445c <OBJ_GetNoOfObjects+0x40>
                n++;
   244cc:	94800044 	addi	r18,r18,1
   244d0:	003ffc06 	br	244c4 <OBJ_GetNoOfObjects+0xa8>

000244d4 <OBJ_GetObjectList>:
    if ( pIndex[0] == 0x1000 )
   244d4:	2880000b 	ldhu	r2,0(r5)
{
   244d8:	defff604 	addi	sp,sp,-40
   244dc:	ddc00715 	stw	r23,28(sp)
   244e0:	dd800615 	stw	r22,24(sp)
   244e4:	dd400515 	stw	r21,20(sp)
   244e8:	dd000415 	stw	r20,16(sp)
   244ec:	dcc00315 	stw	r19,12(sp)
   244f0:	dc800215 	stw	r18,8(sp)
   244f4:	dc400115 	stw	r17,4(sp)
   244f8:	dfc00915 	stw	ra,36(sp)
   244fc:	df000815 	stw	fp,32(sp)
   24500:	dc000015 	stw	r16,0(sp)
    if ( pIndex[0] == 0x1000 )
   24504:	10840018 	cmpnei	r2,r2,4096
{
   24508:	ddc00a17 	ldw	r23,40(sp)
   2450c:	2025883a 	mov	r18,r4
   24510:	2827883a 	mov	r19,r5
   24514:	3023883a 	mov	r17,r6
   24518:	3829883a 	mov	r20,r7
   2451c:	202d883a 	mov	r22,r4
   24520:	302b883a 	mov	r21,r6
    if ( pIndex[0] == 0x1000 )
   24524:	10001c1e 	bne	r2,zero,24598 <OBJ_GetObjectList+0xc4>
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24528:	00209580 	call	20958 <COE_GetObjectDictionary>
   2452c:	1021883a 	mov	r16,r2
        if((pObjEntry == NULL) && (pAbort != NULL))
   24530:	10001326 	beq	r2,zero,24580 <OBJ_GetObjectList+0xac>
        while (pObjEntry != NULL && size > 1 )
   24534:	8c7fffcc 	andi	r17,r17,65535
   24538:	8c4000a8 	cmpgeui	r17,r17,2
   2453c:	8800191e 	bne	r17,zero,245a4 <OBJ_GetObjectList+0xd0>
            pIndex[0] = pObjEntry->Index;
   24540:	8080020b 	ldhu	r2,8(r16)
   24544:	9880000d 	sth	r2,0(r19)
}
   24548:	a805883a 	mov	r2,r21
    pSdoInfoObjEntry = pObjEntry;
   2454c:	d4268e15 	stw	r16,-26056(gp)
}
   24550:	dfc00917 	ldw	ra,36(sp)
   24554:	df000817 	ldw	fp,32(sp)
   24558:	ddc00717 	ldw	r23,28(sp)
   2455c:	dd800617 	ldw	r22,24(sp)
   24560:	dd400517 	ldw	r21,20(sp)
   24564:	dd000417 	ldw	r20,16(sp)
   24568:	dcc00317 	ldw	r19,12(sp)
   2456c:	dc800217 	ldw	r18,8(sp)
   24570:	dc400117 	ldw	r17,4(sp)
   24574:	dc000017 	ldw	r16,0(sp)
   24578:	dec00a04 	addi	sp,sp,40
   2457c:	f800283a 	ret
        if((pObjEntry == NULL) && (pAbort != NULL))
   24580:	b8000226 	beq	r23,zero,2458c <OBJ_GetObjectList+0xb8>
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
   24584:	008006c4 	movi	r2,27
   24588:	b8800005 	stb	r2,0(r23)
            pIndex[0] = 0xFFFF;
   2458c:	00bfffc4 	movi	r2,-1
   24590:	0021883a 	mov	r16,zero
   24594:	003feb06 	br	24544 <OBJ_GetObjectList+0x70>
        pObjEntry = pSdoInfoObjEntry;
   24598:	d4268e17 	ldw	r16,-26056(gp)
    if ( pObjEntry != NULL )
   2459c:	803fe51e 	bne	r16,zero,24534 <OBJ_GetObjectList+0x60>
   245a0:	003ffa06 	br	2458c <OBJ_GetObjectList+0xb8>
    UINT16 listFlags = 0x0020 << listType;
   245a4:	94bfffcc 	andi	r18,r18,65535
   245a8:	00800804 	movi	r2,32
   245ac:	14a4983a 	sll	r18,r2,r18
                if ( t )
   245b0:	b5bfffcc 	andi	r22,r22,65535
            if ( pObjEntry->Index >= 0x1000 )
   245b4:	85c0020b 	ldhu	r23,8(r16)
   245b8:	b8bfffcc 	andi	r2,r23,65535
   245bc:	10840030 	cmpltui	r2,r2,4096
   245c0:	10000c1e 	bne	r2,zero,245f4 <OBJ_GetObjectList+0x120>
                if ( t )
   245c4:	b0001126 	beq	r22,zero,2460c <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   245c8:	87000303 	ldbu	fp,12(r16)
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   245cc:	0023883a 	mov	r17,zero
                        if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
   245d0:	880b883a 	mov	r5,r17
   245d4:	8009883a 	mov	r4,r16
   245d8:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
   245dc:	1080010b 	ldhu	r2,4(r2)
   245e0:	1484703a 	and	r2,r2,r18
   245e4:	1000091e 	bne	r2,zero,2460c <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   245e8:	8c400044 	addi	r17,r17,1
   245ec:	88bfffcc 	andi	r2,r17,65535
   245f0:	e0bff72e 	bgeu	fp,r2,245d0 <OBJ_GetObjectList+0xfc>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   245f4:	84000117 	ldw	r16,4(r16)
        while (pObjEntry != NULL && size > 1 )
   245f8:	803fe426 	beq	r16,zero,2458c <OBJ_GetObjectList+0xb8>
   245fc:	a8bfffcc 	andi	r2,r21,65535
   24600:	108000a8 	cmpgeui	r2,r2,2
   24604:	103feb1e 	bne	r2,zero,245b4 <OBJ_GetObjectList+0xe0>
   24608:	003fcd06 	br	24540 <OBJ_GetObjectList+0x6c>
                    *pData = SWAPWORD(pObjEntry->Index);
   2460c:	a5c0000d 	sth	r23,0(r20)
                    size -= 2;
   24610:	ad7fff84 	addi	r21,r21,-2
                    pData++;
   24614:	a5000084 	addi	r20,r20,2
                    size -= 2;
   24618:	003ff606 	br	245f4 <OBJ_GetObjectList+0x120>

0002461c <OBJ_GetObjDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    return &pObjEntry->ObjDesc;
}
   2461c:	20800284 	addi	r2,r4,10
   24620:	f800283a 	ret

00024624 <OBJ_GetEntryOffset>:
UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    UINT16 i;
    /* bitOffset will be initialized with the bit offset of subindex 1 */
    UINT16 bitOffset = 0;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24624:	28c0030b 	ldhu	r3,12(r5)
   24628:	1807d23a 	srai	r3,r3,8
   2462c:	18c003cc 	andi	r3,r3,15
   24630:	1811883a 	mov	r8,r3
    {
        /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
        bitOffset +=16;
    }

    if (objCode == OBJCODE_VAR)
   24634:	18c001e0 	cmpeqi	r3,r3,7
   24638:	1800531e 	bne	r3,zero,24788 <OBJ_GetEntryOffset+0x164>
   2463c:	20803fcc 	andi	r2,r4,255
    {
        return 0;
    }

    for (i = 1; i <= subindex; i++)
   24640:	02800044 	movi	r10,1
   24644:	1004c03a 	cmpne	r2,r2,zero
    {
        /* get the entry description */
        if ((objCode == OBJCODE_ARR)
   24648:	42003fcc 	andi	r8,r8,255
        else
        {
            pEntry = &pObjEntry->pEntryDesc[i];
        }

        switch (pEntry->DataType)
   2464c:	02d00074 	movhi	r11,16385
   24650:	03080034 	movhi	r12,8192
    for (i = 1; i <= subindex; i++)
   24654:	21003fcc 	andi	r4,r4,255
   24658:	51bfffcc 	andi	r6,r10,65535
   2465c:	1004913a 	slli	r2,r2,4
   24660:	02400184 	movi	r9,6
        if ((objCode == OBJCODE_ARR)
   24664:	42000218 	cmpnei	r8,r8,8
        case    DEFTYPE_ARRAY_OF_INT :

#if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
            /* the 16-bit variables in the structure are word-aligned,
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
   24668:	03fffc04 	movi	r15,-16
        case    DEFTYPE_ARRAY_OF_DINT :
        case    DEFTYPE_ARRAY_OF_UDINT:
#if OBJ_DWORD_ALIGN
            /* the 32-bit variables in the structure are dword-aligned,
               align the actual bitOffset to a dword */
            bitOffset = (bitOffset+31) & 0xFFE0;
   2466c:	037ff804 	movi	r13,-32
   24670:	03800044 	movi	r14,1
        switch (pEntry->DataType)
   24674:	5ae00004 	addi	r11,r11,-32768
   24678:	63100004 	addi	r12,r12,16384
    for (i = 1; i <= subindex; i++)
   2467c:	2180462e 	bgeu	r4,r6,24798 <OBJ_GetEntryOffset+0x174>
            break;
        }
    }

    return bitOffset;
}
   24680:	f800283a 	ret
            pEntry = &pObjEntry->pEntryDesc[i];
   24684:	3a4f883a 	add	r7,r7,r9
   24688:	00004906 	br	247b0 <OBJ_GetEntryOffset+0x18c>
        switch (pEntry->DataType)
   2468c:	18fffbc4 	addi	r3,r3,-17
   24690:	18ffffcc 	andi	r3,r3,65535
   24694:	70c6983a 	sll	r3,r14,r3
   24698:	1c01044c 	andi	r16,r3,1041
   2469c:	8000341e 	bne	r16,zero,24770 <OBJ_GetEntryOffset+0x14c>
   246a0:	1ae0703a 	and	r16,r3,r11
   246a4:	80002b1e 	bne	r16,zero,24754 <OBJ_GetEntryOffset+0x130>
   246a8:	1b06703a 	and	r3,r3,r12
   246ac:	18004a26 	beq	r3,zero,247d8 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   246b0:	108003c4 	addi	r2,r2,15
   246b4:	00fffc04 	movi	r3,-16
   246b8:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   246bc:	31003436 	bltu	r6,r4,24790 <OBJ_GetEntryOffset+0x16c>
    for (i = 1; i <= subindex; i++)
   246c0:	52800044 	addi	r10,r10,1
   246c4:	51bfffcc 	andi	r6,r10,65535
   246c8:	4a400184 	addi	r9,r9,6
   246cc:	2180352e 	bgeu	r4,r6,247a4 <OBJ_GetEntryOffset+0x180>
}
   246d0:	dfc00117 	ldw	ra,4(sp)
   246d4:	dc000017 	ldw	r16,0(sp)
   246d8:	dec00204 	addi	sp,sp,8
   246dc:	f800283a 	ret
   246e0:	77c6983a 	sll	r3,r14,ra
        switch (pEntry->DataType)
   246e4:	1c00640c 	andi	r16,r3,400
   246e8:	80001a1e 	bne	r16,zero,24754 <OBJ_GetEntryOffset+0x130>
   246ec:	18c2120c 	andi	r3,r3,2120
   246f0:	18003926 	beq	r3,zero,247d8 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   246f4:	108003c4 	addi	r2,r2,15
   246f8:	00fffc04 	movi	r3,-16
   246fc:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24700:	313fef2e 	bgeu	r6,r4,246c0 <OBJ_GetEntryOffset+0x9c>
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
   24704:	ffc002d8 	cmpnei	ra,ra,11
   24708:	f800211e 	bne	ra,zero,24790 <OBJ_GetEntryOffset+0x16c>
                bitOffset += pEntry->BitLength;
   2470c:	38c0008b 	ldhu	r3,2(r7)
   24710:	00000b06 	br	24740 <OBJ_GetEntryOffset+0x11c>
        switch (pEntry->DataType)
   24714:	ffc09820 	cmpeqi	ra,ra,608
   24718:	f8000b1e 	bne	ra,zero,24748 <OBJ_GetEntryOffset+0x124>
   2471c:	18ff6784 	addi	r3,r3,-610
   24720:	18ffffcc 	andi	r3,r3,65535
   24724:	18c000a8 	cmpgeui	r3,r3,2
   24728:	18002b1e 	bne	r3,zero,247d8 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   2472c:	10c007c4 	addi	r3,r2,31
   24730:	1b46703a 	and	r3,r3,r13
   24734:	1805883a 	mov	r2,r3
            if (i < subindex)
   24738:	313fe12e 	bgeu	r6,r4,246c0 <OBJ_GetEntryOffset+0x9c>
                    bitOffset += pEntry->BitLength;
   2473c:	3880008b 	ldhu	r2,2(r7)
                bitOffset += pEntry->BitLength;
   24740:	1885883a 	add	r2,r3,r2
   24744:	003fde06 	br	246c0 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24748:	108003c4 	addi	r2,r2,15
   2474c:	13c4703a 	and	r2,r2,r15
            if (i < subindex)
   24750:	00002106 	br	247d8 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24754:	10c007c4 	addi	r3,r2,31
   24758:	00bff804 	movi	r2,-32
   2475c:	1886703a 	and	r3,r3,r2
   24760:	1805883a 	mov	r2,r3
            if (i < subindex)
   24764:	313fd62e 	bgeu	r6,r4,246c0 <OBJ_GetEntryOffset+0x9c>
                   bitOffset += 32;
   24768:	18800804 	addi	r2,r3,32
   2476c:	003fd406 	br	246c0 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset + 31) & 0xFFE0;
   24770:	10c007c4 	addi	r3,r2,31
   24774:	1b46703a 	and	r3,r3,r13
   24778:	1805883a 	mov	r2,r3
            if (i < subindex)
   2477c:	313fd02e 	bgeu	r6,r4,246c0 <OBJ_GetEntryOffset+0x9c>
                bitOffset += 64;
   24780:	18801004 	addi	r2,r3,64
   24784:	003fce06 	br	246c0 <OBJ_GetEntryOffset+0x9c>
        return 0;
   24788:	0005883a 	mov	r2,zero
   2478c:	f800283a 	ret
                    bitOffset += 16;
   24790:	10800404 	addi	r2,r2,16
   24794:	003fca06 	br	246c0 <OBJ_GetEntryOffset+0x9c>
{
   24798:	defffe04 	addi	sp,sp,-8
   2479c:	dfc00115 	stw	ra,4(sp)
   247a0:	dc000015 	stw	r16,0(sp)
            pEntry = &pObjEntry->pEntryDesc[1];
   247a4:	29c00417 	ldw	r7,16(r5)
        if ((objCode == OBJCODE_ARR)
   247a8:	403fb61e 	bne	r8,zero,24684 <OBJ_GetEntryOffset+0x60>
            pEntry = &pObjEntry->pEntryDesc[1];
   247ac:	39c00184 	addi	r7,r7,6
        switch (pEntry->DataType)
   247b0:	38c0000b 	ldhu	r3,0(r7)
   247b4:	1fffffcc 	andi	ra,r3,65535
   247b8:	fc000c28 	cmpgeui	r16,ra,48
   247bc:	803fd51e 	bne	r16,zero,24714 <OBJ_GetEntryOffset+0xf0>
   247c0:	fc000468 	cmpgeui	r16,ra,17
   247c4:	803fb11e 	bne	r16,zero,2468c <OBJ_GetEntryOffset+0x68>
   247c8:	18ffff44 	addi	r3,r3,-3
   247cc:	18ffffcc 	andi	r3,r3,65535
   247d0:	18c00268 	cmpgeui	r3,r3,9
   247d4:	183fc226 	beq	r3,zero,246e0 <OBJ_GetEntryOffset+0xbc>
            if (i < subindex)
   247d8:	313fb92e 	bgeu	r6,r4,246c0 <OBJ_GetEntryOffset+0x9c>
   247dc:	003fcb06 	br	2470c <OBJ_GetEntryOffset+0xe8>

000247e0 <CheckSyncTypeValue>:

 \brief    Checks if the new Sync type value is valid
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
{
    switch (NewSyncType)
   247e0:	297fffcc 	andi	r5,r5,65535
   247e4:	288000a0 	cmpeqi	r2,r5,2
   247e8:	1000281e 	bne	r2,zero,2488c <CheckSyncTypeValue+0xac>
   247ec:	288000e8 	cmpgeui	r2,r5,3
   247f0:	1000031e 	bne	r2,zero,24800 <CheckSyncTypeValue+0x20>
   247f4:	2800081e 	bne	r5,zero,24818 <CheckSyncTypeValue+0x38>
    {
    case SYNCTYPE_FREERUN:
        return 0; //free run sync mode is always accepted
   247f8:	0005883a 	mov	r2,zero
   247fc:	f800283a 	ret
    switch (NewSyncType)
   24800:	288000e0 	cmpeqi	r2,r5,3
   24804:	10002d1e 	bne	r2,zero,248bc <CheckSyncTypeValue+0xdc>
   24808:	294008a0 	cmpeqi	r5,r5,34
   2480c:	2800161e 	bne	r5,zero,24868 <CheckSyncTypeValue+0x88>
        {
            return 0;
        }
        break;
    } //switch 
    return ABORTIDX_VALUE_EXCEEDED;
   24810:	00800484 	movi	r2,18

}
   24814:	f800283a 	ret
        if ((index == 0x1C32) 
   24818:	213fffcc 	andi	r4,r4,65535
   2481c:	20870c98 	cmpnei	r2,r4,7218
   24820:	1000071e 	bne	r2,zero,24840 <CheckSyncTypeValue+0x60>
            && (nPdOutputSize > 0) 
   24824:	d0a6710b 	ldhu	r2,-26172(gp)
   24828:	103ff926 	beq	r2,zero,24810 <CheckSyncTypeValue+0x30>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
   2482c:	008000f4 	movhi	r2,3
   24830:	10b2fe0b 	ldhu	r2,-13320(r2)
   24834:	1080008c 	andi	r2,r2,2
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24838:	103ff526 	beq	r2,zero,24810 <CheckSyncTypeValue+0x30>
   2483c:	003fee06 	br	247f8 <CheckSyncTypeValue+0x18>
        if ((index == 0x1C33) 
   24840:	21070cd8 	cmpnei	r4,r4,7219
   24844:	203ff21e 	bne	r4,zero,24810 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24848:	008000f4 	movhi	r2,3
   2484c:	10b2ed0b 	ldhu	r2,-13388(r2)
   24850:	1080008c 	andi	r2,r2,2
   24854:	103fee26 	beq	r2,zero,24810 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize == 0) 
   24858:	d0a6710b 	ldhu	r2,-26172(gp)
   2485c:	103fec1e 	bne	r2,zero,24810 <CheckSyncTypeValue+0x30>
            && (nPdInputSize > 0))
   24860:	d0a6718b 	ldhu	r2,-26170(gp)
   24864:	003ff406 	br	24838 <CheckSyncTypeValue+0x58>
        if ((index == 0x1C33) 
   24868:	213fffcc 	andi	r4,r4,65535
   2486c:	21070cd8 	cmpnei	r4,r4,7219
   24870:	203fe71e 	bne	r4,zero,24810 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24874:	008000f4 	movhi	r2,3
   24878:	10b2ed0b 	ldhu	r2,-13388(r2)
   2487c:	1080008c 	andi	r2,r2,2
   24880:	103fe326 	beq	r2,zero,24810 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize > 0))
   24884:	d0a6710b 	ldhu	r2,-26172(gp)
   24888:	003feb06 	br	24838 <CheckSyncTypeValue+0x58>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   2488c:	213fffcc 	andi	r4,r4,65535
   24890:	20870c98 	cmpnei	r2,r4,7218
   24894:	1000041e 	bne	r2,zero,248a8 <CheckSyncTypeValue+0xc8>
   24898:	008000f4 	movhi	r2,3
   2489c:	10b2fe0b 	ldhu	r2,-13320(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   248a0:	1080010c 	andi	r2,r2,4
   248a4:	003fe406 	br	24838 <CheckSyncTypeValue+0x58>
   248a8:	21070cd8 	cmpnei	r4,r4,7219
   248ac:	203fd81e 	bne	r4,zero,24810 <CheckSyncTypeValue+0x30>
   248b0:	008000f4 	movhi	r2,3
   248b4:	10b2ed0b 	ldhu	r2,-13388(r2)
   248b8:	003ff906 	br	248a0 <CheckSyncTypeValue+0xc0>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   248bc:	213fffcc 	andi	r4,r4,65535
   248c0:	20870c98 	cmpnei	r2,r4,7218
   248c4:	1000041e 	bne	r2,zero,248d8 <CheckSyncTypeValue+0xf8>
   248c8:	008000f4 	movhi	r2,3
   248cc:	10b2fe0b 	ldhu	r2,-13320(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   248d0:	1080020c 	andi	r2,r2,8
   248d4:	003fd806 	br	24838 <CheckSyncTypeValue+0x58>
   248d8:	21070cd8 	cmpnei	r4,r4,7219
   248dc:	203fcc1e 	bne	r4,zero,24810 <CheckSyncTypeValue+0x30>
   248e0:	008000f4 	movhi	r2,3
   248e4:	10b2ed0b 	ldhu	r2,-13388(r2)
   248e8:	003ff906 	br	248d0 <CheckSyncTypeValue+0xf0>

000248ec <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
   248ec:	defff004 	addi	sp,sp,-64
   248f0:	dd400b15 	stw	r21,44(sp)
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   248f4:	3d40030b 	ldhu	r21,12(r7)
{
   248f8:	df000e15 	stw	fp,56(sp)
   248fc:	ddc00d15 	stw	r23,52(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24900:	a804d23a 	srli	r2,r21,8
{
   24904:	dd800c15 	stw	r22,48(sp)
   24908:	dd000a15 	stw	r20,40(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2490c:	108003cc 	andi	r2,r2,15
{
   24910:	dcc00915 	stw	r19,36(sp)
   24914:	dc400715 	stw	r17,28(sp)
   24918:	dc000615 	stw	r16,24(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2491c:	102f883a 	mov	r23,r2
{
   24920:	dfc00f15 	stw	ra,60(sp)
   24924:	dc800815 	stw	r18,32(sp)
   24928:	d9800115 	stw	r6,4(sp)
   2492c:	d900008d 	sth	r4,2(sp)
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24930:	108001e0 	cmpeqi	r2,r2,7
{
   24934:	dd801017 	ldw	r22,64(sp)
   24938:	dcc01103 	ldbu	r19,68(sp)
   2493c:	2023883a 	mov	r17,r4
   24940:	2839883a 	mov	fp,r5
   24944:	3821883a 	mov	r16,r7
    UINT16 i = subindex;
   24948:	2d003fcc 	andi	r20,r5,255
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   2494c:	ad403fcc 	andi	r21,r21,255
    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24950:	1000191e 	bne	r2,zero,249b8 <OBJ_Read+0xcc>
   24954:	20bfffcc 	andi	r2,r4,65535
   24958:	10840030 	cmpltui	r2,r2,4096
   2495c:	1000161e 	bne	r2,zero,249b8 <OBJ_Read+0xcc>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
   24960:	38800617 	ldw	r2,24(r7)
   24964:	14800003 	ldbu	r18,0(r2)
   24968:	902b883a 	mov	r21,r18

    }

    if ( bCompleteAccess )
   2496c:	9800211e 	bne	r19,zero,249f4 <OBJ_Read+0x108>

        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
    }
    else
        if ( subindex > maxSubindex )
   24970:	a0bfffcc 	andi	r2,r20,65535
   24974:	a93fffcc 	andi	r4,r21,65535
   24978:	20815c36 	bltu	r4,r2,24eec <OBJ_Read+0x600>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   2497c:	8009883a 	mov	r4,r16
   24980:	e1403fcc 	andi	r5,fp,255
   24984:	00243e00 	call	243e0 <OBJ_GetEntryDesc>

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
   24988:	1100010b 	ldhu	r4,4(r2)
   2498c:	20bfffcc 	andi	r2,r4,65535
   24990:	10000a26 	beq	r2,zero,249bc <OBJ_Read+0xd0>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
   24994:	2004907a 	slli	r2,r4,1
   24998:	d1666fc3 	ldbu	r5,-26177(gp)
   2499c:	1144703a 	and	r2,r2,r5
   249a0:	1080038c 	andi	r2,r2,14
   249a4:	1000191e 	bne	r2,zero,24a0c <OBJ_Read+0x120>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   249a8:	210001cc 	andi	r4,r4,7
   249ac:	2001511e 	bne	r4,zero,24ef4 <OBJ_Read+0x608>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
   249b0:	07000184 	movi	fp,6
   249b4:	00000206 	br	249c0 <OBJ_Read+0xd4>
    if ( bCompleteAccess )
   249b8:	983fed26 	beq	r19,zero,24970 <OBJ_Read+0x84>
            return ABORTIDX_UNSUPPORTED_ACCESS;
   249bc:	07000144 	movi	fp,5
                return result;
            }
        }

    return 0;
}
   249c0:	e005883a 	mov	r2,fp
   249c4:	dfc00f17 	ldw	ra,60(sp)
   249c8:	df000e17 	ldw	fp,56(sp)
   249cc:	ddc00d17 	ldw	r23,52(sp)
   249d0:	dd800c17 	ldw	r22,48(sp)
   249d4:	dd400b17 	ldw	r21,44(sp)
   249d8:	dd000a17 	ldw	r20,40(sp)
   249dc:	dcc00917 	ldw	r19,36(sp)
   249e0:	dc800817 	ldw	r18,32(sp)
   249e4:	dc400717 	ldw	r17,28(sp)
   249e8:	dc000617 	ldw	r16,24(sp)
   249ec:	dec01004 	addi	sp,sp,64
   249f0:	f800283a 	ret
        if (pAPPL_CoeReadInd != NULL)
   249f4:	d0a66717 	ldw	r2,-26212(gp)
   249f8:	1000071e 	bne	r2,zero,24a18 <OBJ_Read+0x12c>
        if ( pObjEntry->Read != NULL )
   249fc:	38800717 	ldw	r2,28(r7)
   24a00:	10000b1e 	bne	r2,zero,24a30 <OBJ_Read+0x144>
    UINT16 i = subindex;
   24a04:	a023883a 	mov	r17,r20
   24a08:	00002006 	br	24a8c <OBJ_Read+0x1a0>
        if (pAPPL_CoeReadInd != NULL)
   24a0c:	d0a66717 	ldw	r2,-26212(gp)
    UINT16 lastSubindex = subindex;
   24a10:	a025883a 	mov	r18,r20
        if (pAPPL_CoeReadInd != NULL)
   24a14:	10000426 	beq	r2,zero,24a28 <OBJ_Read+0x13c>
            pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
   24a18:	980d883a 	mov	r6,r19
   24a1c:	e1403fcc 	andi	r5,fp,255
   24a20:	893fffcc 	andi	r4,r17,65535
   24a24:	103ee83a 	callr	r2
        if ( pObjEntry->Read != NULL )
   24a28:	80800717 	ldw	r2,28(r16)
   24a2c:	10001126 	beq	r2,zero,24a74 <OBJ_Read+0x188>
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24a30:	d9800117 	ldw	r6,4(sp)
   24a34:	b00f883a 	mov	r7,r22
   24a38:	e1403fcc 	andi	r5,fp,255
   24a3c:	893fffcc 	andi	r4,r17,65535
   24a40:	dcc01015 	stw	r19,64(sp)
}
   24a44:	dfc00f17 	ldw	ra,60(sp)
   24a48:	df000e17 	ldw	fp,56(sp)
   24a4c:	ddc00d17 	ldw	r23,52(sp)
   24a50:	dd800c17 	ldw	r22,48(sp)
   24a54:	dd400b17 	ldw	r21,44(sp)
   24a58:	dd000a17 	ldw	r20,40(sp)
   24a5c:	dcc00917 	ldw	r19,36(sp)
   24a60:	dc800817 	ldw	r18,32(sp)
   24a64:	dc400717 	ldw	r17,28(sp)
   24a68:	dc000617 	ldw	r16,24(sp)
   24a6c:	dec01004 	addi	sp,sp,64
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24a70:	1000683a 	jmp	r2
        else if ( index < 0x1000 && subindex != 0 )
   24a74:	88ffffcc 	andi	r3,r17,65535
   24a78:	18c40028 	cmpgeui	r3,r3,4096
   24a7c:	183fe11e 	bne	r3,zero,24a04 <OBJ_Read+0x118>
   24a80:	e7003fcc 	andi	fp,fp,255
   24a84:	e000111e 	bne	fp,zero,24acc <OBJ_Read+0x1e0>
            for (i = subindex; i <= lastSubindex; i++)
   24a88:	0023883a 	mov	r17,zero
                else if ( index >= 0x1000 )
   24a8c:	d880008b 	ldhu	r2,2(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24a90:	bdc03fcc 	andi	r23,r23,255
   24a94:	8c7fffcc 	andi	r17,r17,65535
                else if ( index >= 0x1000 )
   24a98:	10840030 	cmpltui	r2,r2,4096
   24a9c:	d8800215 	stw	r2,8(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24aa0:	b88001e0 	cmpeqi	r2,r23,7
                            bRead = 1;
   24aa4:	0039883a 	mov	fp,zero
   24aa8:	000d883a 	mov	r6,zero
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24aac:	d8800315 	stw	r2,12(sp)
            for (i = subindex; i <= lastSubindex; i++)
   24ab0:	dc40008d 	sth	r17,2(sp)
   24ab4:	88bfffcc 	andi	r2,r17,65535
   24ab8:	90ffffcc 	andi	r3,r18,65535
   24abc:	1880392e 	bgeu	r3,r2,24ba4 <OBJ_Read+0x2b8>
            if(bRead == 0)
   24ac0:	30803fcc 	andi	r2,r6,255
   24ac4:	1000221e 	bne	r2,zero,24b50 <OBJ_Read+0x264>
   24ac8:	003fbd06 	br	249c0 <OBJ_Read+0xd4>
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24acc:	e00b883a 	mov	r5,fp
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   24ad0:	84400617 	ldw	r17,24(r16)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24ad4:	e03890ba 	slli	fp,fp,2
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24ad8:	8009883a 	mov	r4,r16
   24adc:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24ae0:	8f23883a 	add	r17,r17,fp
            size = BIT2BYTE(pEntry->BitLength);
   24ae4:	1180008b 	ldhu	r6,2(r2)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24ae8:	897fff17 	ldw	r5,-4(r17)
            size = BIT2BYTE(pEntry->BitLength);
   24aec:	318001c4 	addi	r6,r6,7
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   24af0:	2880004c 	andi	r2,r5,1
            size = BIT2BYTE(pEntry->BitLength);
   24af4:	300dd0fa 	srai	r6,r6,3
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   24af8:	10002126 	beq	r2,zero,24b80 <OBJ_Read+0x294>
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   24afc:	00bfff84 	movi	r2,-2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b00:	3006d07a 	srli	r3,r6,1
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   24b04:	288a703a 	and	r5,r5,r2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b08:	b009883a 	mov	r4,r22
   24b0c:	0011883a 	mov	r8,zero
   24b10:	2d95c83a 	sub	r10,r5,r22
   24b14:	40bfffcc 	andi	r2,r8,65535
   24b18:	2293883a 	add	r9,r4,r10
   24b1c:	18800e1e 	bne	r3,r2,24b58 <OBJ_Read+0x26c>
                if((size % 2) == 1)
   24b20:	3180004c 	andi	r6,r6,1
   24b24:	30000a26 	beq	r6,zero,24b50 <OBJ_Read+0x264>
   24b28:	1806907a 	slli	r3,r3,1
   24b2c:	b0cf883a 	add	r7,r22,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   24b30:	3880000b 	ldhu	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   24b34:	28cb883a 	add	r5,r5,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   24b38:	10bfc00c 	andi	r2,r2,65280
   24b3c:	3880000d 	sth	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   24b40:	28c0000b 	ldhu	r3,0(r5)
   24b44:	1806d23a 	srli	r3,r3,8
   24b48:	10c4b03a 	or	r2,r2,r3
   24b4c:	3880000d 	sth	r2,0(r7)
    return 0;
   24b50:	0039883a 	mov	fp,zero
   24b54:	003f9a06 	br	249c0 <OBJ_Read+0xd4>
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   24b58:	4880000b 	ldhu	r2,0(r9)
                    pData++;
   24b5c:	21000084 	addi	r4,r4,2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b60:	42000044 	addi	r8,r8,1
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   24b64:	1004d23a 	srli	r2,r2,8
   24b68:	20bfff8d 	sth	r2,-2(r4)
                    pData[0] |= (pVarPtr[1] & 0xFF) << 8;
   24b6c:	4a40008b 	ldhu	r9,2(r9)
   24b70:	4812923a 	slli	r9,r9,8
   24b74:	1244b03a 	or	r2,r2,r9
   24b78:	20bfff8d 	sth	r2,-2(r4)
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b7c:	003fe506 	br	24b14 <OBJ_Read+0x228>
            pData[0] = pVarPtr[0];
   24b80:	2880000b 	ldhu	r2,0(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24b84:	31bfff04 	addi	r6,r6,-4
   24b88:	29400104 	addi	r5,r5,4
            pData[0] = pVarPtr[0];
   24b8c:	b080000d 	sth	r2,0(r22)
            pData[1] = pVarPtr[1];
   24b90:	28bfff8b 	ldhu	r2,-2(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24b94:	b1000104 	addi	r4,r22,4
            pData[1] = pVarPtr[1];
   24b98:	b080008d 	sth	r2,2(r22)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24b9c:	0026e840 	call	26e84 <memcpy>
   24ba0:	003feb06 	br	24b50 <OBJ_Read+0x264>
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   24ba4:	80c00617 	ldw	r3,24(r16)
   24ba8:	d8c00115 	stw	r3,4(sp)
                if (i == 0)
   24bac:	10002226 	beq	r2,zero,24c38 <OBJ_Read+0x34c>
                else if ( index >= 0x1000 )
   24bb0:	d8800217 	ldw	r2,8(sp)
   24bb4:	1000221e 	bne	r2,zero,24c40 <OBJ_Read+0x354>
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   24bb8:	800b883a 	mov	r5,r16
   24bbc:	8809883a 	mov	r4,r17
   24bc0:	d9800415 	stw	r6,16(sp)
   24bc4:	00246240 	call	24624 <OBJ_GetEntryOffset>
   24bc8:	d9800417 	ldw	r6,16(sp)
   24bcc:	1007883a 	mov	r3,r2
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   24bd0:	8009883a 	mov	r4,r16
   24bd4:	880b883a 	mov	r5,r17
   24bd8:	d8c00515 	stw	r3,20(sp)
   24bdc:	d9800415 	stw	r6,16(sp)
   24be0:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
   24be4:	102f883a 	mov	r23,r2
                if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
   24be8:	10800103 	ldbu	r2,4(r2)
   24bec:	d1266fc3 	ldbu	r4,-26177(gp)
   24bf0:	d9800417 	ldw	r6,16(sp)
   24bf4:	1004907a 	slli	r2,r2,1
   24bf8:	d8c00517 	ldw	r3,20(sp)
   24bfc:	1104703a 	and	r2,r2,r4
   24c00:	1080038c 	andi	r2,r2,14
   24c04:	10009e26 	beq	r2,zero,24e80 <OBJ_Read+0x594>
                    if ( i == subindex                                     /* requested entry */
   24c08:	d880008b 	ldhu	r2,2(sp)
   24c0c:	a13fffcc 	andi	r4,r20,65535
   24c10:	11000226 	beq	r2,r4,24c1c <OBJ_Read+0x330>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   24c14:	98000626 	beq	r19,zero,24c30 <OBJ_Read+0x344>
   24c18:	11000536 	bltu	r2,r4,24c30 <OBJ_Read+0x344>
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24c1c:	10000a1e 	bne	r2,zero,24c48 <OBJ_Read+0x35c>
   24c20:	d8800317 	ldw	r2,12(sp)
   24c24:	1000081e 	bne	r2,zero,24c48 <OBJ_Read+0x35c>
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
   24c28:	b540000d 	sth	r21,0(r22)
                            pData++;
   24c2c:	b5800084 	addi	r22,r22,2
            for (i = subindex; i <= lastSubindex; i++)
   24c30:	8c400044 	addi	r17,r17,1
   24c34:	003f9e06 	br	24ab0 <OBJ_Read+0x1c4>
                UINT16 bitOffset = 0;
   24c38:	8807883a 	mov	r3,r17
   24c3c:	003fe406 	br	24bd0 <OBJ_Read+0x2e4>
   24c40:	0007883a 	mov	r3,zero
   24c44:	003fe206 	br	24bd0 <OBJ_Read+0x2e4>
                pVarPtr += (bitOffset >> 4);
   24c48:	180ad0fa 	srli	r5,r3,3
   24c4c:	d8800117 	ldw	r2,4(sp)
                            UINT16 dataType = pEntry->DataType;
   24c50:	b900000b 	ldhu	r4,0(r23)
                pVarPtr += (bitOffset >> 4);
   24c54:	2947ff8c 	andi	r5,r5,8190
   24c58:	114b883a 	add	r5,r2,r5
                            if (pEntry->DataType >= 0x700)
   24c5c:	20bfffcc 	andi	r2,r4,65535
   24c60:	1181c030 	cmpltui	r6,r2,1792
   24c64:	3000201e 	bne	r6,zero,24ce8 <OBJ_Read+0x3fc>
                                if ( pEntry->BitLength <= 8 )
   24c68:	b900008b 	ldhu	r4,2(r23)
   24c6c:	20bfffcc 	andi	r2,r4,65535
   24c70:	11800268 	cmpgeui	r6,r2,9
   24c74:	3000161e 	bne	r6,zero,24cd0 <OBJ_Read+0x3e4>
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   24c78:	21000bc4 	addi	r4,r4,47
                            switch (dataType)
   24c7c:	213ff884 	addi	r4,r4,-30
   24c80:	213fffcc 	andi	r4,r4,65535
   24c84:	00800044 	movi	r2,1
   24c88:	1104983a 	sll	r2,r2,r4
   24c8c:	0100ff74 	movhi	r4,1021
   24c90:	21200044 	addi	r4,r4,-32767
   24c94:	1108703a 	and	r4,r2,r4
   24c98:	2000591e 	bne	r4,zero,24e00 <OBJ_Read+0x514>
   24c9c:	010000b4 	movhi	r4,2
   24ca0:	21000104 	addi	r4,r4,4
   24ca4:	1108703a 	and	r4,r2,r4
   24ca8:	20006d1e 	bne	r4,zero,24e60 <OBJ_Read+0x574>
   24cac:	01000074 	movhi	r4,1
   24cb0:	21000084 	addi	r4,r4,2
   24cb4:	1104703a 	and	r2,r2,r4
   24cb8:	10000926 	beq	r2,zero,24ce0 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24cbc:	18c003cc 	andi	r3,r3,15
   24cc0:	183f3e1e 	bne	r3,zero,249bc <OBJ_Read+0xd0>
                                pData[0] = SWAPWORD(pVarPtr[0]);
   24cc4:	2880000b 	ldhu	r2,0(r5)
   24cc8:	b080000d 	sth	r2,0(r22)
   24ccc:	00005f06 	br	24e4c <OBJ_Read+0x560>
                                else if ( pEntry->BitLength == 16 )
   24cd0:	11000420 	cmpeqi	r4,r2,16
   24cd4:	203ff91e 	bne	r4,zero,24cbc <OBJ_Read+0x3d0>
                                else if ( pEntry->BitLength == 32 )
   24cd8:	10800820 	cmpeqi	r2,r2,32
   24cdc:	1000601e 	bne	r2,zero,24e60 <OBJ_Read+0x574>
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   24ce0:	07000604 	movi	fp,24
   24ce4:	003f3606 	br	249c0 <OBJ_Read+0xd4>
                            switch (dataType)
   24ce8:	11800328 	cmpgeui	r6,r2,12
   24cec:	30000d1e 	bne	r6,zero,24d24 <OBJ_Read+0x438>
   24cf0:	110002a8 	cmpgeui	r4,r2,10
   24cf4:	2000241e 	bne	r4,zero,24d88 <OBJ_Read+0x49c>
   24cf8:	11000260 	cmpeqi	r4,r2,9
   24cfc:	2000221e 	bne	r4,zero,24d88 <OBJ_Read+0x49c>
   24d00:	10003126 	beq	r2,zero,24dc8 <OBJ_Read+0x4dc>
   24d04:	01000044 	movi	r4,1
   24d08:	2084983a 	sll	r2,r4,r2
   24d0c:	1100640c 	andi	r4,r2,400
   24d10:	2000531e 	bne	r4,zero,24e60 <OBJ_Read+0x574>
   24d14:	1100098c 	andi	r4,r2,38
   24d18:	2000391e 	bne	r4,zero,24e00 <OBJ_Read+0x514>
   24d1c:	1080120c 	andi	r2,r2,72
   24d20:	003fe506 	br	24cb8 <OBJ_Read+0x3cc>
   24d24:	11800e28 	cmpgeui	r6,r2,56
   24d28:	3000131e 	bne	r6,zero,24d78 <OBJ_Read+0x48c>
   24d2c:	118007a8 	cmpgeui	r6,r2,30
   24d30:	303fd21e 	bne	r6,zero,24c7c <OBJ_Read+0x390>
   24d34:	213ffecc 	andi	r4,r4,65531
   24d38:	21000460 	cmpeqi	r4,r4,17
   24d3c:	2000021e 	bne	r4,zero,24d48 <OBJ_Read+0x45c>
   24d40:	108006e0 	cmpeqi	r2,r2,27
   24d44:	103fe626 	beq	r2,zero,24ce0 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24d48:	18c003cc 	andi	r3,r3,15
   24d4c:	183f1b1e 	bne	r3,zero,249bc <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   24d50:	2880000b 	ldhu	r2,0(r5)
                                pData += 4;
   24d54:	b5800204 	addi	r22,r22,8
                                pData[0] = pVarPtr[0];
   24d58:	b0bffe0d 	sth	r2,-8(r22)
                                pData[1] = pVarPtr[1];
   24d5c:	2880008b 	ldhu	r2,2(r5)
   24d60:	b0bffe8d 	sth	r2,-6(r22)
                                pData[2] = pVarPtr[2];
   24d64:	2880010b 	ldhu	r2,4(r5)
   24d68:	b0bfff0d 	sth	r2,-4(r22)
                                pData[3] = pVarPtr[3];
   24d6c:	2880018b 	ldhu	r2,6(r5)
   24d70:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   24d74:	00002006 	br	24df8 <OBJ_Read+0x50c>
                            switch (dataType)
   24d78:	213f6804 	addi	r4,r4,-608
   24d7c:	213fffcc 	andi	r4,r4,65535
   24d80:	21000128 	cmpgeui	r4,r4,4
   24d84:	203fd61e 	bne	r4,zero,24ce0 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24d88:	18c003cc 	andi	r3,r3,15
   24d8c:	183f0b1e 	bne	r3,zero,249bc <OBJ_Read+0xd0>
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
   24d90:	b980008b 	ldhu	r6,2(r23)
   24d94:	b009883a 	mov	r4,r22
   24d98:	318001c4 	addi	r6,r6,7
   24d9c:	300cd0fa 	srli	r6,r6,3
   24da0:	0026e840 	call	26e84 <memcpy>
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   24da4:	b880008b 	ldhu	r2,2(r23)
   24da8:	10fffc0c 	andi	r3,r2,65520
   24dac:	1806d0fa 	srli	r3,r3,3
                                if((pEntry->BitLength & 0xF) != 0)
   24db0:	108003cc 	andi	r2,r2,15
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   24db4:	b0ed883a 	add	r22,r22,r3
                                if((pEntry->BitLength & 0xF) != 0)
   24db8:	10000f26 	beq	r2,zero,24df8 <OBJ_Read+0x50c>
                                    *pData &= 0xFF;
   24dbc:	b0800003 	ldbu	r2,0(r22)
   24dc0:	b080000d 	sth	r2,0(r22)
   24dc4:	00000c06 	br	24df8 <OBJ_Read+0x50c>
                                if(bCompleteAccess)
   24dc8:	983fc526 	beq	r19,zero,24ce0 <OBJ_Read+0x3f4>
                                    if (((pEntry->BitLength & 0xF) > 0)
   24dcc:	b880008b 	ldhu	r2,2(r23)
   24dd0:	114003cc 	andi	r5,r2,15
   24dd4:	113fffcc 	andi	r4,r2,65535
   24dd8:	28000426 	beq	r5,zero,24dec <OBJ_Read+0x500>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   24ddc:	10c5883a 	add	r2,r2,r3
   24de0:	108003cc 	andi	r2,r2,15
   24de4:	1000011e 	bne	r2,zero,24dec <OBJ_Read+0x500>
                                        pData++;
   24de8:	b5800084 	addi	r22,r22,2
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
   24dec:	2004d0fa 	srli	r2,r4,3
   24df0:	1080078c 	andi	r2,r2,30
   24df4:	b0ad883a 	add	r22,r22,r2
                            bRead = 1;
   24df8:	01800044 	movi	r6,1
   24dfc:	003f8c06 	br	24c30 <OBJ_Read+0x344>
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   24e00:	b900008b 	ldhu	r4,2(r23)
   24e04:	008000f4 	movhi	r2,3
   24e08:	198003cc 	andi	r6,r3,15
   24e0c:	2008907a 	slli	r4,r4,1
                                    TmpValue = SWAPWORD(pVarPtr[0]);
   24e10:	2940000b 	ldhu	r5,0(r5)
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   24e14:	2085883a 	add	r2,r4,r2
   24e18:	10a5e08b 	ldhu	r2,-26750(r2)
   24e1c:	1184983a 	sll	r2,r2,r6
                                    if ((bitOffset & 0x0F) == 0) 
   24e20:	3000011e 	bne	r6,zero,24e28 <OBJ_Read+0x53c>
                                        pData[0] = 0;
   24e24:	b000000d 	sth	zero,0(r22)
                                    pData[0] = SWAPWORD(pData[0]);
   24e28:	b100000b 	ldhu	r4,0(r22)
                                        pData[0] |= TmpValue & bitMask;
   24e2c:	1144703a 	and	r2,r2,r5
                                    if (bCompleteAccess) 
   24e30:	98000826 	beq	r19,zero,24e54 <OBJ_Read+0x568>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   24e34:	1104b03a 	or	r2,r2,r4
                                        pData[0] |= TmpValue & bitMask;
   24e38:	b080000d 	sth	r2,0(r22)
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
   24e3c:	b880008b 	ldhu	r2,2(r23)
   24e40:	10c5883a 	add	r2,r2,r3
   24e44:	108003cc 	andi	r2,r2,15
   24e48:	103feb1e 	bne	r2,zero,24df8 <OBJ_Read+0x50c>
                                pData++;
   24e4c:	b5800084 	addi	r22,r22,2
                                break;
   24e50:	003fe906 	br	24df8 <OBJ_Read+0x50c>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   24e54:	10bfffcc 	andi	r2,r2,65535
   24e58:	1185d83a 	sra	r2,r2,r6
   24e5c:	003ff506 	br	24e34 <OBJ_Read+0x548>
                                if(bitOffset & 0xF)
   24e60:	18c003cc 	andi	r3,r3,15
   24e64:	183ed51e 	bne	r3,zero,249bc <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   24e68:	2880000b 	ldhu	r2,0(r5)
                                pData += 2;
   24e6c:	b5800104 	addi	r22,r22,4
                                pData[0] = pVarPtr[0];
   24e70:	b0bfff0d 	sth	r2,-4(r22)
                                pData[1] = pVarPtr[1];
   24e74:	2880008b 	ldhu	r2,2(r5)
   24e78:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   24e7c:	003fde06 	br	24df8 <OBJ_Read+0x50c>
                    if ((bitOffset & 0x0F) == 0) 
   24e80:	188003cc 	andi	r2,r3,15
   24e84:	1000011e 	bne	r2,zero,24e8c <OBJ_Read+0x5a0>
                        *pData = 0;
   24e88:	b000000d 	sth	zero,0(r22)
                    if (((pEntry->BitLength & 0xF) > 0)
   24e8c:	b880008b 	ldhu	r2,2(r23)
   24e90:	110003cc 	andi	r4,r2,15
   24e94:	20000526 	beq	r4,zero,24eac <OBJ_Read+0x5c0>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   24e98:	10c5883a 	add	r2,r2,r3
   24e9c:	108003cc 	andi	r2,r2,15
   24ea0:	1000021e 	bne	r2,zero,24eac <OBJ_Read+0x5c0>
                        *pData = 0;
   24ea4:	b000008d 	sth	zero,2(r22)
                        pData++;
   24ea8:	b5800084 	addi	r22,r22,2
   24eac:	0007883a 	mov	r3,zero
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   24eb0:	b880008b 	ldhu	r2,2(r23)
   24eb4:	1005d13a 	srai	r2,r2,4
   24eb8:	108003cc 	andi	r2,r2,15
   24ebc:	18800516 	blt	r3,r2,24ed4 <OBJ_Read+0x5e8>
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   24ec0:	b880010b 	ldhu	r2,4(r23)
   24ec4:	108001cc 	andi	r2,r2,7
   24ec8:	1000061e 	bne	r2,zero,24ee4 <OBJ_Read+0x5f8>
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
   24ecc:	07000184 	movi	fp,6
   24ed0:	003f5706 	br	24c30 <OBJ_Read+0x344>
                        pData++;
   24ed4:	b5800084 	addi	r22,r22,2
                        *pData = 0;
   24ed8:	18c00044 	addi	r3,r3,1
   24edc:	b000000d 	sth	zero,0(r22)
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   24ee0:	003ff306 	br	24eb0 <OBJ_Read+0x5c4>
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   24ee4:	07000684 	movi	fp,26
   24ee8:	003f5106 	br	24c30 <OBJ_Read+0x344>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
   24eec:	07000444 	movi	fp,17
   24ef0:	003eb306 	br	249c0 <OBJ_Read+0xd4>
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   24ef4:	07000684 	movi	fp,26
   24ef8:	003eb106 	br	249c0 <OBJ_Read+0xd4>

00024efc <OBJ_Write>:

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24efc:	3880030b 	ldhu	r2,12(r7)
{
   24f00:	deffec04 	addi	sp,sp,-80
   24f04:	ddc01115 	stw	r23,68(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f08:	1006d23a 	srli	r3,r2,8
    UINT16 maxSubindex = 0;
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   24f0c:	10803fcc 	andi	r2,r2,255
{
   24f10:	dd801015 	stw	r22,64(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f14:	18c003cc 	andi	r3,r3,15
{
   24f18:	dd400f15 	stw	r21,60(sp)
   24f1c:	dd000e15 	stw	r20,56(sp)
   24f20:	dc800c15 	stw	r18,48(sp)
   24f24:	dc000a15 	stw	r16,40(sp)
   24f28:	3825883a 	mov	r18,r7
   24f2c:	dfc01315 	stw	ra,76(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f30:	180f883a 	mov	r7,r3
{
   24f34:	df001215 	stw	fp,72(sp)
   24f38:	dcc00d15 	stw	r19,52(sp)
   24f3c:	dc400b15 	stw	r17,44(sp)
   24f40:	d900010d 	sth	r4,4(sp)
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   24f44:	d880038d 	sth	r2,14(sp)
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
   24f48:	18c001d8 	cmpnei	r3,r3,7
{
   24f4c:	dc001417 	ldw	r16,80(sp)
   24f50:	dd001503 	ldbu	r20,84(sp)
   24f54:	202f883a 	mov	r23,r4
   24f58:	282d883a 	mov	r22,r5
   24f5c:	302b883a 	mov	r21,r6
    UINT16 i = subindex;
   24f60:	2a003fcc 	andi	r8,r5,255
    if ( objCode != OBJCODE_VAR )
   24f64:	1800271e 	bne	r3,zero,25004 <OBJ_Write+0x108>
            maxSubindex = maxConfiguredSubindex;
        }
    }


    if ( bCompleteAccess )
   24f68:	a0007e26 	beq	r20,zero,25164 <OBJ_Write+0x268>
    {
        if ( objCode == OBJCODE_VAR )
        {
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
   24f6c:	07000144 	movi	fp,5
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
    }
    /* ECATCHANGE_END(V5.13) COE4*/

    return 0;
}
   24f70:	e005883a 	mov	r2,fp
   24f74:	dfc01317 	ldw	ra,76(sp)
   24f78:	df001217 	ldw	fp,72(sp)
   24f7c:	ddc01117 	ldw	r23,68(sp)
   24f80:	dd801017 	ldw	r22,64(sp)
   24f84:	dd400f17 	ldw	r21,60(sp)
   24f88:	dd000e17 	ldw	r20,56(sp)
   24f8c:	dcc00d17 	ldw	r19,52(sp)
   24f90:	dc800c17 	ldw	r18,48(sp)
   24f94:	dc400b17 	ldw	r17,44(sp)
   24f98:	dc000a17 	ldw	r16,40(sp)
   24f9c:	dec01404 	addi	sp,sp,80
   24fa0:	f800283a 	ret
    if ( bCompleteAccess )
   24fa4:	a001a21e 	bne	r20,zero,25630 <OBJ_Write+0x734>
   24fa8:	d9c00415 	stw	r7,16(sp)
    if (subindex > maxSubindex)
   24fac:	40bfffcc 	andi	r2,r8,65535
   24fb0:	da000215 	stw	r8,8(sp)
   24fb4:	8c7fffcc 	andi	r17,r17,65535
   24fb8:	88819536 	bltu	r17,r2,25610 <OBJ_Write+0x714>
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24fbc:	b4403fcc 	andi	r17,r22,255
   24fc0:	880b883a 	mov	r5,r17
   24fc4:	9009883a 	mov	r4,r18
   24fc8:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
        if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   24fcc:	10c0010b 	ldhu	r3,4(r2)
   24fd0:	d1666fc3 	ldbu	r5,-26177(gp)
   24fd4:	da000217 	ldw	r8,8(sp)
   24fd8:	193fffcc 	andi	r4,r3,65535
   24fdc:	2005d0ba 	srai	r2,r4,2
   24fe0:	d9c00417 	ldw	r7,16(sp)
   24fe4:	1144703a 	and	r2,r2,r5
   24fe8:	1080038c 	andi	r2,r2,14
   24fec:	1000611e 	bne	r2,zero,25174 <OBJ_Write+0x278>
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
   24ff0:	18c00e0c 	andi	r3,r3,56
   24ff4:	1801881e 	bne	r3,zero,25618 <OBJ_Write+0x71c>
                if (pEntry->ObjAccess == 0)
   24ff8:	203fdc26 	beq	r4,zero,24f6c <OBJ_Write+0x70>
                        return ABORTIDX_READ_ONLY_ENTRY;
   24ffc:	070001c4 	movi	fp,7
   25000:	003fdb06 	br	24f70 <OBJ_Write+0x74>
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   25004:	90c00617 	ldw	r3,24(r18)
   25008:	18c00003 	ldbu	r3,0(r3)
   2500c:	1823883a 	mov	r17,r3
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   25010:	1800331e 	bne	r3,zero,250e0 <OBJ_Write+0x1e4>
   25014:	20f8fc04 	addi	r3,r4,-7184
   25018:	18ffffcc 	andi	r3,r3,65535
   2501c:	18c00830 	cmpltui	r3,r3,32
   25020:	1800081e 	bne	r3,zero,25044 <OBJ_Write+0x148>
   25024:	20fa8004 	addi	r3,r4,-5632
   25028:	18ffffcc 	andi	r3,r3,65535
   2502c:	18c08030 	cmpltui	r3,r3,512
   25030:	1800041e 	bne	r3,zero,25044 <OBJ_Write+0x148>
   25034:	20f98004 	addi	r3,r4,-6656
   25038:	18ffffcc 	andi	r3,r3,65535
   2503c:	18c08028 	cmpgeui	r3,r3,512
   25040:	18001b1e 	bne	r3,zero,250b0 <OBJ_Write+0x1b4>
    if ( bCompleteAccess )
   25044:	a0004926 	beq	r20,zero,2516c <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   25048:	b0c03fcc 	andi	r3,r22,255
   2504c:	18002726 	beq	r3,zero,250ec <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   25050:	1023883a 	mov	r17,r2
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
   25054:	90800617 	ldw	r2,24(r18)
        if(Subindex0 != 0x00)
   25058:	14c00003 	ldbu	r19,0(r2)
   2505c:	9826c03a 	cmpne	r19,r19,zero
    if ( pObjEntry->Write != NULL )
   25060:	90800817 	ldw	r2,32(r18)
   25064:	10005526 	beq	r2,zero,251bc <OBJ_Write+0x2c0>
        result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
   25068:	bdffffcc 	andi	r23,r23,65535
   2506c:	b5803fcc 	andi	r22,r22,255
   25070:	dd000015 	stw	r20,0(sp)
   25074:	800f883a 	mov	r7,r16
   25078:	a80d883a 	mov	r6,r21
   2507c:	b00b883a 	mov	r5,r22
   25080:	b809883a 	mov	r4,r23
   25084:	103ee83a 	callr	r2
   25088:	1039883a 	mov	fp,r2
        if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
   2508c:	10803fcc 	andi	r2,r2,255
   25090:	103fb71e 	bne	r2,zero,24f70 <OBJ_Write+0x74>
   25094:	d0a66617 	ldw	r2,-26216(gp)
   25098:	10001726 	beq	r2,zero,250f8 <OBJ_Write+0x1fc>
            pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   2509c:	a00d883a 	mov	r6,r20
   250a0:	b00b883a 	mov	r5,r22
   250a4:	b809883a 	mov	r4,r23
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   250a8:	103ee83a 	callr	r2
   250ac:	00001206 	br	250f8 <OBJ_Write+0x1fc>
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   250b0:	20ffffcc 	andi	r3,r4,65535
   250b4:	013c0c14 	movui	r4,61488
   250b8:	193fba1e 	bne	r3,r4,24fa4 <OBJ_Write+0xa8>
    if ( bCompleteAccess )
   250bc:	a0002b26 	beq	r20,zero,2516c <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   250c0:	28c03fcc 	andi	r3,r5,255
   250c4:	18000926 	beq	r3,zero,250ec <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   250c8:	1023883a 	mov	r17,r2
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   250cc:	b8bfffcc 	andi	r2,r23,65535
   250d0:	00fc0c14 	movui	r3,61488
   250d4:	10ffdf26 	beq	r2,r3,25054 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   250d8:	0027883a 	mov	r19,zero
   250dc:	003fe006 	br	25060 <OBJ_Write+0x164>
    if ( bCompleteAccess )
   250e0:	a03fb126 	beq	r20,zero,24fa8 <OBJ_Write+0xac>
        if ((subindex == 0) && (dataSize > 0))
   250e4:	28803fcc 	andi	r2,r5,255
   250e8:	1000241e 	bne	r2,zero,2517c <OBJ_Write+0x280>
    if ( pObjEntry->Write != NULL )
   250ec:	90800817 	ldw	r2,32(r18)
        if ((subindex == 0) && (dataSize > 0))
   250f0:	a800031e 	bne	r21,zero,25100 <OBJ_Write+0x204>
    if ( pObjEntry->Write != NULL )
   250f4:	103fdc1e 	bne	r2,zero,25068 <OBJ_Write+0x16c>
           return 0; //no error
   250f8:	0039883a 	mov	fp,zero
   250fc:	003f9c06 	br	24f70 <OBJ_Write+0x74>
    if ( pObjEntry->Write != NULL )
   25100:	103fd91e 	bne	r2,zero,25068 <OBJ_Write+0x16c>
   25104:	84400003 	ldbu	r17,0(r16)
    BOOL bClearSubindex0Required = FALSE;
   25108:	0027883a 	mov	r19,zero
        for (i = subindex; i <= lastSubindex; i++)
   2510c:	88bfffcc 	andi	r2,r17,65535
   25110:	d8800415 	stw	r2,16(sp)
   25114:	40bfffcc 	andi	r2,r8,65535
   25118:	d8800215 	stw	r2,8(sp)
                    if (i == 0 && objCode != OBJCODE_VAR)
   2511c:	38803fcc 	andi	r2,r7,255
   25120:	108001e0 	cmpeqi	r2,r2,7
   25124:	b5403fcc 	andi	r21,r22,255
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
   25128:	070001c4 	movi	fp,7
        UINT8 bWritten = 0;
   2512c:	000d883a 	mov	r6,zero
                    if (i == 0 && objCode != OBJCODE_VAR)
   25130:	d8800515 	stw	r2,20(sp)
        for (i = subindex; i <= lastSubindex; i++)
   25134:	d8800417 	ldw	r2,16(sp)
   25138:	ab7fffcc 	andi	r13,r21,65535
   2513c:	a819883a 	mov	r12,r21
   25140:	1340202e 	bgeu	r2,r13,251c4 <OBJ_Write+0x2c8>
        if (bWritten == 0)
   25144:	31803fcc 	andi	r6,r6,255
   25148:	303f8926 	beq	r6,zero,24f70 <OBJ_Write+0x74>
    if (pAPPL_CoeWriteInd != NULL)
   2514c:	d0a66617 	ldw	r2,-26216(gp)
   25150:	103fe926 	beq	r2,zero,250f8 <OBJ_Write+0x1fc>
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   25154:	a00d883a 	mov	r6,r20
   25158:	b1403fcc 	andi	r5,r22,255
   2515c:	b93fffcc 	andi	r4,r23,65535
   25160:	003fd106 	br	250a8 <OBJ_Write+0x1ac>
    UINT16 maxSubindex = 0;
   25164:	0023883a 	mov	r17,zero
   25168:	003f8f06 	br	24fa8 <OBJ_Write+0xac>
            maxSubindex = maxConfiguredSubindex;
   2516c:	1023883a 	mov	r17,r2
   25170:	003f8d06 	br	24fa8 <OBJ_Write+0xac>
    if((subindex > 0) &&
   25174:	88000e26 	beq	r17,zero,251b0 <OBJ_Write+0x2b4>
    UINT16 lastSubindex = subindex;
   25178:	4023883a 	mov	r17,r8
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   2517c:	b8b8fc04 	addi	r2,r23,-7184
    if((subindex > 0) &&
   25180:	10bfffcc 	andi	r2,r2,65535
   25184:	10800830 	cmpltui	r2,r2,32
   25188:	103fb21e 	bne	r2,zero,25054 <OBJ_Write+0x158>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   2518c:	b8ba8004 	addi	r2,r23,-5632
   25190:	10bfffcc 	andi	r2,r2,65535
   25194:	10808030 	cmpltui	r2,r2,512
   25198:	103fae1e 	bne	r2,zero,25054 <OBJ_Write+0x158>
   2519c:	b8b98004 	addi	r2,r23,-6656
   251a0:	10bfffcc 	andi	r2,r2,65535
   251a4:	10808030 	cmpltui	r2,r2,512
   251a8:	103fc826 	beq	r2,zero,250cc <OBJ_Write+0x1d0>
   251ac:	003fa906 	br	25054 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   251b0:	b027883a 	mov	r19,r22
    UINT16 lastSubindex = subindex;
   251b4:	0023883a 	mov	r17,zero
   251b8:	003fa906 	br	25060 <OBJ_Write+0x164>
        if (dataSize == 0)
   251bc:	a83fd31e 	bne	r21,zero,2510c <OBJ_Write+0x210>
   251c0:	003fcd06 	br	250f8 <OBJ_Write+0x1fc>
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   251c4:	91c00617 	ldw	r7,24(r18)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   251c8:	a80b883a 	mov	r5,r21
   251cc:	9009883a 	mov	r4,r18
   251d0:	db400915 	stw	r13,36(sp)
   251d4:	d9800715 	stw	r6,28(sp)
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   251d8:	db000815 	stw	r12,32(sp)
   251dc:	d9c00615 	stw	r7,24(sp)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   251e0:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   251e4:	900b883a 	mov	r5,r18
   251e8:	a809883a 	mov	r4,r21
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   251ec:	1023883a 	mov	r17,r2
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   251f0:	00246240 	call	24624 <OBJ_GetEntryOffset>
            if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   251f4:	8900010b 	ldhu	r4,4(r17)
   251f8:	d1666fc3 	ldbu	r5,-26177(gp)
   251fc:	d9800717 	ldw	r6,28(sp)
   25200:	2009d0ba 	srai	r4,r4,2
   25204:	db400917 	ldw	r13,36(sp)
   25208:	2148703a 	and	r4,r4,r5
   2520c:	2100038c 	andi	r4,r4,14
   25210:	2000f026 	beq	r4,zero,255d4 <OBJ_Write+0x6d8>
                if (i != 0)
   25214:	d9c00617 	ldw	r7,24(sp)
   25218:	db000817 	ldw	r12,32(sp)
   2521c:	68000926 	beq	r13,zero,25244 <OBJ_Write+0x348>
                    pVarPtr += (bitOffset >> 4);
   25220:	1008d0fa 	srli	r4,r2,3
                if ( i == subindex                                     /* requested entry */
   25224:	d8c00217 	ldw	r3,8(sp)
                    pVarPtr += (bitOffset >> 4);
   25228:	2107ff8c 	andi	r4,r4,8190
   2522c:	390f883a 	add	r7,r7,r4
                if ( i == subindex                                     /* requested entry */
   25230:	1b400f26 	beq	r3,r13,25270 <OBJ_Write+0x374>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25234:	a0000126 	beq	r20,zero,2523c <OBJ_Write+0x340>
   25238:	68c00d2e 	bgeu	r13,r3,25270 <OBJ_Write+0x374>
        for (i = subindex; i <= lastSubindex; i++)
   2523c:	ad400044 	addi	r21,r21,1
   25240:	003fbc06 	br	25134 <OBJ_Write+0x238>
                if ( i == subindex                                     /* requested entry */
   25244:	d8c00217 	ldw	r3,8(sp)
   25248:	183ffc1e 	bne	r3,zero,2523c <OBJ_Write+0x340>
                    if (i == 0 && objCode != OBJCODE_VAR)
   2524c:	d8c00517 	ldw	r3,20(sp)
   25250:	1800071e 	bne	r3,zero,25270 <OBJ_Write+0x374>
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25254:	8100000b 	ldhu	r4,0(r16)
                        if(maxConfiguredSubindex < NewSubindex0)
   25258:	d880038b 	ldhu	r2,14(sp)
   2525c:	21403fcc 	andi	r5,r4,255
   25260:	1140ef36 	bltu	r2,r5,25620 <OBJ_Write+0x724>
                        pVarPtr[0] = SWAPWORD(pData[0]);
   25264:	3900000d 	sth	r4,0(r7)
                            pData++;
   25268:	84000084 	addi	r16,r16,2
                            break;
   2526c:	00008d06 	br	254a4 <OBJ_Write+0x5a8>
                        UINT16 dataType = pEntry->DataType;
   25270:	8980000b 	ldhu	r6,0(r17)
                        if (pEntry->DataType >= 0x700)
   25274:	313fffcc 	andi	r4,r6,65535
   25278:	2141c030 	cmpltui	r5,r4,1792
   2527c:	2800341e 	bne	r5,zero,25350 <OBJ_Write+0x454>
                            if ( pEntry->BitLength <= 8 )
   25280:	8980008b 	ldhu	r6,2(r17)
   25284:	313fffcc 	andi	r4,r6,65535
   25288:	21400268 	cmpgeui	r5,r4,9
   2528c:	28002a1e 	bne	r5,zero,25338 <OBJ_Write+0x43c>
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   25290:	31800bc4 	addi	r6,r6,47
                        switch (dataType)
   25294:	31bff884 	addi	r6,r6,-30
   25298:	31bfffcc 	andi	r6,r6,65535
   2529c:	01000044 	movi	r4,1
   252a0:	2188983a 	sll	r4,r4,r6
   252a4:	0140ff74 	movhi	r5,1021
   252a8:	29600044 	addi	r5,r5,-32767
   252ac:	214a703a 	and	r5,r4,r5
   252b0:	2800681e 	bne	r5,zero,25454 <OBJ_Write+0x558>
   252b4:	014000b4 	movhi	r5,2
   252b8:	29400104 	addi	r5,r5,4
   252bc:	214a703a 	and	r5,r4,r5
   252c0:	2800b41e 	bne	r5,zero,25594 <OBJ_Write+0x698>
   252c4:	01400074 	movhi	r5,1
   252c8:	29400084 	addi	r5,r5,2
   252cc:	2148703a 	and	r4,r4,r5
   252d0:	20001d26 	beq	r4,zero,25348 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   252d4:	108003cc 	andi	r2,r2,15
   252d8:	103f241e 	bne	r2,zero,24f6c <OBJ_Write+0x70>
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   252dc:	98803fcc 	andi	r2,r19,255
                            UINT16 u16NewData = SWAPWORD(pData[0]);
   252e0:	8440000b 	ldhu	r17,0(r16)
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   252e4:	10000326 	beq	r2,zero,252f4 <OBJ_Write+0x3f8>
   252e8:	3900000b 	ldhu	r4,0(r7)
   252ec:	88bfffcc 	andi	r2,r17,65535
   252f0:	2080cd1e 	bne	r4,r2,25628 <OBJ_Write+0x72c>
                            if(IS_PDO_ASSIGN(index))  //PDO assign
   252f4:	d8800117 	ldw	r2,4(sp)
   252f8:	10b8fc04 	addi	r2,r2,-7184
   252fc:	10bfffcc 	andi	r2,r2,65535
   25300:	10800828 	cmpgeui	r2,r2,32
   25304:	1000721e 	bne	r2,zero,254d0 <OBJ_Write+0x5d4>
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
   25308:	88ba8004 	addi	r2,r17,-5632
   2530c:	10bfffcc 	andi	r2,r2,65535
   25310:	10808030 	cmpltui	r2,r2,512
   25314:	1000821e 	bne	r2,zero,25520 <OBJ_Write+0x624>
   25318:	88b98004 	addi	r2,r17,-6656
   2531c:	10bfffcc 	andi	r2,r2,65535
   25320:	10808030 	cmpltui	r2,r2,512
   25324:	10007e1e 	bne	r2,zero,25520 <OBJ_Write+0x624>
   25328:	88bfffcc 	andi	r2,r17,65535
   2532c:	10007c26 	beq	r2,zero,25520 <OBJ_Write+0x624>
                                    return ABORTIDX_VALUE_EXCEEDED;
   25330:	07000484 	movi	fp,18
   25334:	003f0e06 	br	24f70 <OBJ_Write+0x74>
                            else if ( pEntry->BitLength == 16 )
   25338:	21400420 	cmpeqi	r5,r4,16
   2533c:	283fe51e 	bne	r5,zero,252d4 <OBJ_Write+0x3d8>
                            else if ( pEntry->BitLength == 32 )
   25340:	21000820 	cmpeqi	r4,r4,32
   25344:	2000931e 	bne	r4,zero,25594 <OBJ_Write+0x698>
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25348:	07000604 	movi	fp,24
   2534c:	003f0806 	br	24f70 <OBJ_Write+0x74>
                        switch (dataType)
   25350:	21400328 	cmpgeui	r5,r4,12
   25354:	28000d1e 	bne	r5,zero,2538c <OBJ_Write+0x490>
   25358:	214002a8 	cmpgeui	r5,r4,10
   2535c:	2800241e 	bne	r5,zero,253f0 <OBJ_Write+0x4f4>
   25360:	21400260 	cmpeqi	r5,r4,9
   25364:	2800221e 	bne	r5,zero,253f0 <OBJ_Write+0x4f4>
   25368:	20002d26 	beq	r4,zero,25420 <OBJ_Write+0x524>
   2536c:	01400044 	movi	r5,1
   25370:	2908983a 	sll	r4,r5,r4
   25374:	2140640c 	andi	r5,r4,400
   25378:	2800861e 	bne	r5,zero,25594 <OBJ_Write+0x698>
   2537c:	2140098c 	andi	r5,r4,38
   25380:	2800341e 	bne	r5,zero,25454 <OBJ_Write+0x558>
   25384:	2100120c 	andi	r4,r4,72
   25388:	003fd106 	br	252d0 <OBJ_Write+0x3d4>
   2538c:	21400e28 	cmpgeui	r5,r4,56
   25390:	2800131e 	bne	r5,zero,253e0 <OBJ_Write+0x4e4>
   25394:	214007a8 	cmpgeui	r5,r4,30
   25398:	283fbe1e 	bne	r5,zero,25294 <OBJ_Write+0x398>
   2539c:	31bffecc 	andi	r6,r6,65531
   253a0:	31800460 	cmpeqi	r6,r6,17
   253a4:	3000021e 	bne	r6,zero,253b0 <OBJ_Write+0x4b4>
   253a8:	210006e0 	cmpeqi	r4,r4,27
   253ac:	203fe626 	beq	r4,zero,25348 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   253b0:	108003cc 	andi	r2,r2,15
   253b4:	103eed1e 	bne	r2,zero,24f6c <OBJ_Write+0x70>
                            pVarPtr[0] = pData[0];
   253b8:	8080000b 	ldhu	r2,0(r16)
                            pData += 4;
   253bc:	84000204 	addi	r16,r16,8
                            pVarPtr[0] = pData[0];
   253c0:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   253c4:	80bffe8b 	ldhu	r2,-6(r16)
   253c8:	3880008d 	sth	r2,2(r7)
                            pVarPtr[2] = pData[2];
   253cc:	80bfff0b 	ldhu	r2,-4(r16)
   253d0:	3880010d 	sth	r2,4(r7)
                            pVarPtr[3] = pData[3];
   253d4:	80bfff8b 	ldhu	r2,-2(r16)
   253d8:	3880018d 	sth	r2,6(r7)
                            break;
   253dc:	00003106 	br	254a4 <OBJ_Write+0x5a8>
                        switch (dataType)
   253e0:	31bf6804 	addi	r6,r6,-608
   253e4:	31bfffcc 	andi	r6,r6,65535
   253e8:	31800128 	cmpgeui	r6,r6,4
   253ec:	303fd61e 	bne	r6,zero,25348 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   253f0:	108003cc 	andi	r2,r2,15
   253f4:	103edd1e 	bne	r2,zero,24f6c <OBJ_Write+0x70>
                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
   253f8:	8980008b 	ldhu	r6,2(r17)
   253fc:	800b883a 	mov	r5,r16
   25400:	3809883a 	mov	r4,r7
   25404:	318001c4 	addi	r6,r6,7
   25408:	300cd0fa 	srli	r6,r6,3
   2540c:	0026e840 	call	26e84 <memcpy>
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25410:	8880008b 	ldhu	r2,2(r17)
   25414:	1004d13a 	srli	r2,r2,4
   25418:	1004907a 	slli	r2,r2,1
   2541c:	00000b06 	br	2544c <OBJ_Write+0x550>
                            if(bCompleteAccess)
   25420:	a03fc926 	beq	r20,zero,25348 <OBJ_Write+0x44c>
                                if (((pEntry->BitLength & 0xF) > 0)
   25424:	8900008b 	ldhu	r4,2(r17)
   25428:	218003cc 	andi	r6,r4,15
   2542c:	217fffcc 	andi	r5,r4,65535
   25430:	30000426 	beq	r6,zero,25444 <OBJ_Write+0x548>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25434:	2089883a 	add	r4,r4,r2
   25438:	210003cc 	andi	r4,r4,15
   2543c:	2000011e 	bne	r4,zero,25444 <OBJ_Write+0x548>
                                    pData++;
   25440:	84000084 	addi	r16,r16,2
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
   25444:	2804d0fa 	srli	r2,r5,3
   25448:	1080078c 	andi	r2,r2,30
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   2544c:	80a1883a 	add	r16,r16,r2
                            break;
   25450:	00001406 	br	254a4 <OBJ_Write+0x5a8>
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25454:	8940008b 	ldhu	r5,2(r17)
   25458:	010000f4 	movhi	r4,3
   2545c:	130003cc 	andi	r12,r2,15
   25460:	280a907a 	slli	r5,r5,1
                            TmpValue &= ~bitMask;
   25464:	3b80000b 	ldhu	r14,0(r7)
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25468:	2909883a 	add	r4,r5,r4
   2546c:	2125e08b 	ldhu	r4,-26750(r4)
   25470:	217fffcc 	andi	r5,r4,65535
   25474:	2b1a983a 	sll	r13,r5,r12
                            TmpValue &= ~bitMask;
   25478:	034c303a 	nor	r6,zero,r13
   2547c:	338c703a 	and	r6,r6,r14
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25480:	8380000b 	ldhu	r14,0(r16)
                            if (bCompleteAccess) 
   25484:	a0000926 	beq	r20,zero,254ac <OBJ_Write+0x5b0>
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
   25488:	6b9a703a 	and	r13,r13,r14
   2548c:	3348b03a 	or	r4,r6,r13
                            pVarPtr[0] = SWAPWORD(TmpValue);
   25490:	3900000d 	sth	r4,0(r7)
                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
   25494:	8900008b 	ldhu	r4,2(r17)
   25498:	2085883a 	add	r2,r4,r2
   2549c:	108003cc 	andi	r2,r2,15
   254a0:	103f7126 	beq	r2,zero,25268 <OBJ_Write+0x36c>
                    bWritten = 1;
   254a4:	01800044 	movi	r6,1
   254a8:	003f6406 	br	2523c <OBJ_Write+0x340>
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
   254ac:	014a303a 	nor	r5,zero,r5
   254b0:	737fffcc 	andi	r13,r14,65535
   254b4:	2b4a703a 	and	r5,r5,r13
   254b8:	283f9d1e 	bne	r5,zero,25330 <OBJ_Write+0x434>
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
   254bc:	2388703a 	and	r4,r4,r14
   254c0:	213fffcc 	andi	r4,r4,65535
   254c4:	2308983a 	sll	r4,r4,r12
   254c8:	3108b03a 	or	r4,r6,r4
   254cc:	003ff006 	br	25490 <OBJ_Write+0x594>
                            if(index == 0x1C32 || index == 0x1C33)
   254d0:	d8800117 	ldw	r2,4(sp)
   254d4:	10b8f384 	addi	r2,r2,-7218
   254d8:	10bfffcc 	andi	r2,r2,65535
   254dc:	108000b0 	cmpltui	r2,r2,2
   254e0:	10000f26 	beq	r2,zero,25520 <OBJ_Write+0x624>
                               if (i == 1) /* "Synchronisation type" written */
   254e4:	633fffcc 	andi	r12,r12,65535
   254e8:	60800058 	cmpnei	r2,r12,1
   254ec:	10000e1e 	bne	r2,zero,25528 <OBJ_Write+0x62c>
                                  if (pVarPtr[0] != u16NewData)
   254f0:	3880000b 	ldhu	r2,0(r7)
   254f4:	897fffcc 	andi	r5,r17,65535
   254f8:	11400726 	beq	r2,r5,25518 <OBJ_Write+0x61c>
                                     result = CheckSyncTypeValue(index, u16NewData);
   254fc:	d900010b 	ldhu	r4,4(sp)
   25500:	d9c00615 	stw	r7,24(sp)
   25504:	00247e00 	call	247e0 <CheckSyncTypeValue>
   25508:	1039883a 	mov	fp,r2
                                     if (result != 0)
   2550c:	10803fcc 	andi	r2,r2,255
   25510:	d9c00617 	ldw	r7,24(sp)
   25514:	103e961e 	bne	r2,zero,24f70 <OBJ_Write+0x74>
                                  bSyncSetByUser = TRUE;
   25518:	00800044 	movi	r2,1
   2551c:	d0a68685 	stb	r2,-26086(gp)
                            pVarPtr[0] = u16NewData;
   25520:	3c40000d 	sth	r17,0(r7)
   25524:	003f5006 	br	25268 <OBJ_Write+0x36c>
                               if (i == 8) /* "Get Cycle Time" written*/
   25528:	63000218 	cmpnei	r12,r12,8
   2552c:	603ffc1e 	bne	r12,zero,25520 <OBJ_Write+0x624>
                                   sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   25530:	008000f4 	movhi	r2,3
   25534:	10330015 	stw	zero,-13312(r2)
                                   sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25538:	008000b4 	movhi	r2,2
   2553c:	10a1a804 	addi	r2,r2,-31072
   25540:	010000f4 	movhi	r4,3
   25544:	20b2ff15 	stw	r2,-13316(r4)
                                   sSyncManOutPar.u32CycleTime = 0;
   25548:	010000f4 	movhi	r4,3
   2554c:	2032fc15 	stw	zero,-13328(r4)
                                   sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   25550:	010000f4 	movhi	r4,3
   25554:	2032ef15 	stw	zero,-13380(r4)
                                   sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25558:	010000f4 	movhi	r4,3
   2555c:	20b2ee15 	stw	r2,-13384(r4)
                                   sSyncManInPar.u32CycleTime = 0;
   25560:	008000f4 	movhi	r2,3
   25564:	1032eb15 	stw	zero,-13396(r2)
                                  if ((u16NewData & 0x2) == 0x2)
   25568:	8880008c 	andi	r2,r17,2
   2556c:	103fec26 	beq	r2,zero,25520 <OBJ_Write+0x624>
                                     sSyncManOutPar.u16SmEventMissedCounter = 0;
   25570:	008000f4 	movhi	r2,3
   25574:	10330515 	stw	zero,-13292(r2)
                                     sSyncManOutPar.u8SyncError = 0;
   25578:	008000f4 	movhi	r2,3
   2557c:	10330b05 	stb	zero,-13268(r2)
                                     sSyncManInPar.u16SmEventMissedCounter = 0;
   25580:	008000f4 	movhi	r2,3
   25584:	1032f415 	stw	zero,-13360(r2)
                                     sSyncManInPar.u8SyncError = 0;
   25588:	008000f4 	movhi	r2,3
   2558c:	1032fa05 	stb	zero,-13336(r2)
   25590:	003fe306 	br	25520 <OBJ_Write+0x624>
                            if(bitOffset & 0xF)
   25594:	108003cc 	andi	r2,r2,15
   25598:	103e741e 	bne	r2,zero,24f6c <OBJ_Write+0x70>
                            if(bClearSubindex0Required && 
   2559c:	99003fcc 	andi	r4,r19,255
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   255a0:	8080000b 	ldhu	r2,0(r16)
                            if(bClearSubindex0Required && 
   255a4:	20000626 	beq	r4,zero,255c0 <OBJ_Write+0x6c4>
   255a8:	3940000b 	ldhu	r5,0(r7)
   255ac:	113fffcc 	andi	r4,r2,65535
   255b0:	29001d1e 	bne	r5,r4,25628 <OBJ_Write+0x72c>
                                || (pVarPtr[1] != pData[1])))
   255b4:	3940008b 	ldhu	r5,2(r7)
   255b8:	8100008b 	ldhu	r4,2(r16)
   255bc:	29001a1e 	bne	r5,r4,25628 <OBJ_Write+0x72c>
                            pVarPtr[0] = pData[0];
   255c0:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   255c4:	8080008b 	ldhu	r2,2(r16)
                            pData += 2;
   255c8:	84000104 	addi	r16,r16,4
                            pVarPtr[1] = pData[1];
   255cc:	3880008d 	sth	r2,2(r7)
                            break;
   255d0:	003fb406 	br	254a4 <OBJ_Write+0x5a8>
                if(i == 0)
   255d4:	6800031e 	bne	r13,zero,255e4 <OBJ_Write+0x6e8>
                    pData++;
   255d8:	84000084 	addi	r16,r16,2
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   255dc:	07000604 	movi	fp,24
   255e0:	003f1606 	br	2523c <OBJ_Write+0x340>
                    if (((pEntry->BitLength & 0xF) > 0)
   255e4:	88c0008b 	ldhu	r3,2(r17)
   255e8:	190003cc 	andi	r4,r3,15
   255ec:	20000426 	beq	r4,zero,25600 <OBJ_Write+0x704>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   255f0:	1885883a 	add	r2,r3,r2
   255f4:	108003cc 	andi	r2,r2,15
   255f8:	1000011e 	bne	r2,zero,25600 <OBJ_Write+0x704>
                        pData++;
   255fc:	84000084 	addi	r16,r16,2
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
   25600:	1806d0fa 	srli	r3,r3,3
   25604:	18c7ff8c 	andi	r3,r3,8190
   25608:	80e1883a 	add	r16,r16,r3
   2560c:	003ff306 	br	255dc <OBJ_Write+0x6e0>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25610:	07000444 	movi	fp,17
   25614:	003e5606 	br	24f70 <OBJ_Write+0x74>
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25618:	07000684 	movi	fp,26
   2561c:	003e5406 	br	24f70 <OBJ_Write+0x74>
                            return ABORTIDX_VALUE_TOO_GREAT;
   25620:	070004c4 	movi	fp,19
   25624:	003e5206 	br	24f70 <OBJ_Write+0x74>
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
   25628:	07000704 	movi	fp,28
   2562c:	003e5006 	br	24f70 <OBJ_Write+0x74>
        if ((subindex == 0) && (dataSize > 0))
   25630:	b0803fcc 	andi	r2,r22,255
   25634:	103ead26 	beq	r2,zero,250ec <OBJ_Write+0x1f0>
   25638:	003ea706 	br	250d8 <OBJ_Write+0x1dc>

0002563c <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
   2563c:	defffe04 	addi	sp,sp,-8
   25640:	dc000015 	stw	r16,0(sp)
   25644:	dc000317 	ldw	r16,12(sp)
	/* for an upload segment response the toggle bit was overwritten */
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25648:	29403fcc 	andi	r5,r5,255
{
   2564c:	dfc00115 	stw	ra,4(sp)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
	}
	if (abort == 0)
	{
		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25650:	8080018b 	ldhu	r2,6(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25654:	28c01818 	cmpnei	r3,r5,96
{
   25658:	da000217 	ldw	r8,8(sp)
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   2565c:	1083ffcc 	andi	r2,r2,4095
   25660:	21003fcc 	andi	r4,r4,255
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25664:	18000d1e 	bne	r3,zero,2569c <SdoRes+0x60>
	if (abort == 0)
   25668:	20003f1e 	bne	r4,zero,25768 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   2566c:	108c0014 	ori	r2,r2,12288
   25670:	8080018d 	sth	r2,6(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
	}

	// HBu 02.05.06: if the CoE-response could not be sent because the
	//               send mailbox is full it should be stored
	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
   25674:	01400084 	movi	r5,2
   25678:	8009883a 	mov	r4,r16
   2567c:	0023d280 	call	23d28 <MBX_MailboxSendReq>
   25680:	10803fcc 	andi	r2,r2,255
   25684:	10000126 	beq	r2,zero,2568c <SdoRes+0x50>
	{
		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
   25688:	d4266915 	stw	r16,-26204(gp)
	}
}
   2568c:	dfc00117 	ldw	ra,4(sp)
   25690:	dc000017 	ldw	r16,0(sp)
   25694:	dec00204 	addi	sp,sp,8
   25698:	f800283a 	ret
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   2569c:	80c0020b 	ldhu	r3,8(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   256a0:	2800081e 	bne	r5,zero,256c4 <SdoRes+0x88>
	if (abort == 0)
   256a4:	2000301e 	bne	r4,zero,25768 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   256a8:	108c0014 	ori	r2,r2,12288
   256ac:	8080018d 	sth	r2,6(r16)
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   256b0:	00800284 	movi	r2,10
   256b4:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   256b8:	18c00814 	ori	r3,r3,32
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   256bc:	80c0020d 	sth	r3,8(r16)
   256c0:	003fec06 	br	25674 <SdoRes+0x38>
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
   256c4:	027fc004 	movi	r9,-256
   256c8:	1a46703a 	and	r3,r3,r9
   256cc:	80c0020d 	sth	r3,8(r16)
	if (abort == 0)
   256d0:	2000251e 	bne	r4,zero,25768 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   256d4:	108c0014 	ori	r2,r2,12288
   256d8:	8080018d 	sth	r2,6(r16)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   256dc:	29401018 	cmpnei	r5,r5,64
   256e0:	28001d1e 	bne	r5,zero,25758 <SdoRes+0x11c>
			if ((objLength <= 4) && (objLength > 0))
   256e4:	40bfffc4 	addi	r2,r8,-1
   256e8:	10800128 	cmpgeui	r2,r2,4
   256ec:	10000c1e 	bne	r2,zero,25720 <SdoRes+0xe4>
				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
   256f0:	00800284 	movi	r2,10
   256f4:	8080000d 	sth	r2,0(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   256f8:	00800104 	movi	r2,4
   256fc:	1205c83a 	sub	r2,r2,r8
   25700:	100490ba 	slli	r2,r2,2
   25704:	318000d4 	ori	r6,r6,3
   25708:	31803fcc 	andi	r6,r6,255
   2570c:	1184b03a 	or	r2,r2,r6
   25710:	1884b03a 	or	r2,r3,r2
   25714:	10801014 	ori	r2,r2,64
   25718:	8080020d 	sth	r2,8(r16)
   2571c:	003fd506 	br	25674 <SdoRes+0x38>
				if (dataSize < objLength)
   25720:	38bfffcc 	andi	r2,r7,65535
   25724:	12000a2e 	bgeu	r2,r8,25750 <SdoRes+0x114>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25728:	39c00284 	addi	r7,r7,10
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
   2572c:	8200030d 	sth	r8,12(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25730:	31801054 	ori	r6,r6,65
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25734:	4010d43a 	srli	r8,r8,16
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25738:	31803fcc 	andi	r6,r6,255
   2573c:	198cb03a 	or	r6,r3,r6
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25740:	81c0000d 	sth	r7,0(r16)
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25744:	8200038d 	sth	r8,14(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25748:	8180020d 	sth	r6,8(r16)
   2574c:	003fc906 	br	25674 <SdoRes+0x38>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
   25750:	41c00284 	addi	r7,r8,10
   25754:	003ff506 	br	2572c <SdoRes+0xf0>
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   25758:	00800284 	movi	r2,10
   2575c:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   25760:	18c01814 	ori	r3,r3,96
   25764:	003fd506 	br	256bc <SdoRes+0x80>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
   25768:	10880014 	ori	r2,r2,8192
   2576c:	8080018d 	sth	r2,6(r16)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   25770:	8080020b 	ldhu	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25774:	200890ba 	slli	r4,r4,2
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   25778:	00c00284 	movi	r3,10
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   2577c:	10802014 	ori	r2,r2,128
   25780:	8080020d 	sth	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25784:	008000f4 	movhi	r2,3
   25788:	2085883a 	add	r2,r4,r2
   2578c:	10a5e917 	ldw	r2,-26716(r2)
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   25790:	80c0000d 	sth	r3,0(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25794:	80800315 	stw	r2,12(r16)
   25798:	003fb606 	br	25674 <SdoRes+0x38>

0002579c <SDOS_SdoInd>:
			is received from the master and calls depending from
			the command the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
{
   2579c:	defff004 	addi	sp,sp,-64
   257a0:	dd000a15 	stw	r20,40(sp)
	/* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
	UINT8 bCompleteAccess = 0;
	UINT32 objLength = 0;
	UINT32 dataSize = 0;

	if (bSdoInWork)
   257a4:	d5268cc3 	ldbu	r20,-26061(gp)
{
   257a8:	dd400b15 	stw	r21,44(sp)
	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK) >> SDOHEADER_COMMANDSHIFT;
   257ac:	2540020b 	ldhu	r21,8(r4)
{
   257b0:	dc800815 	stw	r18,32(sp)
   257b4:	dfc00f15 	stw	ra,60(sp)
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   257b8:	04bff804 	movi	r18,-32
{
   257bc:	df000e15 	stw	fp,56(sp)
   257c0:	ddc00d15 	stw	r23,52(sp)
   257c4:	dd800c15 	stw	r22,48(sp)
   257c8:	dcc00915 	stw	r19,36(sp)
   257cc:	dc400715 	stw	r17,28(sp)
   257d0:	dc000615 	stw	r16,24(sp)
	if (bSdoInWork)
   257d4:	a0803fcc 	andi	r2,r20,255
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   257d8:	9564703a 	and	r18,r18,r21
	if (bSdoInWork)
   257dc:	1002021e 	bne	r2,zero,25fe8 <SDOS_SdoInd+0x84c>
   257e0:	a880040c 	andi	r2,r21,16
	{
		bCompleteAccess = 1;
	}
/* ECATCHANGE_END(V5.13) COE5*/

	switch (command)
   257e4:	94803fcc 	andi	r18,r18,255
	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
   257e8:	2440000b 	ldhu	r17,0(r4)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   257ec:	2021883a 	mov	r16,r4
   257f0:	d8800315 	stw	r2,12(sp)
	switch (command)
   257f4:	91001020 	cmpeqi	r4,r18,64
   257f8:	2000161e 	bne	r4,zero,25854 <SDOS_SdoInd+0xb8>
   257fc:	91001068 	cmpgeui	r4,r18,65
   25800:	2000071e 	bne	r4,zero,25820 <SDOS_SdoInd+0x84>
   25804:	9000fe26 	beq	r18,zero,25c00 <SDOS_SdoInd+0x464>
   25808:	90800820 	cmpeqi	r2,r18,32
   2580c:	1000111e 	bne	r2,zero,25854 <SDOS_SdoInd+0xb8>
		}
		break;

	case SDOSERVICE_DOWNLOADSEGMENTREQ:
	case SDOSERVICE_UPLOADSEGMENTREQ:
		if (command == nSdoSegService)
   25810:	0013883a 	mov	r9,zero
   25814:	0039883a 	mov	fp,zero
   25818:	044000c4 	movi	r17,3
   2581c:	00008206 	br	25a28 <SDOS_SdoInd+0x28c>
	switch (command)
   25820:	90801820 	cmpeqi	r2,r18,96
   25824:	103ffa26 	beq	r2,zero,25810 <SDOS_SdoInd+0x74>
		if (command == nSdoSegService)
   25828:	d0a68c83 	ldbu	r2,-26062(gp)
   2582c:	10801818 	cmpnei	r2,r2,96
   25830:	103ff71e 	bne	r2,zero,25810 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25834:	80800203 	ldbu	r2,8(r16)
   25838:	d1268903 	ldbu	r4,-26076(gp)
   2583c:	15c0040c 	andi	r23,r2,16
   25840:	25c1801e 	bne	r4,r23,25e44 <SDOS_SdoInd+0x6a8>
	UINT32 dataSize = 0;
   25844:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25848:	0039883a 	mov	fp,zero
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   2584c:	04400044 	movi	r17,1
   25850:	00007506 	br	25a28 <SDOS_SdoInd+0x28c>
		index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
   25854:	8580028b 	ldhu	r22,10(r16)
		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT) & SDOHEADER_INDEXLOMASK;
   25858:	acffffcc 	andi	r19,r21,65535
   2585c:	9826d23a 	srli	r19,r19,8
   25860:	b004923a 	slli	r2,r22,8
   25864:	98a7883a 	add	r19,r19,r2
		pObjEntry = OBJ_GetObjectHandle(index);
   25868:	98bfffcc 	andi	r2,r19,65535
   2586c:	1009883a 	mov	r4,r2
   25870:	d8800215 	stw	r2,8(sp)
   25874:	00240e00 	call	240e0 <OBJ_GetObjectHandle>
   25878:	102f883a 	mov	r23,r2
		if (pObjEntry)
   2587c:	1001d226 	beq	r2,zero,25fc8 <SDOS_SdoInd+0x82c>
		subindex = (pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT) & SDOHEADER_SUBINDEXMASK;
   25880:	b0bfffcc 	andi	r2,r22,65535
   25884:	102cd23a 	srli	r22,r2,8
				if (subindex > maxSubindex)
   25888:	b9000303 	ldbu	r4,12(r23)
   2588c:	2581d236 	bltu	r4,r22,25fd8 <SDOS_SdoInd+0x83c>
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25890:	a880040c 	andi	r2,r21,16
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25894:	b17fffcc 	andi	r5,r22,65535
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25898:	1004c03a 	cmpne	r2,r2,zero
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   2589c:	a9c0040c 	andi	r7,r21,16
   258a0:	b80d883a 	mov	r6,r23
   258a4:	993fffcc 	andi	r4,r19,65535
   258a8:	d9400415 	stw	r5,16(sp)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258ac:	d8800215 	stw	r2,8(sp)
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   258b0:	002411c0 	call	2411c <OBJ_GetObjectLength>
   258b4:	1039883a 	mov	fp,r2
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   258b8:	90801018 	cmpnei	r2,r18,64
   258bc:	d9400417 	ldw	r5,16(sp)
   258c0:	8c7fffcc 	andi	r17,r17,65535
   258c4:	1000151e 	bne	r2,zero,2591c <SDOS_SdoInd+0x180>
						if (mbxSize != EXPEDITED_FRAME_SIZE)
   258c8:	88800298 	cmpnei	r2,r17,10
   258cc:	1001c81e 	bne	r2,zero,25ff0 <SDOS_SdoInd+0x854>
						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
   258d0:	e0bfffc4 	addi	r2,fp,-1
   258d4:	10800128 	cmpgeui	r2,r2,4
   258d8:	1000081e 	bne	r2,zero,258fc <SDOS_SdoInd+0x160>
							pData[0] = 0;
   258dc:	8000030d 	sth	zero,12(r16)
							pData[1] = 0;
   258e0:	8000038d 	sth	zero,14(r16)
			if ((abort == 0) && (bCompleteAccess == 1))
   258e4:	a880040c 	andi	r2,r21,16
   258e8:	1001e626 	beq	r2,zero,26084 <SDOS_SdoInd+0x8e8>
				if (subindex > 1)
   258ec:	288000a8 	cmpgeui	r2,r5,2
   258f0:	1001e426 	beq	r2,zero,26084 <SDOS_SdoInd+0x8e8>
   258f4:	e013883a 	mov	r9,fp
   258f8:	0001e006 	br	2607c <SDOS_SdoInd+0x8e0>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   258fc:	d2a6848b 	ldhu	r10,-26094(gp)
   25900:	52bffc04 	addi	r10,r10,-16
							if (dataSize < objLength)
   25904:	57007336 	bltu	r10,fp,25ad4 <SDOS_SdoInd+0x338>
			if ((abort == 0) && (bCompleteAccess == 1))
   25908:	a880040c 	andi	r2,r21,16
								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
   2590c:	83000404 	addi	r12,r16,16
			if ((abort == 0) && (bCompleteAccess == 1))
   25910:	10004f26 	beq	r2,zero,25a50 <SDOS_SdoInd+0x2b4>
   25914:	5013883a 	mov	r9,r10
   25918:	00000b06 	br	25948 <SDOS_SdoInd+0x1ac>
				if (bTransferType)
   2591c:	a880008c 	andi	r2,r21,2
   25920:	10001226 	beq	r2,zero,2596c <SDOS_SdoInd+0x1d0>
					if (mbxSize != EXPEDITED_FRAME_SIZE)
   25924:	8c400298 	cmpnei	r17,r17,10
   25928:	8801b11e 	bne	r17,zero,25ff0 <SDOS_SdoInd+0x854>
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   2592c:	a804d0ba 	srli	r2,r21,2
   25930:	02400104 	movi	r9,4
					pData = (UINT16 MBXMEM *) &pSdoInd[1];
   25934:	83000304 	addi	r12,r16,12
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25938:	108000cc 	andi	r2,r2,3
   2593c:	4893c83a 	sub	r9,r9,r2
			if ((abort == 0) && (bCompleteAccess == 1))
   25940:	a880040c 	andi	r2,r21,16
   25944:	1001ac26 	beq	r2,zero,25ff8 <SDOS_SdoInd+0x85c>
				if (subindex > 1)
   25948:	288000a8 	cmpgeui	r2,r5,2
   2594c:	1001cb1e 	bne	r2,zero,2607c <SDOS_SdoInd+0x8e0>
					if (objLength == 0)
   25950:	e000031e 	bne	fp,zero,25960 <SDOS_SdoInd+0x1c4>
						nSdoSegIndex = index;
   25954:	d4e68b8d 	sth	r19,-26066(gp)
						nSdoSegSubindex = subindex;
   25958:	d5a68b05 	stb	r22,-26068(gp)
						pSdoSegObjEntry = pObjEntry;
   2595c:	d5e68715 	stw	r23,-26084(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25960:	90801018 	cmpnei	r2,r18,64
   25964:	1001a81e 	bne	r2,zero,26008 <SDOS_SdoInd+0x86c>
   25968:	00003b06 	br	25a58 <SDOS_SdoInd+0x2bc>
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   2596c:	8280038b 	ldhu	r10,14(r16)
   25970:	8080030b 	ldhu	r2,12(r16)
   25974:	5014943a 	slli	r10,r10,16
   25978:	5094b03a 	or	r10,r10,r2
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   2597c:	d0a6840b 	ldhu	r2,-26096(gp)
   25980:	51000404 	addi	r4,r10,16
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   25984:	5013883a 	mov	r9,r10
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   25988:	11002f2e 	bgeu	r2,r4,25a48 <SDOS_SdoInd+0x2ac>
						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
   2598c:	10bffe84 	addi	r2,r2,-6
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25990:	8881971e 	bne	r17,r2,25ff0 <SDOS_SdoInd+0x854>
					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
   25994:	88bffd84 	addi	r2,r17,-10
   25998:	1280522e 	bgeu	r2,r10,25ae4 <SDOS_SdoInd+0x348>
			if ((abort == 0) && (bCompleteAccess == 1))
   2599c:	a880040c 	andi	r2,r21,16
   259a0:	10000226 	beq	r2,zero,259ac <SDOS_SdoInd+0x210>
				if (subindex > 1)
   259a4:	288000a8 	cmpgeui	r2,r5,2
   259a8:	1001b41e 	bne	r2,zero,2607c <SDOS_SdoInd+0x8e0>
					bSdoSegFollows = TRUE;
   259ac:	00800044 	movi	r2,1
   259b0:	d0a68c45 	stb	r2,-26063(gp)
					bSdoSegLastToggle = 1;
   259b4:	d0a68905 	stb	r2,-26076(gp)
					bSdoSegAccess = bCompleteAccess;
   259b8:	d8800217 	ldw	r2,8(sp)
					if (pSdoSegData != NULL)
   259bc:	d1269017 	ldw	r4,-26048(gp)
					nSdoSegIndex = index;
   259c0:	d4e68b8d 	sth	r19,-26066(gp)
					bSdoSegAccess = bCompleteAccess;
   259c4:	d0a68c05 	stb	r2,-26064(gp)
					nSdoSegSubindex = subindex;
   259c8:	d5a68b05 	stb	r22,-26068(gp)
					pSdoSegObjEntry = pObjEntry;
   259cc:	d5e68715 	stw	r23,-26084(gp)
						nSdoSegCompleteSize = objLength;
   259d0:	d2668815 	stw	r9,-26080(gp)
					if (pSdoSegData != NULL)
   259d4:	20000526 	beq	r4,zero,259ec <SDOS_SdoInd+0x250>
   259d8:	da800515 	stw	r10,20(sp)
   259dc:	d9400415 	stw	r5,16(sp)
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   259e0:	0026b8c0 	call	26b8c <free>
   259e4:	da800517 	ldw	r10,20(sp)
   259e8:	d9400417 	ldw	r5,16(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   259ec:	d0a68817 	ldw	r2,-26080(gp)
   259f0:	013fff84 	movi	r4,-2
   259f4:	da800515 	stw	r10,20(sp)
   259f8:	10800044 	addi	r2,r2,1
   259fc:	1108703a 	and	r4,r2,r4
   25a00:	d9400415 	stw	r5,16(sp)
   25a04:	0026b7c0 	call	26b7c <malloc>
   25a08:	d0a69015 	stw	r2,-26048(gp)
					if (pSdoSegData == NULL)
   25a0c:	d9400417 	ldw	r5,16(sp)
   25a10:	da800517 	ldw	r10,20(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25a14:	1009883a 	mov	r4,r2
					if (pSdoSegData == NULL)
   25a18:	1000341e 	bne	r2,zero,25aec <SDOS_SdoInd+0x350>
						if (bCompleteAccess)
   25a1c:	d8800217 	ldw	r2,8(sp)
   25a20:	14400104 	addi	r17,r2,4
						nSdoSegBytesToHandle = dataSize;
   25a24:	5013883a 	mov	r9,r10
	}

	if (abort != ABORTIDX_WORKING)
	{
		/*  type cast was added because of warning */
		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
   25a28:	d9800317 	ldw	r6,12(sp)
   25a2c:	dc000115 	stw	r16,4(sp)
   25a30:	df000015 	stw	fp,0(sp)
   25a34:	49ffffcc 	andi	r7,r9,65535
   25a38:	900b883a 	mov	r5,r18
   25a3c:	89003fcc 	andi	r4,r17,255
   25a40:	002563c0 	call	2563c <SdoRes>
   25a44:	00005506 	br	25b9c <SDOS_SdoInd+0x400>
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25a48:	50800284 	addi	r2,r10,10
   25a4c:	003fd006 	br	25990 <SDOS_SdoInd+0x1f4>
					if (objLength == 0)
   25a50:	e0006726 	beq	fp,zero,25bf0 <SDOS_SdoInd+0x454>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25a54:	5013883a 	mov	r9,r10
						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
   25a58:	d8800217 	ldw	r2,8(sp)
   25a5c:	db000015 	stw	r12,0(sp)
   25a60:	b80f883a 	mov	r7,r23
   25a64:	d8800115 	stw	r2,4(sp)
   25a68:	e00d883a 	mov	r6,fp
   25a6c:	993fffcc 	andi	r4,r19,65535
   25a70:	da400515 	stw	r9,20(sp)
   25a74:	db000415 	stw	r12,16(sp)
   25a78:	00248ec0 	call	248ec <OBJ_Read>
   25a7c:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   25a80:	10803fcc 	andi	r2,r2,255
   25a84:	10803fd8 	cmpnei	r2,r2,255
   25a88:	db000417 	ldw	r12,16(sp)
   25a8c:	da400517 	ldw	r9,20(sp)
   25a90:	103fe51e 	bne	r2,zero,25a28 <SDOS_SdoInd+0x28c>
							u8PendingSdo = SDO_PENDING_READ;
   25a94:	008000c4 	movi	r2,3
   25a98:	d0a69505 	stb	r2,-26028(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25a9c:	d8800217 	ldw	r2,8(sp)
							u8StoreSubindex = subindex;
   25aa0:	d5a69485 	stb	r22,-26030(gp)
							u16StoreIndex = index;
   25aa4:	d4e6940d 	sth	r19,-26032(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25aa8:	d0a694c5 	stb	r2,-26029(gp)
							pSdoPendFunc = pObjEntry->Read;
   25aac:	b8800717 	ldw	r2,28(r23)
							u32StoreDataSize = objLength;
   25ab0:	d7269315 	stw	fp,-26036(gp)
							pStoreData = pData;
   25ab4:	d3269215 	stw	r12,-26040(gp)
							pSdoPendFunc = pObjEntry->Read;
   25ab8:	d0a69115 	stw	r2,-26044(gp)
							bSdoInWork = TRUE;
   25abc:	00800044 	movi	r2,1
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25ac0:	a8c03c0c 	andi	r3,r21,240
							bSdoInWork = TRUE;
   25ac4:	d0a68cc5 	stb	r2,-26061(gp)
							pSdoResStored = pSdoInd;
   25ac8:	d4268d15 	stw	r16,-26060(gp)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25acc:	80c00205 	stb	r3,8(r16)
							return 0;
   25ad0:	00003206 	br	25b9c <SDOS_SdoInd+0x400>
			if ((abort == 0) && (bCompleteAccess == 1))
   25ad4:	a880040c 	andi	r2,r21,16
   25ad8:	1001651e 	bne	r2,zero,26070 <SDOS_SdoInd+0x8d4>
				if (subindex > 1)
   25adc:	e013883a 	mov	r9,fp
   25ae0:	003fb206 	br	259ac <SDOS_SdoInd+0x210>
					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
   25ae4:	83000404 	addi	r12,r16,16
   25ae8:	003f9506 	br	25940 <SDOS_SdoInd+0x1a4>
						if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25aec:	90801018 	cmpnei	r2,r18,64
   25af0:	1000371e 	bne	r2,zero,25bd0 <SDOS_SdoInd+0x434>
							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
   25af4:	d8800217 	ldw	r2,8(sp)
   25af8:	d9000015 	stw	r4,0(sp)
   25afc:	b80f883a 	mov	r7,r23
   25b00:	d8800115 	stw	r2,4(sp)
   25b04:	e00d883a 	mov	r6,fp
   25b08:	993fffcc 	andi	r4,r19,65535
   25b0c:	da800415 	stw	r10,16(sp)
   25b10:	00248ec0 	call	248ec <OBJ_Read>
   25b14:	1023883a 	mov	r17,r2
							if (abort == 0)
   25b18:	10803fcc 	andi	r2,r2,255
   25b1c:	da800417 	ldw	r10,16(sp)
   25b20:	10000a1e 	bne	r2,zero,25b4c <SDOS_SdoInd+0x3b0>
								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
   25b24:	d1669017 	ldw	r5,-26048(gp)
   25b28:	500d883a 	mov	r6,r10
   25b2c:	81000404 	addi	r4,r16,16
   25b30:	da800215 	stw	r10,8(sp)
   25b34:	0026e840 	call	26e84 <memcpy>
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   25b38:	00801804 	movi	r2,96
   25b3c:	d0a68c85 	stb	r2,-26062(gp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25b40:	da800217 	ldw	r10,8(sp)
						nSdoSegBytesToHandle = dataSize;
   25b44:	d2a68a15 	stw	r10,-26072(gp)
   25b48:	003fb606 	br	25a24 <SDOS_SdoInd+0x288>
							else if (abort == ABORTIDX_WORKING)
   25b4c:	10803fd8 	cmpnei	r2,r2,255
   25b50:	103ffc1e 	bne	r2,zero,25b44 <SDOS_SdoInd+0x3a8>
								u8PendingSdo = SDO_PENDING_SEG_READ;
   25b54:	00800104 	movi	r2,4
   25b58:	d0a69505 	stb	r2,-26028(gp)
								bStoreCompleteAccess = bCompleteAccess;
   25b5c:	d8800217 	ldw	r2,8(sp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25b60:	a8c03c0c 	andi	r3,r21,240
								u8StoreSubindex = subindex;
   25b64:	d5a69485 	stb	r22,-26030(gp)
								bStoreCompleteAccess = bCompleteAccess;
   25b68:	d0a694c5 	stb	r2,-26029(gp)
								pStoreData = pSdoSegData;
   25b6c:	d0a69017 	ldw	r2,-26048(gp)
								u16StoreIndex = index;
   25b70:	d4e6940d 	sth	r19,-26032(gp)
								u32StoreDataSize = objLength;
   25b74:	d7269315 	stw	fp,-26036(gp)
								pStoreData = pSdoSegData;
   25b78:	d0a69215 	stw	r2,-26040(gp)
								pSdoPendFunc = pObjEntry->Read;
   25b7c:	b8800717 	ldw	r2,28(r23)
								pSdoResStored = pSdoInd;
   25b80:	d4268d15 	stw	r16,-26060(gp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25b84:	80c00205 	stb	r3,8(r16)
								pSdoPendFunc = pObjEntry->Read;
   25b88:	d0a69115 	stw	r2,-26044(gp)
								bSdoInWork = TRUE;
   25b8c:	00800044 	movi	r2,1
   25b90:	d0a68cc5 	stb	r2,-26061(gp)
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   25b94:	00801804 	movi	r2,96
   25b98:	d0a68c85 	stb	r2,-26062(gp)
	}

	return 0;
}
   25b9c:	a005883a 	mov	r2,r20
   25ba0:	dfc00f17 	ldw	ra,60(sp)
   25ba4:	df000e17 	ldw	fp,56(sp)
   25ba8:	ddc00d17 	ldw	r23,52(sp)
   25bac:	dd800c17 	ldw	r22,48(sp)
   25bb0:	dd400b17 	ldw	r21,44(sp)
   25bb4:	dd000a17 	ldw	r20,40(sp)
   25bb8:	dcc00917 	ldw	r19,36(sp)
   25bbc:	dc800817 	ldw	r18,32(sp)
   25bc0:	dc400717 	ldw	r17,28(sp)
   25bc4:	dc000617 	ldw	r16,24(sp)
   25bc8:	dec01004 	addi	sp,sp,64
   25bcc:	f800283a 	ret
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25bd0:	8abffd84 	addi	r10,r17,-10
   25bd4:	500d883a 	mov	r6,r10
   25bd8:	81400404 	addi	r5,r16,16
   25bdc:	da800215 	stw	r10,8(sp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25be0:	a023883a 	mov	r17,r20
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25be4:	0026e840 	call	26e84 <memcpy>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25be8:	d0268c85 	stb	zero,-26062(gp)
							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25bec:	003fd406 	br	25b40 <SDOS_SdoInd+0x3a4>
						nSdoSegIndex = index;
   25bf0:	d4e68b8d 	sth	r19,-26066(gp)
						nSdoSegSubindex = subindex;
   25bf4:	d5a68b05 	stb	r22,-26068(gp)
						pSdoSegObjEntry = pObjEntry;
   25bf8:	d5e68715 	stw	r23,-26084(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25bfc:	003f9506 	br	25a54 <SDOS_SdoInd+0x2b8>
		if (command == nSdoSegService)
   25c00:	d1268c83 	ldbu	r4,-26062(gp)
   25c04:	203f021e 	bne	r4,zero,25810 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c08:	d1668903 	ldbu	r5,-26076(gp)
		if (pSdoSegData)
   25c0c:	d1269017 	ldw	r4,-26048(gp)
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c10:	28808826 	beq	r5,r2,25e34 <SDOS_SdoInd+0x698>
		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
   25c14:	d0a68905 	stb	r2,-26076(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25c18:	d4e6840b 	ldhu	r19,-26096(gp)
		if (pSdoSegData)
   25c1c:	20008726 	beq	r4,zero,25e3c <SDOS_SdoInd+0x6a0>
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25c20:	d0a68a17 	ldw	r2,-26072(gp)
   25c24:	d1668817 	ldw	r5,-26080(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25c28:	9cfffdc4 	addi	r19,r19,-9
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   25c2c:	a980004c 	andi	r6,r21,1
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25c30:	288bc83a 	sub	r5,r5,r2
				if (bytesToSave <= maxData)
   25c34:	9cffffcc 	andi	r19,r19,65535
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   25c38:	30003d26 	beq	r6,zero,25d30 <SDOS_SdoInd+0x594>
				if (bytesToSave <= maxData)
   25c3c:	9940092e 	bgeu	r19,r5,25c64 <SDOS_SdoInd+0x4c8>
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
   25c40:	04400384 	movi	r17,14
		if (pSdoSegData)
   25c44:	d1269017 	ldw	r4,-26048(gp)
		bSdoSegFollows = FALSE;
   25c48:	d0268c45 	stb	zero,-26063(gp)
		nSdoSegService = 0;
   25c4c:	d0268c85 	stb	zero,-26062(gp)
		if (pSdoSegData)
   25c50:	20000226 	beq	r4,zero,25c5c <SDOS_SdoInd+0x4c0>
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25c54:	0026b8c0 	call	26b8c <free>
			pSdoSegData = NULL;
   25c58:	d0269015 	stw	zero,-26048(gp)
		nSdoSegBytesToHandle = 0;
   25c5c:	d0268a15 	stw	zero,-26072(gp)
   25c60:	00003006 	br	25d24 <SDOS_SdoInd+0x588>
					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   25c64:	8c7fffcc 	andi	r17,r17,65535
   25c68:	8c7fff44 	addi	r17,r17,-3
   25c6c:	897ff436 	bltu	r17,r5,25c40 <SDOS_SdoInd+0x4a4>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c70:	a9bfffcc 	andi	r6,r21,65535
						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
   25c74:	300dd07a 	srai	r6,r6,1
   25c78:	018c303a 	nor	r6,zero,r6
   25c7c:	318001cc 	andi	r6,r6,7
   25c80:	29800326 	beq	r5,r6,25c90 <SDOS_SdoInd+0x4f4>
						|| ((bytesToSave > MIN_SEGMENTED_DATA)
   25c84:	29800230 	cmpltui	r6,r5,8
   25c88:	303fed1e 	bne	r6,zero,25c40 <SDOS_SdoInd+0x4a4>
							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   25c8c:	2c7fec1e 	bne	r5,r17,25c40 <SDOS_SdoInd+0x4a4>
						bSdoSegFollows = FALSE;
   25c90:	d0268c45 	stb	zero,-26063(gp)
   25c94:	2827883a 	mov	r19,r5
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25c98:	11c0004c 	andi	r7,r2,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25c9c:	1004d07a 	srli	r2,r2,1
   25ca0:	81400284 	addi	r5,r16,10
   25ca4:	1004907a 	slli	r2,r2,1
   25ca8:	208d883a 	add	r6,r4,r2
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25cac:	38002426 	beq	r7,zero,25d40 <SDOS_SdoInd+0x5a4>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25cb0:	30c00003 	ldbu	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   25cb4:	10800084 	addi	r2,r2,2
   25cb8:	2089883a 	add	r4,r4,r2
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25cbc:	30c0000d 	sth	r3,0(r6)
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
   25cc0:	81c0020b 	ldhu	r7,8(r16)
   25cc4:	39ffc00c 	andi	r7,r7,65280
   25cc8:	19c6b03a 	or	r3,r3,r7
   25ccc:	30c0000d 	sth	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   25cd0:	99bfffc4 	addi	r6,r19,-1
   25cd4:	0026e840 	call	26e84 <memcpy>
				if (bSdoSegFollows == FALSE)
   25cd8:	d0a68c43 	ldbu	r2,-26063(gp)
   25cdc:	10002b26 	beq	r2,zero,25d8c <SDOS_SdoInd+0x5f0>
		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25ce0:	00800284 	movi	r2,10
   25ce4:	8080000d 	sth	r2,0(r16)
		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25ce8:	8080018b 	ldhu	r2,6(r16)
   25cec:	1083ffcc 	andi	r2,r2,4095
		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25cf0:	108c0014 	ori	r2,r2,12288
   25cf4:	8080018d 	sth	r2,6(r16)
		if (bSdoSegLastToggle)
   25cf8:	d0a68903 	ldbu	r2,-26076(gp)
   25cfc:	10004b1e 	bne	r2,zero,25e2c <SDOS_SdoInd+0x690>
   25d00:	00800804 	movi	r2,32
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
   25d04:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   25d08:	d0a68c43 	ldbu	r2,-26063(gp)
   25d0c:	10800058 	cmpnei	r2,r2,1
   25d10:	1000981e 	bne	r2,zero,25f74 <SDOS_SdoInd+0x7d8>
			nSdoSegBytesToHandle += bytesToSave;
   25d14:	d0a68a17 	ldw	r2,-26072(gp)
   25d18:	14c5883a 	add	r2,r2,r19
   25d1c:	d0a68a15 	stw	r2,-26072(gp)
	if (abort != ABORTIDX_WORKING)
   25d20:	a023883a 	mov	r17,r20
	UINT32 dataSize = 0;
   25d24:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25d28:	0039883a 	mov	fp,zero
   25d2c:	003f3e06 	br	25a28 <SDOS_SdoInd+0x28c>
				bSdoSegFollows = TRUE;
   25d30:	01800044 	movi	r6,1
   25d34:	d1a68c45 	stb	r6,-26063(gp)
				if (bytesToSave <= maxData)
   25d38:	997fc12e 	bgeu	r19,r5,25c40 <SDOS_SdoInd+0x4a4>
   25d3c:	003fd606 	br	25c98 <SDOS_SdoInd+0x4fc>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   25d40:	8080028b 	ldhu	r2,10(r16)
   25d44:	a8ffffcc 	andi	r3,r21,65535
   25d48:	1806d23a 	srli	r3,r3,8
   25d4c:	1004923a 	slli	r2,r2,8
   25d50:	10c4b03a 	or	r2,r2,r3
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25d54:	98c00044 	addi	r3,r19,1
   25d58:	1806d07a 	srli	r3,r3,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   25d5c:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25d60:	39c00044 	addi	r7,r7,1
   25d64:	29400084 	addi	r5,r5,2
   25d68:	31800084 	addi	r6,r6,2
   25d6c:	38ffda2e 	bgeu	r7,r3,25cd8 <SDOS_SdoInd+0x53c>
						pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
   25d70:	28bfff8b 	ldhu	r2,-2(r5)
   25d74:	2900000b 	ldhu	r4,0(r5)
   25d78:	1004d23a 	srli	r2,r2,8
   25d7c:	2008923a 	slli	r4,r4,8
   25d80:	1104b03a 	or	r2,r2,r4
   25d84:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25d88:	003ff506 	br	25d60 <SDOS_SdoInd+0x5c4>
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   25d8c:	d0a68c03 	ldbu	r2,-26064(gp)
   25d90:	d1e68717 	ldw	r7,-26084(gp)
   25d94:	d1a68817 	ldw	r6,-26080(gp)
   25d98:	d8800115 	stw	r2,4(sp)
   25d9c:	d0a69017 	ldw	r2,-26048(gp)
   25da0:	d1668b03 	ldbu	r5,-26068(gp)
   25da4:	d1268b8b 	ldhu	r4,-26066(gp)
   25da8:	d8800015 	stw	r2,0(sp)
   25dac:	0024efc0 	call	24efc <OBJ_Write>
					if (abort == ABORTIDX_WORKING)
   25db0:	15803fcc 	andi	r22,r2,255
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   25db4:	1023883a 	mov	r17,r2
					if (abort == ABORTIDX_WORKING)
   25db8:	b0803fd8 	cmpnei	r2,r22,255
   25dbc:	1000161e 	bne	r2,zero,25e18 <SDOS_SdoInd+0x67c>
						u8PendingSdo = SDO_PENDING_SEG_WRITE;
   25dc0:	00800084 	movi	r2,2
   25dc4:	d0a69505 	stb	r2,-26028(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   25dc8:	d0a68c03 	ldbu	r2,-26064(gp)
						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
   25dcc:	d4268d15 	stw	r16,-26060(gp)
						bSdoSegFollows = FALSE;
   25dd0:	d0268c45 	stb	zero,-26063(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   25dd4:	d0a694c5 	stb	r2,-26029(gp)
						u8StoreSubindex = nSdoSegSubindex;
   25dd8:	d0a68b03 	ldbu	r2,-26068(gp)
						nSdoSegService = 0;
   25ddc:	d0268c85 	stb	zero,-26062(gp)
						nSdoSegBytesToHandle = 0;
   25de0:	d0268a15 	stw	zero,-26072(gp)
						u8StoreSubindex = nSdoSegSubindex;
   25de4:	d0a69485 	stb	r2,-26030(gp)
						u16StoreIndex = nSdoSegIndex;
   25de8:	d0a68b8b 	ldhu	r2,-26066(gp)
   25dec:	d0a6940d 	sth	r2,-26032(gp)
						u32StoreDataSize = nSdoSegCompleteSize;
   25df0:	d0a68817 	ldw	r2,-26080(gp)
   25df4:	d0a69315 	stw	r2,-26036(gp)
						pStoreData = pSdoSegData;
   25df8:	d0a69017 	ldw	r2,-26048(gp)
   25dfc:	d0a69215 	stw	r2,-26040(gp)
						pSdoPendFunc = pSdoSegObjEntry->Write;
   25e00:	d0a68717 	ldw	r2,-26084(gp)
   25e04:	10800817 	ldw	r2,32(r2)
   25e08:	d0a69115 	stw	r2,-26044(gp)
						bSdoInWork = TRUE;
   25e0c:	00800044 	movi	r2,1
   25e10:	d0a68cc5 	stb	r2,-26061(gp)
	if (abort != ABORTIDX_WORKING)
   25e14:	003f6106 	br	25b9c <SDOS_SdoInd+0x400>
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25e18:	d1269017 	ldw	r4,-26048(gp)
   25e1c:	0026b8c0 	call	26b8c <free>
						pSdoSegData = NULL;
   25e20:	d0269015 	stw	zero,-26048(gp)
	if (abort == 0)
   25e24:	b03fae26 	beq	r22,zero,25ce0 <SDOS_SdoInd+0x544>
   25e28:	003f8606 	br	25c44 <SDOS_SdoInd+0x4a8>
   25e2c:	00800c04 	movi	r2,48
   25e30:	003fb406 	br	25d04 <SDOS_SdoInd+0x568>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   25e34:	04400044 	movi	r17,1
   25e38:	003f8206 	br	25c44 <SDOS_SdoInd+0x4a8>
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   25e3c:	044000c4 	movi	r17,3
   25e40:	003f8006 	br	25c44 <SDOS_SdoInd+0x4a8>
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25e44:	d466848b 	ldhu	r17,-26094(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e48:	d4e68a17 	ldw	r19,-26072(gp)
   25e4c:	d0a68817 	ldw	r2,-26080(gp)
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25e50:	8c7ffdc4 	addi	r17,r17,-9
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e54:	8c7fffcc 	andi	r17,r17,65535
		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
   25e58:	d5e68905 	stb	r23,-26076(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e5c:	8cc9883a 	add	r4,r17,r19
   25e60:	1100242e 	bgeu	r2,r4,25ef4 <SDOS_SdoInd+0x758>
			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25e64:	14e3c83a 	sub	r17,r2,r19
			bSdoSegFollows = FALSE;
   25e68:	a039883a 	mov	fp,r20
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25e6c:	980cd07a 	srli	r6,r19,1
   25e70:	d5a69017 	ldw	r22,-26048(gp)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   25e74:	a8c03fcc 	andi	r3,r21,255
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25e78:	300a907a 	slli	r5,r6,1
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   25e7c:	80c0020d 	sth	r3,8(r16)
			bSdoSegFollows = FALSE;
   25e80:	d7268c45 	stb	fp,-26063(gp)
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25e84:	b145883a 	add	r2,r22,r5
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25e88:	9900004c 	andi	r4,r19,1
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25e8c:	1080000b 	ldhu	r2,0(r2)
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25e90:	20001a26 	beq	r4,zero,25efc <SDOS_SdoInd+0x760>
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25e94:	10bfc00c 	andi	r2,r2,65280
   25e98:	1886b03a 	or	r3,r3,r2
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   25e9c:	29400084 	addi	r5,r5,2
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ea0:	80c0020d 	sth	r3,8(r16)
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   25ea4:	89bfffc4 	addi	r6,r17,-1
   25ea8:	b14b883a 	add	r5,r22,r5
   25eac:	81000284 	addi	r4,r16,10
   25eb0:	0026e840 	call	26e84 <memcpy>
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25eb4:	8080018b 	ldhu	r2,6(r16)
		if (bSdoSegFollows)
   25eb8:	e7003fcc 	andi	fp,fp,255
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25ebc:	8807883a 	mov	r3,r17
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25ec0:	1083ffcc 	andi	r2,r2,4095
		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25ec4:	108c0014 	ori	r2,r2,12288
   25ec8:	8080018d 	sth	r2,6(r16)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
   25ecc:	8080020b 	ldhu	r2,8(r16)
   25ed0:	890001f0 	cmpltui	r4,r17,7
   25ed4:	10bfc00c 	andi	r2,r2,65280
		if (bSdoSegFollows)
   25ed8:	e0001d26 	beq	fp,zero,25f50 <SDOS_SdoInd+0x7b4>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
   25edc:	15c4b03a 	or	r2,r2,r23
   25ee0:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   25ee4:	20002e1e 	bne	r4,zero,25fa0 <SDOS_SdoInd+0x804>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25ee8:	18c000c4 	addi	r3,r3,3
   25eec:	80c0000d 	sth	r3,0(r16)
		if (bSdoSegFollows == TRUE)
   25ef0:	00003206 	br	25fbc <SDOS_SdoInd+0x820>
   25ef4:	07000044 	movi	fp,1
   25ef8:	003fdc06 	br	25e6c <SDOS_SdoInd+0x6d0>
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   25efc:	1004923a 	slli	r2,r2,8
			for (i = 0; i < (size >> 1); i++)
   25f00:	880ed07a 	srli	r7,r17,1
   25f04:	000b883a 	mov	r5,zero
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   25f08:	1886b03a 	or	r3,r3,r2
   25f0c:	80c0020d 	sth	r3,8(r16)
			for (i = 0; i < (size >> 1); i++)
   25f10:	28bfffcc 	andi	r2,r5,65535
   25f14:	11ffe72e 	bgeu	r2,r7,25eb4 <SDOS_SdoInd+0x718>
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   25f18:	1187883a 	add	r3,r2,r6
   25f1c:	1806907a 	slli	r3,r3,1
   25f20:	10800104 	addi	r2,r2,4
   25f24:	1004907a 	slli	r2,r2,1
   25f28:	b0c7883a 	add	r3,r22,r3
   25f2c:	1900008b 	ldhu	r4,2(r3)
   25f30:	18c0000b 	ldhu	r3,0(r3)
   25f34:	8085883a 	add	r2,r16,r2
   25f38:	2008923a 	slli	r4,r4,8
   25f3c:	1806d23a 	srli	r3,r3,8
			for (i = 0; i < (size >> 1); i++)
   25f40:	29400044 	addi	r5,r5,1
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   25f44:	20c6b03a 	or	r3,r4,r3
   25f48:	10c0008d 	sth	r3,2(r2)
			for (i = 0; i < (size >> 1); i++)
   25f4c:	003ff006 	br	25f10 <SDOS_SdoInd+0x774>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
   25f50:	bdc00054 	ori	r23,r23,1
   25f54:	15c4b03a 	or	r2,r2,r23
   25f58:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   25f5c:	2000081e 	bne	r4,zero,25f80 <SDOS_SdoInd+0x7e4>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25f60:	18c000c4 	addi	r3,r3,3
   25f64:	80c0000d 	sth	r3,0(r16)
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25f68:	b009883a 	mov	r4,r22
   25f6c:	0026b8c0 	call	26b8c <free>
			pSdoSegData = NULL;
   25f70:	d0269015 	stw	zero,-26048(gp)
			nSdoSegBytesToHandle = 0;
   25f74:	d0268a15 	stw	zero,-26072(gp)
			nSdoSegService = 0;
   25f78:	d0268c85 	stb	zero,-26062(gp)
	if (abort != ABORTIDX_WORKING)
   25f7c:	003f6806 	br	25d20 <SDOS_SdoInd+0x584>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25f80:	01000284 	movi	r4,10
   25f84:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   25f88:	010001c4 	movi	r4,7
   25f8c:	20c7c83a 	sub	r3,r4,r3
   25f90:	1806907a 	slli	r3,r3,1
   25f94:	1884b03a 	or	r2,r3,r2
   25f98:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   25f9c:	003ff206 	br	25f68 <SDOS_SdoInd+0x7cc>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25fa0:	01000284 	movi	r4,10
   25fa4:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   25fa8:	010001c4 	movi	r4,7
   25fac:	20c7c83a 	sub	r3,r4,r3
   25fb0:	1806907a 	slli	r3,r3,1
   25fb4:	1884b03a 	or	r2,r3,r2
   25fb8:	8080020d 	sth	r2,8(r16)
			nSdoSegBytesToHandle += size;
   25fbc:	9c67883a 	add	r19,r19,r17
   25fc0:	d4e68a15 	stw	r19,-26072(gp)
	if (abort != ABORTIDX_WORKING)
   25fc4:	003f5606 	br	25d20 <SDOS_SdoInd+0x584>
	UINT32 dataSize = 0;
   25fc8:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25fcc:	0039883a 	mov	fp,zero
			abort = ABORTIDX_OBJECT_NOT_EXISTING;
   25fd0:	04400204 	movi	r17,8
   25fd4:	003e9406 	br	25a28 <SDOS_SdoInd+0x28c>
   25fd8:	0013883a 	mov	r9,zero
   25fdc:	0039883a 	mov	fp,zero
   25fe0:	04400444 	movi	r17,17
   25fe4:	003e9006 	br	25a28 <SDOS_SdoInd+0x28c>
		return MBXERR_SERVICEINWORK;
   25fe8:	05000244 	movi	r20,9
   25fec:	003eeb06 	br	25b9c <SDOS_SdoInd+0x400>
							return MBXERR_INVALIDSIZE;
   25ff0:	05000204 	movi	r20,8
   25ff4:	003ee906 	br	25b9c <SDOS_SdoInd+0x400>
					if (objLength == 0)
   25ff8:	e000031e 	bne	fp,zero,26008 <SDOS_SdoInd+0x86c>
						nSdoSegIndex = index;
   25ffc:	d4e68b8d 	sth	r19,-26066(gp)
						nSdoSegSubindex = subindex;
   26000:	d5a68b05 	stb	r22,-26068(gp)
						pSdoSegObjEntry = pObjEntry;
   26004:	d5e68715 	stw	r23,-26084(gp)
						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
   26008:	d8800217 	ldw	r2,8(sp)
   2600c:	db000015 	stw	r12,0(sp)
   26010:	480d883a 	mov	r6,r9
   26014:	d8800115 	stw	r2,4(sp)
   26018:	b80f883a 	mov	r7,r23
   2601c:	993fffcc 	andi	r4,r19,65535
   26020:	db000515 	stw	r12,20(sp)
   26024:	da400415 	stw	r9,16(sp)
   26028:	0024efc0 	call	24efc <OBJ_Write>
   2602c:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   26030:	10803fcc 	andi	r2,r2,255
   26034:	10803fd8 	cmpnei	r2,r2,255
   26038:	da400417 	ldw	r9,16(sp)
   2603c:	db000517 	ldw	r12,20(sp)
   26040:	103e791e 	bne	r2,zero,25a28 <SDOS_SdoInd+0x28c>
							bStoreCompleteAccess = bCompleteAccess;
   26044:	d8c00217 	ldw	r3,8(sp)
							pSdoPendFunc = pObjEntry->Write;
   26048:	b9000817 	ldw	r4,32(r23)
							u8PendingSdo = SDO_PENDING_WRITE;
   2604c:	00800044 	movi	r2,1
   26050:	d0a69505 	stb	r2,-26028(gp)
							bStoreCompleteAccess = bCompleteAccess;
   26054:	d0e694c5 	stb	r3,-26029(gp)
							u8StoreSubindex = subindex;
   26058:	d5a69485 	stb	r22,-26030(gp)
							u16StoreIndex = index;
   2605c:	d4e6940d 	sth	r19,-26032(gp)
							u32StoreDataSize = dataSize;
   26060:	d2669315 	stw	r9,-26036(gp)
							pStoreData = pData;
   26064:	d3269215 	stw	r12,-26040(gp)
							pSdoPendFunc = pObjEntry->Write;
   26068:	d1269115 	stw	r4,-26044(gp)
   2606c:	003e9406 	br	25ac0 <SDOS_SdoInd+0x324>
				if (subindex > 1)
   26070:	288000a8 	cmpgeui	r2,r5,2
   26074:	103e9926 	beq	r2,zero,25adc <SDOS_SdoInd+0x340>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   26078:	5013883a 	mov	r9,r10
							abort = ABORTIDX_UNSUPPORTED_ACCESS;
   2607c:	04400144 	movi	r17,5
   26080:	003e6906 	br	25a28 <SDOS_SdoInd+0x28c>
							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
   26084:	83000304 	addi	r12,r16,12
   26088:	e013883a 	mov	r9,fp
   2608c:	003e7206 	br	25a58 <SDOS_SdoInd+0x2bc>

00026090 <SDOS_SdoRes>:

void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
{
	UINT16 dataSize = 0;

	if (bSdoInWork)
   26090:	d0a68cc3 	ldbu	r2,-26061(gp)
   26094:	10004126 	beq	r2,zero,2619c <SDOS_SdoRes+0x10c>
{
   26098:	defff604 	addi	sp,sp,-40
   2609c:	dcc00515 	stw	r19,20(sp)
	{
		/* SDO-Response is expected */
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   260a0:	d4e68d17 	ldw	r19,-26060(gp)
{
   260a4:	dc800415 	stw	r18,16(sp)
   260a8:	dd400715 	stw	r21,28(sp)
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   260ac:	9c800203 	ldbu	r18,8(r19)
{
   260b0:	dd000615 	stw	r20,24(sp)
   260b4:	dc000215 	stw	r16,8(sp)
		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
   260b8:	9540040c 	andi	r21,r18,16

		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   260bc:	9480380c 	andi	r18,r18,224
{
   260c0:	dfc00915 	stw	ra,36(sp)
   260c4:	dd800815 	stw	r22,32(sp)
   260c8:	dc400315 	stw	r17,12(sp)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   260cc:	90801018 	cmpnei	r2,r18,64
   260d0:	2029883a 	mov	r20,r4
   260d4:	2821883a 	mov	r16,r5
   260d8:	10002e1e 	bne	r2,zero,26194 <SDOS_SdoRes+0x104>
		{
			/* dataSize contains the available size in one mailbox */
			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   260dc:	d466848b 	ldhu	r17,-26094(gp)
   260e0:	300b883a 	mov	r5,r6
   260e4:	8c7ffc04 	addi	r17,r17,-16
   260e8:	882d883a 	mov	r22,r17
			if (dataSize < objLength)
   260ec:	8c7fffcc 	andi	r17,r17,65535
   260f0:	8c001e2e 	bgeu	r17,r16,2616c <SDOS_SdoRes+0xdc>
			{
				/* Segmented Upload, the variables for the segmented transfer should be initialized */
				bSdoSegFollows = TRUE;
   260f4:	00800044 	movi	r2,1
   260f8:	d0a68c45 	stb	r2,-26063(gp)
				bSdoSegLastToggle = 1;
   260fc:	d0a68905 	stb	r2,-26076(gp)
				bSdoSegAccess = completeAccess;
				nSdoSegCompleteSize = objLength;
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
				pSdoSegData = (UINT16 VARMEM *) pData;
   26100:	d1a69015 	stw	r6,-26048(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26104:	00801804 	movi	r2,96
				/* the first segment shall be copied */
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   26108:	880d883a 	mov	r6,r17
   2610c:	99000404 	addi	r4,r19,16
				bSdoSegAccess = completeAccess;
   26110:	d5668c05 	stb	r21,-26064(gp)
				nSdoSegCompleteSize = objLength;
   26114:	d4268815 	stw	r16,-26080(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26118:	d0a68c85 	stb	r2,-26062(gp)
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   2611c:	0026e840 	call	26e84 <memcpy>
				nSdoSegBytesToHandle = dataSize;
   26120:	d4668a15 	stw	r17,-26072(gp)
				}
		}

		/* SDO access is finished, send the response */
		bSdoInWork = FALSE;
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26124:	dcc00115 	stw	r19,4(sp)
   26128:	dc000015 	stw	r16,0(sp)
   2612c:	b1ffffcc 	andi	r7,r22,65535
   26130:	a80d883a 	mov	r6,r21
   26134:	900b883a 	mov	r5,r18
   26138:	a1003fcc 	andi	r4,r20,255
		bSdoInWork = FALSE;
   2613c:	d0268cc5 	stb	zero,-26061(gp)
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26140:	002563c0 	call	2563c <SdoRes>
	}
}
   26144:	dfc00917 	ldw	ra,36(sp)
   26148:	dd800817 	ldw	r22,32(sp)
   2614c:	dd400717 	ldw	r21,28(sp)
   26150:	dd000617 	ldw	r20,24(sp)
   26154:	dcc00517 	ldw	r19,20(sp)
   26158:	dc800417 	ldw	r18,16(sp)
   2615c:	dc400317 	ldw	r17,12(sp)
   26160:	dc000217 	ldw	r16,8(sp)
   26164:	dec00a04 	addi	sp,sp,40
   26168:	f800283a 	ret
				if ((objLength <= 4) && (objLength > 0))
   2616c:	80bfffc4 	addi	r2,r16,-1
   26170:	10800128 	cmpgeui	r2,r2,4
   26174:	1000051e 	bne	r2,zero,2618c <SDOS_SdoRes+0xfc>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
   26178:	99000304 	addi	r4,r19,12
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   2617c:	217fe926 	beq	r4,r5,26124 <SDOS_SdoRes+0x94>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
   26180:	800d883a 	mov	r6,r16
   26184:	0026e840 	call	26e84 <memcpy>
   26188:	003fe606 	br	26124 <SDOS_SdoRes+0x94>
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   2618c:	99000404 	addi	r4,r19,16
   26190:	003ffa06 	br	2617c <SDOS_SdoRes+0xec>
	UINT16 dataSize = 0;
   26194:	002d883a 	mov	r22,zero
   26198:	003fe206 	br	26124 <SDOS_SdoRes+0x94>
   2619c:	f800283a 	ret

000261a0 <SDOS_ClearPendingResponse>:
		   This function shall be called before the other mailbox data pointer are set to NULL
*////////////////////////////////////////////////////////////////////////////////////////

void  SDOS_ClearPendingResponse(void)
{
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   261a0:	d0a68cc3 	ldbu	r2,-26061(gp)
{
   261a4:	deffff04 	addi	sp,sp,-4
   261a8:	dfc00015 	stw	ra,0(sp)
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   261ac:	10800058 	cmpnei	r2,r2,1
   261b0:	1000081e 	bne	r2,zero,261d4 <SDOS_ClearPendingResponse+0x34>
   261b4:	d1268d17 	ldw	r4,-26060(gp)
   261b8:	20000626 	beq	r4,zero,261d4 <SDOS_ClearPendingResponse+0x34>
   261bc:	d0a67f17 	ldw	r2,-26116(gp)
   261c0:	20800426 	beq	r4,r2,261d4 <SDOS_ClearPendingResponse+0x34>
   261c4:	d0a67e17 	ldw	r2,-26120(gp)
   261c8:	20800226 	beq	r4,r2,261d4 <SDOS_ClearPendingResponse+0x34>
	{
		APPL_FreeMailboxBuffer(pSdoResStored);
   261cc:	0026b8c0 	call	26b8c <free>
		pSdoResStored = NULL;
   261d0:	d0268d15 	stw	zero,-26060(gp)
	u32StoreDataSize = 0;
	pStoreData = NULL;
	pSdoPendFunc = NULL;
	bSdoInWork = FALSE;

	if (pSdoSegData != NULL)
   261d4:	d1269017 	ldw	r4,-26048(gp)
	u8PendingSdo = 0;
   261d8:	d0269505 	stb	zero,-26028(gp)
	bStoreCompleteAccess = FALSE;
   261dc:	d02694c5 	stb	zero,-26029(gp)
	u16StoreIndex = 0;
   261e0:	d026940d 	sth	zero,-26032(gp)
	u8StoreSubindex = 0;
   261e4:	d0269485 	stb	zero,-26030(gp)
	u32StoreDataSize = 0;
   261e8:	d0269315 	stw	zero,-26036(gp)
	pStoreData = NULL;
   261ec:	d0269215 	stw	zero,-26040(gp)
	pSdoPendFunc = NULL;
   261f0:	d0269115 	stw	zero,-26044(gp)
	bSdoInWork = FALSE;
   261f4:	d0268cc5 	stb	zero,-26061(gp)
	if (pSdoSegData != NULL)
   261f8:	20000226 	beq	r4,zero,26204 <SDOS_ClearPendingResponse+0x64>
	{
		FREEMEM((UINT16 VARMEM *) pSdoSegData);
   261fc:	0026b8c0 	call	26b8c <free>
		pSdoSegData = NULL;
   26200:	d0269015 	stw	zero,-26048(gp)
	}

	nSdoSegBytesToHandle = 0;
   26204:	d0268a15 	stw	zero,-26072(gp)
	nSdoSegService = 0;
   26208:	d0268c85 	stb	zero,-26062(gp)

}
   2620c:	dfc00017 	ldw	ra,0(sp)
   26210:	dec00104 	addi	sp,sp,4
   26214:	f800283a 	ret

00026218 <SDOS_SdoInfoInd>:
			is received from the master and calls depending from
			the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
{
   26218:	defff804 	addi	sp,sp,-32
   2621c:	dcc00515 	stw	r19,20(sp)
	UINT8 abort = 0;
	/* the variable opCode contains the requested SDO Information type */
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26220:	24c00203 	ldbu	r19,8(r4)
{
   26224:	dc800415 	stw	r18,16(sp)
   26228:	dc000215 	stw	r16,8(sp)
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   2622c:	9c801fcc 	andi	r18,r19,127
{
   26230:	dfc00715 	stw	ra,28(sp)
   26234:	dd000615 	stw	r20,24(sp)
   26238:	dc400315 	stw	r17,12(sp)
	UINT8 abort = 0;
   2623c:	d8000145 	stb	zero,5(sp)
	UINT16 index;
	UINT8 flags = COE_SERVICE;

	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
	   great enough for the service header of the requested SDO Information type */
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26240:	90c00158 	cmpnei	r3,r18,5
   26244:	2080000b 	ldhu	r2,0(r4)
{
   26248:	2021883a 	mov	r16,r4
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   2624c:	9027883a 	mov	r19,r18
   26250:	1800041e 	bne	r3,zero,26264 <SDOS_SdoInfoInd+0x4c>
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
   26254:	108002b0 	cmpltui	r2,r2,10
   26258:	10000926 	beq	r2,zero,26280 <SDOS_SdoInfoInd+0x68>
		{
			return MBXERR_SIZETOOSHORT;
   2625c:	00800184 	movi	r2,6
   26260:	00004b06 	br	26390 <SDOS_SdoInfoInd+0x178>
		}
	}
	else
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
   26264:	10800230 	cmpltui	r2,r2,8
   26268:	103ffc1e 	bne	r2,zero,2625c <SDOS_SdoInfoInd+0x44>
		{
			return MBXERR_SIZETOOSHORT;
		}
	}

	switch (opCode)
   2626c:	90800060 	cmpeqi	r2,r18,1
   26270:	10000b1e 	bne	r2,zero,262a0 <SDOS_SdoInfoInd+0x88>
   26274:	9000dc26 	beq	r18,zero,265e8 <SDOS_SdoInfoInd+0x3d0>
   26278:	908000e0 	cmpeqi	r2,r18,3
   2627c:	1000da26 	beq	r2,zero,265e8 <SDOS_SdoInfoInd+0x3d0>
		break;

	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
		/* get the requested index */
		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
   26280:	8100030b 	ldhu	r4,12(r16)
   26284:	d900018d 	sth	r4,6(sp)



		if (index < 0x1000)
   26288:	213fffcc 	andi	r4,r4,65535
   2628c:	20840028 	cmpgeui	r2,r4,4096
   26290:	1000741e 	bne	r2,zero,26464 <SDOS_SdoInfoInd+0x24c>
		{
			/*SDO Info access is only allowed for objects >= 0x1000*/
			abort = ABORTIDX_UNSUPPORTED_ACCESS;
   26294:	00800144 	movi	r2,5
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
			}
		}
		break;
	default:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   26298:	d8800145 	stb	r2,5(sp)
   2629c:	00009506 	br	264f4 <SDOS_SdoInfoInd+0x2dc>
		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
   262a0:	2440030b 	ldhu	r17,12(r4)
   262a4:	8cbfffcc 	andi	r18,r17,65535
   262a8:	908001b0 	cmpltui	r2,r18,6
   262ac:	10009126 	beq	r2,zero,264f4 <SDOS_SdoInfoInd+0x2dc>
			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
   262b0:	200b883a 	mov	r5,r4
   262b4:	010000f4 	movhi	r4,3
   262b8:	01800384 	movi	r6,14
   262bc:	21330c04 	addi	r4,r4,-13264
   262c0:	0026e840 	call	26e84 <memcpy>
			if (listType-- == 0)
   262c4:	90003a1e 	bne	r18,zero,263b0 <SDOS_SdoInfoInd+0x198>
				nSdoInfoFragmentsLeft = 0;
   262c8:	d0268f8d 	sth	zero,-26050(gp)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   262cc:	84800384 	addi	r18,r16,14
				nSdoInfoFragmentsLeft = 0;
   262d0:	0023883a 	mov	r17,zero
					UINT16 n = OBJ_GetNoOfObjects(i);
   262d4:	8809883a 	mov	r4,r17
   262d8:	002441c0 	call	2441c <OBJ_GetNoOfObjects>
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   262dc:	8c400044 	addi	r17,r17,1
					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
   262e0:	9080000d 	sth	r2,0(r18)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   262e4:	88800158 	cmpnei	r2,r17,5
   262e8:	94800084 	addi	r18,r18,2
   262ec:	103ff91e 	bne	r2,zero,262d4 <SDOS_SdoInfoInd+0xbc>
				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
   262f0:	00800484 	movi	r2,18
			pSdoInfoInd->MbxHeader.Length = size;
   262f4:	8080000d 	sth	r2,0(r16)
			if (abort == 0)
   262f8:	d8800143 	ldbu	r2,5(sp)
   262fc:	10007d1e 	bne	r2,zero,264f4 <SDOS_SdoInfoInd+0x2dc>
				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26300:	8080020b 	ldhu	r2,8(r16)
   26304:	00ffe004 	movi	r3,-128
   26308:	10c6703a 	and	r3,r2,r3
				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
   2630c:	18c00094 	ori	r3,r3,2
   26310:	80c0020d 	sth	r3,8(r16)
				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
   26314:	d0e68f8b 	ldhu	r3,-26050(gp)
   26318:	80c0028d 	sth	r3,10(r16)
				if (nSdoInfoFragmentsLeft)
   2631c:	18ffffcc 	andi	r3,r3,65535
   26320:	18007426 	beq	r3,zero,264f4 <SDOS_SdoInfoInd+0x2dc>
					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
   26324:	00ffc004 	movi	r3,-256
   26328:	10c4703a 	and	r2,r2,r3
   2632c:	10802094 	ori	r2,r2,130
   26330:	8080020d 	sth	r2,8(r16)
					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
   26334:	017fe084 	movi	r5,-126
	}

	if (abort)
   26338:	d8c00143 	ldbu	r3,5(sp)
   2633c:	18000d26 	beq	r3,zero,26374 <SDOS_SdoInfoInd+0x15c>
	{
		/* send a SDO Information Error response */
		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
   26340:	00800284 	movi	r2,10
   26344:	8080000d 	sth	r2,0(r16)

		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26348:	8080020b 	ldhu	r2,8(r16)
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);

		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   2634c:	180690ba 	slli	r3,r3,2
		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26350:	8000028d 	sth	zero,10(r16)
		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26354:	10bfe00c 	andi	r2,r2,65408
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
   26358:	108001d4 	ori	r2,r2,7
   2635c:	8080020d 	sth	r2,8(r16)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   26360:	008000f4 	movhi	r2,3
   26364:	1885883a 	add	r2,r3,r2
   26368:	10a5e917 	ldw	r2,-26716(r2)

		nSdoInfoFragmentsLeft = 0;
   2636c:	d0268f8d 	sth	zero,-26050(gp)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   26370:	80800315 	stw	r2,12(r16)
	}

	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
   26374:	29403fcc 	andi	r5,r5,255
   26378:	8009883a 	mov	r4,r16
   2637c:	0023d280 	call	23d28 <MBX_MailboxSendReq>
   26380:	10803fcc 	andi	r2,r2,255
   26384:	10000126 	beq	r2,zero,2638c <SDOS_SdoInfoInd+0x174>
	{
		/* if the mailbox response could not be sent (or stored), the response will be
		   stored in the variable pCoeSendStored and will be sent automatically
			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
			the next time from the master */
		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
   26388:	d4266915 	stw	r16,-26204(gp)
	}

	return 0;
   2638c:	0005883a 	mov	r2,zero
}
   26390:	dfc00717 	ldw	ra,28(sp)
   26394:	dd000617 	ldw	r20,24(sp)
   26398:	dcc00517 	ldw	r19,20(sp)
   2639c:	dc800417 	ldw	r18,16(sp)
   263a0:	dc400317 	ldw	r17,12(sp)
   263a4:	dc000217 	ldw	r16,8(sp)
   263a8:	dec00804 	addi	sp,sp,32
   263ac:	f800283a 	ret
				if (nSdoInfoFragmentsLeft)
   263b0:	d4a68f8b 	ldhu	r18,-26050(gp)
			if (listType-- == 0)
   263b4:	8c7fffc4 	addi	r17,r17,-1
					n = OBJ_GetNoOfObjects(listType);
   263b8:	8c403fcc 	andi	r17,r17,255
				if (nSdoInfoFragmentsLeft)
   263bc:	90bfffcc 	andi	r2,r18,65535
   263c0:	10001426 	beq	r2,zero,26414 <SDOS_SdoInfoInd+0x1fc>
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   263c4:	d4e6848b 	ldhu	r19,-26094(gp)
					index = nSdoInfoIndex;
   263c8:	d0a68f0b 	ldhu	r2,-26052(gp)
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
   263cc:	85000304 	addi	r20,r16,12
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   263d0:	9cfffd04 	addi	r19,r19,-12
					index = nSdoInfoIndex;
   263d4:	d880018d 	sth	r2,6(sp)
					nSdoInfoFragmentsLeft--;
   263d8:	94bfffc4 	addi	r18,r18,-1
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   263dc:	d8800144 	addi	r2,sp,5
   263e0:	d8800015 	stw	r2,0(sp)
   263e4:	a00f883a 	mov	r7,r20
   263e8:	99bfffcc 	andi	r6,r19,65535
   263ec:	d9400184 	addi	r5,sp,6
   263f0:	8809883a 	mov	r4,r17
					nSdoInfoFragmentsLeft--;
   263f4:	d4a68f8d 	sth	r18,-26050(gp)
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   263f8:	00244d40 	call	244d4 <OBJ_GetObjectList>
				nSdoInfoIndex = index;
   263fc:	d8c0018b 	ldhu	r3,6(sp)
   26400:	d0e68f0d 	sth	r3,-26052(gp)
					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
   26404:	d0e6848b 	ldhu	r3,-26094(gp)
   26408:	18fffe84 	addi	r3,r3,-6
   2640c:	1885c83a 	sub	r2,r3,r2
   26410:	003fb806 	br	262f4 <SDOS_SdoInfoInd+0xdc>
					n = OBJ_GetNoOfObjects(listType);
   26414:	8809883a 	mov	r4,r17
   26418:	002441c0 	call	2441c <OBJ_GetNoOfObjects>
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   2641c:	d166848b 	ldhu	r5,-26094(gp)
					if ((n << 1) > size)
   26420:	113fffcc 	andi	r4,r2,65535
					index = 0x1000;
   26424:	00c40004 	movi	r3,4096
					if ((n << 1) > size)
   26428:	2008907a 	slli	r4,r4,1
					index = 0x1000;
   2642c:	d8c0018d 	sth	r3,6(sp)
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26430:	28fffc84 	addi	r3,r5,-14
					if ((n << 1) > size)
   26434:	18bfffcc 	andi	r2,r3,65535
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26438:	1827883a 	mov	r19,r3
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
   2643c:	85000384 	addi	r20,r16,14
					if ((n << 1) > size)
   26440:	113fe60e 	bge	r2,r4,263dc <SDOS_SdoInfoInd+0x1c4>
						UINT16 Fragsize = size + 2;
   26444:	297ffd04 	addi	r5,r5,-12
						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
   26448:	297fffcc 	andi	r5,r5,65535
   2644c:	2089c83a 	sub	r4,r4,r2
   26450:	28bfffc4 	addi	r2,r5,-1
   26454:	2089883a 	add	r4,r4,r2
   26458:	00269a00 	call	269a0 <__divsi3>
   2645c:	1025883a 	mov	r18,r2
   26460:	003fde06 	br	263dc <SDOS_SdoInfoInd+0x1c4>
			pObjEntry = OBJ_GetObjectHandle(index);
   26464:	00240e00 	call	240e0 <OBJ_GetObjectHandle>
   26468:	1023883a 	mov	r17,r2
			if (pObjEntry)
   2646c:	10005c26 	beq	r2,zero,265e0 <SDOS_SdoInfoInd+0x3c8>
				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
   26470:	9cc000d8 	cmpnei	r19,r19,3
   26474:	9800211e 	bne	r19,zero,264fc <SDOS_SdoInfoInd+0x2e4>
					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
   26478:	1009883a 	mov	r4,r2
   2647c:	002461c0 	call	2461c <OBJ_GetObjDesc>
   26480:	01800104 	movi	r6,4
   26484:	100b883a 	mov	r5,r2
   26488:	81000384 	addi	r4,r16,14
   2648c:	0026e840 	call	26e84 <memcpy>
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   26490:	d900018b 	ldhu	r4,6(sp)
   26494:	000f883a 	mov	r7,zero
   26498:	880d883a 	mov	r6,r17
   2649c:	000b883a 	mov	r5,zero
   264a0:	00242a80 	call	242a8 <OBJ_GetDesc>
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   264a4:	d0e6848b 	ldhu	r3,-26094(gp)
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   264a8:	10800304 	addi	r2,r2,12
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   264ac:	10bfffcc 	andi	r2,r2,65535
   264b0:	18fffec4 	addi	r3,r3,-5
   264b4:	10c0460e 	bge	r2,r3,265d0 <SDOS_SdoInfoInd+0x3b8>
						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
   264b8:	d900018b 	ldhu	r4,6(sp)
   264bc:	81c00484 	addi	r7,r16,18
   264c0:	880d883a 	mov	r6,r17
   264c4:	000b883a 	mov	r5,zero
   264c8:	00242a80 	call	242a8 <OBJ_GetDesc>
   264cc:	10800304 	addi	r2,r2,12
				if (abort == 0)
   264d0:	d8c00143 	ldbu	r3,5(sp)
   264d4:	1800071e 	bne	r3,zero,264f4 <SDOS_SdoInfoInd+0x2dc>
						pSdoInfoInd->MbxHeader.Length = size;
   264d8:	8080000d 	sth	r2,0(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   264dc:	8080020b 	ldhu	r2,8(r16)
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   264e0:	94800044 	addi	r18,r18,1
						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   264e4:	8000028d 	sth	zero,10(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   264e8:	10bfe00c 	andi	r2,r2,65408
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   264ec:	14a4b03a 	or	r18,r2,r18
   264f0:	8480020d 	sth	r18,8(r16)
	UINT8 flags = COE_SERVICE;
   264f4:	01400084 	movi	r5,2
   264f8:	003f8f06 	br	26338 <SDOS_SdoInfoInd+0x120>
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   264fc:	1009883a 	mov	r4,r2
					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
   26500:	84c00383 	ldbu	r19,14(r16)
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26504:	002461c0 	call	2461c <OBJ_GetObjDesc>
					if (subindex <= maxSubindex)
   26508:	10800083 	ldbu	r2,2(r2)
   2650c:	9cc03fcc 	andi	r19,r19,255
   26510:	14c02b36 	bltu	r2,r19,265c0 <SDOS_SdoInfoInd+0x3a8>
						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
   26514:	980b883a 	mov	r5,r19
   26518:	8809883a 	mov	r4,r17
   2651c:	00243e00 	call	243e0 <OBJ_GetEntryDesc>
   26520:	01800184 	movi	r6,6
   26524:	100b883a 	mov	r5,r2
   26528:	81000404 	addi	r4,r16,16
   2652c:	0026e840 	call	26e84 <memcpy>
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26530:	80800383 	ldbu	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26534:	8809883a 	mov	r4,r17
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26538:	8080038d 	sth	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   2653c:	002461c0 	call	2461c <OBJ_GetObjDesc>
						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   26540:	1080008b 	ldhu	r2,2(r2)
   26544:	1005d23a 	srai	r2,r2,8
   26548:	108003cc 	andi	r2,r2,15
						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
   2654c:	10bffe04 	addi	r2,r2,-8
   26550:	10bfffcc 	andi	r2,r2,65535
   26554:	108000a8 	cmpgeui	r2,r2,2
   26558:	1000081e 	bne	r2,zero,2657c <SDOS_SdoInfoInd+0x364>
   2655c:	9800071e 	bne	r19,zero,2657c <SDOS_SdoInfoInd+0x364>
							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
   26560:	014000f4 	movhi	r5,3
   26564:	01800344 	movi	r6,13
   26568:	296bf504 	addi	r5,r5,-20524
   2656c:	81000584 	addi	r4,r16,22
   26570:	0026e840 	call	26e84 <memcpy>
							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
   26574:	00800704 	movi	r2,28
   26578:	003fd506 	br	264d0 <SDOS_SdoInfoInd+0x2b8>
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   2657c:	d900018b 	ldhu	r4,6(sp)
   26580:	000f883a 	mov	r7,zero
   26584:	880d883a 	mov	r6,r17
   26588:	980b883a 	mov	r5,r19
   2658c:	00242a80 	call	242a8 <OBJ_GetDesc>
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   26590:	d0e6848b 	ldhu	r3,-26094(gp)
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26594:	10800404 	addi	r2,r2,16
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   26598:	10bfffcc 	andi	r2,r2,65535
   2659c:	18fffec4 	addi	r3,r3,-5
   265a0:	10c00d0e 	bge	r2,r3,265d8 <SDOS_SdoInfoInd+0x3c0>
								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265a4:	d900018b 	ldhu	r4,6(sp)
   265a8:	81c00584 	addi	r7,r16,22
   265ac:	880d883a 	mov	r6,r17
   265b0:	980b883a 	mov	r5,r19
   265b4:	00242a80 	call	242a8 <OBJ_GetDesc>
   265b8:	10800404 	addi	r2,r2,16
   265bc:	003fc406 	br	264d0 <SDOS_SdoInfoInd+0x2b8>
						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
   265c0:	00800444 	movi	r2,17
   265c4:	d8800145 	stb	r2,5(sp)
				UINT16 size = 0;
   265c8:	0005883a 	mov	r2,zero
   265cc:	003fc006 	br	264d0 <SDOS_SdoInfoInd+0x2b8>
						size = SIZEOF_SDOINFOOBJSTRUCT;
   265d0:	00800304 	movi	r2,12
   265d4:	003fbe06 	br	264d0 <SDOS_SdoInfoInd+0x2b8>
								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265d8:	00800404 	movi	r2,16
   265dc:	003fbc06 	br	264d0 <SDOS_SdoInfoInd+0x2b8>
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
   265e0:	00800204 	movi	r2,8
   265e4:	003f2c06 	br	26298 <SDOS_SdoInfoInd+0x80>
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   265e8:	008000c4 	movi	r2,3
   265ec:	003f2a06 	br	26298 <SDOS_SdoInfoInd+0x80>

000265f0 <exti0_isr>:

volatile int edge_capture;

//ISR routine
void exti0_isr (void * context)
{
   265f0:	deffff04 	addi	sp,sp,-4
   265f4:	dfc00015 	stw	ra,0(sp)
	 //IOWR_32DIRECT(USER_HANDLER_0_BASE, 0x204, 1); //DC SYNC
	 PDI_Isr();
   265f8:	00213080 	call	21308 <PDI_Isr>
	 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0);
   265fc:	00800134 	movhi	r2,4
   26600:	10040b35 	stwio	zero,4140(r2)
	 IORD_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE);
   26604:	10840b37 	ldwio	r2,4140(r2)
	 // for debugging
	 //printf("Called ISR!\n");
}
   26608:	dfc00017 	ldw	ra,0(sp)
   2660c:	dec00104 	addi	sp,sp,4
   26610:	f800283a 	ret

00026614 <init_exti0_it>:

void init_exti0_it (void)
{
   26614:	defffe04 	addi	sp,sp,-8
   26618:	dfc00115 	stw	ra,4(sp)
	 void* edge_capture_ptr = (void*) &edge_capture;
	 IOWR_ALTERA_AVALON_PIO_IRQ_MASK(ESC_SPI_SINT_BASE, 0x1);
   2661c:	00c00044 	movi	r3,1
   26620:	00800134 	movhi	r2,4
   26624:	10c40a35 	stwio	r3,4136(r2)
	 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0x0);
   26628:	10040b35 	stwio	zero,4140(r2)
	 alt_ic_isr_register(ESC_SPI_SINT_IRQ_INTERRUPT_CONTROLLER_ID, ESC_SPI_SINT_IRQ, exti0_isr, edge_capture_ptr, 0x0);
   2662c:	018000b4 	movhi	r6,2
   26630:	d8000015 	stw	zero,0(sp)
   26634:	d1e69604 	addi	r7,gp,-26024
   26638:	31997c04 	addi	r6,r6,26096
   2663c:	01400084 	movi	r5,2
   26640:	0009883a 	mov	r4,zero
   26644:	00271280 	call	27128 <alt_ic_isr_register>
	 IORD_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE);
   26648:	00800134 	movhi	r2,4
   2664c:	10840b37 	ldwio	r2,4140(r2)
	 //IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0x0);
}
   26650:	dfc00117 	ldw	ra,4(sp)
   26654:	dec00204 	addi	sp,sp,8
   26658:	f800283a 	ret

0002665c <delay_ms>:
#include "system.h"
#include "stdint.h"

// Delay function
// No Parameters
void delay_ms(int milliseconds) {
   2665c:	deffff04 	addi	sp,sp,-4
    usleep(milliseconds * 1000);  // Convert to microseconds
   26660:	0140fa04 	movi	r5,1000
void delay_ms(int milliseconds) {
   26664:	dfc00015 	stw	ra,0(sp)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26668:	0026b540 	call	26b54 <__mulsi3>
   2666c:	1009883a 	mov	r4,r2
}
   26670:	dfc00017 	ldw	ra,0(sp)
   26674:	dec00104 	addi	sp,sp,4
    usleep(milliseconds * 1000);  // Convert to microseconds
   26678:	00273201 	jmpi	27320 <usleep>

0002667c <adc_init>:
// Parameter 2: Base address for SPI Chip Select Manual
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){

	int spi_check = -1;
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   2667c:	008100f4 	movhi	r2,1027
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   26680:	defff404 	addi	sp,sp,-48
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   26684:	10804044 	addi	r2,r2,257
   26688:	d8800415 	stw	r2,16(sp)
	alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   2668c:	00954184 	movi	r2,21766
   26690:	d8800515 	stw	r2,20(sp)
	alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
   26694:	008201f4 	movhi	r2,2055
   26698:	10818144 	addi	r2,r2,1541
   2669c:	d8800615 	stw	r2,24(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   266a0:	00954144 	movi	r2,21765
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   266a4:	dc400a15 	stw	r17,40(sp)
   266a8:	dc000915 	stw	r16,36(sp)
   266ac:	dfc00b15 	stw	ra,44(sp)
   266b0:	2021883a 	mov	r16,r4
   266b4:	2823883a 	mov	r17,r5
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   266b8:	d8000315 	stw	zero,12(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   266bc:	d8800715 	stw	r2,28(sp)
	uint8_t opcode_lock_receive[4] = {0x00, 0x00, 0x00, 0x00};
   266c0:	d8000815 	stw	zero,32(sp)

	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   266c4:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   266c8:	0104e204 	movi	r4,5000
   266cc:	00273200 	call	27320 <usleep>
	delay_ms(5);
	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   266d0:	00800044 	movi	r2,1
   266d4:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   266d8:	01138804 	movi	r4,20000
   266dc:	00273200 	call	27320 <usleep>
	delay_ms(20);

	spi_check = alt_avalon_spi_command(base,
   266e0:	d9c00304 	addi	r7,sp,12
   266e4:	01800104 	movi	r6,4
   266e8:	000b883a 	mov	r5,zero
   266ec:	8009883a 	mov	r4,r16
   266f0:	d8000215 	stw	zero,8(sp)
   266f4:	d8000115 	stw	zero,4(sp)
   266f8:	d8000015 	stw	zero,0(sp)
   266fc:	00273d40 	call	273d4 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26700:	0130d414 	movui	r4,50000
   26704:	00273200 	call	27320 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26708:	04400104 	movi	r17,4
   2670c:	d8800404 	addi	r2,sp,16
   26710:	8009883a 	mov	r4,r16
   26714:	d8000215 	stw	zero,8(sp)
   26718:	d8800115 	stw	r2,4(sp)
   2671c:	dc400015 	stw	r17,0(sp)
   26720:	000f883a 	mov	r7,zero
   26724:	000d883a 	mov	r6,zero
   26728:	000b883a 	mov	r5,zero
   2672c:	00273d40 	call	273d4 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_null_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26730:	d9c00504 	addi	r7,sp,20
   26734:	01800104 	movi	r6,4
   26738:	000b883a 	mov	r5,zero
   2673c:	8009883a 	mov	r4,r16
   26740:	d8000215 	stw	zero,8(sp)
   26744:	d8000115 	stw	zero,4(sp)
   26748:	d8000015 	stw	zero,0(sp)
   2674c:	00273d40 	call	273d4 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26750:	0130d414 	movui	r4,50000
   26754:	00273200 	call	27320 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26758:	d8800604 	addi	r2,sp,24
   2675c:	8009883a 	mov	r4,r16
   26760:	d8000215 	stw	zero,8(sp)
   26764:	d8800115 	stw	r2,4(sp)
   26768:	dc400015 	stw	r17,0(sp)
   2676c:	000f883a 	mov	r7,zero
   26770:	000d883a 	mov	r6,zero
   26774:	000b883a 	mov	r5,zero
   26778:	00273d40 	call	273d4 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   2677c:	d9c00704 	addi	r7,sp,28
   26780:	01800104 	movi	r6,4
   26784:	000b883a 	mov	r5,zero
   26788:	8009883a 	mov	r4,r16
   2678c:	d8000215 	stw	zero,8(sp)
   26790:	d8000115 	stw	zero,4(sp)
   26794:	d8000015 	stw	zero,0(sp)
   26798:	00273d40 	call	273d4 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   2679c:	0130d414 	movui	r4,50000
   267a0:	00273200 	call	27320 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   267a4:	d8800804 	addi	r2,sp,32
   267a8:	000f883a 	mov	r7,zero
   267ac:	000d883a 	mov	r6,zero
   267b0:	000b883a 	mov	r5,zero
   267b4:	8009883a 	mov	r4,r16
   267b8:	d8000215 	stw	zero,8(sp)
   267bc:	d8800115 	stw	r2,4(sp)
   267c0:	dc400015 	stw	r17,0(sp)
   267c4:	00273d40 	call	273d4 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   267c8:	0130d414 	movui	r4,50000
   267cc:	00273200 	call	27320 <usleep>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);
	 delay_ms(50);
}
   267d0:	dfc00b17 	ldw	ra,44(sp)
   267d4:	dc400a17 	ldw	r17,40(sp)
   267d8:	dc000917 	ldw	r16,36(sp)
   267dc:	dec00c04 	addi	sp,sp,48
   267e0:	f800283a 	ret

000267e4 <spi_transmit_receive>:
    alt_u8 *rx_ptr = rx_buf;
    const alt_u8 *tx_end = tx_buf ? (tx_buf + length) : NULL;
    alt_u8 dummy_tx = 0xFF;

    // 1. Select slave
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   267e4:	00c00044 	movi	r3,1
{
   267e8:	d8800017 	ldw	r2,0(sp)
   267ec:	da000117 	ldw	r8,4(sp)
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   267f0:	1946983a 	sll	r3,r3,r5
   267f4:	20c00535 	stwio	r3,20(r4)

    // 2. Assert CS unless toggle flag is set
    if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   267f8:	40c0008c 	andi	r3,r8,2
   267fc:	1800021e 	bne	r3,zero,26808 <spi_transmit_receive+0x24>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   26800:	00c10004 	movi	r3,1024
   26804:	20c00335 	stwio	r3,12(r4)
    }

    // 3. Clear stale RX
    IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26808:	20c00037 	ldwio	r3,0(r4)
    alt_32 credits = 1;
   2680c:	00c00044 	movi	r3,1
    alt_u8 *rx_ptr = rx_buf;
   26810:	3813883a 	mov	r9,r7

    while ((rx_ptr - rx_buf) < length)
   26814:	49cbc83a 	sub	r5,r9,r7
   26818:	22800204 	addi	r10,r4,8
   2681c:	28800736 	bltu	r5,r2,2683c <spi_transmit_receive+0x58>
        }
    }

    // Wait until TX FIFO is empty (transmit complete)
    do {
        status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26820:	50c00037 	ldwio	r3,0(r10)
    } while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   26824:	18c0080c 	andi	r3,r3,32
   26828:	183ffd26 	beq	r3,zero,26820 <spi_transmit_receive+0x3c>

    // Release chip select unless merging
    if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0) {
   2682c:	4200004c 	andi	r8,r8,1
   26830:	4000011e 	bne	r8,zero,26838 <spi_transmit_receive+0x54>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   26834:	20000335 	stwio	zero,12(r4)
    }

    return length;
}
   26838:	f800283a 	ret
            status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   2683c:	51400037 	ldwio	r5,0(r10)
        } while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   26840:	2ac0100c 	andi	r11,r5,64
   26844:	2940200c 	andi	r5,r5,128
   26848:	58000126 	beq	r11,zero,26850 <spi_transmit_receive+0x6c>
   2684c:	1800031e 	bne	r3,zero,2685c <spi_transmit_receive+0x78>
   26850:	283ffa26 	beq	r5,zero,2683c <spi_transmit_receive+0x58>
        if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) && credits > 0) {
   26854:	58000726 	beq	r11,zero,26874 <spi_transmit_receive+0x90>
   26858:	18000626 	beq	r3,zero,26874 <spi_transmit_receive+0x90>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   2685c:	30000b26 	beq	r6,zero,2688c <spi_transmit_receive+0xa8>
   26860:	32800003 	ldbu	r10,0(r6)
   26864:	31800044 	addi	r6,r6,1
            IOWR_ALTERA_AVALON_SPI_TXDATA(base, tx_data);
   26868:	52803fcc 	andi	r10,r10,255
   2686c:	22800135 	stwio	r10,4(r4)
            credits--;
   26870:	18ffffc4 	addi	r3,r3,-1
        if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) {
   26874:	283fe726 	beq	r5,zero,26814 <spi_transmit_receive+0x30>
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26878:	21400037 	ldwio	r5,0(r4)
   2687c:	49400005 	stb	r5,0(r9)
            credits++;
   26880:	18c00044 	addi	r3,r3,1
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26884:	4a400044 	addi	r9,r9,1
   26888:	003fe206 	br	26814 <spi_transmit_receive+0x30>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   2688c:	02bfffc4 	movi	r10,-1
   26890:	003ff506 	br	26868 <spi_transmit_receive+0x84>

00026894 <adc_init_spi_transmit_receive>:

// ADC Initialization Using Full-Duplex SPI
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26894:	defff304 	addi	sp,sp,-52
	int spi_check = -1;
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
		alt_u8 opcode_null_receive[4] = {0x01, 0x02, 0x03, 0x04};
		alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   26898:	00954184 	movi	r2,21766
   2689c:	d8800515 	stw	r2,20(sp)
		alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
		uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   268a0:	00954144 	movi	r2,21765
   268a4:	d8800715 	stw	r2,28(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   268a8:	00824274 	movhi	r2,2313
   268ac:	108201c4 	addi	r2,r2,2055
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   268b0:	dc400a15 	stw	r17,40(sp)
   268b4:	dc000915 	stw	r16,36(sp)
   268b8:	dfc00c15 	stw	ra,48(sp)
   268bc:	dc800b15 	stw	r18,44(sp)
   268c0:	2021883a 	mov	r16,r4
   268c4:	2823883a 	mov	r17,r5
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   268c8:	d8000315 	stw	zero,12(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   268cc:	d8800815 	stw	r2,32(sp)

		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   268d0:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   268d4:	0104e204 	movi	r4,5000
   268d8:	00273200 	call	27320 <usleep>
		delay_ms(5);
		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   268dc:	00800044 	movi	r2,1
   268e0:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   268e4:	01138804 	movi	r4,20000
   268e8:	00273200 	call	27320 <usleep>
		delay_ms(20);

		spi_check = spi_transmit_receive(	base,
   268ec:	04400104 	movi	r17,4
   268f0:	d9c00404 	addi	r7,sp,16
   268f4:	d9800304 	addi	r6,sp,12
   268f8:	000b883a 	mov	r5,zero
   268fc:	8009883a 	mov	r4,r16
   26900:	d8000115 	stw	zero,4(sp)
   26904:	dc400015 	stw	r17,0(sp)
   26908:	00267e40 	call	267e4 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   2690c:	0100fa04 	movi	r4,1000
   26910:	00273200 	call	27320 <usleep>
											4,
											0							// Special control flags for the SPI command
											);

				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26914:	d9c00604 	addi	r7,sp,24
   26918:	d9800504 	addi	r6,sp,20
   2691c:	000b883a 	mov	r5,zero
   26920:	8009883a 	mov	r4,r16
   26924:	d8000115 	stw	zero,4(sp)
   26928:	dc400015 	stw	r17,0(sp)
   2692c:	00267e40 	call	267e4 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26930:	0100fa04 	movi	r4,1000
   26934:	00273200 	call	27320 <usleep>
											opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26938:	dc800804 	addi	r18,sp,32
   2693c:	900f883a 	mov	r7,r18
   26940:	d9800704 	addi	r6,sp,28
   26944:	000b883a 	mov	r5,zero
   26948:	8009883a 	mov	r4,r16
   2694c:	d8000115 	stw	zero,4(sp)
   26950:	dc400015 	stw	r17,0(sp)
   26954:	00267e40 	call	267e4 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26958:	0100fa04 	movi	r4,1000
   2695c:	00273200 	call	27320 <usleep>
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = alt_avalon_spi_command(base,
   26960:	000f883a 	mov	r7,zero
   26964:	000d883a 	mov	r6,zero
   26968:	000b883a 	mov	r5,zero
   2696c:	8009883a 	mov	r4,r16
   26970:	d8000215 	stw	zero,8(sp)
   26974:	dc800115 	stw	r18,4(sp)
   26978:	dc400015 	stw	r17,0(sp)
   2697c:	00273d40 	call	273d4 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26980:	0100fa04 	movi	r4,1000
   26984:	00273200 	call	27320 <usleep>
											4,							// The number of bytes to read from the SPI slave, '0' if only writing
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
}
   26988:	dfc00c17 	ldw	ra,48(sp)
   2698c:	dc800b17 	ldw	r18,44(sp)
   26990:	dc400a17 	ldw	r17,40(sp)
   26994:	dc000917 	ldw	r16,36(sp)
   26998:	dec00d04 	addi	sp,sp,52
   2699c:	f800283a 	ret

000269a0 <__divsi3>:
   269a0:	20001a16 	blt	r4,zero,26a0c <__divsi3+0x6c>
   269a4:	000f883a 	mov	r7,zero
   269a8:	2800020e 	bge	r5,zero,269b4 <__divsi3+0x14>
   269ac:	014bc83a 	sub	r5,zero,r5
   269b0:	39c0005c 	xori	r7,r7,1
   269b4:	200d883a 	mov	r6,r4
   269b8:	00c00044 	movi	r3,1
   269bc:	2900092e 	bgeu	r5,r4,269e4 <__divsi3+0x44>
   269c0:	00800804 	movi	r2,32
   269c4:	00c00044 	movi	r3,1
   269c8:	00000106 	br	269d0 <__divsi3+0x30>
   269cc:	10001226 	beq	r2,zero,26a18 <__divsi3+0x78>
   269d0:	294b883a 	add	r5,r5,r5
   269d4:	10bfffc4 	addi	r2,r2,-1
   269d8:	18c7883a 	add	r3,r3,r3
   269dc:	293ffb36 	bltu	r5,r4,269cc <__divsi3+0x2c>
   269e0:	18000d26 	beq	r3,zero,26a18 <__divsi3+0x78>
   269e4:	0005883a 	mov	r2,zero
   269e8:	31400236 	bltu	r6,r5,269f4 <__divsi3+0x54>
   269ec:	314dc83a 	sub	r6,r6,r5
   269f0:	10c4b03a 	or	r2,r2,r3
   269f4:	1806d07a 	srli	r3,r3,1
   269f8:	280ad07a 	srli	r5,r5,1
   269fc:	183ffa1e 	bne	r3,zero,269e8 <__divsi3+0x48>
   26a00:	38000126 	beq	r7,zero,26a08 <__divsi3+0x68>
   26a04:	0085c83a 	sub	r2,zero,r2
   26a08:	f800283a 	ret
   26a0c:	0109c83a 	sub	r4,zero,r4
   26a10:	01c00044 	movi	r7,1
   26a14:	003fe406 	br	269a8 <__divsi3+0x8>
   26a18:	0005883a 	mov	r2,zero
   26a1c:	003ff806 	br	26a00 <__divsi3+0x60>

00026a20 <__modsi3>:
   26a20:	20001716 	blt	r4,zero,26a80 <__modsi3+0x60>
   26a24:	000f883a 	mov	r7,zero
   26a28:	2005883a 	mov	r2,r4
   26a2c:	2800010e 	bge	r5,zero,26a34 <__modsi3+0x14>
   26a30:	014bc83a 	sub	r5,zero,r5
   26a34:	00c00044 	movi	r3,1
   26a38:	2900092e 	bgeu	r5,r4,26a60 <__modsi3+0x40>
   26a3c:	01800804 	movi	r6,32
   26a40:	00c00044 	movi	r3,1
   26a44:	00000106 	br	26a4c <__modsi3+0x2c>
   26a48:	30001026 	beq	r6,zero,26a8c <__modsi3+0x6c>
   26a4c:	294b883a 	add	r5,r5,r5
   26a50:	31bfffc4 	addi	r6,r6,-1
   26a54:	18c7883a 	add	r3,r3,r3
   26a58:	293ffb36 	bltu	r5,r4,26a48 <__modsi3+0x28>
   26a5c:	18000b26 	beq	r3,zero,26a8c <__modsi3+0x6c>
   26a60:	1806d07a 	srli	r3,r3,1
   26a64:	11400136 	bltu	r2,r5,26a6c <__modsi3+0x4c>
   26a68:	1145c83a 	sub	r2,r2,r5
   26a6c:	280ad07a 	srli	r5,r5,1
   26a70:	183ffb1e 	bne	r3,zero,26a60 <__modsi3+0x40>
   26a74:	38000126 	beq	r7,zero,26a7c <__modsi3+0x5c>
   26a78:	0085c83a 	sub	r2,zero,r2
   26a7c:	f800283a 	ret
   26a80:	0109c83a 	sub	r4,zero,r4
   26a84:	01c00044 	movi	r7,1
   26a88:	003fe706 	br	26a28 <__modsi3+0x8>
   26a8c:	2005883a 	mov	r2,r4
   26a90:	003ff806 	br	26a74 <__modsi3+0x54>

00026a94 <__udivsi3>:
   26a94:	200d883a 	mov	r6,r4
   26a98:	2900152e 	bgeu	r5,r4,26af0 <__udivsi3+0x5c>
   26a9c:	28001416 	blt	r5,zero,26af0 <__udivsi3+0x5c>
   26aa0:	00800804 	movi	r2,32
   26aa4:	00c00044 	movi	r3,1
   26aa8:	00000206 	br	26ab4 <__udivsi3+0x20>
   26aac:	10000e26 	beq	r2,zero,26ae8 <__udivsi3+0x54>
   26ab0:	28000416 	blt	r5,zero,26ac4 <__udivsi3+0x30>
   26ab4:	294b883a 	add	r5,r5,r5
   26ab8:	10bfffc4 	addi	r2,r2,-1
   26abc:	18c7883a 	add	r3,r3,r3
   26ac0:	293ffa36 	bltu	r5,r4,26aac <__udivsi3+0x18>
   26ac4:	18000826 	beq	r3,zero,26ae8 <__udivsi3+0x54>
   26ac8:	0005883a 	mov	r2,zero
   26acc:	31400236 	bltu	r6,r5,26ad8 <__udivsi3+0x44>
   26ad0:	314dc83a 	sub	r6,r6,r5
   26ad4:	10c4b03a 	or	r2,r2,r3
   26ad8:	1806d07a 	srli	r3,r3,1
   26adc:	280ad07a 	srli	r5,r5,1
   26ae0:	183ffa1e 	bne	r3,zero,26acc <__udivsi3+0x38>
   26ae4:	f800283a 	ret
   26ae8:	0005883a 	mov	r2,zero
   26aec:	f800283a 	ret
   26af0:	00c00044 	movi	r3,1
   26af4:	003ff406 	br	26ac8 <__udivsi3+0x34>

00026af8 <__umodsi3>:
   26af8:	2005883a 	mov	r2,r4
   26afc:	2900132e 	bgeu	r5,r4,26b4c <__umodsi3+0x54>
   26b00:	28001216 	blt	r5,zero,26b4c <__umodsi3+0x54>
   26b04:	01800804 	movi	r6,32
   26b08:	00c00044 	movi	r3,1
   26b0c:	00000206 	br	26b18 <__umodsi3+0x20>
   26b10:	30000c26 	beq	r6,zero,26b44 <__umodsi3+0x4c>
   26b14:	28000416 	blt	r5,zero,26b28 <__umodsi3+0x30>
   26b18:	294b883a 	add	r5,r5,r5
   26b1c:	31bfffc4 	addi	r6,r6,-1
   26b20:	18c7883a 	add	r3,r3,r3
   26b24:	293ffa36 	bltu	r5,r4,26b10 <__umodsi3+0x18>
   26b28:	18000626 	beq	r3,zero,26b44 <__umodsi3+0x4c>
   26b2c:	1806d07a 	srli	r3,r3,1
   26b30:	11400136 	bltu	r2,r5,26b38 <__umodsi3+0x40>
   26b34:	1145c83a 	sub	r2,r2,r5
   26b38:	280ad07a 	srli	r5,r5,1
   26b3c:	183ffb1e 	bne	r3,zero,26b2c <__umodsi3+0x34>
   26b40:	f800283a 	ret
   26b44:	2005883a 	mov	r2,r4
   26b48:	f800283a 	ret
   26b4c:	00c00044 	movi	r3,1
   26b50:	003ff606 	br	26b2c <__umodsi3+0x34>

00026b54 <__mulsi3>:
   26b54:	0005883a 	mov	r2,zero
   26b58:	20000726 	beq	r4,zero,26b78 <__mulsi3+0x24>
   26b5c:	20c0004c 	andi	r3,r4,1
   26b60:	2008d07a 	srli	r4,r4,1
   26b64:	18000126 	beq	r3,zero,26b6c <__mulsi3+0x18>
   26b68:	1145883a 	add	r2,r2,r5
   26b6c:	294b883a 	add	r5,r5,r5
   26b70:	203ffa1e 	bne	r4,zero,26b5c <__mulsi3+0x8>
   26b74:	f800283a 	ret
   26b78:	f800283a 	ret

00026b7c <malloc>:
   26b7c:	008000f4 	movhi	r2,3
   26b80:	200b883a 	mov	r5,r4
   26b84:	112c3317 	ldw	r4,-20276(r2)
   26b88:	0026c281 	jmpi	26c28 <_malloc_r>

00026b8c <free>:
   26b8c:	008000f4 	movhi	r2,3
   26b90:	200b883a 	mov	r5,r4
   26b94:	112c3317 	ldw	r4,-20276(r2)
   26b98:	0026f301 	jmpi	26f30 <_free_r>

00026b9c <sbrk_aligned>:
   26b9c:	008000f4 	movhi	r2,3
   26ba0:	10b2a817 	ldw	r2,-13664(r2)
   26ba4:	defffd04 	addi	sp,sp,-12
   26ba8:	dc400115 	stw	r17,4(sp)
   26bac:	dc000015 	stw	r16,0(sp)
   26bb0:	dfc00215 	stw	ra,8(sp)
   26bb4:	2023883a 	mov	r17,r4
   26bb8:	2821883a 	mov	r16,r5
   26bbc:	1000041e 	bne	r2,zero,26bd0 <sbrk_aligned+0x34>
   26bc0:	000b883a 	mov	r5,zero
   26bc4:	0026ee80 	call	26ee8 <_sbrk_r>
   26bc8:	00c000f4 	movhi	r3,3
   26bcc:	18b2a815 	stw	r2,-13664(r3)
   26bd0:	800b883a 	mov	r5,r16
   26bd4:	8809883a 	mov	r4,r17
   26bd8:	0026ee80 	call	26ee8 <_sbrk_r>
   26bdc:	10ffffd8 	cmpnei	r3,r2,-1
   26be0:	1800071e 	bne	r3,zero,26c00 <sbrk_aligned+0x64>
   26be4:	043fffc4 	movi	r16,-1
   26be8:	8005883a 	mov	r2,r16
   26bec:	dfc00217 	ldw	ra,8(sp)
   26bf0:	dc400117 	ldw	r17,4(sp)
   26bf4:	dc000017 	ldw	r16,0(sp)
   26bf8:	dec00304 	addi	sp,sp,12
   26bfc:	f800283a 	ret
   26c00:	140000c4 	addi	r16,r2,3
   26c04:	00ffff04 	movi	r3,-4
   26c08:	80e0703a 	and	r16,r16,r3
   26c0c:	143ff626 	beq	r2,r16,26be8 <sbrk_aligned+0x4c>
   26c10:	808bc83a 	sub	r5,r16,r2
   26c14:	8809883a 	mov	r4,r17
   26c18:	0026ee80 	call	26ee8 <_sbrk_r>
   26c1c:	10bfffe0 	cmpeqi	r2,r2,-1
   26c20:	103ff126 	beq	r2,zero,26be8 <sbrk_aligned+0x4c>
   26c24:	003fef06 	br	26be4 <sbrk_aligned+0x48>

00026c28 <_malloc_r>:
   26c28:	defffb04 	addi	sp,sp,-20
   26c2c:	00bfff04 	movi	r2,-4
   26c30:	dc400115 	stw	r17,4(sp)
   26c34:	2c4000c4 	addi	r17,r5,3
   26c38:	88a2703a 	and	r17,r17,r2
   26c3c:	8c400204 	addi	r17,r17,8
   26c40:	dc800215 	stw	r18,8(sp)
   26c44:	dfc00415 	stw	ra,16(sp)
   26c48:	dcc00315 	stw	r19,12(sp)
   26c4c:	dc000015 	stw	r16,0(sp)
   26c50:	88800328 	cmpgeui	r2,r17,12
   26c54:	2025883a 	mov	r18,r4
   26c58:	10002a1e 	bne	r2,zero,26d04 <_malloc_r+0xdc>
   26c5c:	04400304 	movi	r17,12
   26c60:	89402936 	bltu	r17,r5,26d08 <_malloc_r+0xe0>
   26c64:	9009883a 	mov	r4,r18
   26c68:	00272cc0 	call	272cc <__malloc_lock>
   26c6c:	008000f4 	movhi	r2,3
   26c70:	10b2a917 	ldw	r2,-13660(r2)
   26c74:	1021883a 	mov	r16,r2
   26c78:	80002d1e 	bne	r16,zero,26d30 <_malloc_r+0x108>
   26c7c:	880b883a 	mov	r5,r17
   26c80:	9009883a 	mov	r4,r18
   26c84:	0026b9c0 	call	26b9c <sbrk_aligned>
   26c88:	1021883a 	mov	r16,r2
   26c8c:	10bfffd8 	cmpnei	r2,r2,-1
   26c90:	1000561e 	bne	r2,zero,26dec <_malloc_r+0x1c4>
   26c94:	008000f4 	movhi	r2,3
   26c98:	1432a917 	ldw	r16,-13660(r2)
   26c9c:	8005883a 	mov	r2,r16
   26ca0:	1000481e 	bne	r2,zero,26dc4 <_malloc_r+0x19c>
   26ca4:	80004c26 	beq	r16,zero,26dd8 <_malloc_r+0x1b0>
   26ca8:	84c00017 	ldw	r19,0(r16)
   26cac:	000b883a 	mov	r5,zero
   26cb0:	9009883a 	mov	r4,r18
   26cb4:	84e7883a 	add	r19,r16,r19
   26cb8:	0026ee80 	call	26ee8 <_sbrk_r>
   26cbc:	9880461e 	bne	r19,r2,26dd8 <_malloc_r+0x1b0>
   26cc0:	80800017 	ldw	r2,0(r16)
   26cc4:	9009883a 	mov	r4,r18
   26cc8:	88a3c83a 	sub	r17,r17,r2
   26ccc:	880b883a 	mov	r5,r17
   26cd0:	0026b9c0 	call	26b9c <sbrk_aligned>
   26cd4:	10bfffe0 	cmpeqi	r2,r2,-1
   26cd8:	10003f1e 	bne	r2,zero,26dd8 <_malloc_r+0x1b0>
   26cdc:	80800017 	ldw	r2,0(r16)
   26ce0:	1445883a 	add	r2,r2,r17
   26ce4:	80800015 	stw	r2,0(r16)
   26ce8:	008000f4 	movhi	r2,3
   26cec:	10b2a917 	ldw	r2,-13660(r2)
   26cf0:	10000226 	beq	r2,zero,26cfc <_malloc_r+0xd4>
   26cf4:	10c00117 	ldw	r3,4(r2)
   26cf8:	1c00351e 	bne	r3,r16,26dd0 <_malloc_r+0x1a8>
   26cfc:	10000115 	stw	zero,4(r2)
   26d00:	00001806 	br	26d64 <_malloc_r+0x13c>
   26d04:	883fd60e 	bge	r17,zero,26c60 <_malloc_r+0x38>
   26d08:	00800304 	movi	r2,12
   26d0c:	90800015 	stw	r2,0(r18)
   26d10:	0005883a 	mov	r2,zero
   26d14:	dfc00417 	ldw	ra,16(sp)
   26d18:	dcc00317 	ldw	r19,12(sp)
   26d1c:	dc800217 	ldw	r18,8(sp)
   26d20:	dc400117 	ldw	r17,4(sp)
   26d24:	dc000017 	ldw	r16,0(sp)
   26d28:	dec00504 	addi	sp,sp,20
   26d2c:	f800283a 	ret
   26d30:	81000017 	ldw	r4,0(r16)
   26d34:	2449c83a 	sub	r4,r4,r17
   26d38:	20001f16 	blt	r4,zero,26db8 <_malloc_r+0x190>
   26d3c:	20c00330 	cmpltui	r3,r4,12
   26d40:	1800161e 	bne	r3,zero,26d9c <_malloc_r+0x174>
   26d44:	84400015 	stw	r17,0(r16)
   26d48:	8447883a 	add	r3,r16,r17
   26d4c:	1400111e 	bne	r2,r16,26d94 <_malloc_r+0x16c>
   26d50:	008000f4 	movhi	r2,3
   26d54:	10f2a915 	stw	r3,-13660(r2)
   26d58:	80800117 	ldw	r2,4(r16)
   26d5c:	19000015 	stw	r4,0(r3)
   26d60:	18800115 	stw	r2,4(r3)
   26d64:	9009883a 	mov	r4,r18
   26d68:	00272d00 	call	272d0 <__malloc_unlock>
   26d6c:	013ffe04 	movi	r4,-8
   26d70:	808002c4 	addi	r2,r16,11
   26d74:	80c00104 	addi	r3,r16,4
   26d78:	1104703a 	and	r2,r2,r4
   26d7c:	10c9c83a 	sub	r4,r2,r3
   26d80:	10ffe426 	beq	r2,r3,26d14 <_malloc_r+0xec>
   26d84:	8121883a 	add	r16,r16,r4
   26d88:	1887c83a 	sub	r3,r3,r2
   26d8c:	80c00015 	stw	r3,0(r16)
   26d90:	003fe006 	br	26d14 <_malloc_r+0xec>
   26d94:	10c00115 	stw	r3,4(r2)
   26d98:	003fef06 	br	26d58 <_malloc_r+0x130>
   26d9c:	80c00117 	ldw	r3,4(r16)
   26da0:	1400031e 	bne	r2,r16,26db0 <_malloc_r+0x188>
   26da4:	008000f4 	movhi	r2,3
   26da8:	10f2a915 	stw	r3,-13660(r2)
   26dac:	003fed06 	br	26d64 <_malloc_r+0x13c>
   26db0:	10c00115 	stw	r3,4(r2)
   26db4:	003feb06 	br	26d64 <_malloc_r+0x13c>
   26db8:	8005883a 	mov	r2,r16
   26dbc:	84000117 	ldw	r16,4(r16)
   26dc0:	003fad06 	br	26c78 <_malloc_r+0x50>
   26dc4:	1021883a 	mov	r16,r2
   26dc8:	10800117 	ldw	r2,4(r2)
   26dcc:	003fb406 	br	26ca0 <_malloc_r+0x78>
   26dd0:	1805883a 	mov	r2,r3
   26dd4:	003fc606 	br	26cf0 <_malloc_r+0xc8>
   26dd8:	00800304 	movi	r2,12
   26ddc:	90800015 	stw	r2,0(r18)
   26de0:	9009883a 	mov	r4,r18
   26de4:	00272d00 	call	272d0 <__malloc_unlock>
   26de8:	003fc906 	br	26d10 <_malloc_r+0xe8>
   26dec:	84400015 	stw	r17,0(r16)
   26df0:	003fdc06 	br	26d64 <_malloc_r+0x13c>

00026df4 <_puts_r>:
   26df4:	defffd04 	addi	sp,sp,-12
   26df8:	dc000015 	stw	r16,0(sp)
   26dfc:	2021883a 	mov	r16,r4
   26e00:	2809883a 	mov	r4,r5
   26e04:	dfc00215 	stw	ra,8(sp)
   26e08:	dc400115 	stw	r17,4(sp)
   26e0c:	2823883a 	mov	r17,r5
   26e10:	0026ecc0 	call	26ecc <strlen>
   26e14:	81400217 	ldw	r5,8(r16)
   26e18:	00c000b4 	movhi	r3,2
   26e1c:	18dc0c04 	addi	r3,r3,28720
   26e20:	28c00115 	stw	r3,4(r5)
   26e24:	100f883a 	mov	r7,r2
   26e28:	880d883a 	mov	r6,r17
   26e2c:	8009883a 	mov	r4,r16
   26e30:	00270300 	call	27030 <__sfvwrite_small_dev>
   26e34:	10ffffe0 	cmpeqi	r3,r2,-1
   26e38:	1800091e 	bne	r3,zero,26e60 <_puts_r+0x6c>
   26e3c:	81400217 	ldw	r5,8(r16)
   26e40:	018000f4 	movhi	r6,3
   26e44:	01c00044 	movi	r7,1
   26e48:	28800117 	ldw	r2,4(r5)
   26e4c:	31a60704 	addi	r6,r6,-26596
   26e50:	8009883a 	mov	r4,r16
   26e54:	103ee83a 	callr	r2
   26e58:	10bfffe0 	cmpeqi	r2,r2,-1
   26e5c:	0085c83a 	sub	r2,zero,r2
   26e60:	dfc00217 	ldw	ra,8(sp)
   26e64:	dc400117 	ldw	r17,4(sp)
   26e68:	dc000017 	ldw	r16,0(sp)
   26e6c:	dec00304 	addi	sp,sp,12
   26e70:	f800283a 	ret

00026e74 <puts>:
   26e74:	008000f4 	movhi	r2,3
   26e78:	200b883a 	mov	r5,r4
   26e7c:	112c3317 	ldw	r4,-20276(r2)
   26e80:	0026df41 	jmpi	26df4 <_puts_r>

00026e84 <memcpy>:
   26e84:	2005883a 	mov	r2,r4
   26e88:	0007883a 	mov	r3,zero
   26e8c:	30c0011e 	bne	r6,r3,26e94 <memcpy+0x10>
   26e90:	f800283a 	ret
   26e94:	28cf883a 	add	r7,r5,r3
   26e98:	39c00003 	ldbu	r7,0(r7)
   26e9c:	10c9883a 	add	r4,r2,r3
   26ea0:	18c00044 	addi	r3,r3,1
   26ea4:	21c00005 	stb	r7,0(r4)
   26ea8:	003ff806 	br	26e8c <memcpy+0x8>

00026eac <memset>:
   26eac:	2005883a 	mov	r2,r4
   26eb0:	218d883a 	add	r6,r4,r6
   26eb4:	2007883a 	mov	r3,r4
   26eb8:	1980011e 	bne	r3,r6,26ec0 <memset+0x14>
   26ebc:	f800283a 	ret
   26ec0:	18c00044 	addi	r3,r3,1
   26ec4:	197fffc5 	stb	r5,-1(r3)
   26ec8:	003ffb06 	br	26eb8 <memset+0xc>

00026ecc <strlen>:
   26ecc:	2005883a 	mov	r2,r4
   26ed0:	10c00007 	ldb	r3,0(r2)
   26ed4:	1800021e 	bne	r3,zero,26ee0 <strlen+0x14>
   26ed8:	1105c83a 	sub	r2,r2,r4
   26edc:	f800283a 	ret
   26ee0:	10800044 	addi	r2,r2,1
   26ee4:	003ffa06 	br	26ed0 <strlen+0x4>

00026ee8 <_sbrk_r>:
   26ee8:	defffe04 	addi	sp,sp,-8
   26eec:	dc000015 	stw	r16,0(sp)
   26ef0:	008000f4 	movhi	r2,3
   26ef4:	2021883a 	mov	r16,r4
   26ef8:	2809883a 	mov	r4,r5
   26efc:	dfc00115 	stw	ra,4(sp)
   26f00:	1032aa15 	stw	zero,-13656(r2)
   26f04:	00272d40 	call	272d4 <sbrk>
   26f08:	10ffffd8 	cmpnei	r3,r2,-1
   26f0c:	1800041e 	bne	r3,zero,26f20 <_sbrk_r+0x38>
   26f10:	00c000f4 	movhi	r3,3
   26f14:	18f2aa17 	ldw	r3,-13656(r3)
   26f18:	18000126 	beq	r3,zero,26f20 <_sbrk_r+0x38>
   26f1c:	80c00015 	stw	r3,0(r16)
   26f20:	dfc00117 	ldw	ra,4(sp)
   26f24:	dc000017 	ldw	r16,0(sp)
   26f28:	dec00204 	addi	sp,sp,8
   26f2c:	f800283a 	ret

00026f30 <_free_r>:
   26f30:	28003e26 	beq	r5,zero,2702c <_free_r+0xfc>
   26f34:	28bfff17 	ldw	r2,-4(r5)
   26f38:	defffd04 	addi	sp,sp,-12
   26f3c:	dc000115 	stw	r16,4(sp)
   26f40:	dfc00215 	stw	ra,8(sp)
   26f44:	2c3fff04 	addi	r16,r5,-4
   26f48:	1000010e 	bge	r2,zero,26f50 <_free_r+0x20>
   26f4c:	80a1883a 	add	r16,r16,r2
   26f50:	d9000015 	stw	r4,0(sp)
   26f54:	00272cc0 	call	272cc <__malloc_lock>
   26f58:	008000f4 	movhi	r2,3
   26f5c:	10b2a917 	ldw	r2,-13660(r2)
   26f60:	d9000017 	ldw	r4,0(sp)
   26f64:	1000071e 	bne	r2,zero,26f84 <_free_r+0x54>
   26f68:	80000115 	stw	zero,4(r16)
   26f6c:	008000f4 	movhi	r2,3
   26f70:	1432a915 	stw	r16,-13660(r2)
   26f74:	dfc00217 	ldw	ra,8(sp)
   26f78:	dc000117 	ldw	r16,4(sp)
   26f7c:	dec00304 	addi	sp,sp,12
   26f80:	00272d01 	jmpi	272d0 <__malloc_unlock>
   26f84:	8080092e 	bgeu	r16,r2,26fac <_free_r+0x7c>
   26f88:	81400017 	ldw	r5,0(r16)
   26f8c:	8147883a 	add	r3,r16,r5
   26f90:	10c0041e 	bne	r2,r3,26fa4 <_free_r+0x74>
   26f94:	10c00017 	ldw	r3,0(r2)
   26f98:	10800117 	ldw	r2,4(r2)
   26f9c:	1947883a 	add	r3,r3,r5
   26fa0:	80c00015 	stw	r3,0(r16)
   26fa4:	80800115 	stw	r2,4(r16)
   26fa8:	003ff006 	br	26f6c <_free_r+0x3c>
   26fac:	1007883a 	mov	r3,r2
   26fb0:	10800117 	ldw	r2,4(r2)
   26fb4:	10000126 	beq	r2,zero,26fbc <_free_r+0x8c>
   26fb8:	80bffc2e 	bgeu	r16,r2,26fac <_free_r+0x7c>
   26fbc:	19400017 	ldw	r5,0(r3)
   26fc0:	194d883a 	add	r6,r3,r5
   26fc4:	34000b1e 	bne	r6,r16,26ff4 <_free_r+0xc4>
   26fc8:	81800017 	ldw	r6,0(r16)
   26fcc:	298b883a 	add	r5,r5,r6
   26fd0:	19400015 	stw	r5,0(r3)
   26fd4:	194d883a 	add	r6,r3,r5
   26fd8:	11bfe61e 	bne	r2,r6,26f74 <_free_r+0x44>
   26fdc:	11800017 	ldw	r6,0(r2)
   26fe0:	10800117 	ldw	r2,4(r2)
   26fe4:	314b883a 	add	r5,r6,r5
   26fe8:	19400015 	stw	r5,0(r3)
   26fec:	18800115 	stw	r2,4(r3)
   26ff0:	003fe006 	br	26f74 <_free_r+0x44>
   26ff4:	8180032e 	bgeu	r16,r6,27004 <_free_r+0xd4>
   26ff8:	00800304 	movi	r2,12
   26ffc:	20800015 	stw	r2,0(r4)
   27000:	003fdc06 	br	26f74 <_free_r+0x44>
   27004:	81800017 	ldw	r6,0(r16)
   27008:	818b883a 	add	r5,r16,r6
   2700c:	1140041e 	bne	r2,r5,27020 <_free_r+0xf0>
   27010:	11400017 	ldw	r5,0(r2)
   27014:	10800117 	ldw	r2,4(r2)
   27018:	298b883a 	add	r5,r5,r6
   2701c:	81400015 	stw	r5,0(r16)
   27020:	80800115 	stw	r2,4(r16)
   27024:	1c000115 	stw	r16,4(r3)
   27028:	003fd206 	br	26f74 <_free_r+0x44>
   2702c:	f800283a 	ret

00027030 <__sfvwrite_small_dev>:
   27030:	2880000b 	ldhu	r2,0(r5)
   27034:	1080020c 	andi	r2,r2,8
   27038:	10002526 	beq	r2,zero,270d0 <__sfvwrite_small_dev+0xa0>
   2703c:	2880008f 	ldh	r2,2(r5)
   27040:	defffb04 	addi	sp,sp,-20
   27044:	dcc00315 	stw	r19,12(sp)
   27048:	dc800215 	stw	r18,8(sp)
   2704c:	dc400115 	stw	r17,4(sp)
   27050:	dc000015 	stw	r16,0(sp)
   27054:	dfc00415 	stw	ra,16(sp)
   27058:	2027883a 	mov	r19,r4
   2705c:	2821883a 	mov	r16,r5
   27060:	3025883a 	mov	r18,r6
   27064:	3823883a 	mov	r17,r7
   27068:	1000100e 	bge	r2,zero,270ac <__sfvwrite_small_dev+0x7c>
   2706c:	8080000b 	ldhu	r2,0(r16)
   27070:	10801014 	ori	r2,r2,64
   27074:	8080000d 	sth	r2,0(r16)
   27078:	00bfffc4 	movi	r2,-1
   2707c:	00000d06 	br	270b4 <__sfvwrite_small_dev+0x84>
   27080:	88810050 	cmplti	r2,r17,1025
   27084:	880f883a 	mov	r7,r17
   27088:	1000011e 	bne	r2,zero,27090 <__sfvwrite_small_dev+0x60>
   2708c:	01c10004 	movi	r7,1024
   27090:	8140008f 	ldh	r5,2(r16)
   27094:	900d883a 	mov	r6,r18
   27098:	9809883a 	mov	r4,r19
   2709c:	00270d80 	call	270d8 <_write_r>
   270a0:	00bff20e 	bge	zero,r2,2706c <__sfvwrite_small_dev+0x3c>
   270a4:	88a3c83a 	sub	r17,r17,r2
   270a8:	90a5883a 	add	r18,r18,r2
   270ac:	047ff416 	blt	zero,r17,27080 <__sfvwrite_small_dev+0x50>
   270b0:	0005883a 	mov	r2,zero
   270b4:	dfc00417 	ldw	ra,16(sp)
   270b8:	dcc00317 	ldw	r19,12(sp)
   270bc:	dc800217 	ldw	r18,8(sp)
   270c0:	dc400117 	ldw	r17,4(sp)
   270c4:	dc000017 	ldw	r16,0(sp)
   270c8:	dec00504 	addi	sp,sp,20
   270cc:	f800283a 	ret
   270d0:	00bfffc4 	movi	r2,-1
   270d4:	f800283a 	ret

000270d8 <_write_r>:
   270d8:	defffe04 	addi	sp,sp,-8
   270dc:	dc000015 	stw	r16,0(sp)
   270e0:	008000f4 	movhi	r2,3
   270e4:	2021883a 	mov	r16,r4
   270e8:	2809883a 	mov	r4,r5
   270ec:	300b883a 	mov	r5,r6
   270f0:	380d883a 	mov	r6,r7
   270f4:	dfc00115 	stw	ra,4(sp)
   270f8:	1032aa15 	stw	zero,-13656(r2)
   270fc:	00273240 	call	27324 <write>
   27100:	10ffffd8 	cmpnei	r3,r2,-1
   27104:	1800041e 	bne	r3,zero,27118 <_write_r+0x40>
   27108:	00c000f4 	movhi	r3,3
   2710c:	18f2aa17 	ldw	r3,-13656(r3)
   27110:	18000126 	beq	r3,zero,27118 <_write_r+0x40>
   27114:	80c00015 	stw	r3,0(r16)
   27118:	dfc00117 	ldw	ra,4(sp)
   2711c:	dc000017 	ldw	r16,0(sp)
   27120:	dec00204 	addi	sp,sp,8
   27124:	f800283a 	ret

00027128 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   27128:	00271b41 	jmpi	271b4 <alt_iic_isr_register>

0002712c <alt_ic_irq_enable>:
  NIOS2_READ_STATUS (context);
   2712c:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27130:	00bfff84 	movi	r2,-2
   27134:	1884703a 	and	r2,r3,r2
   27138:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   2713c:	00800044 	movi	r2,1
   27140:	d1269a17 	ldw	r4,-26008(gp)
   27144:	114a983a 	sll	r5,r2,r5
   27148:	290ab03a 	or	r5,r5,r4
   2714c:	d1669a15 	stw	r5,-26008(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   27150:	d0a69a17 	ldw	r2,-26008(gp)
   27154:	100170fa 	wrctl	ienable,r2
  NIOS2_WRITE_STATUS (context);
   27158:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   2715c:	0005883a 	mov	r2,zero
   27160:	f800283a 	ret

00027164 <alt_ic_irq_disable>:
  NIOS2_READ_STATUS (context);
   27164:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27168:	00bfff84 	movi	r2,-2
   2716c:	1884703a 	and	r2,r3,r2
   27170:	1001703a 	wrctl	status,r2
  alt_irq_active &= ~(1 << id);
   27174:	00bfff84 	movi	r2,-2
   27178:	d1269a17 	ldw	r4,-26008(gp)
   2717c:	114a183a 	rol	r5,r2,r5
   27180:	290a703a 	and	r5,r5,r4
   27184:	d1669a15 	stw	r5,-26008(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   27188:	d0a69a17 	ldw	r2,-26008(gp)
   2718c:	100170fa 	wrctl	ienable,r2
  NIOS2_WRITE_STATUS (context);
   27190:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   27194:	0005883a 	mov	r2,zero
   27198:	f800283a 	ret

0002719c <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   2719c:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
   271a0:	00800044 	movi	r2,1
   271a4:	1144983a 	sll	r2,r2,r5
   271a8:	10c4703a 	and	r2,r2,r3
}
   271ac:	1004c03a 	cmpne	r2,r2,zero
   271b0:	f800283a 	ret

000271b4 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   271b4:	28800808 	cmpgei	r2,r5,32
   271b8:	1000161e 	bne	r2,zero,27214 <alt_iic_isr_register+0x60>
{
   271bc:	defffe04 	addi	sp,sp,-8
   271c0:	dfc00115 	stw	ra,4(sp)
   271c4:	dc000015 	stw	r16,0(sp)
  NIOS2_READ_STATUS (context);
   271c8:	0021303a 	rdctl	r16,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   271cc:	00bfff84 	movi	r2,-2
   271d0:	8084703a 	and	r2,r16,r2
   271d4:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   271d8:	280690fa 	slli	r3,r5,3
   271dc:	008000f4 	movhi	r2,3
   271e0:	10b31004 	addi	r2,r2,-13248
   271e4:	10c5883a 	add	r2,r2,r3
   271e8:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   271ec:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   271f0:	30000626 	beq	r6,zero,2720c <alt_iic_isr_register+0x58>
   271f4:	002712c0 	call	2712c <alt_ic_irq_enable>
  NIOS2_WRITE_STATUS (context);
   271f8:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   271fc:	dfc00117 	ldw	ra,4(sp)
   27200:	dc000017 	ldw	r16,0(sp)
   27204:	dec00204 	addi	sp,sp,8
   27208:	f800283a 	ret
    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   2720c:	00271640 	call	27164 <alt_ic_irq_disable>
   27210:	003ff906 	br	271f8 <alt_iic_isr_register+0x44>
  int rc = -EINVAL;  
   27214:	00bffa84 	movi	r2,-22
}
   27218:	f800283a 	ret

0002721c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   2721c:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   27220:	010000f4 	movhi	r4,3
   27224:	014000f4 	movhi	r5,3
   27228:	dfc00015 	stw	ra,0(sp)
   2722c:	21260804 	addi	r4,r4,-26592
   27230:	296c3804 	addi	r5,r5,-20256
   27234:	21400426 	beq	r4,r5,27248 <alt_load+0x2c>
  {
    while( to != end )
    {
      *to++ = *from++;
   27238:	018000f4 	movhi	r6,3
   2723c:	31ac3804 	addi	r6,r6,-20256
   27240:	310dc83a 	sub	r6,r6,r4
   27244:	0026e840 	call	26e84 <memcpy>
  if (to != from)
   27248:	010000b4 	movhi	r4,2
   2724c:	014000b4 	movhi	r5,2
   27250:	21000804 	addi	r4,r4,32
   27254:	29400804 	addi	r5,r5,32
   27258:	21400426 	beq	r4,r5,2726c <alt_load+0x50>
      *to++ = *from++;
   2725c:	018000b4 	movhi	r6,2
   27260:	31806004 	addi	r6,r6,384
   27264:	310dc83a 	sub	r6,r6,r4
   27268:	0026e840 	call	26e84 <memcpy>
  if (to != from)
   2726c:	010000b4 	movhi	r4,2
   27270:	014000b4 	movhi	r5,2
   27274:	211d5c04 	addi	r4,r4,30064
   27278:	295d5c04 	addi	r5,r5,30064
   2727c:	21400426 	beq	r4,r5,27290 <alt_load+0x74>
      *to++ = *from++;
   27280:	018000f4 	movhi	r6,3
   27284:	31a60804 	addi	r6,r6,-26592
   27288:	310dc83a 	sub	r6,r6,r4
   2728c:	0026e840 	call	26e84 <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   27290:	002753c0 	call	2753c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   27294:	dfc00017 	ldw	ra,0(sp)
   27298:	dec00104 	addi	sp,sp,4
  alt_icache_flush_all();
   2729c:	00275401 	jmpi	27540 <alt_icache_flush_all>

000272a0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   272a0:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   272a4:	0009883a 	mov	r4,zero
{
   272a8:	dfc00015 	stw	ra,0(sp)
  alt_irq_init (NULL);
   272ac:	00273800 	call	27380 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   272b0:	00273a00 	call	273a0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   272b4:	d1a69b17 	ldw	r6,-26004(gp)
   272b8:	d1669c17 	ldw	r5,-26000(gp)
   272bc:	d1269d17 	ldw	r4,-25996(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   272c0:	dfc00017 	ldw	ra,0(sp)
   272c4:	dec00104 	addi	sp,sp,4
  main (alt_argc, alt_argv, alt_envp);
   272c8:	00201bc1 	jmpi	201bc <main>

000272cc <__malloc_lock>:
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
}
   272cc:	f800283a 	ret

000272d0 <__malloc_unlock>:

/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
   272d0:	f800283a 	ret

000272d4 <sbrk>:
  NIOS2_READ_STATUS (context);
   272d4:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   272d8:	00bfff84 	movi	r2,-2
   272dc:	1884703a 	and	r2,r3,r2
   272e0:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   272e4:	d0a02417 	ldw	r2,-32624(gp)
   272e8:	017fff04 	movi	r5,-4
   272ec:	108000c4 	addi	r2,r2,3
   272f0:	1144703a 	and	r2,r2,r5
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   272f4:	014000f4 	movhi	r5,3
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   272f8:	d0a02415 	stw	r2,-32624(gp)
  if ((heap_end + incr) > __alt_heap_limit) {
   272fc:	1109883a 	add	r4,r2,r4
   27300:	29500004 	addi	r5,r5,16384
   27304:	2900032e 	bgeu	r5,r4,27314 <sbrk+0x40>
  NIOS2_WRITE_STATUS (context);
   27308:	1801703a 	wrctl	status,r3
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   2730c:	00bfffc4 	movi	r2,-1
   27310:	f800283a 	ret
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
   27314:	d1202415 	stw	r4,-32624(gp)
   27318:	1801703a 	wrctl	status,r3
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
   2731c:	f800283a 	ret

00027320 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   27320:	00274ac1 	jmpi	274ac <alt_busy_sleep>

00027324 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   27324:	213fffc4 	addi	r4,r4,-1
   27328:	210000a8 	cmpgeui	r4,r4,2
   2732c:	2000041e 	bne	r4,zero,27340 <write+0x1c>
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
   27330:	010000f4 	movhi	r4,3
   27334:	000f883a 	mov	r7,zero
   27338:	212c3604 	addi	r4,r4,-20264
   2733c:	00273a41 	jmpi	273a4 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   27340:	d0a02617 	ldw	r2,-32616(gp)
   27344:	10000926 	beq	r2,zero,2736c <write+0x48>
{
   27348:	deffff04 	addi	sp,sp,-4
   2734c:	dfc00015 	stw	ra,0(sp)
   27350:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   27354:	00c01444 	movi	r3,81
   27358:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   2735c:	00bfffc4 	movi	r2,-1
   27360:	dfc00017 	ldw	ra,0(sp)
   27364:	dec00104 	addi	sp,sp,4
   27368:	f800283a 	ret
   2736c:	d0a69904 	addi	r2,gp,-26012
        ALT_ERRNO = EBADFD;
   27370:	00c01444 	movi	r3,81
   27374:	10c00015 	stw	r3,0(r2)
}
   27378:	00bfffc4 	movi	r2,-1
   2737c:	f800283a 	ret

00027380 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   27380:	deffff04 	addi	sp,sp,-4
   27384:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, NIOS);
   27388:	00275680 	call	27568 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   2738c:	00800044 	movi	r2,1
   27390:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   27394:	dfc00017 	ldw	ra,0(sp)
   27398:	dec00104 	addi	sp,sp,4
   2739c:	f800283a 	ret

000273a0 <alt_sys_init>:
void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
    ALTERA_AVALON_SPI_INIT ( ESC_SPI, ESC_SPI);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, SYSID);
}
   273a0:	f800283a 	ret

000273a4 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   273a4:	20c00017 	ldw	r3,0(r4)
{
   273a8:	3005883a 	mov	r2,r6

  const char * end = ptr + count;
   273ac:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   273b0:	01bfffd4 	movui	r6,65535
  while (ptr < end)
   273b4:	29000136 	bltu	r5,r4,273bc <altera_avalon_jtag_uart_write+0x18>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
   273b8:	f800283a 	ret
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   273bc:	19c00137 	ldwio	r7,4(r3)
   273c0:	31fffc2e 	bgeu	r6,r7,273b4 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   273c4:	29c00007 	ldb	r7,0(r5)
   273c8:	29400044 	addi	r5,r5,1
   273cc:	19c00035 	stwio	r7,0(r3)
   273d0:	003ff806 	br	273b4 <altera_avalon_jtag_uart_write+0x10>

000273d4 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   273d4:	d8800017 	ldw	r2,0(sp)
   273d8:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   273dc:	00c00044 	movi	r3,1
{
   273e0:	da400217 	ldw	r9,8(sp)
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   273e4:	1946983a 	sll	r3,r3,r5
  const alt_u8 * write_end = write_data + write_length;
   273e8:	399b883a 	add	r13,r7,r6
  alt_u8 * read_end = read_data + read_length;
   273ec:	4099883a 	add	r12,r8,r2
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   273f0:	20c00535 	stwio	r3,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   273f4:	48c0008c 	andi	r3,r9,2
   273f8:	1800021e 	bne	r3,zero,27404 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   273fc:	00c10004 	movi	r3,1024
   27400:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   27404:	20c00037 	ldwio	r3,0(r4)
  alt_32 credits = 1;
   27408:	00c00044 	movi	r3,1
  alt_u32 write_zeros = read_length;
   2740c:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27410:	22c00204 	addi	r11,r4,8
   27414:	21400237 	ldwio	r5,8(r4)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   27418:	2b80100c 	andi	r14,r5,64
   2741c:	2940200c 	andi	r5,r5,128
   27420:	70000126 	beq	r14,zero,27428 <alt_avalon_spi_command+0x54>
   27424:	1800101e 	bne	r3,zero,27468 <alt_avalon_spi_command+0x94>
      }
      else
        credits = -1024;
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   27428:	283ff926 	beq	r5,zero,27410 <alt_avalon_spi_command+0x3c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   2742c:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
        read_ignore--;
      else
        *read_data++ = (alt_u8)rxdata;
      credits++;
   27430:	18c00044 	addi	r3,r3,1
      if (read_ignore > 0)
   27434:	30001a26 	beq	r6,zero,274a0 <alt_avalon_spi_command+0xcc>
        read_ignore--;
   27438:	31bfffc4 	addi	r6,r6,-1

      if (read_ignore == 0 && read_data == read_end)
   2743c:	303ff41e 	bne	r6,zero,27410 <alt_avalon_spi_command+0x3c>
   27440:	6200071e 	bne	r12,r8,27460 <alt_avalon_spi_command+0x8c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27444:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   27448:	18c0080c 	andi	r3,r3,32
   2744c:	183ffd26 	beq	r3,zero,27444 <alt_avalon_spi_command+0x70>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   27450:	4a40004c 	andi	r9,r9,1
   27454:	4800011e 	bne	r9,zero,2745c <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   27458:	20000335 	stwio	zero,12(r4)

  return read_length;
}
   2745c:	f800283a 	ret
   27460:	000d883a 	mov	r6,zero
   27464:	003fea06 	br	27410 <alt_avalon_spi_command+0x3c>
    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   27468:	00ffef0e 	bge	zero,r3,27428 <alt_avalon_spi_command+0x54>
      credits--;
   2746c:	18ffffc4 	addi	r3,r3,-1
      if (write_data < write_end)
   27470:	3b40052e 	bgeu	r7,r13,27488 <alt_avalon_spi_command+0xb4>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   27474:	3b800044 	addi	r14,r7,1
   27478:	39c00003 	ldbu	r7,0(r7)
   2747c:	21c00135 	stwio	r7,4(r4)
   27480:	700f883a 	mov	r7,r14
   27484:	003fe806 	br	27428 <alt_avalon_spi_command+0x54>
      else if (write_zeros > 0)
   27488:	50000326 	beq	r10,zero,27498 <alt_avalon_spi_command+0xc4>
        write_zeros--;
   2748c:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   27490:	20000135 	stwio	zero,4(r4)
   27494:	003fe406 	br	27428 <alt_avalon_spi_command+0x54>
        credits = -1024;
   27498:	00ff0004 	movi	r3,-1024
   2749c:	003fe206 	br	27428 <alt_avalon_spi_command+0x54>
        *read_data++ = (alt_u8)rxdata;
   274a0:	41400005 	stb	r5,0(r8)
   274a4:	42000044 	addi	r8,r8,1
   274a8:	003fe506 	br	27440 <alt_avalon_spi_command+0x6c>

000274ac <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   274ac:	defffe04 	addi	sp,sp,-8
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   274b0:	008666b4 	movhi	r2,6554
{
   274b4:	dc000015 	stw	r16,0(sp)
   274b8:	dfc00115 	stw	ra,4(sp)
  if (big_loops)
   274bc:	10a66604 	addi	r2,r2,-26216
{
   274c0:	2021883a 	mov	r16,r4
  if (big_loops)
   274c4:	1100182e 	bgeu	r2,r4,27528 <alt_busy_sleep+0x7c>
  big_loops = us / (INT_MAX/
   274c8:	014666b4 	movhi	r5,6554
   274cc:	29666644 	addi	r5,r5,-26215
   274d0:	0026a940 	call	26a94 <__udivsi3>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   274d4:	00e00034 	movhi	r3,32768
  big_loops = us / (INT_MAX/
   274d8:	1009883a 	mov	r4,r2
      __asm__ volatile (
   274dc:	18ffffc4 	addi	r3,r3,-1
    for(i=0;i<big_loops;i++)
   274e0:	0005883a 	mov	r2,zero
      __asm__ volatile (
   274e4:	18ffffc4 	addi	r3,r3,-1
   274e8:	183ffe1e 	bne	r3,zero,274e4 <alt_busy_sleep+0x38>
    for(i=0;i<big_loops;i++)
   274ec:	10800044 	addi	r2,r2,1
   274f0:	113ffc16 	blt	r2,r4,274e4 <alt_busy_sleep+0x38>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   274f4:	017999b4 	movhi	r5,58982
   274f8:	295999c4 	addi	r5,r5,26215
   274fc:	0026b540 	call	26b54 <__mulsi3>
   27500:	1405883a 	add	r2,r2,r16
   27504:	100690ba 	slli	r3,r2,2
   27508:	1885883a 	add	r2,r3,r2
    __asm__ volatile (
   2750c:	10bfffc4 	addi	r2,r2,-1
   27510:	103ffe1e 	bne	r2,zero,2750c <alt_busy_sleep+0x60>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   27514:	0005883a 	mov	r2,zero
   27518:	dfc00117 	ldw	ra,4(sp)
   2751c:	dc000017 	ldw	r16,0(sp)
   27520:	dec00204 	addi	sp,sp,8
   27524:	f800283a 	ret
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   27528:	200490ba 	slli	r2,r4,2
   2752c:	1105883a 	add	r2,r2,r4
    __asm__ volatile (
   27530:	10bfffc4 	addi	r2,r2,-1
   27534:	00bffe16 	blt	zero,r2,27530 <alt_busy_sleep+0x84>
   27538:	003ff606 	br	27514 <alt_busy_sleep+0x68>

0002753c <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2753c:	f800283a 	ret

00027540 <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   27540:	f800283a 	ret

00027544 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
   27544:	213ffe84 	addi	r4,r4,-6
   27548:	20800428 	cmpgeui	r2,r4,16
   2754c:	1000041e 	bne	r2,zero,27560 <alt_exception_cause_generated_bad_addr+0x1c>
   27550:	00a2c8d4 	movui	r2,35619
   27554:	1104d83a 	srl	r2,r2,r4
   27558:	1080004c 	andi	r2,r2,1
   2755c:	f800283a 	ret
   27560:	0005883a 	mov	r2,zero
    return 0;

  default:
    return 0;
  }
}
   27564:	f800283a 	ret

00027568 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   27568:	000170fa 	wrctl	ienable,zero
}
   2756c:	f800283a 	ret
