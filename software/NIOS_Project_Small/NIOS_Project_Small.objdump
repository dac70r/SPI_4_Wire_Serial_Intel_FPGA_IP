
NIOS_Project_Small.elf:     file format elf32-littlenios2
NIOS_Project_Small.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00020020

Program Header:
    LOAD off    0x00001000 vaddr 0x00020000 paddr 0x00020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00020020 paddr 0x00020020 align 2**12
         filesz 0x00007fb4 memsz 0x00007fb4 flags r-x
    LOAD off    0x00008fd4 vaddr 0x00027fd4 paddr 0x00028434 align 2**12
         filesz 0x00000460 memsz 0x00000460 flags rw-
    LOAD off    0x00000894 vaddr 0x00028894 paddr 0x00028894 align 2**12
         filesz 0x00000000 memsz 0x00000488 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00020000  00020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00020020  00020020  00009434  2**0
                  CONTENTS
  2 .text         00007908  00020020  00020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000006ac  00027928  00027928  00008928  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000460  00027fd4  00028434  00008fd4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          00000488  00028894  00028894  00009894  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  00028d1c  00028d1c  00009434  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  00009434  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000568  00000000  00000000  00009468  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   0000e4b4  00000000  00000000  000099d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 0000411f  00000000  00000000  00017e84  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   00008358  00000000  00000000  0001bfa3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  0000156c  00000000  00000000  000242fc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    00002a7d  00000000  00000000  00025868  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000040  00000000  00000000  000282e8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000020  00000000  00000000  00028328  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000070f  00000000  00000000  00028348  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00000fb9  00000000  00000000  00028a57  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 00005b6f  00000000  00000000  00029a10  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  00033066  2**0
                  CONTENTS, READONLY
 20 .cpu          00000004  00000000  00000000  00033069  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  0003306d  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  0003306e  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  0003306f  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00033073  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  00033077  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000005  00000000  00000000  0003307b  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000005  00000000  00000000  00033080  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000005  00000000  00000000  00033085  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000015  00000000  00000000  0003308a  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000004c  00000000  00000000  0003309f  2**0
                  CONTENTS, READONLY
 31 .jdi          0000527d  00000000  00000000  000330eb  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     0004b80c  00000000  00000000  00038368  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00020000 l    d  .entry	00000000 .entry
00020020 l    d  .exceptions	00000000 .exceptions
00020020 l    d  .text	00000000 .text
00027928 l    d  .rodata	00000000 .rodata
00027fd4 l    d  .rwdata	00000000 .rwdata
00028894 l    d  .bss	00000000 .bss
00028d1c l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.o
00020058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
000283c4 l     O .rwdata	00000001 invert_me.0
00000000 l    df *ABS*	00000000 ViCAT_LSC.c
00000000 l    df *ABS*	00000000 ax58100_hw.c
00020358 l     F .text	00000144 HW_SPI_Read
0002049c l     F .text	00000118 HW_SPI_Write
00000000 l    df *ABS*	00000000 bootmode.c
00000000 l    df *ABS*	00000000 coeappl.c
00000000 l    df *ABS*	00000000 ecatappl.c
00000000 l    df *ABS*	00000000 ecatcoe.c
00000000 l    df *ABS*	00000000 ecatfoe.c
00000000 l    df *ABS*	00000000 ecatslv.c
00000000 l    df *ABS*	00000000 foeappl.c
00000000 l    df *ABS*	00000000 mailbox.c
00000000 l    df *ABS*	00000000 objdef.c
00000000 l    df *ABS*	00000000 sdoserv.c
00000000 l    df *ABS*	00000000 peripheral_linker.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
0002706c l     F .text	0000008c sbrk_aligned
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 freer.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00028428 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00028930 g     O .bss	00000001 b3BufferMode
00028928 g     O .bss	00000002 nEcatStateTrans
00028914 g     O .bss	00000002 u16IdValue
0002767c g     F .text	0000002c alt_main
000272c4 g     F .text	00000080 _puts_r
0002841a g     O .rwdata	00000006 sEntryDesc0x1000
00028434 g       *ABS*	00000000 __flash_rwdata_start
00020658 g     F .text	0000000c HW_EscReadIsr
00028d1c g       *ABS*	00000000 __alt_heap_start
00027fec g     O .rwdata	000001e0 GenObjDic
0002840e g     O .rwdata	00000006 sEntryDesc0x1008
00020748 g     F .text	00000004 BL_Start
00027c9c g     O .rodata	00000047 aName0x1018
00024b58 g     F .text	00000008 OBJ_GetObjDesc
00023c6c g     F .text	00000010 FOE_Error
0002892b g     O .bss	00000001 bApplEsmPending
00020740 g     F .text	00000004 HW_SYNC1_IRQHandler
000227bc g     F .text	0000005c StartOutputHandler
000202c4 g     F .text	0000004c APPL_OutputMapping
000276ac g     F .text	00000004 __malloc_unlock
000288ec g     O .bss	00000004 pCoeSendStored
00026cb4 g     F .text	000000b0 spi_transmit_receive
00024344 g     F .text	000000e0 MBX_MailboxWriteInd
0002899c g     O .bss	00000002 nSdoInfoIndex
00023724 g     F .text	000001e4 ECAT_StateChange
000289a8 g     O .bss	00000004 pStoreData
000288d0 g     O .bss	00000004 pAPPL_CoeReadInd
00028969 g     O .bss	00000001 u8MbxReadCounter
00021bf0 g     F .text	00000034 FOE_ContinueInd
000217dc g     F .text	00000068 COE_ContinueInd
0002891f g     O .bss	00000001 nAlStatus
00028924 g     O .bss	00000002 nPdOutputSize
00020738 g     F .text	00000004 HW_ALEVENT_IRQHandler
00028900 g     O .bss	00000004 u32FileOffset
00027920 g     F .text	00000008 altera_nios2_gen2_irq_init
000289d0 g     O .bss	0000000c spiRxBuf
00020000 g     F .entry	0000000c __reset
000288b0 g     O .bss	00000001 bInitFinished
00020020 g       *ABS*	00000000 __flash_exceptions_start
0002892e g     O .bss	00000002 u16LocalErrorCode
00028988 g     O .bss	00000004 nSdoSegBytesToHandle
00020324 g     F .text	00000034 main_initial
00021c24 g     F .text	0000004c ResetALEventMask
000289c0 g     O .bss	00000004 errno
00028894 g     O .bss	00000002 bootSwitchID
0002892c g     O .bss	00000001 u8LocalErrorState
000281e0 g     O .rwdata	0000000a acDevicename
00027e3c g     O .rodata	0000000c asEntryDesc0x7000
00028c50 g     O .bss	00000034 sMbxSendQueue
0002891e g     O .bss	00000001 bExplicitDevIdRequested
00028364 g     O .rwdata	0000000c sErrorSettings
000289c8 g     O .bss	00000004 alt_argv
00020084 g     F .text	00000004 APPL_AckErrorInd
000303c4 g       *ABS*	00000000 _gp
000276fc g     F .text	00000004 usleep
0002074c g     F .text	00000004 BL_Stop
000283f4 g     O .rwdata	00000006 sEntryDesc0x100A
00021854 g     F .text	0000039c FOE_ServiceInd
00022824 g     F .text	000000a0 StopInputHandler
00028c1c g     O .bss	00000034 sMbxReceiveQueue
00028954 g     O .bss	00000001 bNoMbxMemoryAvailable
0002413c g     F .text	000000c0 MBX_MailboxReadInd
000281cc g     O .rwdata	00000014 sIdentity
000288f8 g     O .bss	00000002 u16FileAccessState
0002893e g     O .bss	00000002 Sync0WdCounter
00027354 g     F .text	00000028 memcpy
00028904 g     O .bss	00000004 u32PacketNo
00024d1c g     F .text	0000010c CheckSyncTypeValue
000283d4 g     O .rwdata	00000004 sRxPDOassign
000288b8 g     O .bss	00000001 bMinCycleTimeMeasurementStarted
00027344 g     F .text	00000010 puts
00020728 g     F .text	0000000c HW_EscWriteIsr
00028976 g     O .bss	00000001 bSendMbxIsFull
000288c4 g     O .bss	00000004 u32CycleTimeStartValue
00027c34 g     O .rodata	00000013 aName0x10F8
00028934 g     O .bss	00000002 LatchInputSync0Counter
0002704c g     F .text	00000010 malloc
00028940 g     O .bss	00000002 i16WaitForPllRunningCnt
00026f64 g     F .text	00000064 .hidden __udivsi3
0002891a g     O .bss	00000002 nEscAddrOutputData
00028975 g     O .bss	00000001 bMbxRunning
00025cd8 g     F .text	000008f4 SDOS_SdoInd
000283c8 g     O .rwdata	00000004 OUT_GENERIC0x7000
000200b0 g     F .text	00000008 APPL_StopOutputHandler
00021de0 g     F .text	00000270 CheckSmSettings
00023b94 g     F .text	0000003c FOE_Read
00027a44 g     O .rodata	00000108 aName0x1C32
0002893c g     O .bss	00000002 Sync0WdValue
000273b8 g     F .text	00000048 _sbrk_r
0002491c g     F .text	0000003c OBJ_GetEntryDesc
00027fe0 g     O .rwdata	0000000c MLParameterSetting0x8000
00027d60 g     O .rodata	0000000c aName0x1000
00023c60 g     F .text	0000000c FOE_Busy
00020cfc g     F .text	00000068 GetSystemTimeDelay
000200a0 g     F .text	00000008 APPL_StopInputHandler
00028942 g     O .bss	00000002 i16WaitForPllRunningTimeout
00028990 g     O .bss	00000001 bSdoSegAccess
00028938 g     O .bss	00000002 Sync1WdValue
00022050 g     F .text	0000076c StartInputHandler
00020744 g     F .text	00000004 HW_TIMETASK_IRQHandler
00027e98 g     O .rodata	0000001b aName0x1C12
000283d0 g     O .rwdata	00000004 sTxPDOassign
00023dc0 g     F .text	000000dc MBX_StartMailboxHandler
00028d1c g       *ABS*	00000000 __bss_end
00028908 g     O .bss	00000001 EepromLoaded
00027e48 g     O .rodata	00000019 aName0x6000
00027f2c g     O .rodata	0000000c asEntryDesc0x1600
00028991 g     O .bss	00000001 bSdoSegFollows
00028980 g     O .bss	00000004 nSdoSegCompleteSize
00028913 g     O .bss	00000001 u8dummy
00028916 g     O .bss	00000002 u16ALEventMask
00027f58 g     O .rodata	00000078 cAbortCode
000289a4 g     O .bss	00000004 pSdoPendFunc
0002894a g     O .bss	00000001 bDcRunning
00024e28 g     F .text	00000610 OBJ_Read
000288e8 g     O .bss	00000001 bRunApplication
00027e20 g     O .rodata	0000001b aName0x7000
0002896e g     O .bss	00000002 u16EscAddrReceiveMbx
00028958 g     O .bss	00000004 psStoreMbx
00024558 g     F .text	000000c4 MBX_Main
0002890a g     O .bss	00000008 SyncManInfo
000283e8 g     O .rwdata	00000006 sSyncmanagertype
00028932 g     O .bss	00000001 b32BitDc
00021d84 g     F .text	0000005c EnableSyncManChannel
00027918 g     F .text	00000004 alt_dcache_flush_all
00027efc g     O .rodata	00000030 aName0x1600
00028434 g       *ABS*	00000000 __ram_rwdata_end
00020868 g     F .text	0000005c COE_UpdateSyncErrorStatus
000283e0 g     O .rwdata	00000008 OUT_GENERICProcessDataMapping0x1600
00027700 g     F .text	0000005c write
000288bc g     O .bss	00000004 u32SystemTimeReadFailure
00023e9c g     F .text	0000010c MBX_StopMailboxHandler
00027c48 g     O .rodata	0000003f aName0x10F1
000289b4 g     O .bss	00000001 u8PendingSdo
00027fd4 g       *ABS*	00000000 __ram_rodata_end
0002842c g     O .rwdata	00000004 DEBUG
00020754 g     F .text	00000008 BL_Data
000281ec g     O .rwdata	00000168 ApplicationObjDic
00020e14 g     F .text	0000006c HandleCycleTimeMeasurement
00028936 g     O .bss	00000002 LatchInputSync0Value
00026fc8 g     F .text	0000005c .hidden __umodsi3
000283d8 g     O .rwdata	00000008 IN_GENERICProcessDataMapping0x1A00
00027ce4 g     O .rodata	0000001e asEntryDesc0x1018
00028d1c g       *ABS*	00000000 end
00020098 g     F .text	00000008 APPL_StartInputHandler
00023be8 g     F .text	0000005c FOE_Data
00028972 g     O .bss	00000002 u16SendMbxSize
0002892a g     O .bss	00000001 bEcatWaitForAlControlRes
000266dc g     F .text	00000078 SDOS_ClearPendingResponse
00028960 g     O .bss	00000004 psReadMbx
00022818 g     F .text	0000000c StopOutputHandler
00027d24 g     O .rodata	0000001e aName0x1009
000288eb g     O .bss	00000001 bEcatWaitForInputUpdate
0002122c g     F .text	000001c0 PDI_Isr
00028c84 g     O .bss	00000044 sSyncManInPar
00034000 g       *ABS*	00000000 __alt_stack_pointer
00028408 g     O .rwdata	00000006 acHardwareversion
00026754 g     F .text	000003d8 SDOS_SdoInfoInd
00027780 g     F .text	00000030 altera_avalon_jtag_uart_write
000288b4 g     O .bss	00000004 u32MinCycleTimeValue
00028926 g     O .bss	00000002 nPdInputSize
00027400 g     F .text	00000100 _free_r
00027d50 g     O .rodata	0000000f aName0x1001
000283cc g     O .rwdata	00000004 IN_GENERIC0x6000
00020664 g     F .text	00000038 HW_EscWrite
00020090 g     F .text	00000008 APPL_StopMailboxHandler
00028354 g     O .rwdata	0000000d aSubindexDesc
00023d10 g     F .text	000000b0 MBX_Init
00020020 g     F .text	0000003c _start
00026d64 g     F .text	0000010c adc_init_spi_transmit_receive
00028993 g     O .bss	00000001 bSdoInWork
0002073c g     F .text	00000004 HW_SYNC0_IRQHandler
00028946 g     O .bss	00000002 u16SmSync0Value
000289b3 g     O .bss	00000001 bStoreCompleteAccess
000277b0 g     F .text	000000d8 alt_avalon_spi_command
00024764 g     F .text	00000080 OBJ_CopyNumberToString
00020860 g     F .text	00000008 COE_GetObjectDictionary
0002777c g     F .text	00000004 alt_sys_init
00024958 g     F .text	000000b8 OBJ_GetNoOfObjects
00028c0c g     O .bss	00000010 aPdOutputData
00028984 g     O .bss	00000001 bSdoSegLastToggle
00023ff0 g     F .text	0000014c MBX_CopyToSendMailbox
00022970 g     F .text	00000914 AL_ControlInd
00027024 g     F .text	00000028 .hidden __mulsi3
00027fd4 g       *ABS*	00000000 __ram_rwdata_start
00027928 g       *ABS*	00000000 __ram_rodata_start
00028992 g     O .bss	00000001 nSdoSegService
000283ee g     O .rwdata	00000006 sEntryDesc0x10F8
00020c6c g     F .text	00000090 ECAT_CheckTimer
000239ec g     F .text	000001a8 ECAT_Main
00028977 g     O .bss	00000001 bReceiveMbxIsLocked
000288dc g     O .bss	00000004 pAPPL_FoeError
0002896c g     O .bss	00000002 u16EscAddrSendMbx
00028920 g     O .bss	00000002 nMaxEscAddress
00028950 g     O .bss	00000001 bEcatFirstOutputsReceived
00027888 g     F .text	00000090 alt_busy_sleep
00028964 g     O .bss	00000004 psWriteMbx
000288a8 g     O .bss	00000008 u64Timestamp
00027c26 g     O .rodata	0000000c asEntryDesc0x1C00
00020088 g     F .text	00000008 APPL_StartMailboxHandler
0002896a g     O .bss	00000001 u8MbxWriteCounter
0002069c g     F .text	0000008c HW_Init
00028d1c g       *ABS*	00000000 __alt_stack_base
00027f38 g     O .rodata	00000020 cBitMask
00028912 g     O .bss	00000001 SMActivate
000288a4 g     O .bss	00000004 u32LastDc32Value
00023fa8 g     F .text	00000048 MailboxServiceInd
00023c7c g     F .text	00000050 PutInMbxQueue
000247e4 g     F .text	00000138 OBJ_GetDesc
000288a0 g     O .bss	00000004 u32CheckForDcOverrunCnt
000241fc g     F .text	00000068 MBX_MailboxRepeatReq
00028968 g     O .bss	00000001 u8MailboxSendReqStored
00021788 g     F .text	0000000c COE_Init
00020950 g     F .text	00000054 COE_RemoveDicEntry
00020d64 g     F .text	000000b0 PDO_InputMapping
000283fc g     O .rwdata	00000006 acSoftwareversion
0002889c g     O .bss	00000002 u16ErrorRegister
000276a8 g     F .text	00000004 __malloc_lock
000276b0 g     F .text	0000004c sbrk
000288cc g     O .bss	00000004 pAPPL_CoeWriteInd
000265cc g     F .text	00000110 SDOS_SdoRes
00028998 g     O .bss	00000004 pSdoInfoObjEntry
000214c0 g     F .text	00000218 ESC_EepromAccess
00027500 g     F .text	000000a8 __sfvwrite_small_dev
00028944 g     O .bss	00000001 bSmSyncSequenceValid
0002899e g     O .bss	00000002 nSdoInfoFragmentsLeft
00023284 g     F .text	00000308 AL_ControlRes
00028894 g       *ABS*	00000000 __bss_start
0002737c g     F .text	00000020 memset
00025438 g     F .text	00000740 OBJ_Write
0002005c g     F .text	00000028 main
00020000 g       *ABS*	00000000 __alt_mem_RAM
00026b2c g     F .text	00000020 delay_ms
00027eb4 g     O .rodata	0000000c asEntryDesc0x1C12
000289c4 g     O .bss	00000004 alt_envp
00028414 g     O .rwdata	00000006 sEntryDesc0x1001
000200b8 g     F .text	000001c0 APPL_GenerateMapping
000205b8 g     F .text	00000028 HW_GetALEventRegister_Isr
0002894c g     O .bss	00000002 EsmTimeoutCounter
00020ba0 g     F .text	000000cc COE_Main
00021844 g     F .text	00000010 FOE_Init
00034000 g       *ABS*	00000000 __alt_heap_limit
000288e0 g     O .bss	00000004 pAPPL_FoeReadData
000216d8 g     F .text	000000b0 ESC_EepromWriteCRC
000270f8 g     F .text	000001cc _malloc_r
000207c8 g     F .text	00000098 Read0x10F8
00028896 g     O .bss	00000002 EscALEvent
00028970 g     O .bss	00000002 u16ReceiveMbxSize
00028898 g     O .bss	00000004 ObjDicList
00028430 g     O .rwdata	00000004 alt_errno
00028402 g     O .rwdata	00000006 sEntryDesc0x1009
00028994 g     O .bss	00000004 pSdoResStored
00028953 g     O .bss	00000001 bBootMode
000289ac g     O .bss	00000004 u32StoreDataSize
00026e70 g     F .text	00000080 .hidden __divsi3
0002358c g     F .text	000000c0 DC_CheckWatchdog
000289a0 g     O .bss	00000004 pSdoSegData
00027928 g       *ABS*	00000000 __flash_rodata_start
00021d24 g     F .text	00000060 DisableSyncManChannel
0002894e g     O .bss	00000001 bDcSyncActive
00028952 g     O .bss	00000001 bEcatOutputUpdateRunning
0002775c g     F .text	00000020 alt_irq_init
000213ec g     F .text	000000d4 MainLoop
00024264 g     F .text	000000e0 MBX_MailboxSendReq
000288c8 g     O .bss	00000004 pAPPL_MainLoop
00020f94 g     F .text	000000fc MainInit
000208c4 g     F .text	0000008c COE_AddObjectToDic
000275a8 g     F .text	00000050 _write_r
00028cc8 g     O .bss	00000044 sSyncManOutPar
0002893a g     O .bss	00000002 Sync1WdCounter
00028424 g     O .rwdata	00000004 _impure_ptr
000289cc g     O .bss	00000004 alt_argc
00026b4c g     F .text	00000168 adc_init
00021cf4 g     F .text	00000030 GetSyncMan
00021794 g     F .text	00000048 COE_ServiceInd
00027c88 g     O .rodata	00000012 asEntryDesc0x10F1
00027e70 g     O .rodata	0000001b aName0x1C13
00027e8c g     O .rodata	0000000c asEntryDesc0x1C13
000228cc g     F .text	000000a4 SetALStatus
000210cc g     F .text	00000160 Sync0_Isr
0002891c g     O .bss	00000002 EcatWdValue
000288e9 g     O .bss	00000001 bEtherCATErrorLed
0002075c g     F .text	0000006c COE_SyncTimeStamp
00020020 g       *ABS*	00000000 __ram_exceptions_start
00023bd0 g     F .text	00000018 FOE_Write
00020618 g     F .text	00000040 HW_GetALEventRegister
000288c0 g     O .bss	00000004 u32MinCycleTimeStartValue
00027c14 g     O .rodata	00000012 aName0x1C00
00027e0e g     O .rodata	00000012 asEntryDesc0x8000
00028434 g       *ABS*	00000000 _edata
00021c70 g     F .text	0000004c SetALEventMask
0002897a g     O .bss	00000001 bSyncSetByUser
00028d1c g       *ABS*	00000000 _end
00028974 g     O .bss	00000001 bMbxRepeatToggle
00027d04 g     O .rodata	0000001e aName0x100A
00028951 g     O .bss	00000001 bEcatInputUpdateRunning
00021cbc g     F .text	00000038 UpdateEEPROMLoadedState
00020f40 g     F .text	00000054 Sync1_Isr
00020020 g       *ABS*	00000000 __ram_exceptions_end
00028931 g     O .bss	00000001 bEscIntEnabled
0002895c g     O .bss	00000004 psRepeatMbx
0002031c g     F .text	00000008 APPL_GetDeviceID
00027b4c g     O .rodata	000000c6 asEntryDesc0x1C3x
0002461c g     F .text	0000003c OBJ_GetObjectHandle
00027dc4 g     O .rodata	00000018 asEntryDesc0x8008
00027fd4 g     O .rwdata	0000000c ADCParameterSetting0x8008
0002898e g     O .bss	00000002 nSdoSegIndex
00028d0c g     O .bss	00000010 aSdoInfoHeader
00027ec0 g     O .rodata	0000002f aName0x1A00
000200a8 g     F .text	00000008 APPL_StartOutputHandler
0002897c g     O .bss	00000004 pSdoSegObjEntry
00027ef0 g     O .rodata	0000000c asEntryDesc0x1A00
00024b60 g     F .text	000001bc OBJ_GetEntryOffset
00020a30 g     F .text	00000040 COE_ObjDictionaryInit
00027ddc g     O .rodata	00000031 aName0x8000
00024424 g     F .text	00000134 MBX_CheckAndCopyMailbox
00020a70 g     F .text	00000130 COE_ObjInit
000289e8 g     O .bss	00000224 aPdInputData
000209a4 g     F .text	0000003c COE_ClearObjDictionary
0002894f g     O .bss	00000001 bWdTrigger
00026ef0 g     F .text	00000074 .hidden __modsi3
00020e80 g     F .text	000000c0 PDO_OutputMapping
0002898c g     O .bss	00000001 nSdoSegSubindex
00028370 g     O .rwdata	00000054 _impure_data
00034000 g       *ABS*	00000000 __alt_data_end
00025b78 g     F .text	00000160 SdoRes
000205e0 g     F .text	00000038 HW_EscRead
00020750 g     F .text	00000004 BL_StartDownload
000289b0 g     O .bss	00000002 u16StoreIndex
000288ea g     O .bss	00000001 bEtherCATRunLed
0002364c g     F .text	000000d8 CheckIfEcatError
00024a10 g     F .text	00000148 OBJ_GetObjectList
000288d4 g     O .bss	00000004 pAPPL_FoeWriteData
00027e62 g     O .rodata	0000000c asEntryDesc0x6000
0002000c g       .entry	00000000 _exit
00028948 g     O .bss	00000002 u16SmSync0Counter
000288f4 g     O .bss	00000004 pFoeSendStored
00028922 g     O .bss	00000001 nMaxSyncMan
00020734 g     F .text	00000004 HW_RestartTarget
0002739c g     F .text	0000001c strlen
00020278 g     F .text	0000004c APPL_InputMapping
00020310 g     F .text	0000000c APPL_Application
00028420 g     O .rwdata	00000004 u32Devicetype
000289b8 g     O .bss	00000004 __malloc_sbrk_start
000289b2 g     O .bss	00000001 u8StoreSubindex
0002793c g     O .rodata	00000107 aName0x1C33
000228c4 g     F .text	00000008 BackToInitTransition
000288fc g     O .bss	00000004 u32LastFileOffset
00024658 g     F .text	0000010c OBJ_GetObjectLength
00023ccc g     F .text	00000044 GetOutOfMbxQueue
0002791c g     F .text	00000004 alt_icache_flush_all
000289bc g     O .bss	00000004 __malloc_free_list
000288e4 g     O .bss	00000004 pAPPL_FoeRead
000209e0 g     F .text	00000050 AddObjectsToObjDictionary
000289dc g     O .bss	0000000c spiTxBuf
00028978 g     O .bss	00000002 sCycleDiag
00021090 g     F .text	0000003c ECAT_Application
00027d44 g     O .rodata	0000000c aName0x1008
000288d8 g     O .bss	00000004 pAPPL_FoeWrite
00027d6c g     O .rodata	00000057 aName0x8008
000288f0 g     O .bss	00000002 u16FoeMaxSendBlockSize
00023908 g     F .text	000000e4 ECAT_Init
000275f8 g     F .text	00000084 alt_load
00023c44 g     F .text	0000001c FOE_Ack
00028918 g     O .bss	00000002 nEscAddrInputData
0002705c g     F .text	00000010 free
000205b4 g     F .text	00000004 HW_Release



Disassembly of section .entry:

00020000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   20000:	004000b4 	movhi	at,2
    ori r1, r1, %lo(_start)
   20004:	08400814 	ori	at,at,32
    jmp r1
   20008:	0800683a 	jmp	at

0002000c <_exit>:
	...

Disassembly of section .text:

00020020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   20020:	06c000f4 	movhi	sp,3
    ori sp, sp, %lo(__alt_stack_pointer)
   20024:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
   20028:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
   2002c:	d680f114 	ori	gp,gp,964
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   20030:	008000b4 	movhi	r2,2
    ori r2, r2, %lo(__bss_start)
   20034:	10a22514 	ori	r2,r2,34964

    movhi r3, %hi(__bss_end)
   20038:	00c000b4 	movhi	r3,2
    ori r3, r3, %lo(__bss_end)
   2003c:	18e34714 	ori	r3,r3,36124

    beq r2, r3, 1f
   20040:	10c00326 	beq	r2,r3,20050 <_start+0x30>

0:
    stw zero, (r2)
   20044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   20048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   2004c:	10fffd36 	bltu	r2,r3,20044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   20050:	00275f80 	call	275f8 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   20054:	002767c0 	call	2767c <alt_main>

00020058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   20058:	003fff06 	br	20058 <alt_after_alt_main>

0002005c <main>:
#include "altera_avalon_pio_regs.h"
#include "peripheral/peripheral_linker.h"

int main()
{
  printf("Hello from Nios II!\n");
   2005c:	010000b4 	movhi	r4,2
{
   20060:	deffff04 	addi	sp,sp,-4
  printf("Hello from Nios II!\n");
   20064:	211e4a04 	addi	r4,r4,31016
{
   20068:	dfc00015 	stw	ra,0(sp)
  printf("Hello from Nios II!\n");
   2006c:	00273440 	call	27344 <puts>
  	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, invert_me);
  	  delay_ms(1000);
  	  invert_me = ~invert_me;
  }*/

  main_initial();
   20070:	00203240 	call	20324 <main_initial>

  return 0;
}
   20074:	0005883a 	mov	r2,zero
   20078:	dfc00017 	ldw	ra,0(sp)
   2007c:	dec00104 	addi	sp,sp,4
   20080:	f800283a 	ret

00020084 <APPL_AckErrorInd>:
*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{

}
   20084:	f800283a 	ret

00020088 <APPL_StartMailboxHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}
   20088:	0005883a 	mov	r2,zero
   2008c:	f800283a 	ret

00020090 <APPL_StopMailboxHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
   20090:	0005883a 	mov	r2,zero
   20094:	f800283a 	ret

00020098 <APPL_StartInputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
    return ALSTATUSCODE_NOERROR;
}
   20098:	0005883a 	mov	r2,zero
   2009c:	f800283a 	ret

000200a0 <APPL_StopInputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
   200a0:	0005883a 	mov	r2,zero
   200a4:	f800283a 	ret

000200a8 <APPL_StartOutputHandler>:
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
   200a8:	0005883a 	mov	r2,zero
   200ac:	f800283a 	ret

000200b0 <APPL_StopOutputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
   200b0:	0005883a 	mov	r2,zero
   200b4:	f800283a 	ret

000200b8 <APPL_GenerateMapping>:

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
{
   200b8:	defff404 	addi	sp,sp,-48
   200bc:	dd800815 	stw	r22,32(sp)
   200c0:	dd400715 	stw	r21,28(sp)
   200c4:	dd000615 	stw	r20,24(sp)
   200c8:	dcc00515 	stw	r19,20(sp)
   200cc:	dc000215 	stw	r16,8(sp)
   200d0:	dfc00b15 	stw	ra,44(sp)
   200d4:	df000a15 	stw	fp,40(sp)
   200d8:	ddc00915 	stw	r23,36(sp)
   200dc:	dc800415 	stw	r18,16(sp)
   200e0:	dc400315 	stw	r17,12(sp)
   200e4:	2029883a 	mov	r20,r4
   200e8:	2827883a 	mov	r19,r5
    UINT32 *pPDOEntry = NULL;
    UINT16 PDOEntryCnt = 0;
   
#if MAX_PD_OUTPUT_SIZE > 0
    /*Scan object 0x1C12 RXPDO assign*/
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   200ec:	002d883a 	mov	r22,zero
    UINT16 OutputSize = 0;
   200f0:	0021883a 	mov	r16,zero
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   200f4:	d5600404 	addi	r21,gp,-32752
   200f8:	d0e0040b 	ldhu	r3,-32752(gp)
   200fc:	b0bfffcc 	andi	r2,r22,65535
   20100:	10c01a36 	bltu	r2,r3,2016c <APPL_GenerateMapping+0xb4>
    UINT16 result = ALSTATUSCODE_NOERROR;
   20104:	0023883a 	mov	r17,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
            break;
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
   20108:	84bfffcc 	andi	r18,r16,65535
   2010c:	948001c4 	addi	r18,r18,7
#endif

#if MAX_PD_INPUT_SIZE > 0
    if(result == 0)
   20110:	88bfffcc 	andi	r2,r17,65535
    OutputSize = (OutputSize + 7) >> 3;
   20114:	9025d0fa 	srai	r18,r18,3
    if(result == 0)
   20118:	10005026 	beq	r2,zero,2025c <APPL_GenerateMapping+0x1a4>
    UINT16 InputSize = 0;
   2011c:	0021883a 	mov	r16,zero
   20120:	04400944 	movi	r17,37
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
                break;
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
   20124:	843fffcc 	andi	r16,r16,65535
   20128:	840001c4 	addi	r16,r16,7
   2012c:	8021d0fa 	srai	r16,r16,3
#endif

    *pInputSize = InputSize;
    *pOutputSize = OutputSize;
    return result;
}
   20130:	8805883a 	mov	r2,r17
    InputSize = (InputSize + 7) >> 3;
   20134:	a400000d 	sth	r16,0(r20)
    *pOutputSize = OutputSize;
   20138:	9c80000d 	sth	r18,0(r19)
}
   2013c:	dfc00b17 	ldw	ra,44(sp)
   20140:	df000a17 	ldw	fp,40(sp)
   20144:	ddc00917 	ldw	r23,36(sp)
   20148:	dd800817 	ldw	r22,32(sp)
   2014c:	dd400717 	ldw	r21,28(sp)
   20150:	dd000617 	ldw	r20,24(sp)
   20154:	dcc00517 	ldw	r19,20(sp)
   20158:	dc800417 	ldw	r18,16(sp)
   2015c:	dc400317 	ldw	r17,12(sp)
   20160:	dc000217 	ldw	r16,8(sp)
   20164:	dec00c04 	addi	sp,sp,48
   20168:	f800283a 	ret
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
   2016c:	1004907a 	slli	r2,r2,1
   20170:	a885883a 	add	r2,r21,r2
   20174:	1100008b 	ldhu	r4,2(r2)
   20178:	002461c0 	call	2461c <OBJ_GetObjectHandle>
   2017c:	1025883a 	mov	r18,r2
        if(pPDO != NULL)
   20180:	10001326 	beq	r2,zero,201d0 <APPL_GenerateMapping+0x118>
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   20184:	10800617 	ldw	r2,24(r2)
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20188:	0007883a 	mov	r3,zero
   2018c:	1700000b 	ldhu	fp,0(r2)
   20190:	18bfffcc 	andi	r2,r3,65535
   20194:	1700021e 	bne	r2,fp,201a0 <APPL_GenerateMapping+0xe8>
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20198:	b5800044 	addi	r22,r22,1
   2019c:	003fd606 	br	200f8 <APPL_GenerateMapping+0x40>
                pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   201a0:	1c400044 	addi	r17,r3,1
   201a4:	900b883a 	mov	r5,r18
   201a8:	89003fcc 	andi	r4,r17,255
   201ac:	95c00617 	ldw	r23,24(r18)
   201b0:	0024b600 	call	24b60 <OBJ_GetEntryOffset>
   201b4:	1004d0fa 	srli	r2,r2,3
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   201b8:	8807883a 	mov	r3,r17
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   201bc:	1087ff8c 	andi	r2,r2,8190
   201c0:	b8af883a 	add	r23,r23,r2
   201c4:	b8800003 	ldbu	r2,0(r23)
   201c8:	1421883a 	add	r16,r2,r16
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   201cc:	003ff006 	br	20190 <APPL_GenerateMapping+0xd8>
            OutputSize = 0;
   201d0:	0021883a 	mov	r16,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
   201d4:	04400944 	movi	r17,37
   201d8:	003fcb06 	br	20108 <APPL_GenerateMapping+0x50>
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
   201dc:	1004907a 	slli	r2,r2,1
   201e0:	b885883a 	add	r2,r23,r2
   201e4:	1100008b 	ldhu	r4,2(r2)
   201e8:	002461c0 	call	2461c <OBJ_GetObjectHandle>
   201ec:	102d883a 	mov	r22,r2
            if(pPDO != NULL)
   201f0:	10001e26 	beq	r2,zero,2026c <APPL_GenerateMapping+0x1b4>
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   201f4:	10800617 	ldw	r2,24(r2)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   201f8:	8807883a 	mov	r3,r17
   201fc:	11c0000b 	ldhu	r7,0(r2)
   20200:	18bfffcc 	andi	r2,r3,65535
   20204:	11c0051e 	bne	r2,r7,2021c <APPL_GenerateMapping+0x164>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20208:	e7000044 	addi	fp,fp,1
   2020c:	d0e0030b 	ldhu	r3,-32756(gp)
   20210:	e0bfffcc 	andi	r2,fp,65535
   20214:	10fff136 	bltu	r2,r3,201dc <APPL_GenerateMapping+0x124>
   20218:	003fc206 	br	20124 <APPL_GenerateMapping+0x6c>
                    pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   2021c:	b1800617 	ldw	r6,24(r22)
   20220:	1d400044 	addi	r21,r3,1
   20224:	b00b883a 	mov	r5,r22
   20228:	a9003fcc 	andi	r4,r21,255
   2022c:	d9c00115 	stw	r7,4(sp)
   20230:	d9800015 	stw	r6,0(sp)
   20234:	0024b600 	call	24b60 <OBJ_GetEntryOffset>
   20238:	1004d0fa 	srli	r2,r2,3
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   2023c:	d9800017 	ldw	r6,0(sp)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20240:	d9c00117 	ldw	r7,4(sp)
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   20244:	1087ff8c 	andi	r2,r2,8190
   20248:	308d883a 	add	r6,r6,r2
   2024c:	30800003 	ldbu	r2,0(r6)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20250:	a807883a 	mov	r3,r21
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   20254:	1421883a 	add	r16,r2,r16
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20258:	003fe906 	br	20200 <APPL_GenerateMapping+0x148>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   2025c:	8839883a 	mov	fp,r17
    UINT16 InputSize = 0;
   20260:	8821883a 	mov	r16,r17
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20264:	d5e00304 	addi	r23,gp,-32756
   20268:	003fe806 	br	2020c <APPL_GenerateMapping+0x154>
                InputSize = 0;
   2026c:	8821883a 	mov	r16,r17
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
   20270:	04400904 	movi	r17,36
   20274:	003fab06 	br	20124 <APPL_GenerateMapping+0x6c>

00020278 <APPL_InputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   20278:	0007883a 	mov	r3,zero
   2027c:	d1a00304 	addi	r6,gp,-32756
   20280:	d160030b 	ldhu	r5,-32756(gp)
   20284:	18803fcc 	andi	r2,r3,255
   20288:	11400136 	bltu	r2,r5,20290 <APPL_InputMapping+0x18>
					   sizeof(IN_GENERIC0x6000.IN_GEN_INT1));
				pTmpData += sizeof(IN_GENERIC0x6000.IN_GEN_INT1);
				break;
		}
	}
}
   2028c:	f800283a 	ret
		switch (sTxPDOassign.aEntries[j]) {
   20290:	18803fcc 	andi	r2,r3,255
   20294:	1004907a 	slli	r2,r2,1
   20298:	3085883a 	add	r2,r6,r2
   2029c:	1080008b 	ldhu	r2,2(r2)
   202a0:	10868018 	cmpnei	r2,r2,6656
   202a4:	1000051e 	bne	r2,zero,202bc <APPL_InputMapping+0x44>
				memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   202a8:	d0a00283 	ldbu	r2,-32758(gp)
				pTmpData += sizeof(IN_GENERIC0x6000.IN_GEN_INT1);
   202ac:	21000084 	addi	r4,r4,2
				memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   202b0:	20bfff85 	stb	r2,-2(r4)
   202b4:	d0a002c3 	ldbu	r2,-32757(gp)
   202b8:	20bfffc5 	stb	r2,-1(r4)
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   202bc:	18c00044 	addi	r3,r3,1
   202c0:	003fef06 	br	20280 <APPL_InputMapping+0x8>

000202c4 <APPL_OutputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	    for (UINT8 k = 0; k < sRxPDOassign.u16SubIndex0; k++) {
   202c4:	0007883a 	mov	r3,zero
   202c8:	d1a00404 	addi	r6,gp,-32752
   202cc:	d160040b 	ldhu	r5,-32752(gp)
   202d0:	18803fcc 	andi	r2,r3,255
   202d4:	11400136 	bltu	r2,r5,202dc <APPL_OutputMapping+0x18>
	                       sizeof(OUT_GENERIC0x7000.OUT_GEN_INT1));
	                pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_INT1);
	                break;
	        }
	    }
}
   202d8:	f800283a 	ret
	        switch (sRxPDOassign.aEntries[k]) {
   202dc:	18803fcc 	andi	r2,r3,255
   202e0:	1004907a 	slli	r2,r2,1
   202e4:	3085883a 	add	r2,r6,r2
   202e8:	1080008b 	ldhu	r2,2(r2)
   202ec:	10858018 	cmpnei	r2,r2,5632
   202f0:	1000051e 	bne	r2,zero,20308 <APPL_OutputMapping+0x44>
	                memcpy(&OUT_GENERIC0x7000.OUT_GEN_INT1, pTmpData,
   202f4:	20800003 	ldbu	r2,0(r4)
	                pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_INT1);
   202f8:	21000084 	addi	r4,r4,2
	                memcpy(&OUT_GENERIC0x7000.OUT_GEN_INT1, pTmpData,
   202fc:	d0a00185 	stb	r2,-32762(gp)
   20300:	20bfffc3 	ldbu	r2,-1(r4)
   20304:	d0a001c5 	stb	r2,-32761(gp)
	    for (UINT8 k = 0; k < sRxPDOassign.u16SubIndex0; k++) {
   20308:	18c00044 	addi	r3,r3,1
   2030c:	003fef06 	br	202cc <APPL_OutputMapping+0x8>

00020310 <APPL_Application>:
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
	static int haha = 0;
	//IN_GENERIC0x6000.IN_GEN_INT1 = haha++;
	IN_GENERIC0x6000.IN_GEN_INT1 = OUT_GENERIC0x7000.OUT_GEN_INT1;
   20310:	d0a0018b 	ldhu	r2,-32762(gp)
   20314:	d0a0028d 	sth	r2,-32758(gp)
}
   20318:	f800283a 	ret

0002031c <APPL_GetDeviceID>:
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GetDeviceID()
{
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    return 0x5;
}
   2031c:	00800144 	movi	r2,5
   20320:	f800283a 	ret

00020324 <main_initial>:
/**

 \brief    This is the main function

*////////////////////////////////////////////////////////////////////////////////////////
void main_initial(void) {
   20324:	deffff04 	addi	sp,sp,-4
   20328:	dfc00015 	stw	ra,0(sp)
    /* initialize the Hardware and the EtherCAT Slave Controller */
    HW_Init();
   2032c:	002069c0 	call	2069c <HW_Init>
    MainInit();
   20330:	0020f940 	call	20f94 <MainInit>

    bRunApplication = TRUE;
   20334:	00800044 	movi	r2,1
   20338:	d0a14905 	stb	r2,-31452(gp)
    do {
        MainLoop();
   2033c:	00213ec0 	call	213ec <MainLoop>
    } while (bRunApplication == TRUE);
   20340:	d0a14903 	ldbu	r2,-31452(gp)
   20344:	10800060 	cmpeqi	r2,r2,1
   20348:	103ffc1e 	bne	r2,zero,2033c <main_initial+0x18>

    HW_Release();
}
   2034c:	dfc00017 	ldw	ra,0(sp)
   20350:	dec00104 	addi	sp,sp,4
    HW_Release();
   20354:	00205b41 	jmpi	205b4 <HW_Release>

00020358 <HW_SPI_Read>:
 * @param pBuf
 * @param Addr
 * @param ByteLen
 */

static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   20358:	defff504 	addi	sp,sp,-44
   2035c:	ddc00915 	stw	r23,36(sp)
   20360:	dd000615 	stw	r20,24(sp)

        /* Set dummy byte */
        spiTxBuf[DataOffset] = 0xff;

        /* Set read terminal byte */
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20364:	05c000f4 	movhi	r23,3
        spiTxBuf[0] = ptr[1];
   20368:	050000f4 	movhi	r20,3
static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   2036c:	dd400715 	stw	r21,28(sp)
   20370:	dc800415 	stw	r18,16(sp)
   20374:	dc400315 	stw	r17,12(sp)
   20378:	dc000215 	stw	r16,8(sp)
   2037c:	dfc00a15 	stw	ra,40(sp)
   20380:	dd800815 	stw	r22,32(sp)
   20384:	dcc00515 	stw	r19,20(sp)
   20388:	2023883a 	mov	r17,r4
   2038c:	2825883a 	mov	r18,r5
   20390:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   20394:	a5227704 	addi	r20,r20,-30244
        spiTxBuf[DataOffset] = 0xff;
   20398:	057fffc4 	movi	r21,-1
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2039c:	bde277c4 	addi	r23,r23,-30241
    while (ByteLen) {
   203a0:	80bfffcc 	andi	r2,r16,65535
   203a4:	10000b1e 	bne	r2,zero,203d4 <HW_SPI_Read+0x7c>
        /* Next section */
        Addr += XferLen;
        pBuf += XferLen;
        ByteLen -= XferLen;
    }
}
   203a8:	dfc00a17 	ldw	ra,40(sp)
   203ac:	ddc00917 	ldw	r23,36(sp)
   203b0:	dd800817 	ldw	r22,32(sp)
   203b4:	dd400717 	ldw	r21,28(sp)
   203b8:	dd000617 	ldw	r20,24(sp)
   203bc:	dcc00517 	ldw	r19,20(sp)
   203c0:	dc800417 	ldw	r18,16(sp)
   203c4:	dc400317 	ldw	r17,12(sp)
   203c8:	dc000217 	ldw	r16,8(sp)
   203cc:	dec00b04 	addi	sp,sp,44
   203d0:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   203d4:	10800270 	cmpltui	r2,r2,9
   203d8:	802d883a 	mov	r22,r16
   203dc:	1000011e 	bne	r2,zero,203e4 <HW_SPI_Read+0x8c>
   203e0:	05800204 	movi	r22,8
        AddrTmp = AddrTmp << 3;
   203e4:	900490fa 	slli	r2,r18,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   203e8:	b4ffffcc 	andi	r19,r22,65535
        spiTxBuf[0] = ptr[1];
   203ec:	010000f4 	movhi	r4,3
   203f0:	10ffffcc 	andi	r3,r2,65535
   203f4:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   203f8:	108000d4 	ori	r2,r2,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   203fc:	980d883a 	mov	r6,r19
        spiTxBuf[0] = ptr[1];
   20400:	20e27705 	stb	r3,-30244(r4)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20404:	000b883a 	mov	r5,zero
   20408:	b809883a 	mov	r4,r23
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   2040c:	a0800045 	stb	r2,1(r20)
        spiTxBuf[DataOffset] = 0xff;
   20410:	a5400085 	stb	r21,2(r20)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20414:	002737c0 	call	2737c <memset>
        spiTxBuf[DataOffset + XferLen] = 0xff;
   20418:	008000f4 	movhi	r2,3
   2041c:	9885883a 	add	r2,r19,r2
   20420:	15627785 	stb	r21,-30242(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   20424:	00800134 	movhi	r2,4
   20428:	10041035 	stwio	zero,4160(r2)
													DataOffset + XferLen, 0);
   2042c:	988000c4 	addi	r2,r19,3
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20430:	01c000f4 	movhi	r7,3
   20434:	018000f4 	movhi	r6,3
   20438:	01000134 	movhi	r4,4
   2043c:	d8000115 	stw	zero,4(sp)
   20440:	d8800015 	stw	r2,0(sp)
   20444:	39e27404 	addi	r7,r7,-30256
   20448:	31a27704 	addi	r6,r6,-30244
   2044c:	000b883a 	mov	r5,zero
   20450:	21040004 	addi	r4,r4,4096
   20454:	0026cb40 	call	26cb4 <spi_transmit_receive>
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20458:	00c00044 	movi	r3,1
   2045c:	00800134 	movhi	r2,4
   20460:	10c41035 	stwio	r3,4160(r2)
        for (i = 0; i < XferLen; i++) {
   20464:	008000f4 	movhi	r2,3
   20468:	10a27404 	addi	r2,r2,-30256
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   2046c:	0007883a 	mov	r3,zero
            pBuf[i] = spiRxBuf[DataOffset + i];
   20470:	114000c3 	ldbu	r5,3(r2)
   20474:	88c9883a 	add	r4,r17,r3
        for (i = 0; i < XferLen; i++) {
   20478:	18c00044 	addi	r3,r3,1
            pBuf[i] = spiRxBuf[DataOffset + i];
   2047c:	21400005 	stb	r5,0(r4)
        for (i = 0; i < XferLen; i++) {
   20480:	193fffcc 	andi	r4,r3,65535
   20484:	10800044 	addi	r2,r2,1
   20488:	24fff936 	bltu	r4,r19,20470 <HW_SPI_Read+0x118>
        Addr += XferLen;
   2048c:	b4a5883a 	add	r18,r22,r18
        pBuf += XferLen;
   20490:	8ce3883a 	add	r17,r17,r19
        ByteLen -= XferLen;
   20494:	85a1c83a 	sub	r16,r16,r22
   20498:	003fc106 	br	203a0 <HW_SPI_Read+0x48>

0002049c <HW_SPI_Write>:
 *
 * @param pData
 * @param Addr
 * @param ByteLen
 */
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   2049c:	defff604 	addi	sp,sp,-40
   204a0:	dd400715 	stw	r21,28(sp)
   204a4:	dd000615 	stw	r20,24(sp)
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
        DataOffset = 2;
#endif

        /* Set transmit data bytes */
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   204a8:	054000f4 	movhi	r21,3
        spiTxBuf[0] = ptr[1];
   204ac:	050000f4 	movhi	r20,3
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   204b0:	dcc00515 	stw	r19,20(sp)
   204b4:	dc800415 	stw	r18,16(sp)
   204b8:	dc000215 	stw	r16,8(sp)
   204bc:	dfc00915 	stw	ra,36(sp)
   204c0:	dd800815 	stw	r22,32(sp)
   204c4:	dc400315 	stw	r17,12(sp)
   204c8:	2025883a 	mov	r18,r4
   204cc:	2827883a 	mov	r19,r5
   204d0:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   204d4:	a5227704 	addi	r20,r20,-30244
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   204d8:	ad627784 	addi	r21,r21,-30242
    while (ByteLen) {
   204dc:	80bfffcc 	andi	r2,r16,65535
   204e0:	10000a1e 	bne	r2,zero,2050c <HW_SPI_Write+0x70>

        Addr += XferLen;
        pData += XferLen;
        ByteLen -= XferLen;
    }
}
   204e4:	dfc00917 	ldw	ra,36(sp)
   204e8:	dd800817 	ldw	r22,32(sp)
   204ec:	dd400717 	ldw	r21,28(sp)
   204f0:	dd000617 	ldw	r20,24(sp)
   204f4:	dcc00517 	ldw	r19,20(sp)
   204f8:	dc800417 	ldw	r18,16(sp)
   204fc:	dc400317 	ldw	r17,12(sp)
   20500:	dc000217 	ldw	r16,8(sp)
   20504:	dec00a04 	addi	sp,sp,40
   20508:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   2050c:	10c00268 	cmpgeui	r3,r2,9
   20510:	1800241e 	bne	r3,zero,205a4 <HW_SPI_Write+0x108>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   20514:	108000e0 	cmpeqi	r2,r2,3
   20518:	1000241e 	bne	r2,zero,205ac <HW_SPI_Write+0x110>
   2051c:	8023883a 	mov	r17,r16
        AddrTmp = AddrTmp << 3;
   20520:	980490fa 	slli	r2,r19,3
        spiTxBuf[0] = ptr[1];
   20524:	010000f4 	movhi	r4,3
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20528:	8dbfffcc 	andi	r22,r17,65535
        spiTxBuf[0] = ptr[1];
   2052c:	10ffffcc 	andi	r3,r2,65535
   20530:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   20534:	10800114 	ori	r2,r2,4
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20538:	b00d883a 	mov	r6,r22
        spiTxBuf[0] = ptr[1];
   2053c:	20e27705 	stb	r3,-30244(r4)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20540:	900b883a 	mov	r5,r18
   20544:	a809883a 	mov	r4,r21
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   20548:	a0800045 	stb	r2,1(r20)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   2054c:	00273540 	call	27354 <memcpy>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   20550:	00800134 	movhi	r2,4
   20554:	10041035 	stwio	zero,4160(r2)
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20558:	88800084 	addi	r2,r17,2
   2055c:	10bfffcc 	andi	r2,r2,65535
   20560:	01c000f4 	movhi	r7,3
   20564:	018000f4 	movhi	r6,3
   20568:	01000134 	movhi	r4,4
   2056c:	d8000115 	stw	zero,4(sp)
   20570:	d8800015 	stw	r2,0(sp)
   20574:	39e27404 	addi	r7,r7,-30256
   20578:	31a27704 	addi	r6,r6,-30244
   2057c:	000b883a 	mov	r5,zero
   20580:	21040004 	addi	r4,r4,4096
   20584:	0026cb40 	call	26cb4 <spi_transmit_receive>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20588:	00c00044 	movi	r3,1
   2058c:	00800134 	movhi	r2,4
   20590:	10c41035 	stwio	r3,4160(r2)
        Addr += XferLen;
   20594:	9c67883a 	add	r19,r19,r17
        pData += XferLen;
   20598:	95a5883a 	add	r18,r18,r22
        ByteLen -= XferLen;
   2059c:	8461c83a 	sub	r16,r16,r17
   205a0:	003fce06 	br	204dc <HW_SPI_Write+0x40>
            XferLen = HW_SPI_MAX_DATA_FRAGMENT_SIZE;
   205a4:	04400204 	movi	r17,8
   205a8:	003fdd06 	br	20520 <HW_SPI_Write+0x84>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   205ac:	04400084 	movi	r17,2
   205b0:	003fdb06 	br	20520 <HW_SPI_Write+0x84>

000205b4 <HW_Release>:
 * @brief  This function shall be implemented if hardware resources need to be
 * release when the sample application stops.
 * @param  None
 * @retval None
 */
void HW_Release(void) {}
   205b4:	f800283a 	ret

000205b8 <HW_GetALEventRegister_Isr>:
 * interrupts service routines. The behaviour is equal to
 * "HW_GetALEventRegister()"
 * @param  None
 * @retval First two Bytes of ALEvent register (0x220)
 */
uint16_t HW_GetALEventRegister_Isr(void) {
   205b8:	deffff04 	addi	sp,sp,-4
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscReadIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   205bc:	01800084 	movi	r6,2
   205c0:	01408804 	movi	r5,544
   205c4:	d1213484 	addi	r4,gp,-31534
uint16_t HW_GetALEventRegister_Isr(void) {
   205c8:	dfc00015 	stw	ra,0(sp)
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   205cc:	00203580 	call	20358 <HW_SPI_Read>
}
   205d0:	d0a1348b 	ldhu	r2,-31534(gp)
   205d4:	dfc00017 	ldw	ra,0(sp)
   205d8:	dec00104 	addi	sp,sp,4
   205dc:	f800283a 	ret

000205e0 <HW_EscRead>:
void HW_EscRead(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   205e0:	deffff04 	addi	sp,sp,-4
   205e4:	dfc00015 	stw	ra,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   205e8:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   205ec:	00ffff84 	movi	r3,-2
   205f0:	10c4703a 	and	r2,r2,r3
   205f4:	1001703a 	wrctl	status,r2
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   205f8:	31bfffcc 	andi	r6,r6,65535
   205fc:	297fffcc 	andi	r5,r5,65535
   20600:	00203580 	call	20358 <HW_SPI_Read>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   20604:	00800044 	movi	r2,1
   20608:	1001703a 	wrctl	status,r2
}
   2060c:	dfc00017 	ldw	ra,0(sp)
   20610:	dec00104 	addi	sp,sp,4
   20614:	f800283a 	ret

00020618 <HW_GetALEventRegister>:
uint16_t HW_GetALEventRegister(void) {
   20618:	deffff04 	addi	sp,sp,-4
   2061c:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   20620:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20624:	00ffff84 	movi	r3,-2
   20628:	10c4703a 	and	r2,r2,r3
   2062c:	1001703a 	wrctl	status,r2
    HW_EscRead((MEM_ADDR*)EscALEvent.Byte, ESC_AL_EVENT_OFFSET, 2);
   20630:	01800084 	movi	r6,2
   20634:	01408804 	movi	r5,544
   20638:	d1213484 	addi	r4,gp,-31534
   2063c:	00205e00 	call	205e0 <HW_EscRead>
  NIOS2_WRITE_STATUS (context);
   20640:	00800044 	movi	r2,1
   20644:	1001703a 	wrctl	status,r2
}
   20648:	d0a1348b 	ldhu	r2,-31534(gp)
   2064c:	dfc00017 	ldw	ra,0(sp)
   20650:	dec00104 	addi	sp,sp,4
   20654:	f800283a 	ret

00020658 <HW_EscReadIsr>:
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20658:	31bfffcc 	andi	r6,r6,65535
   2065c:	297fffcc 	andi	r5,r5,65535
   20660:	00203581 	jmpi	20358 <HW_SPI_Read>

00020664 <HW_EscWrite>:
 * @param  Address     EtherCAT ASIC address ( upper limit is 0x1FFF ) for
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWrite(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   20664:	deffff04 	addi	sp,sp,-4
   20668:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   2066c:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20670:	00ffff84 	movi	r3,-2
   20674:	10c4703a 	and	r2,r2,r3
   20678:	1001703a 	wrctl	status,r2

#if AL_EVENT_ENABLED
    DISABLE_AL_EVENT_INT;
#endif
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   2067c:	31bfffcc 	andi	r6,r6,65535
   20680:	297fffcc 	andi	r5,r5,65535
   20684:	002049c0 	call	2049c <HW_SPI_Write>
  NIOS2_WRITE_STATUS (context);
   20688:	00800044 	movi	r2,1
   2068c:	1001703a 	wrctl	status,r2
#if AL_EVENT_ENABLED
    ENABLE_AL_EVENT_INT;
#endif
}
   20690:	dfc00017 	ldw	ra,0(sp)
   20694:	dec00104 	addi	sp,sp,4
   20698:	f800283a 	ret

0002069c <HW_Init>:
uint8_t HW_Init(void) {
   2069c:	defffd04 	addi	sp,sp,-12
   206a0:	dc000115 	stw	r16,4(sp)
   206a4:	dfc00215 	stw	ra,8(sp)
        intMask = 0x93;
   206a8:	040024c4 	movi	r16,147
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206ac:	01800104 	movi	r6,4
   206b0:	01408104 	movi	r5,516
   206b4:	d809883a 	mov	r4,sp
        intMask = 0x93;
   206b8:	dc000015 	stw	r16,0(sp)
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206bc:	00206640 	call	20664 <HW_EscWrite>
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206c0:	01800104 	movi	r6,4
   206c4:	01408104 	movi	r5,516
   206c8:	d809883a 	mov	r4,sp
        intMask = 0;
   206cc:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206d0:	00205e00 	call	205e0 <HW_EscRead>
    } while (intMask != 0x93);
   206d4:	d8800017 	ldw	r2,0(sp)
   206d8:	108024d8 	cmpnei	r2,r2,147
   206dc:	103ff31e 	bne	r2,zero,206ac <HW_Init+0x10>
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206e0:	01800104 	movi	r6,4
   206e4:	01408104 	movi	r5,516
   206e8:	d809883a 	mov	r4,sp
    intMask = 0x00;
   206ec:	d8000015 	stw	zero,0(sp)
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206f0:	00206640 	call	20664 <HW_EscWrite>
   206f4:	00800044 	movi	r2,1
   206f8:	1001703a 	wrctl	status,r2
    if (bootSwitchID) {
   206fc:	d0a1340b 	ldhu	r2,-31536(gp)
   20700:	10000426 	beq	r2,zero,20714 <HW_Init+0x78>
        HW_EscWriteWord(bootSwitchID, ESC_ALIAS_ADDRESS_OFFSET);
   20704:	01800084 	movi	r6,2
   20708:	01400484 	movi	r5,18
   2070c:	d1213404 	addi	r4,gp,-31536
   20710:	00206640 	call	20664 <HW_EscWrite>
}
   20714:	0005883a 	mov	r2,zero
   20718:	dfc00217 	ldw	ra,8(sp)
   2071c:	dc000117 	ldw	r16,4(sp)
   20720:	dec00304 	addi	sp,sp,12
   20724:	f800283a 	ret

00020728 <HW_EscWriteIsr>:
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWriteIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   20728:	31bfffcc 	andi	r6,r6,65535
   2072c:	297fffcc 	andi	r5,r5,65535
   20730:	002049c1 	jmpi	2049c <HW_SPI_Write>

00020734 <HW_RestartTarget>:
/**
 * @brief  This function resets the hardware
 * @param  None
 * @retval None
 */
void HW_RestartTarget(void) {}
   20734:	f800283a 	ret

00020738 <HW_ALEVENT_IRQHandler>:
 * @retval None
 */
void HW_ALEVENT_IRQHandler(void) {
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SPI_ESC_INT_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SPI_ESC_INT_PIN);
        PDI_Isr();
   20738:	002122c1 	jmpi	2122c <PDI_Isr>

0002073c <HW_SYNC0_IRQHandler>:
 */
void HW_SYNC0_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC0_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC0_PIN);
        Sync0_Isr();
   2073c:	00210cc1 	jmpi	210cc <Sync0_Isr>

00020740 <HW_SYNC1_IRQHandler>:

void HW_SYNC1_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC1_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC1_PIN);
        Sync1_Isr();
   20740:	0020f401 	jmpi	20f40 <Sync1_Isr>

00020744 <HW_TIMETASK_IRQHandler>:
	if ((__HAL_TIM_GET_IT_SOURCE(&HW_TIMETASK_INSTANCE_H, TIM_IT_UPDATE) ==
		 SET) &&
		(__HAL_TIM_GET_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE) != 0)) {
		__HAL_TIM_CLEAR_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE);
		*/
		ECAT_CheckTimer();
   20744:	0020c6c1 	jmpi	20c6c <ECAT_CheckTimer>

00020748 <BL_Start>:

 \brief Called from INIT to BOOT
*////////////////////////////////////////////////////////////////////////////////////////
void BL_Start( UINT8 State)
{
}
   20748:	f800283a 	ret

0002074c <BL_Stop>:

\brief Called in the state transition from BOOT to Init
*////////////////////////////////////////////////////////////////////////////////////////
void BL_Stop(void)
{
}
   2074c:	f800283a 	ret

00020750 <BL_StartDownload>:

 \brief Dummy BL_StartDownload function
*////////////////////////////////////////////////////////////////////////////////////////
void BL_StartDownload(UINT32 password)
{
}
   20750:	f800283a 	ret

00020754 <BL_Data>:
 \brief Dummy BL_Data function
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 BL_Data(UINT16 *pData,UINT16 Size)
{
    return 0;
}
   20754:	0005883a 	mov	r2,zero
   20758:	f800283a 	ret

0002075c <COE_SyncTimeStamp>:
          Called from the Timer handler 
*////////////////////////////////////////////////////////////////////////////////////////
void COE_SyncTimeStamp(void)
{

    if (b32BitDc)
   2075c:	d0a15b83 	ldbu	r2,-31378(gp)
{
   20760:	defffe04 	addi	sp,sp,-8
   20764:	dfc00115 	stw	ra,4(sp)
    if (b32BitDc)
   20768:	10001226 	beq	r2,zero,207b4 <COE_SyncTimeStamp+0x58>
    {
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   2076c:	d0a13917 	ldw	r2,-31516(gp)


        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   20770:	d809883a 	mov	r4,sp
   20774:	01800104 	movi	r6,4
   20778:	01424404 	movi	r5,2320
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   2077c:	d8800015 	stw	r2,0(sp)
        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   20780:	00205e00 	call	205e0 <HW_EscRead>

        /*update the lower 32Bit*/
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   20784:	d8800017 	ldw	r2,0(sp)

        if (DcTime < u32LastDc32Value)
   20788:	d1213817 	ldw	r4,-31520(gp)
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   2078c:	d0e13a17 	ldw	r3,-31512(gp)
   20790:	d0a13915 	stw	r2,-31516(gp)
        if (DcTime < u32LastDc32Value)
   20794:	1100022e 	bgeu	r2,r4,207a0 <COE_SyncTimeStamp+0x44>
        {
            /*32Bit overrun*/
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
   20798:	18c00044 	addi	r3,r3,1
   2079c:	d0e13a15 	stw	r3,-31512(gp)
        }
        
        u32LastDc32Value = DcTime;
   207a0:	d0a13815 	stw	r2,-31520(gp)
        /*The DC unit supports 64Bit => update the complete object*/
        
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
    }

    u32CheckForDcOverrunCnt = 0;
   207a4:	d0213715 	stw	zero,-31524(gp)

}
   207a8:	dfc00117 	ldw	ra,4(sp)
   207ac:	dec00204 	addi	sp,sp,8
   207b0:	f800283a 	ret
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
   207b4:	01800204 	movi	r6,8
   207b8:	01424404 	movi	r5,2320
   207bc:	d1213904 	addi	r4,gp,-31516
   207c0:	00205e00 	call	205e0 <HW_EscRead>
   207c4:	003ff706 	br	207a4 <COE_SyncTimeStamp+0x48>

000207c8 <Read0x10F8>:
{
   207c8:	defffc04 	addi	sp,sp,-16
    if (index != 0x10F8)
   207cc:	20bfffcc 	andi	r2,r4,65535
{
   207d0:	dfc00315 	stw	ra,12(sp)
   207d4:	dc800215 	stw	r18,8(sp)
   207d8:	dc400115 	stw	r17,4(sp)
   207dc:	dc000015 	stw	r16,0(sp)
    if (index != 0x10F8)
   207e0:	10843e18 	cmpnei	r2,r2,4344
{
   207e4:	d8c00403 	ldbu	r3,16(sp)
    if (index != 0x10F8)
   207e8:	1000151e 	bne	r2,zero,20840 <Read0x10F8+0x78>
    if (bCompleteAccess)
   207ec:	18c03fcc 	andi	r3,r3,255
   207f0:	1800151e 	bne	r3,zero,20848 <Read0x10F8+0x80>
   207f4:	2821883a 	mov	r16,r5
    if (subindex > 0)
   207f8:	29403fcc 	andi	r5,r5,255
   207fc:	2800141e 	bne	r5,zero,20850 <Read0x10F8+0x88>
    if (dataSize > 8)
   20800:	30800268 	cmpgeui	r2,r6,9
   20804:	3023883a 	mov	r17,r6
   20808:	1000131e 	bne	r2,zero,20858 <Read0x10F8+0x90>
   2080c:	3825883a 	mov	r18,r7
    COE_SyncTimeStamp();
   20810:	002075c0 	call	2075c <COE_SyncTimeStamp>
    MEMCPY(pData, &u64Timestamp, dataSize);
   20814:	880d883a 	mov	r6,r17
   20818:	d1613904 	addi	r5,gp,-31516
   2081c:	9009883a 	mov	r4,r18
   20820:	00273540 	call	27354 <memcpy>
}
   20824:	8005883a 	mov	r2,r16
   20828:	dfc00317 	ldw	ra,12(sp)
   2082c:	dc800217 	ldw	r18,8(sp)
   20830:	dc400117 	ldw	r17,4(sp)
   20834:	dc000017 	ldw	r16,0(sp)
   20838:	dec00404 	addi	sp,sp,16
   2083c:	f800283a 	ret
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
   20840:	040002c4 	movi	r16,11
   20844:	003ff706 	br	20824 <Read0x10F8+0x5c>
        return ABORTIDX_UNSUPPORTED_ACCESS;
   20848:	04000144 	movi	r16,5
   2084c:	003ff506 	br	20824 <Read0x10F8+0x5c>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   20850:	04000444 	movi	r16,17
   20854:	003ff306 	br	20824 <Read0x10F8+0x5c>
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
   20858:	040003c4 	movi	r16,15
   2085c:	003ff106 	br	20824 <Read0x10F8+0x5c>

00020860 <COE_GetObjectDictionary>:
 \brief    returns the pointer to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
OBJCONST TOBJECT OBJMEM * COE_GetObjectDictionary(void)
{
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
}
   20860:	d0a13517 	ldw	r2,-31532(gp)
   20864:	f800283a 	ret

00020868 <COE_UpdateSyncErrorStatus>:
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   20868:	00c000f4 	movhi	r3,3
   2086c:	18e33204 	addi	r3,r3,-29496
   20870:	18800a8b 	ldhu	r2,42(r3)
   20874:	10000f1e 	bne	r2,zero,208b4 <COE_UpdateSyncErrorStatus+0x4c>
   20878:	008000f4 	movhi	r2,3
   2087c:	19000a0b 	ldhu	r4,40(r3)
   20880:	10a0db0b 	ldhu	r2,-31892(r2)
   20884:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManOutPar.u8SyncError = 1;
   20888:	18801005 	stb	r2,64(r3)
    {
        sSyncManOutPar.u8SyncError = 0;
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   2088c:	00c000f4 	movhi	r3,3
   20890:	18e32104 	addi	r3,r3,-29564
   20894:	18800a8b 	ldhu	r2,42(r3)
   20898:	1000081e 	bne	r2,zero,208bc <COE_UpdateSyncErrorStatus+0x54>
   2089c:	008000f4 	movhi	r2,3
   208a0:	19000a0b 	ldhu	r4,40(r3)
   208a4:	10a0db0b 	ldhu	r2,-31892(r2)
   208a8:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManInPar.u8SyncError = 1;
   208ac:	18801005 	stb	r2,64(r3)
    else
    {
        sSyncManInPar.u8SyncError = 0;
    }

}
   208b0:	f800283a 	ret
   208b4:	00800044 	movi	r2,1
   208b8:	003ff306 	br	20888 <COE_UpdateSyncErrorStatus+0x20>
   208bc:	00800044 	movi	r2,1
   208c0:	003ffa06 	br	208ac <COE_UpdateSyncErrorStatus+0x44>

000208c4 <COE_AddObjectToDic>:

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
    if(pNewObjEntry != NULL)
   208c4:	20002026 	beq	r4,zero,20948 <COE_AddObjectToDic+0x84>
    {
        if(ObjDicList == NULL)
   208c8:	d0a13517 	ldw	r2,-31532(gp)
   208cc:	1000051e 	bne	r2,zero,208e4 <COE_AddObjectToDic+0x20>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
   208d0:	d1213515 	stw	r4,-31532(gp)
            ObjDicList->pNext = NULL;
   208d4:	20000115 	stw	zero,4(r4)
            ObjDicList->pPrev = NULL;
   208d8:	20000015 	stw	zero,0(r4)
            return 0;
   208dc:	0005883a 	mov	r2,zero
   208e0:	f800283a 	ret
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
   208e4:	1140020b 	ldhu	r5,8(r2)
   208e8:	20c0020b 	ldhu	r3,8(r4)
   208ec:	1940142e 	bgeu	r3,r5,20940 <COE_AddObjectToDic+0x7c>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
   208f0:	20000015 	stw	zero,0(r4)
            pNewObjEntry->pNext = ObjDicList;
   208f4:	20800115 	stw	r2,4(r4)
            ObjDicList->pPrev = pNewObjEntry;
   208f8:	11000015 	stw	r4,0(r2)
            ObjDicList = pNewObjEntry;
   208fc:	d1213515 	stw	r4,-31532(gp)
            return 0;
   20900:	003ff606 	br	208dc <COE_AddObjectToDic+0x18>
                if(pDicEntry->Index == pNewObjEntry->Index)
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
   20904:	1940072e 	bgeu	r3,r5,20924 <COE_AddObjectToDic+0x60>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20908:	10c00017 	ldw	r3,0(r2)
                    pNewObjEntry->pNext = pDicEntry;
   2090c:	20800115 	stw	r2,4(r4)
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20910:	20c00015 	stw	r3,0(r4)

                    if(pDicEntry->pPrev != NULL)
   20914:	18000126 	beq	r3,zero,2091c <COE_AddObjectToDic+0x58>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
   20918:	19000115 	stw	r4,4(r3)

                    pDicEntry->pPrev = pNewObjEntry;
   2091c:	11000015 	stw	r4,0(r2)

                    return 0;
   20920:	003fee06 	br	208dc <COE_AddObjectToDic+0x18>
                }
                else if(pDicEntry->pNext == NULL)
   20924:	11400117 	ldw	r5,4(r2)
   20928:	2800041e 	bne	r5,zero,2093c <COE_AddObjectToDic+0x78>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
   2092c:	11000115 	stw	r4,4(r2)
                    pNewObjEntry->pPrev = pDicEntry;
   20930:	20800015 	stw	r2,0(r4)
                    pNewObjEntry->pNext = NULL;
   20934:	20000115 	stw	zero,4(r4)
                    return 0;
   20938:	003fe806 	br	208dc <COE_AddObjectToDic+0x18>
   2093c:	2805883a 	mov	r2,r5
                if(pDicEntry->Index == pNewObjEntry->Index)
   20940:	1140020b 	ldhu	r5,8(r2)
   20944:	197fef1e 	bne	r3,r5,20904 <COE_AddObjectToDic+0x40>
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
   20948:	00800044 	movi	r2,1
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
}
   2094c:	f800283a 	ret

00020950 <COE_RemoveDicEntry>:

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20950:	d1613517 	ldw	r5,-31532(gp)

    while(pDicEntry != NULL)
    {
        if(pDicEntry->Index == index)
   20954:	213fffcc 	andi	r4,r4,65535
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20958:	2805883a 	mov	r2,r5
    while(pDicEntry != NULL)
   2095c:	1000011e 	bne	r2,zero,20964 <COE_RemoveDicEntry+0x14>
            return;
        }

        pDicEntry = pDicEntry->pNext;
    }
}
   20960:	f800283a 	ret
        if(pDicEntry->Index == index)
   20964:	1180020b 	ldhu	r6,8(r2)
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20968:	10c00117 	ldw	r3,4(r2)
        if(pDicEntry->Index == index)
   2096c:	31000b1e 	bne	r6,r4,2099c <COE_RemoveDicEntry+0x4c>
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
   20970:	11000017 	ldw	r4,0(r2)
            if(pPrevEntry != NULL)
   20974:	20000126 	beq	r4,zero,2097c <COE_RemoveDicEntry+0x2c>
                pPrevEntry->pNext = pNextEntry;
   20978:	20c00115 	stw	r3,4(r4)
            if(pNextEntry != NULL)
   2097c:	18000126 	beq	r3,zero,20984 <COE_RemoveDicEntry+0x34>
                pNextEntry->pPrev = pPrevEntry;
   20980:	19000015 	stw	r4,0(r3)
            pDicEntry->pPrev = NULL;
   20984:	10000015 	stw	zero,0(r2)
            pDicEntry->pNext = NULL;
   20988:	10000115 	stw	zero,4(r2)
            if(pDicEntry->Index == ObjDicList->Index)
   2098c:	2880020b 	ldhu	r2,8(r5)
   20990:	30bff31e 	bne	r6,r2,20960 <COE_RemoveDicEntry+0x10>
                ObjDicList = pNextEntry;
   20994:	d0e13515 	stw	r3,-31532(gp)
   20998:	f800283a 	ret
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   2099c:	1805883a 	mov	r2,r3
   209a0:	003fee06 	br	2095c <COE_RemoveDicEntry+0xc>

000209a4 <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
   209a4:	defffe04 	addi	sp,sp,-8
   209a8:	dc000015 	stw	r16,0(sp)
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
   209ac:	d4213517 	ldw	r16,-31532(gp)
{
   209b0:	dfc00115 	stw	ra,4(sp)
    UINT16 Index = 0;

    while(pObjEntry != NULL)
   209b4:	8000051e 	bne	r16,zero,209cc <COE_ClearObjDictionary+0x28>
        Index = pObjEntry->Index;
        pObjEntry = pObjEntry->pNext;

        COE_RemoveDicEntry(Index);
    }
    ObjDicList = NULL;
   209b8:	d0213515 	stw	zero,-31532(gp)
}
   209bc:	dfc00117 	ldw	ra,4(sp)
   209c0:	dc000017 	ldw	r16,0(sp)
   209c4:	dec00204 	addi	sp,sp,8
   209c8:	f800283a 	ret
        Index = pObjEntry->Index;
   209cc:	8100020b 	ldhu	r4,8(r16)
        pObjEntry = pObjEntry->pNext;
   209d0:	84000117 	ldw	r16,4(r16)
        COE_RemoveDicEntry(Index);
   209d4:	213fffcc 	andi	r4,r4,65535
   209d8:	00209500 	call	20950 <COE_RemoveDicEntry>
   209dc:	003ff506 	br	209b4 <COE_ClearObjDictionary+0x10>

000209e0 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
   209e0:	defffd04 	addi	sp,sp,-12
   209e4:	dc400115 	stw	r17,4(sp)
   209e8:	dc000015 	stw	r16,0(sp)
   209ec:	dfc00215 	stw	ra,8(sp)
   209f0:	2021883a 	mov	r16,r4
    UINT16 result = 0;
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;

    while(pEntry->Index != 0xFFFF)
   209f4:	047fffd4 	movui	r17,65535
   209f8:	8080020b 	ldhu	r2,8(r16)
   209fc:	1440061e 	bne	r2,r17,20a18 <AddObjectsToObjDictionary+0x38>
        }

        pEntry++;
    }

    return result;
   20a00:	0005883a 	mov	r2,zero

}
   20a04:	dfc00217 	ldw	ra,8(sp)
   20a08:	dc400117 	ldw	r17,4(sp)
   20a0c:	dc000017 	ldw	r16,0(sp)
   20a10:	dec00304 	addi	sp,sp,12
   20a14:	f800283a 	ret
        result = COE_AddObjectToDic(pEntry);
   20a18:	8009883a 	mov	r4,r16
   20a1c:	00208c40 	call	208c4 <COE_AddObjectToDic>
        if(result != 0)
   20a20:	10ffffcc 	andi	r3,r2,65535
   20a24:	183ff71e 	bne	r3,zero,20a04 <AddObjectsToObjDictionary+0x24>
        pEntry++;
   20a28:	84000a04 	addi	r16,r16,40
   20a2c:	003ff206 	br	209f8 <AddObjectsToObjDictionary+0x18>

00020a30 <COE_ObjDictionaryInit>:
    UINT16 result = 0;

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20a30:	010000b4 	movhi	r4,2
{
   20a34:	deffff04 	addi	sp,sp,-4
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20a38:	211ffb04 	addi	r4,r4,32748
{
   20a3c:	dfc00015 	stw	ra,0(sp)
    ObjDicList = NULL;
   20a40:	d0213515 	stw	zero,-31532(gp)
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20a44:	00209e00 	call	209e0 <AddObjectsToObjDictionary>

    if(result != 0)
   20a48:	10ffffcc 	andi	r3,r2,65535
   20a4c:	1800051e 	bne	r3,zero,20a64 <COE_ObjDictionaryInit+0x34>
        return result;
    }
    
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20a50:	010000f4 	movhi	r4,3
   20a54:	21207b04 	addi	r4,r4,-32276
    }



    return result;
}
   20a58:	dfc00017 	ldw	ra,0(sp)
   20a5c:	dec00104 	addi	sp,sp,4
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20a60:	00209e01 	jmpi	209e0 <AddObjectsToObjDictionary>
}
   20a64:	dfc00017 	ldw	ra,0(sp)
   20a68:	dec00104 	addi	sp,sp,4
   20a6c:	f800283a 	ret

00020a70 <COE_ObjInit>:
    sSyncManOutPar.subindex0         = 32;
   20a70:	01400804 	movi	r5,32
   20a74:	00c000f4 	movhi	r3,3
   20a78:	19633215 	stw	r5,-29496(r3)
    sSyncManOutPar.u32CycleTime     = 0;
   20a7c:	00c000f4 	movhi	r3,3
{
   20a80:	defffe04 	addi	sp,sp,-8
    sSyncManOutPar.u32CycleTime     = 0;
   20a84:	18233315 	stw	zero,-29492(r3)
    sSyncManOutPar.subindex0         = 32;
   20a88:	008000f4 	movhi	r2,3
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20a8c:	00c000b4 	movhi	r3,2
{
   20a90:	dfc00115 	stw	ra,4(sp)
    sSyncManOutPar.subindex0         = 32;
   20a94:	10a33204 	addi	r2,r2,-29496
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20a98:	011007c4 	movi	r4,16415
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20a9c:	18e1a804 	addi	r3,r3,-31072
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20aa0:	1100030d 	sth	r4,12(r2)
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20aa4:	10c00415 	stw	r3,16(r2)
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   20aa8:	008000f4 	movhi	r2,3
   20aac:	10233715 	stw	zero,-29476(r2)
    sSyncManOutPar.u16GetCycleTime = 0;
   20ab0:	008000f4 	movhi	r2,3
   20ab4:	1023390d 	sth	zero,-29468(r2)
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
   20ab8:	008000f4 	movhi	r2,3
   20abc:	10233a15 	stw	zero,-29464(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   20ac0:	008000f4 	movhi	r2,3
   20ac4:	10233c15 	stw	zero,-29456(r2)
    sSyncManOutPar.u8SyncError = 0;
   20ac8:	008000f4 	movhi	r2,3
   20acc:	10234205 	stb	zero,-29432(r2)
    sSyncManInPar.subindex0         = 32;
   20ad0:	008000f4 	movhi	r2,3
   20ad4:	10a32104 	addi	r2,r2,-29564
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
   20ad8:	1100030d 	sth	r4,12(r2)
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20adc:	10c00415 	stw	r3,16(r2)
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   20ae0:	008000f4 	movhi	r2,3
   20ae4:	10232615 	stw	zero,-29544(r2)
    sSyncManInPar.u16GetCycleTime = 0;
   20ae8:	008000f4 	movhi	r2,3
   20aec:	1023280d 	sth	zero,-29536(r2)
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20af0:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20af4:	018000f4 	movhi	r6,3
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20af8:	10232915 	stw	zero,-29532(r2)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20afc:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20b00:	31632115 	stw	r5,-29564(r6)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20b04:	10232b15 	stw	zero,-29524(r2)
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20b08:	014000f4 	movhi	r5,3
    sSyncManInPar.u8SyncError = 0;
   20b0c:	008000f4 	movhi	r2,3
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20b10:	28232215 	stw	zero,-29560(r5)
    sSyncManInPar.u8SyncError = 0;
   20b14:	10233105 	stb	zero,-29500(r2)
    bSyncSetByUser = FALSE;
   20b18:	d0216d85 	stb	zero,-31306(gp)
    UINT16 result = COE_ObjDictionaryInit();
   20b1c:	0020a300 	call	20a30 <COE_ObjDictionaryInit>
    if(result != 0)
   20b20:	10bfffcc 	andi	r2,r2,65535
   20b24:	10000126 	beq	r2,zero,20b2c <COE_ObjInit+0xbc>
        COE_ClearObjDictionary();
   20b28:	00209a40 	call	209a4 <COE_ClearObjDictionary>
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20b2c:	01800104 	movi	r6,4
   20b30:	01400204 	movi	r5,8
   20b34:	d809883a 	mov	r4,sp
    u8PendingSdo = 0;
   20b38:	d0217c05 	stb	zero,-31248(gp)
    bStoreCompleteAccess = FALSE;
   20b3c:	d0217bc5 	stb	zero,-31249(gp)
    u16StoreIndex   =   0;
   20b40:	d0217b0d 	sth	zero,-31252(gp)
    u8StoreSubindex = 0;
   20b44:	d0217b85 	stb	zero,-31250(gp)
    u32StoreDataSize = 0;
   20b48:	d0217a15 	stw	zero,-31256(gp)
    pStoreData = NULL;
   20b4c:	d0217915 	stw	zero,-31260(gp)
    pSdoPendFunc    = NULL;
   20b50:	d0217815 	stw	zero,-31264(gp)
    pSdoSegData = NULL;
   20b54:	d0217715 	stw	zero,-31268(gp)
        UINT32 EscFeature = 0;
   20b58:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20b5c:	00205e00 	call	205e0 <HW_EscRead>
        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
   20b60:	d8800017 	ldw	r2,0(sp)
   20b64:	1080020c 	andi	r2,r2,8
   20b68:	10000626 	beq	r2,zero,20b84 <COE_ObjInit+0x114>
            b32BitDc = FALSE;
   20b6c:	d0215b85 	stb	zero,-31378(gp)
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20b70:	0083e804 	movi	r2,4000
   20b74:	d0a13715 	stw	r2,-31524(gp)
}
   20b78:	dfc00117 	ldw	ra,4(sp)
   20b7c:	dec00204 	addi	sp,sp,8
   20b80:	f800283a 	ret
            b32BitDc = TRUE;
   20b84:	00800044 	movi	r2,1
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20b88:	01800104 	movi	r6,4
   20b8c:	01424404 	movi	r5,2320
   20b90:	d1213804 	addi	r4,gp,-31520
            b32BitDc = TRUE;
   20b94:	d0a15b85 	stb	r2,-31378(gp)
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20b98:	00205e00 	call	205e0 <HW_EscRead>
   20b9c:	003ff406 	br	20b70 <COE_ObjInit+0x100>

00020ba0 <COE_Main>:

void COE_Main(void)
{
     UINT8 abort = 0;
     
    if(pSdoPendFunc != NULL)
   20ba0:	d0a17817 	ldw	r2,-31264(gp)
   20ba4:	10003026 	beq	r2,zero,20c68 <COE_Main+0xc8>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20ba8:	d0e17bc3 	ldbu	r3,-31249(gp)
   20bac:	d1e17917 	ldw	r7,-31260(gp)
   20bb0:	d1a17a17 	ldw	r6,-31256(gp)
   20bb4:	d1617b83 	ldbu	r5,-31250(gp)
   20bb8:	d1217b0b 	ldhu	r4,-31252(gp)
{
   20bbc:	defffd04 	addi	sp,sp,-12
   20bc0:	dc000115 	stw	r16,4(sp)
   20bc4:	dfc00215 	stw	ra,8(sp)
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20bc8:	d8c00015 	stw	r3,0(sp)
   20bcc:	103ee83a 	callr	r2

        if(abort != ABORTIDX_WORKING)
   20bd0:	14003fcc 	andi	r16,r2,255
   20bd4:	80803fe0 	cmpeqi	r2,r16,255
   20bd8:	10000f1e 	bne	r2,zero,20c18 <COE_Main+0x78>
        {
            switch(u8PendingSdo)
   20bdc:	d0e17c03 	ldbu	r3,-31248(gp)
   20be0:	18803fcc 	andi	r2,r3,255
   20be4:	110000a0 	cmpeqi	r4,r2,2
   20be8:	2000161e 	bne	r4,zero,20c44 <COE_Main+0xa4>
   20bec:	110000e8 	cmpgeui	r4,r2,3
   20bf0:	20000d1e 	bne	r4,zero,20c28 <COE_Main+0x88>
   20bf4:	10800060 	cmpeqi	r2,r2,1
   20bf8:	1000161e 	bne	r2,zero,20c54 <COE_Main+0xb4>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
                    break;

            }

            u8PendingSdo = 0;
   20bfc:	d0217c05 	stb	zero,-31248(gp)
            u16StoreIndex = 0;
   20c00:	d0217b0d 	sth	zero,-31252(gp)
            u8StoreSubindex = 0;
   20c04:	d0217b85 	stb	zero,-31250(gp)
            u32StoreDataSize = 0;
   20c08:	d0217a15 	stw	zero,-31256(gp)
            pStoreData = NULL;
   20c0c:	d0217915 	stw	zero,-31260(gp)
            bStoreCompleteAccess = 0;
   20c10:	d0217bc5 	stb	zero,-31249(gp)
            pSdoPendFunc = NULL;
   20c14:	d0217815 	stw	zero,-31264(gp)
        }
    }
}
   20c18:	dfc00217 	ldw	ra,8(sp)
   20c1c:	dc000117 	ldw	r16,4(sp)
   20c20:	dec00304 	addi	sp,sp,12
   20c24:	f800283a 	ret
            switch(u8PendingSdo)
   20c28:	18ffff44 	addi	r3,r3,-3
   20c2c:	18c03fcc 	andi	r3,r3,255
   20c30:	18c000a8 	cmpgeui	r3,r3,2
   20c34:	183ff11e 	bne	r3,zero,20bfc <COE_Main+0x5c>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20c38:	d1a17917 	ldw	r6,-31260(gp)
   20c3c:	d1617a17 	ldw	r5,-31256(gp)
   20c40:	00000606 	br	20c5c <COE_Main+0xbc>
                    if(pSdoSegData)
   20c44:	d1217717 	ldw	r4,-31268(gp)
   20c48:	20000226 	beq	r4,zero,20c54 <COE_Main+0xb4>
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
   20c4c:	002705c0 	call	2705c <free>
                        pSdoSegData = NULL;
   20c50:	d0217715 	stw	zero,-31268(gp)
                    SDOS_SdoRes(abort, 0, NULL);
   20c54:	000d883a 	mov	r6,zero
   20c58:	000b883a 	mov	r5,zero
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20c5c:	8009883a 	mov	r4,r16
   20c60:	00265cc0 	call	265cc <SDOS_SdoRes>
                    break;
   20c64:	003fe506 	br	20bfc <COE_Main+0x5c>
   20c68:	f800283a 	ret

00020c6c <ECAT_CheckTimer>:

void ECAT_CheckTimer(void)
{

    /*decrement the state transition timeout counter*/
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20c6c:	d0a15983 	ldbu	r2,-31386(gp)
{
   20c70:	deffff04 	addi	sp,sp,-4
   20c74:	dfc00015 	stw	ra,0(sp)
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20c78:	10000726 	beq	r2,zero,20c98 <ECAT_CheckTimer+0x2c>
   20c7c:	d0a1620b 	ldhu	r2,-31352(gp)
   20c80:	10ffffcc 	andi	r3,r2,65535
   20c84:	18e0001c 	xori	r3,r3,32768
   20c88:	18e00004 	addi	r3,r3,-32768
   20c8c:	00c0020e 	bge	zero,r3,20c98 <ECAT_CheckTimer+0x2c>
    {
        EsmTimeoutCounter--;
   20c90:	10bfffc4 	addi	r2,r2,-1
   20c94:	d0a1620d 	sth	r2,-31352(gp)
    }



    DC_CheckWatchdog();
   20c98:	002358c0 	call	2358c <DC_CheckWatchdog>



/*ECATCHANGE_START(V5.13) */
    /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
   20c9c:	d0a15b83 	ldbu	r2,-31378(gp)
   20ca0:	10000426 	beq	r2,zero,20cb4 <ECAT_CheckTimer+0x48>
   20ca4:	d0e13917 	ldw	r3,-31516(gp)
   20ca8:	00bff8b4 	movhi	r2,65506
   20cac:	10bed004 	addi	r2,r2,-1216
   20cb0:	10c00f36 	bltu	r2,r3,20cf0 <ECAT_CheckTimer+0x84>
/*ECATCHANGE_END(V5.13) */
    {

        /* the timestamp is stored in ns */
        u64Timestamp = u64Timestamp + 1000000;
   20cb4:	d0a13917 	ldw	r2,-31516(gp)
   20cb8:	00c003f4 	movhi	r3,15
   20cbc:	d1213a17 	ldw	r4,-31512(gp)
   20cc0:	18d09004 	addi	r3,r3,16960
   20cc4:	10c7883a 	add	r3,r2,r3
   20cc8:	1885803a 	cmpltu	r2,r3,r2
   20ccc:	1105883a 	add	r2,r2,r4
   20cd0:	d0e13915 	stw	r3,-31516(gp)
   20cd4:	d0a13a15 	stw	r2,-31512(gp)
    {
        /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
    }

    u32CheckForDcOverrunCnt++;
   20cd8:	d0a13717 	ldw	r2,-31524(gp)
   20cdc:	10800044 	addi	r2,r2,1
   20ce0:	d0a13715 	stw	r2,-31524(gp)


}
   20ce4:	dfc00017 	ldw	ra,0(sp)
   20ce8:	dec00104 	addi	sp,sp,4
   20cec:	f800283a 	ret
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20cf0:	0083e804 	movi	r2,4000
   20cf4:	d0a13715 	stw	r2,-31524(gp)
   20cf8:	003ff706 	br	20cd8 <ECAT_CheckTimer+0x6c>

00020cfc <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
   20cfc:	defffd04 	addi	sp,sp,-12
   20d00:	dc000115 	stw	r16,4(sp)
   UINT32 u32CurValue = 0;
   UINT32 u32Delta = 0;

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20d04:	01800104 	movi	r6,4
{
   20d08:	2021883a 	mov	r16,r4
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20d0c:	01424404 	movi	r5,2320
   20d10:	d809883a 	mov	r4,sp
{
   20d14:	dfc00215 	stw	ra,8(sp)
   UINT32 u32CurValue = 0;
   20d18:	d8000015 	stw	zero,0(sp)
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20d1c:	00206580 	call	20658 <HW_EscReadIsr>

   if (u32CurValue > 0)
   20d20:	d8800017 	ldw	r2,0(sp)
   20d24:	10000626 	beq	r2,zero,20d40 <GetSystemTimeDelay+0x44>
   {
      if (u32StartTime <= u32CurValue)
   20d28:	14000936 	bltu	r2,r16,20d50 <GetSystemTimeDelay+0x54>
      {
         u32Delta = u32CurValue - u32StartTime;
   20d2c:	1405c83a 	sub	r2,r2,r16
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
      }
   }// current value successfully read out

   if (u32StartTime > 0)
   20d30:	80000326 	beq	r16,zero,20d40 <GetSystemTimeDelay+0x44>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
   20d34:	d0e13e17 	ldw	r3,-31496(gp)
   20d38:	1880082e 	bgeu	r3,r2,20d5c <GetSystemTimeDelay+0x60>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
   20d3c:	10c5c83a 	sub	r2,r2,r3
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
       }
   }
   return u32Delta;
}
   20d40:	dfc00217 	ldw	ra,8(sp)
   20d44:	dc000117 	ldw	r16,4(sp)
   20d48:	dec00304 	addi	sp,sp,12
   20d4c:	f800283a 	ret
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
   20d50:	10bfffc4 	addi	r2,r2,-1
   20d54:	1405c83a 	sub	r2,r2,r16
   if (u32StartTime > 0)
   20d58:	003ff606 	br	20d34 <GetSystemTimeDelay+0x38>
   UINT32 u32Delta = 0;
   20d5c:	0005883a 	mov	r2,zero
   return u32Delta;
   20d60:	003ff706 	br	20d40 <GetSystemTimeDelay+0x44>

00020d64 <PDO_InputMapping>:
{
   20d64:	defffc04 	addi	sp,sp,-16
   20d68:	dc800215 	stw	r18,8(sp)
   20d6c:	dc000015 	stw	r16,0(sp)
    if (MEASUREMENT_ACTIVE)
   20d70:	048000f4 	movhi	r18,3
   20d74:	040000f4 	movhi	r16,3
{
   20d78:	dfc00315 	stw	ra,12(sp)
   20d7c:	dc400115 	stw	r17,4(sp)
    if (MEASUREMENT_ACTIVE)
   20d80:	94a33204 	addi	r18,r18,-29496
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
   20d84:	00205b80 	call	205b8 <HW_GetALEventRegister_Isr>
    if (MEASUREMENT_ACTIVE)
   20d88:	84232104 	addi	r16,r16,-29564
   20d8c:	9080070b 	ldhu	r2,28(r18)
   20d90:	80c0070b 	ldhu	r3,28(r16)
   20d94:	10c4b03a 	or	r2,r2,r3
   20d98:	1080004c 	andi	r2,r2,1
   20d9c:	10001b26 	beq	r2,zero,20e0c <PDO_InputMapping+0xa8>
        u32TimeValue = GetSystemTimeDelay(0);
   20da0:	0009883a 	mov	r4,zero
   20da4:	0020cfc0 	call	20cfc <GetSystemTimeDelay>
   20da8:	1023883a 	mov	r17,r2
    APPL_InputMapping((UINT16*)aPdInputData);
   20dac:	010000f4 	movhi	r4,3
   20db0:	21227a04 	addi	r4,r4,-30232
   20db4:	00202780 	call	20278 <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
   20db8:	d1a1588b 	ldhu	r6,-31390(gp)
   20dbc:	d161550b 	ldhu	r5,-31404(gp)
   20dc0:	010000f4 	movhi	r4,3
   20dc4:	21227a04 	addi	r4,r4,-30232
   20dc8:	00207280 	call	20728 <HW_EscWriteIsr>
    if (MEASUREMENT_ACTIVE)
   20dcc:	90c0070b 	ldhu	r3,28(r18)
   20dd0:	8080070b 	ldhu	r2,28(r16)
   20dd4:	1886b03a 	or	r3,r3,r2
   20dd8:	18c0004c 	andi	r3,r3,1
   20ddc:	18000526 	beq	r3,zero,20df4 <PDO_InputMapping+0x90>
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20de0:	8809883a 	mov	r4,r17
   20de4:	0020cfc0 	call	20cfc <GetSystemTimeDelay>
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
   20de8:	80c00517 	ldw	r3,20(r16)
   20dec:	1880012e 	bgeu	r3,r2,20df4 <PDO_InputMapping+0x90>
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
   20df0:	80800515 	stw	r2,20(r16)
}
   20df4:	dfc00317 	ldw	ra,12(sp)
   20df8:	dc800217 	ldw	r18,8(sp)
   20dfc:	dc400117 	ldw	r17,4(sp)
   20e00:	dc000017 	ldw	r16,0(sp)
   20e04:	dec00404 	addi	sp,sp,16
   20e08:	f800283a 	ret
    UINT32 u32TimeValue = 0;
   20e0c:	0023883a 	mov	r17,zero
   20e10:	003fe606 	br	20dac <PDO_InputMapping+0x48>

00020e14 <HandleCycleTimeMeasurement>:
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
   20e14:	d0a16283 	ldbu	r2,-31350(gp)
   20e18:	1000181e 	bne	r2,zero,20e7c <HandleCycleTimeMeasurement+0x68>
        if (u32CycleTimeStartValue > 0)
   20e1c:	d1214017 	ldw	r4,-31488(gp)
{
   20e20:	deffff04 	addi	sp,sp,-4
   20e24:	dfc00015 	stw	ra,0(sp)
        if (u32CycleTimeStartValue > 0)
   20e28:	20000e26 	beq	r4,zero,20e64 <HandleCycleTimeMeasurement+0x50>
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20e2c:	0020cfc0 	call	20cfc <GetSystemTimeDelay>
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20e30:	00c000f4 	movhi	r3,3
   20e34:	18e33204 	addi	r3,r3,-29496
   20e38:	19000117 	ldw	r4,4(r3)
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20e3c:	d0a14015 	stw	r2,-31488(gp)
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20e40:	20000126 	beq	r4,zero,20e48 <HandleCycleTimeMeasurement+0x34>
   20e44:	1100012e 	bgeu	r2,r4,20e4c <HandleCycleTimeMeasurement+0x38>
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
   20e48:	18800115 	stw	r2,4(r3)
            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
   20e4c:	00c000f4 	movhi	r3,3
   20e50:	18e32104 	addi	r3,r3,-29564
   20e54:	19000117 	ldw	r4,4(r3)
   20e58:	20000126 	beq	r4,zero,20e60 <HandleCycleTimeMeasurement+0x4c>
   20e5c:	1100012e 	bgeu	r2,r4,20e64 <HandleCycleTimeMeasurement+0x50>
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
   20e60:	18800115 	stw	r2,4(r3)
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
   20e64:	0009883a 	mov	r4,zero
   20e68:	0020cfc0 	call	20cfc <GetSystemTimeDelay>
   20e6c:	d0a14015 	stw	r2,-31488(gp)
}
   20e70:	dfc00017 	ldw	ra,0(sp)
   20e74:	dec00104 	addi	sp,sp,4
   20e78:	f800283a 	ret
   20e7c:	f800283a 	ret

00020e80 <PDO_OutputMapping>:
{
   20e80:	defffc04 	addi	sp,sp,-16
   20e84:	dc800215 	stw	r18,8(sp)
   20e88:	dc000015 	stw	r16,0(sp)
   if (MEASUREMENT_ACTIVE)
   20e8c:	048000f4 	movhi	r18,3
   20e90:	040000f4 	movhi	r16,3
   20e94:	84233204 	addi	r16,r16,-29496
   20e98:	94a32104 	addi	r18,r18,-29564
   20e9c:	8080070b 	ldhu	r2,28(r16)
   20ea0:	90c0070b 	ldhu	r3,28(r18)
{
   20ea4:	dfc00315 	stw	ra,12(sp)
   20ea8:	dc400115 	stw	r17,4(sp)
   if (MEASUREMENT_ACTIVE)
   20eac:	10c4b03a 	or	r2,r2,r3
   20eb0:	1080004c 	andi	r2,r2,1
   20eb4:	10002026 	beq	r2,zero,20f38 <PDO_OutputMapping+0xb8>
      u32TimeValue = GetSystemTimeDelay(0);
   20eb8:	0009883a 	mov	r4,zero
   20ebc:	0020cfc0 	call	20cfc <GetSystemTimeDelay>
   20ec0:	1023883a 	mov	r17,r2
      u32MinCycleTimeStartValue = u32TimeValue;
   20ec4:	d0a13f15 	stw	r2,-31492(gp)
      bMinCycleTimeMeasurementStarted = TRUE;
   20ec8:	00800044 	movi	r2,1
   20ecc:	d0a13d05 	stb	r2,-31500(gp)
      u32MinCycleTimeValue = 0;
   20ed0:	d0213c15 	stw	zero,-31504(gp)
      HandleCycleTimeMeasurement();
   20ed4:	0020e140 	call	20e14 <HandleCycleTimeMeasurement>
    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
   20ed8:	d1a1580b 	ldhu	r6,-31392(gp)
   20edc:	d161558b 	ldhu	r5,-31402(gp)
   20ee0:	010000f4 	movhi	r4,3
   20ee4:	21230304 	addi	r4,r4,-29684
   20ee8:	00206580 	call	20658 <HW_EscReadIsr>
    APPL_OutputMapping((UINT16*) aPdOutputData);
   20eec:	010000f4 	movhi	r4,3
   20ef0:	21230304 	addi	r4,r4,-29684
   20ef4:	00202c40 	call	202c4 <APPL_OutputMapping>
    if (MEASUREMENT_ACTIVE)
   20ef8:	8080070b 	ldhu	r2,28(r16)
   20efc:	90c0070b 	ldhu	r3,28(r18)
   20f00:	10c4b03a 	or	r2,r2,r3
   20f04:	1080004c 	andi	r2,r2,1
   20f08:	10000526 	beq	r2,zero,20f20 <PDO_OutputMapping+0xa0>
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20f0c:	8809883a 	mov	r4,r17
   20f10:	0020cfc0 	call	20cfc <GetSystemTimeDelay>
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
   20f14:	80c00517 	ldw	r3,20(r16)
   20f18:	1880012e 	bgeu	r3,r2,20f20 <PDO_OutputMapping+0xa0>
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
   20f1c:	80800515 	stw	r2,20(r16)
}
   20f20:	dfc00317 	ldw	ra,12(sp)
   20f24:	dc800217 	ldw	r18,8(sp)
   20f28:	dc400117 	ldw	r17,4(sp)
   20f2c:	dc000017 	ldw	r16,0(sp)
   20f30:	dec00404 	addi	sp,sp,16
   20f34:	f800283a 	ret
   UINT32 u32TimeValue = 0;
   20f38:	0023883a 	mov	r17,zero
   20f3c:	003fe606 	br	20ed8 <PDO_OutputMapping+0x58>

00020f40 <Sync1_Isr>:
void Sync1_Isr(void)
{
    Sync1WdCounter = 0;

    /*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   20f40:	d0a16343 	ldbu	r2,-31347(gp)
    Sync1WdCounter = 0;
   20f44:	d0215d8d 	sth	zero,-31370(gp)
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   20f48:	10800058 	cmpnei	r2,r2,1
   20f4c:	10000f1e 	bne	r2,zero,20f8c <Sync1_Isr+0x4c>
   20f50:	d0a1588b 	ldhu	r2,-31390(gp)
   20f54:	10000d26 	beq	r2,zero,20f8c <Sync1_Isr+0x4c>
/*ECATCHANGE_END(V5.13) ECAT 5*/
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
   20f58:	008000f4 	movhi	r2,3
   20f5c:	10a3218b 	ldhu	r2,-29562(r2)
   20f60:	108000d8 	cmpnei	r2,r2,3
   20f64:	1000091e 	bne	r2,zero,20f8c <Sync1_Isr+0x4c>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
   20f68:	d0a15c8b 	ldhu	r2,-31374(gp)
   20f6c:	1000071e 	bne	r2,zero,20f8c <Sync1_Isr+0x4c>
{
   20f70:	deffff04 	addi	sp,sp,-4
   20f74:	dfc00015 	stw	ra,0(sp)
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
   20f78:	0020d640 	call	20d64 <PDO_InputMapping>
        }

        /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
        LatchInputSync0Counter = 0;
   20f7c:	d0215c0d 	sth	zero,-31376(gp)
}
   20f80:	dfc00017 	ldw	ra,0(sp)
   20f84:	dec00104 	addi	sp,sp,4
   20f88:	f800283a 	ret
        LatchInputSync0Counter = 0;
   20f8c:	d0215c0d 	sth	zero,-31376(gp)
   20f90:	f800283a 	ret

00020f94 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
   20f94:	defffc04 	addi	sp,sp,-16
   20f98:	dfc00315 	stw	ra,12(sp)
   20f9c:	dc000215 	stw	r16,8(sp)

/* Reset application function pointer*/



    pAPPL_FoeRead = NULL;
   20fa0:	d0214815 	stw	zero,-31456(gp)
    pAPPL_FoeReadData = NULL;
   20fa4:	d0214715 	stw	zero,-31460(gp)
    pAPPL_FoeError = NULL;
   20fa8:	d0214615 	stw	zero,-31464(gp)
    pAPPL_FoeWrite = NULL;
   20fac:	d0214515 	stw	zero,-31468(gp)
    pAPPL_FoeWriteData = NULL;
   20fb0:	d0214415 	stw	zero,-31472(gp)

    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
   20fb4:	d0214315 	stw	zero,-31476(gp)
    pAPPL_CoeWriteInd = NULL;
   20fb8:	d0214215 	stw	zero,-31480(gp)
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
   20fbc:	d0214115 	stw	zero,-31484(gp)

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
   20fc0:	00239080 	call	23908 <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
   20fc4:	0020a700 	call	20a70 <COE_ObjInit>

    /*Reset PDI Access*/
    {
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values

    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20fc8:	01800084 	movi	r6,2
   20fcc:	01414004 	movi	r5,1280
   20fd0:	d9000104 	addi	r4,sp,4
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values
   20fd4:	d800010d 	sth	zero,4(sp)
    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20fd8:	00205e00 	call	205e0 <HW_EscRead>
    eepromConfigControl = SWAPWORD(eepromConfigControl);
   20fdc:	d880010b 	ldhu	r2,4(sp)

    if((eepromConfigControl & ESC_EEPROM_ASSIGN_TO_PDI_MASK) > 0)
   20fe0:	10c0004c 	andi	r3,r2,1
   20fe4:	18000626 	beq	r3,zero,21000 <MainInit+0x6c>
    {
        /*Clear access register(0x0501.1)*/
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   20fe8:	10bfbfcc 	andi	r2,r2,65279

        eepromConfigControl = SWAPWORD(eepromConfigControl);
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20fec:	01800084 	movi	r6,2
   20ff0:	01414004 	movi	r5,1280
   20ff4:	d9000104 	addi	r4,sp,4
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   20ff8:	d880010d 	sth	r2,4(sp)
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20ffc:	00206640 	call	20664 <HW_EscWrite>
    }
    }
    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
   21000:	00800044 	movi	r2,1
   21004:	d0a13b05 	stb	r2,-31508(gp)


    bMinCycleTimeMeasurementStarted = FALSE;
   21008:	d0213d05 	stb	zero,-31500(gp)
    u32CycleTimeStartValue = 0;
   2100c:	d0214015 	stw	zero,-31488(gp)
    u32MinCycleTimeStartValue = 0;
   21010:	d0213f15 	stw	zero,-31492(gp)

    u32SystemTimeReadFailure = 0;
   21014:	d0213e15 	stw	zero,-31496(gp)

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
   21018:	d8000015 	stw	zero,0(sp)
       UINT32 u32Cnt = 0;
       UINT32 u32Delta = 0;
   2101c:	d8000115 	stw	zero,4(sp)
   21020:	0400fa04 	movi	r16,1000

       while (u32Cnt < 1000)
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
   21024:	01800104 	movi	r6,4
   21028:	01424404 	movi	r5,2320
   2102c:	d809883a 	mov	r4,sp
   21030:	00206580 	call	20658 <HW_EscReadIsr>
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
   21034:	01800104 	movi	r6,4
   21038:	01424404 	movi	r5,2320
   2103c:	d9000104 	addi	r4,sp,4
   21040:	00206580 	call	20658 <HW_EscReadIsr>

            if (u32TimeValue <= u32Delta)
   21044:	d8800017 	ldw	r2,0(sp)
   21048:	d8c00117 	ldw	r3,4(sp)
   2104c:	18800636 	bltu	r3,r2,21068 <MainInit+0xd4>
                    u32Delta = u32Delta - u32TimeValue;
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   21050:	1885c83a 	sub	r2,r3,r2
            }


            if (u32SystemTimeReadFailure == 0)
   21054:	d0e13e17 	ldw	r3,-31496(gp)
                    u32Delta = u32Delta - u32TimeValue;
   21058:	d8800115 	stw	r2,4(sp)
            if (u32SystemTimeReadFailure == 0)
   2105c:	1800041e 	bne	r3,zero,21070 <MainInit+0xdc>
            {
                u32SystemTimeReadFailure = u32Delta;
            }
            else if (u32SystemTimeReadFailure > u32Delta)
            {
                u32SystemTimeReadFailure = u32Delta;
   21060:	d0a13e15 	stw	r2,-31496(gp)
   21064:	00000306 	br	21074 <MainInit+0xe0>
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   21068:	18ffffc4 	addi	r3,r3,-1
   2106c:	003ff806 	br	21050 <MainInit+0xbc>
            else if (u32SystemTimeReadFailure > u32Delta)
   21070:	10fffb36 	bltu	r2,r3,21060 <MainInit+0xcc>
       while (u32Cnt < 1000)
   21074:	843fffc4 	addi	r16,r16,-1
   21078:	803fea1e 	bne	r16,zero,21024 <MainInit+0x90>



/*Application Init need to be called from the application layer*/
     return Error;
}
   2107c:	0005883a 	mov	r2,zero
   21080:	dfc00317 	ldw	ra,12(sp)
   21084:	dc000217 	ldw	r16,8(sp)
   21088:	dec00404 	addi	sp,sp,16
   2108c:	f800283a 	ret

00021090 <ECAT_Application>:
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
   21090:	008000f4 	movhi	r2,3
   21094:	00c000f4 	movhi	r3,3
   21098:	10a3390b 	ldhu	r2,-29468(r2)
   2109c:	18e3280b 	ldhu	r3,-29536(r3)
   210a0:	10c4b03a 	or	r2,r2,r3
   210a4:	1080004c 	andi	r2,r2,1
   210a8:	10000726 	beq	r2,zero,210c8 <ECAT_Application+0x38>
    {
        if (nPdOutputSize == 0)
   210ac:	d0a1580b 	ldhu	r2,-31392(gp)
   210b0:	1000051e 	bne	r2,zero,210c8 <ECAT_Application+0x38>
{
   210b4:	deffff04 	addi	sp,sp,-4
   210b8:	dfc00015 	stw	ra,0(sp)
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
   210bc:	0020e140 	call	20e14 <HandleCycleTimeMeasurement>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
   210c0:	dfc00017 	ldw	ra,0(sp)
   210c4:	dec00104 	addi	sp,sp,4
    APPL_Application();
   210c8:	00203101 	jmpi	20310 <APPL_Application>

000210cc <Sync0_Isr>:
    if(bDcSyncActive)
   210cc:	d0a16283 	ldbu	r2,-31350(gp)
     Sync0WdCounter = 0;
   210d0:	d0215e8d 	sth	zero,-31366(gp)
    if(bDcSyncActive)
   210d4:	10000d26 	beq	r2,zero,2110c <Sync0_Isr+0x40>
{
   210d8:	defffe04 	addi	sp,sp,-8
   210dc:	dc000015 	stw	r16,0(sp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   210e0:	d4216343 	ldbu	r16,-31347(gp)
{
   210e4:	dfc00115 	stw	ra,4(sp)
   210e8:	d0a1608b 	ldhu	r2,-31358(gp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   210ec:	80c03fcc 	andi	r3,r16,255
   210f0:	18c00060 	cmpeqi	r3,r3,1
   210f4:	1800061e 	bne	r3,zero,21110 <Sync0_Isr+0x44>
        if(u16SmSync0Value > 0)
   210f8:	1000181e 	bne	r2,zero,2115c <Sync0_Isr+0x90>
        ECAT_Application();
   210fc:	00210900 	call	21090 <ECAT_Application>
}
   21100:	dfc00117 	ldw	ra,4(sp)
   21104:	dc000017 	ldw	r16,0(sp)
   21108:	dec00204 	addi	sp,sp,8
    COE_UpdateSyncErrorStatus();
   2110c:	00208681 	jmpi	20868 <COE_UpdateSyncErrorStatus>
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   21110:	d1215c8b 	ldhu	r4,-31374(gp)
   21114:	203ff826 	beq	r4,zero,210f8 <Sync0_Isr+0x2c>
   21118:	d0e1588b 	ldhu	r3,-31390(gp)
   2111c:	183ff626 	beq	r3,zero,210f8 <Sync0_Isr+0x2c>
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
   21120:	d0e15c0b 	ldhu	r3,-31376(gp)
   21124:	197fffcc 	andi	r5,r3,65535
   21128:	2900022e 	bgeu	r5,r4,21134 <Sync0_Isr+0x68>
                LatchInputSync0Counter++;
   2112c:	18c00044 	addi	r3,r3,1
   21130:	d0e15c0d 	sth	r3,-31376(gp)
            if (LatchInputSync0Value == LatchInputSync0Counter)
   21134:	d0e15c0b 	ldhu	r3,-31376(gp)
   21138:	20ffef1e 	bne	r4,r3,210f8 <Sync0_Isr+0x2c>
        if(u16SmSync0Value > 0)
   2113c:	1000081e 	bne	r2,zero,21160 <Sync0_Isr+0x94>
        ECAT_Application();
   21140:	00210900 	call	21090 <ECAT_Application>
            PDO_InputMapping();
   21144:	0020d640 	call	20d64 <PDO_InputMapping>
            if(LatchInputSync0Value == 1)
   21148:	d0a15c8b 	ldhu	r2,-31374(gp)
   2114c:	10800058 	cmpnei	r2,r2,1
   21150:	103feb1e 	bne	r2,zero,21100 <Sync0_Isr+0x34>
                LatchInputSync0Counter = 0;
   21154:	d0215c0d 	sth	zero,-31376(gp)
   21158:	003fe906 	br	21100 <Sync0_Isr+0x34>
        BOOL bCallInputMapping = FALSE;
   2115c:	0021883a 	mov	r16,zero
           if (u16SmSync0Counter > u16SmSync0Value)
   21160:	d0e1610b 	ldhu	r3,-31356(gp)
   21164:	d121580b 	ldhu	r4,-31392(gp)
   21168:	197fffcc 	andi	r5,r3,65535
   2116c:	11400a36 	bltu	r2,r5,21198 <Sync0_Isr+0xcc>
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   21170:	20002b1e 	bne	r4,zero,21220 <Sync0_Isr+0x154>
   21174:	d0a1588b 	ldhu	r2,-31390(gp)
   21178:	10002926 	beq	r2,zero,21220 <Sync0_Isr+0x154>
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
   2117c:	00205b80 	call	205b8 <HW_GetALEventRegister_Isr>
              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
   21180:	1082000c 	andi	r2,r2,2048
   21184:	10001f26 	beq	r2,zero,21204 <Sync0_Isr+0x138>
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   21188:	008000f4 	movhi	r2,3
                 u16SmSync0Counter = 0;
   2118c:	d021610d 	sth	zero,-31356(gp)
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   21190:	10232b0d 	sth	zero,-29524(r2)
   21194:	00001606 	br	211f0 <Sync0_Isr+0x124>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   21198:	20000c1e 	bne	r4,zero,211cc <Sync0_Isr+0x100>
               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   2119c:	d0a1588b 	ldhu	r2,-31390(gp)
   211a0:	10001326 	beq	r2,zero,211f0 <Sync0_Isr+0x124>
   211a4:	008000f4 	movhi	r2,3
   211a8:	10a32104 	addi	r2,r2,-29564
   211ac:	10c00a0b 	ldhu	r3,40(r2)
   211b0:	014000f4 	movhi	r5,3
   211b4:	2960db0b 	ldhu	r5,-31892(r5)
   211b8:	193fffcc 	andi	r4,r3,65535
   211bc:	293fef36 	bltu	r5,r4,2117c <Sync0_Isr+0xb0>
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
   211c0:	18c000c4 	addi	r3,r3,3
   211c4:	10c00a0d 	sth	r3,40(r2)
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   211c8:	003fec06 	br	2117c <Sync0_Isr+0xb0>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   211cc:	008000f4 	movhi	r2,3
   211d0:	10a33204 	addi	r2,r2,-29496
   211d4:	010000f4 	movhi	r4,3
   211d8:	10c00a0b 	ldhu	r3,40(r2)
   211dc:	2160db0b 	ldhu	r5,-31892(r4)
   211e0:	193fffcc 	andi	r4,r3,65535
   211e4:	29000236 	bltu	r5,r4,211f0 <Sync0_Isr+0x124>
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
   211e8:	18c000c4 	addi	r3,r3,3
   211ec:	10c00a0d 	sth	r3,40(r2)
        if (bCallInputMapping == TRUE)
   211f0:	84003fcc 	andi	r16,r16,255
   211f4:	84000058 	cmpnei	r16,r16,1
        ECAT_Application();
   211f8:	00210900 	call	21090 <ECAT_Application>
        if (bCallInputMapping == TRUE)
   211fc:	803fd126 	beq	r16,zero,21144 <Sync0_Isr+0x78>
   21200:	003fbf06 	br	21100 <Sync0_Isr+0x34>
                if (u16SmSync0Counter <= u16SmSync0Value)
   21204:	d0a1610b 	ldhu	r2,-31356(gp)
   21208:	d121608b 	ldhu	r4,-31358(gp)
   2120c:	10ffffcc 	andi	r3,r2,65535
   21210:	20fff736 	bltu	r4,r3,211f0 <Sync0_Isr+0x124>
                    u16SmSync0Counter++;
   21214:	10800044 	addi	r2,r2,1
   21218:	d0a1610d 	sth	r2,-31356(gp)
   2121c:	003ff406 	br	211f0 <Sync0_Isr+0x124>
               u16SmSync0Counter++;
   21220:	18c00044 	addi	r3,r3,1
   21224:	d0e1610d 	sth	r3,-31356(gp)
   21228:	003ff106 	br	211f0 <Sync0_Isr+0x124>

0002122c <PDI_Isr>:
{
   2122c:	defffb04 	addi	sp,sp,-20
   21230:	dc000115 	stw	r16,4(sp)
   21234:	dfc00415 	stw	ra,16(sp)
   21238:	dc800315 	stw	r18,12(sp)
   2123c:	dc400215 	stw	r17,8(sp)
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
   21240:	00205b80 	call	205b8 <HW_GetALEventRegister_Isr>
   21244:	1021883a 	mov	r16,r2
    if (ALEvent & SYNC1_EVENT)
   21248:	8080020c 	andi	r2,r16,8
   2124c:	10000b1e 	bne	r2,zero,2127c <PDI_Isr+0x50>
    if(bEscIntEnabled)
   21250:	d0a15b43 	ldbu	r2,-31379(gp)
   21254:	10000f1e 	bne	r2,zero,21294 <PDI_Isr+0x68>
    if (ALEvent & SYNC0_EVENT)
   21258:	8400010c 	andi	r16,r16,4
   2125c:	80004d26 	beq	r16,zero,21394 <PDI_Isr+0x168>
        Sync0_Isr();
   21260:	00210cc0 	call	210cc <Sync0_Isr>
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   21264:	01800104 	movi	r6,4
   21268:	01426304 	movi	r5,2444
   2126c:	d809883a 	mov	r4,sp
        volatile UINT32 SyncState = 0;
   21270:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   21274:	00205e00 	call	205e0 <HW_EscRead>
   21278:	00004606 	br	21394 <PDI_Isr+0x168>
        Sync1_Isr();
   2127c:	0020f400 	call	20f40 <Sync1_Isr>
    if(bEscIntEnabled)
   21280:	d0a15b43 	ldbu	r2,-31379(gp)
   21284:	10004a1e 	bne	r2,zero,213b0 <PDI_Isr+0x184>
    if (ALEvent & SYNC0_EVENT)
   21288:	8400010c 	andi	r16,r16,4
   2128c:	803ff526 	beq	r16,zero,21264 <PDI_Isr+0x38>
   21290:	003ff306 	br	21260 <PDI_Isr+0x34>
    BOOL SyncAcknowledgePending = FALSE;
   21294:	0025883a 	mov	r18,zero
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21298:	044000f4 	movhi	r17,3
   2129c:	8401000c 	andi	r16,r16,1024
   212a0:	8c633204 	addi	r17,r17,-29496
   212a4:	80001226 	beq	r16,zero,212f0 <PDI_Isr+0xc4>
            if(bDcRunning && bDcSyncActive)
   212a8:	d0a16183 	ldbu	r2,-31354(gp)
   212ac:	10000326 	beq	r2,zero,212bc <PDI_Isr+0x90>
   212b0:	d0a16283 	ldbu	r2,-31350(gp)
   212b4:	10000126 	beq	r2,zero,212bc <PDI_Isr+0x90>
                u16SmSync0Counter = 0;
   212b8:	d021610d 	sth	zero,-31356(gp)
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
   212bc:	88800a0b 	ldhu	r2,40(r17)
   212c0:	10ffffcc 	andi	r3,r2,65535
   212c4:	18000226 	beq	r3,zero,212d0 <PDI_Isr+0xa4>
                sSyncManOutPar.u16SmEventMissedCounter--;
   212c8:	10bfffc4 	addi	r2,r2,-1
   212cc:	88800a0d 	sth	r2,40(r17)
            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
   212d0:	88c00a0b 	ldhu	r3,40(r17)
   212d4:	008000f4 	movhi	r2,3
   212d8:	10e32b0d 	sth	r3,-29524(r2)
        bEcatFirstOutputsReceived = TRUE;
   212dc:	00800044 	movi	r2,1
   212e0:	d0a16305 	stb	r2,-31348(gp)
        if ( bEcatOutputUpdateRunning )
   212e4:	d0a16383 	ldbu	r2,-31346(gp)
   212e8:	10003326 	beq	r2,zero,213b8 <PDI_Isr+0x18c>
            PDO_OutputMapping();
   212ec:	0020e800 	call	20e80 <PDO_OutputMapping>
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
   212f0:	8880008b 	ldhu	r2,2(r17)
   212f4:	10800058 	cmpnei	r2,r2,1
   212f8:	1000011e 	bne	r2,zero,21300 <PDI_Isr+0xd4>
            ECAT_Application();
   212fc:	00210900 	call	21090 <ECAT_Application>
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21300:	d0a16343 	ldbu	r2,-31347(gp)
   21304:	10800058 	cmpnei	r2,r2,1
   21308:	1000091e 	bne	r2,zero,21330 <PDI_Isr+0x104>
   2130c:	d0a1588b 	ldhu	r2,-31390(gp)
   21310:	10000726 	beq	r2,zero,21330 <PDI_Isr+0x104>
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
   21314:	008000f4 	movhi	r2,3
   21318:	10a3218b 	ldhu	r2,-29562(r2)
   2131c:	10c00060 	cmpeqi	r3,r2,1
   21320:	1800021e 	bne	r3,zero,2132c <PDI_Isr+0x100>
   21324:	10800898 	cmpnei	r2,r2,34
   21328:	1000011e 	bne	r2,zero,21330 <PDI_Isr+0x104>
        PDO_InputMapping();
   2132c:	0020d640 	call	20d64 <PDO_InputMapping>
    ALEvent = HW_GetALEventRegister_Isr();
   21330:	00205b80 	call	205b8 <HW_GetALEventRegister_Isr>
   21334:	1021883a 	mov	r16,r2
    if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21338:	8081000c 	andi	r2,r16,1024
   2133c:	10001126 	beq	r2,zero,21384 <PDI_Isr+0x158>
        sSyncManOutPar.u16CycleExceededCounter++;
   21340:	88800a8b 	ldhu	r2,42(r17)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21344:	d161558b 	ldhu	r5,-31402(gp)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21348:	00c000f4 	movhi	r3,3
        sSyncManOutPar.u16CycleExceededCounter++;
   2134c:	10800044 	addi	r2,r2,1
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21350:	01800044 	movi	r6,1
   21354:	d12153c4 	addi	r4,gp,-31409
        sSyncManOutPar.u16CycleExceededCounter++;
   21358:	88800a8d 	sth	r2,42(r17)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   2135c:	18a32b8d 	sth	r2,-29522(r3)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21360:	00206580 	call	20658 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   21364:	d161558b 	ldhu	r5,-31402(gp)
   21368:	d0a1580b 	ldhu	r2,-31392(gp)
   2136c:	01800044 	movi	r6,1
   21370:	d12153c4 	addi	r4,gp,-31409
   21374:	288b883a 	add	r5,r5,r2
   21378:	297fffc4 	addi	r5,r5,-1
   2137c:	297fffcc 	andi	r5,r5,65535
   21380:	00206580 	call	20658 <HW_EscReadIsr>
    if (ALEvent & SYNC0_EVENT)
   21384:	8400010c 	andi	r16,r16,4
   21388:	803fb51e 	bne	r16,zero,21260 <PDI_Isr+0x34>
    if (SyncAcknowledgePending)
   2138c:	94803fcc 	andi	r18,r18,255
   21390:	903fb41e 	bne	r18,zero,21264 <PDI_Isr+0x38>
    COE_UpdateSyncErrorStatus();
   21394:	00208680 	call	20868 <COE_UpdateSyncErrorStatus>
}
   21398:	dfc00417 	ldw	ra,16(sp)
   2139c:	dc800317 	ldw	r18,12(sp)
   213a0:	dc400217 	ldw	r17,8(sp)
   213a4:	dc000117 	ldw	r16,4(sp)
   213a8:	dec00504 	addi	sp,sp,20
   213ac:	f800283a 	ret
        SyncAcknowledgePending = TRUE;
   213b0:	04800044 	movi	r18,1
   213b4:	003fb806 	br	21298 <PDI_Isr+0x6c>
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   213b8:	d161558b 	ldhu	r5,-31402(gp)
   213bc:	01800044 	movi	r6,1
   213c0:	d12153c4 	addi	r4,gp,-31409
   213c4:	00206580 	call	20658 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   213c8:	d0a1580b 	ldhu	r2,-31392(gp)
   213cc:	d161558b 	ldhu	r5,-31402(gp)
   213d0:	01800044 	movi	r6,1
   213d4:	d12153c4 	addi	r4,gp,-31409
   213d8:	288b883a 	add	r5,r5,r2
   213dc:	297fffc4 	addi	r5,r5,-1
   213e0:	297fffcc 	andi	r5,r5,65535
   213e4:	00206580 	call	20658 <HW_EscReadIsr>
   213e8:	003fc106 	br	212f0 <PDI_Isr+0xc4>

000213ec <MainLoop>:
    if(bInitFinished == FALSE)
   213ec:	d0a13b03 	ldbu	r2,-31508(gp)
   213f0:	10003226 	beq	r2,zero,214bc <MainLoop+0xd0>
        if (
   213f4:	d0a15b43 	ldbu	r2,-31379(gp)
{
   213f8:	deffff04 	addi	sp,sp,-4
   213fc:	dfc00015 	stw	ra,0(sp)
          && !bDcSyncActive                                               /* DC-Synchronous */
   21400:	d0e16283 	ldbu	r3,-31350(gp)
        if (
   21404:	10000e1e 	bne	r2,zero,21440 <MainLoop+0x54>
          && !bDcSyncActive                                               /* DC-Synchronous */
   21408:	18c03fcc 	andi	r3,r3,255
   2140c:	18001826 	beq	r3,zero,21470 <MainLoop+0x84>
        if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
   21410:	d0a13717 	ldw	r2,-31524(gp)
   21414:	1083e830 	cmpltui	r2,r2,4000
   21418:	1000011e 	bne	r2,zero,21420 <MainLoop+0x34>
            COE_SyncTimeStamp();
   2141c:	002075c0 	call	2075c <COE_SyncTimeStamp>
        ECAT_Main();
   21420:	00239ec0 	call	239ec <ECAT_Main>
       COE_Main();
   21424:	0020ba00 	call	20ba0 <COE_Main>
       CheckIfEcatError();
   21428:	002364c0 	call	2364c <CheckIfEcatError>
    if (pAPPL_MainLoop != NULL)
   2142c:	d0a14117 	ldw	r2,-31484(gp)
   21430:	10001f26 	beq	r2,zero,214b0 <MainLoop+0xc4>
}
   21434:	dfc00017 	ldw	ra,0(sp)
   21438:	dec00104 	addi	sp,sp,4
        pAPPL_MainLoop();
   2143c:	1000683a 	jmp	r2
          && !bDcSyncActive                                               /* DC-Synchronous */
   21440:	d0a16303 	ldbu	r2,-31348(gp)
   21444:	10c4b03a 	or	r2,r2,r3
   21448:	10803fcc 	andi	r2,r2,255
   2144c:	103ff01e 	bne	r2,zero,21410 <MainLoop+0x24>
             ECAT_Application();
   21450:	00210900 	call	21090 <ECAT_Application>
             if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
   21454:	d0a16343 	ldbu	r2,-31347(gp)
   21458:	10800058 	cmpnei	r2,r2,1
   2145c:	103fec1e 	bne	r2,zero,21410 <MainLoop+0x24>
   21460:	d0a1588b 	ldhu	r2,-31390(gp)
   21464:	103fea26 	beq	r2,zero,21410 <MainLoop+0x24>
                PDO_InputMapping();
   21468:	0020d640 	call	20d64 <PDO_InputMapping>
   2146c:	003fe806 	br	21410 <MainLoop+0x24>
                UINT16 ALEvent = HW_GetALEventRegister();
   21470:	00206180 	call	20618 <HW_GetALEventRegister>
                if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21474:	10c1000c 	andi	r3,r2,1024
   21478:	18000626 	beq	r3,zero,21494 <MainLoop+0xa8>
                    bEcatFirstOutputsReceived = TRUE;
   2147c:	00800044 	movi	r2,1
   21480:	d0a16305 	stb	r2,-31348(gp)
                    if ( bEcatOutputUpdateRunning )
   21484:	d0a16383 	ldbu	r2,-31346(gp)
   21488:	103ff126 	beq	r2,zero,21450 <MainLoop+0x64>
                        PDO_OutputMapping();
   2148c:	0020e800 	call	20e80 <PDO_OutputMapping>
   21490:	003fef06 	br	21450 <MainLoop+0x64>
                else if ( nPdOutputSize == 0 )
   21494:	d0e1580b 	ldhu	r3,-31392(gp)
   21498:	183fed1e 	bne	r3,zero,21450 <MainLoop+0x64>
                    if ( ALEvent & PROCESS_INPUT_EVENT )
   2149c:	1082000c 	andi	r2,r2,2048
   214a0:	103feb26 	beq	r2,zero,21450 <MainLoop+0x64>
                        bEcatFirstOutputsReceived = TRUE;
   214a4:	00800044 	movi	r2,1
   214a8:	d0a16305 	stb	r2,-31348(gp)
   214ac:	003fe806 	br	21450 <MainLoop+0x64>
}
   214b0:	dfc00017 	ldw	ra,0(sp)
   214b4:	dec00104 	addi	sp,sp,4
   214b8:	f800283a 	ret
   214bc:	f800283a 	ret

000214c0 <ESC_EepromAccess>:
 \brief        Controller (switch BIG_ENDIAN_FORMAT set) the data has to be swapped outside
 \brief        of this function)
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access)
{
   214c0:	defff404 	addi	sp,sp,-48
   214c4:	dd000615 	stw	r20,24(sp)
   214c8:	dcc00515 	stw	r19,20(sp)
   214cc:	d9000015 	stw	r4,0(sp)
   214d0:	3029883a 	mov	r20,r6
    UINT8 RetryCnt = MAX_CMD_RETIRES; //Maximum number of retries (evaluated in case of an Acknowledge Error)

    UINT16 nConfig;
    VARVOLATILE UINT16 nControl;

    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   214d4:	d9000104 	addi	r4,sp,4
   214d8:	01800084 	movi	r6,2
{
   214dc:	2827883a 	mov	r19,r5
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   214e0:	01414004 	movi	r5,1280
{
   214e4:	dfc00b15 	stw	ra,44(sp)
   214e8:	dd800815 	stw	r22,32(sp)
   214ec:	dc000215 	stw	r16,8(sp)
   214f0:	382d883a 	mov	r22,r7
   214f4:	3821883a 	mov	r16,r7
   214f8:	df000a15 	stw	fp,40(sp)
   214fc:	ddc00915 	stw	r23,36(sp)
   21500:	dd400715 	stw	r21,28(sp)
   21504:	dc800415 	stw	r18,16(sp)
   21508:	dc400315 	stw	r17,12(sp)
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   2150c:	00205e00 	call	205e0 <HW_EscRead>
    HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21510:	01800084 	movi	r6,2
   21514:	01414084 	movi	r5,1282
   21518:	d9000184 	addi	r4,sp,6
   2151c:	00205e00 	call	205e0 <HW_EscRead>



    if ( nConfig & ESC_EEPROM_ASSIGN_TO_PDI_MASK )
   21520:	d880010b 	ldhu	r2,4(sp)
   21524:	1080004c 	andi	r2,r2,1
   21528:	10006926 	beq	r2,zero,216d0 <ESC_EepromAccess+0x210>
    {
        /* register 0x500.0 is set (should be written by the master before sending
        the state transition request to PREOP),we have access to the EEPROM */
        UINT16 step = 1; /* we write always only 1 word with one write access */

        if ( access == ESC_RD )
   2152c:	84003fcc 	andi	r16,r16,255
   21530:	84000098 	cmpnei	r16,r16,2
   21534:	1023883a 	mov	r17,r2
   21538:	8000041e 	bne	r16,zero,2154c <ESC_EepromAccess+0x8c>
        {
            /* read access requested, we have to check if we read 2 (register 0x502.6=0)
            or 4 words (register 0x502.6=1) with one access */
            if ( nControl & ESC_EEPROM_SUPPORTED_READBYTES_MASK )
   2153c:	d880018b 	ldhu	r2,6(sp)
   21540:	1080100c 	andi	r2,r2,64
   21544:	10002126 	beq	r2,zero,215cc <ESC_EepromAccess+0x10c>
            {
                step = 4; /* we get 4 words with one read access */
   21548:	04400104 	movi	r17,4
            }
            else
            {
                if ( access == ESC_RD )
                {
                    UINT16 u16BytesToCopy = (step << 1);
   2154c:	882e907a 	slli	r23,r17,1
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21550:	00804004 	movi	r2,256
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21554:	01800084 	movi	r6,2
   21558:	01414004 	movi	r5,1280
   2155c:	d9000104 	addi	r4,sp,4
            if ( access == ESC_RD )
   21560:	b5803fcc 	andi	r22,r22,255
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21564:	d880010d 	sth	r2,4(sp)
        for (i = 0; i < wordsize;)
   21568:	0025883a 	mov	r18,zero
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   2156c:	00206640 	call	20664 <HW_EscWrite>
        for (i = 0; i < wordsize;)
   21570:	9d7fffcc 	andi	r21,r19,65535
                if ( access == ESC_RD )
   21574:	b7000098 	cmpnei	fp,r22,2
        for (i = 0; i < wordsize;)
   21578:	943fffcc 	andi	r16,r18,65535
   2157c:	85401536 	bltu	r16,r21,215d4 <ESC_EepromAccess+0x114>
    UINT16 u16RetErr = 0;
   21580:	0021883a 	mov	r16,zero
    }

    /* clear EEPROM control register 0x500 */
    nConfig = 0;

    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   21584:	01800084 	movi	r6,2
   21588:	01414004 	movi	r5,1280
   2158c:	d9000104 	addi	r4,sp,4
    nConfig = 0;
   21590:	d800010d 	sth	zero,4(sp)
    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   21594:	00206640 	call	20664 <HW_EscWrite>
    return u16RetErr;
}
   21598:	8005883a 	mov	r2,r16
   2159c:	dfc00b17 	ldw	ra,44(sp)
   215a0:	df000a17 	ldw	fp,40(sp)
   215a4:	ddc00917 	ldw	r23,36(sp)
   215a8:	dd800817 	ldw	r22,32(sp)
   215ac:	dd400717 	ldw	r21,28(sp)
   215b0:	dd000617 	ldw	r20,24(sp)
   215b4:	dcc00517 	ldw	r19,20(sp)
   215b8:	dc800417 	ldw	r18,16(sp)
   215bc:	dc400317 	ldw	r17,12(sp)
   215c0:	dc000217 	ldw	r16,8(sp)
   215c4:	dec00c04 	addi	sp,sp,48
   215c8:	f800283a 	ret
                step = 2; /* we get 2 words with one read access */
   215cc:	04400084 	movi	r17,2
   215d0:	003fde06 	br	2154c <ESC_EepromAccess+0x8c>
            HW_EscWrite((MEM_ADDR *) &wordaddress, ESC_EEPROM_ADDRESS_OFFSET, 4);
   215d4:	01800104 	movi	r6,4
   215d8:	01414104 	movi	r5,1284
   215dc:	d809883a 	mov	r4,sp
   215e0:	00206640 	call	20664 <HW_EscWrite>
            if ( access == ESC_RD )
   215e4:	b0800098 	cmpnei	r2,r22,2
   215e8:	10001b1e 	bne	r2,zero,21658 <ESC_EepromAccess+0x198>
                nControl = ESC_EEPROM_CMD_READ_MASK;
   215ec:	00804004 	movi	r2,256
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   215f0:	01800084 	movi	r6,2
   215f4:	01414084 	movi	r5,1282
   215f8:	d9000184 	addi	r4,sp,6
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   215fc:	d880018d 	sth	r2,6(sp)
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21600:	00206640 	call	20664 <HW_EscWrite>
                HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21604:	01800084 	movi	r6,2
   21608:	01414084 	movi	r5,1282
   2160c:	d9000184 	addi	r4,sp,6
   21610:	00205e00 	call	205e0 <HW_EscRead>
            while ( nControl & (ESC_EEPROM_BUSY_MASK));
   21614:	d880018b 	ldhu	r2,6(sp)
   21618:	10bfffcc 	andi	r2,r2,65535
   2161c:	10a0001c 	xori	r2,r2,32768
   21620:	10a00004 	addi	r2,r2,-32768
   21624:	103ff716 	blt	r2,zero,21604 <ESC_EepromAccess+0x144>
            HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21628:	01800084 	movi	r6,2
   2162c:	01414084 	movi	r5,1282
   21630:	d9000184 	addi	r4,sp,6
   21634:	00205e00 	call	205e0 <HW_EscRead>
            if ( nControl & ESC_EEPROM_ERROR_MASK )
   21638:	d880018b 	ldhu	r2,6(sp)
   2163c:	109e000c 	andi	r2,r2,30720
   21640:	10000c26 	beq	r2,zero,21674 <ESC_EepromAccess+0x1b4>
                if(!(nControl & ESC_EEPROM_ERROR_CMD_ACK) && (RetryCnt != 0))
   21644:	d880018b 	ldhu	r2,6(sp)
   21648:	1088000c 	andi	r2,r2,8192
   2164c:	1000141e 	bne	r2,zero,216a0 <ESC_EepromAccess+0x1e0>
                    u16RetErr =  ALSTATUSCODE_EE_ERROR;
   21650:	04001444 	movi	r16,81
   21654:	003fcb06 	br	21584 <ESC_EepromAccess+0xc4>
                HW_EscWriteWord(pData[i],ESC_EEPROM_DATA_OFFSET);
   21658:	8008907a 	slli	r4,r16,1
   2165c:	01800084 	movi	r6,2
   21660:	01414204 	movi	r5,1288
   21664:	a109883a 	add	r4,r20,r4
   21668:	00206640 	call	20664 <HW_EscWrite>
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   2166c:	00808004 	movi	r2,512
   21670:	003fdf06 	br	215f0 <ESC_EepromAccess+0x130>
                if ( access == ESC_RD )
   21674:	e0000a1e 	bne	fp,zero,216a0 <ESC_EepromAccess+0x1e0>
                    if((u16WordOffset + step) > wordsize)
   21678:	88bfffcc 	andi	r2,r17,65535
   2167c:	8085883a 	add	r2,r16,r2
   21680:	a880100e 	bge	r21,r2,216c4 <ESC_EepromAccess+0x204>
                        u16BytesToCopy = (wordsize - u16WordOffset) << 1;
   21684:	9c8dc83a 	sub	r6,r19,r18
   21688:	300c907a 	slli	r6,r6,1
                    HW_EscRead((MEM_ADDR *) &pData[i], ESC_EEPROM_DATA_OFFSET, u16BytesToCopy);
   2168c:	8008907a 	slli	r4,r16,1
   21690:	31bfffcc 	andi	r6,r6,65535
   21694:	01414204 	movi	r5,1288
   21698:	a109883a 	add	r4,r20,r4
   2169c:	00205e00 	call	205e0 <HW_EscRead>
            if(!(nControl & ESC_EEPROM_ERROR_MASK))
   216a0:	d880018b 	ldhu	r2,6(sp)
   216a4:	109e000c 	andi	r2,r2,30720
   216a8:	1000081e 	bne	r2,zero,216cc <ESC_EepromAccess+0x20c>
                wordaddress += step;
   216ac:	d8800017 	ldw	r2,0(sp)
   216b0:	88ffffcc 	andi	r3,r17,65535
                u16WordOffset +=step;
   216b4:	9465883a 	add	r18,r18,r17
                wordaddress += step;
   216b8:	10c5883a 	add	r2,r2,r3
   216bc:	d8800015 	stw	r2,0(sp)
                i += step;
   216c0:	003fad06 	br	21578 <ESC_EepromAccess+0xb8>
                    UINT16 u16BytesToCopy = (step << 1);
   216c4:	b80d883a 	mov	r6,r23
   216c8:	003ff006 	br	2168c <ESC_EepromAccess+0x1cc>
                    while(i32TimeoutTicks > 0)
   216cc:	003fff06 	br	216cc <ESC_EepromAccess+0x20c>
        u16RetErr = ALSTATUSCODE_EE_NOACCESS;
   216d0:	04001404 	movi	r16,80
   216d4:	003fab06 	br	21584 <ESC_EepromAccess+0xc4>

000216d8 <ESC_EepromWriteCRC>:

 \brief        This function recalculates the EEPROM CRC and writes the updated value to EEPROM.
            After writing the ESC Config Area a device restart is required!
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 ESC_EepromWriteCRC(void)
{
   216d8:	defffa04 	addi	sp,sp,-24
    UINT16 u16Return = ALSTATUSCODE_UNSPECIFIEDERROR;
    UINT16 EscCfgData[8];
    UINT16 u16Crc = 0x00FF;
   216dc:	00803fc4 	movi	r2,255
    UINT16 i,j;

    
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   216e0:	01c00084 	movi	r7,2
   216e4:	d9800104 	addi	r6,sp,4
   216e8:	014001c4 	movi	r5,7
   216ec:	0009883a 	mov	r4,zero
{
   216f0:	dfc00515 	stw	ra,20(sp)
    UINT16 u16Crc = 0x00FF;
   216f4:	d880008d 	sth	r2,2(sp)
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   216f8:	00214c00 	call	214c0 <ESC_EepromAccess>
    if(u16Return == 0)
   216fc:	10ffffcc 	andi	r3,r2,65535
   21700:	18001c1e 	bne	r3,zero,21774 <ESC_EepromWriteCRC+0x9c>
   21704:	d880008b 	ldhu	r2,2(sp)
    {
        UINT8 *pData = (UINT8 *)EscCfgData;

        for(i = 0; i < 14; i++ )
        {
            u16Crc ^= pData[i];
   21708:	d9000104 	addi	r4,sp,4
   2170c:	20c9883a 	add	r4,r4,r3
   21710:	21000003 	ldbu	r4,0(r4)
   21714:	01400204 	movi	r5,8
   21718:	2084f03a 	xor	r2,r4,r2

            for(j=0; j<8; j++ )
            {
                if( u16Crc & 0x80 )
   2171c:	1100200c 	andi	r4,r2,128
   21720:	20001726 	beq	r4,zero,21780 <ESC_EepromWriteCRC+0xa8>
   21724:	10bfffcc 	andi	r2,r2,65535
                {
                    u16Crc = (u16Crc<<1) ^ 0x07;
   21728:	1004907a 	slli	r2,r2,1
   2172c:	108001dc 	xori	r2,r2,7
            for(j=0; j<8; j++ )
   21730:	293fffc4 	addi	r4,r5,-1
   21734:	200b883a 	mov	r5,r4
   21738:	213fffcc 	andi	r4,r4,65535
   2173c:	203ff71e 	bne	r4,zero,2171c <ESC_EepromWriteCRC+0x44>
        for(i = 0; i < 14; i++ )
   21740:	18c00044 	addi	r3,r3,1
   21744:	19000398 	cmpnei	r4,r3,14
   21748:	203fef1e 	bne	r4,zero,21708 <ESC_EepromWriteCRC+0x30>
                }
            }
        }

        /*only low Byte shall be written*/
        u16Crc &= 0x00FF;
   2174c:	10803fcc 	andi	r2,r2,255

        /*write new calculated Crc to Esc Config area*/
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   21750:	01c00104 	movi	r7,4
   21754:	d9800084 	addi	r6,sp,2
   21758:	01400044 	movi	r5,1
   2175c:	010001c4 	movi	r4,7
        u16Crc &= 0x00FF;
   21760:	d880008d 	sth	r2,2(sp)
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   21764:	00214c00 	call	214c0 <ESC_EepromAccess>
        if(u16Return == 0)
   21768:	10ffffcc 	andi	r3,r2,65535
   2176c:	1800011e 	bne	r3,zero,21774 <ESC_EepromWriteCRC+0x9c>
        {
            u16Return =  ALSTATUSCODE_WAITFORCOLDSTART;
   21770:	00800804 	movi	r2,32
        }
    }

    return u16Return;
}
   21774:	dfc00517 	ldw	ra,20(sp)
   21778:	dec00604 	addi	sp,sp,24
   2177c:	f800283a 	ret
                    u16Crc <<= 1;
   21780:	1004907a 	slli	r2,r2,1
   21784:	003fea06 	br	21730 <ESC_EepromWriteCRC+0x58>

00021788 <COE_Init>:
 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
    pCoeSendStored = 0;
   21788:	d0214a15 	stw	zero,-31448(gp)
    nSdoInfoFragmentsLeft = 0;
   2178c:	d021768d 	sth	zero,-31270(gp)
}
   21790:	f800283a 	ret

00021794 <COE_ServiceInd>:

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
    UINT8 result = 0;

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
   21794:	2080018b 	ldhu	r2,6(r4)
   21798:	1004d33a 	srli	r2,r2,12
   2179c:	10c00228 	cmpgeui	r3,r2,8
   217a0:	1800081e 	bne	r3,zero,217c4 <COE_ServiceInd+0x30>
   217a4:	10c000e8 	cmpgeui	r3,r2,3
   217a8:	18000a1e 	bne	r3,zero,217d4 <COE_ServiceInd+0x40>
   217ac:	10c00060 	cmpeqi	r3,r2,1
   217b0:	1800081e 	bne	r3,zero,217d4 <COE_ServiceInd+0x40>
   217b4:	108000a0 	cmpeqi	r2,r2,2
   217b8:	1000051e 	bne	r2,zero,217d0 <COE_ServiceInd+0x3c>
   217bc:	00800144 	movi	r2,5
   217c0:	f800283a 	ret
   217c4:	10800220 	cmpeqi	r2,r2,8
   217c8:	103ffc26 	beq	r2,zero,217bc <COE_ServiceInd+0x28>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
        break;

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
   217cc:	00267541 	jmpi	26754 <SDOS_SdoInfoInd>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
   217d0:	0025cd81 	jmpi	25cd8 <SDOS_SdoInd>
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
   217d4:	00800104 	movi	r2,4
    default:
        result = MBXERR_INVALIDHEADER;
        break;
    }
    return result;
}
   217d8:	f800283a 	ret

000217dc <COE_ContinueInd>:
 \brief  be put in the send mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if (pCoeSendStored)
   217dc:	d1214a17 	ldw	r4,-31448(gp)
{
   217e0:	deffff04 	addi	sp,sp,-4
   217e4:	dfc00015 	stw	ra,0(sp)
    if (pCoeSendStored)
   217e8:	20000926 	beq	r4,zero,21810 <COE_ContinueInd+0x34>
    {
        /* send the stored CoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) COE8*/
        if (MBX_MailboxSendReq(pCoeSendStored, COE_SERVICE) == 0)
   217ec:	01400084 	movi	r5,2
   217f0:	00242640 	call	24264 <MBX_MailboxSendReq>
   217f4:	10803fcc 	andi	r2,r2,255
   217f8:	1000011e 	bne	r2,zero,21800 <COE_ContinueInd+0x24>
        {
            pCoeSendStored = 0;
   217fc:	d0214a15 	stw	zero,-31448(gp)
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
        }
    }

    return 0;
   21800:	0005883a 	mov	r2,zero
}
   21804:	dfc00017 	ldw	ra,0(sp)
   21808:	dec00104 	addi	sp,sp,4
   2180c:	f800283a 	ret
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
   21810:	01002004 	movi	r4,128
   21814:	002704c0 	call	2704c <malloc>
   21818:	1009883a 	mov	r4,r2
        if (pMbx == NULL)
   2181c:	10000726 	beq	r2,zero,2183c <COE_ContinueInd+0x60>
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
   21820:	014000f4 	movhi	r5,3
   21824:	01800384 	movi	r6,14
   21828:	29634304 	addi	r5,r5,-29428
   2182c:	00273540 	call	27354 <memcpy>
   21830:	1009883a 	mov	r4,r2
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
   21834:	00267540 	call	26754 <SDOS_SdoInfoInd>
   21838:	003ff106 	br	21800 <COE_ContinueInd+0x24>
            return MBXERR_NOMOREMEMORY;
   2183c:	008001c4 	movi	r2,7
   21840:	003ff006 	br	21804 <COE_ContinueInd+0x28>

00021844 <FOE_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void FOE_Init(void)
{
    /* no file transmission sequence is running */
    u16FileAccessState    = FOE_READY;
   21844:	d0214d0d 	sth	zero,-31436(gp)
    /* initialize the expected packet number */
    u32PacketNo = 0;
   21848:	d0215015 	stw	zero,-31424(gp)
    pFoeSendStored = NULL;
   2184c:	d0214c15 	stw	zero,-31440(gp)
}
   21850:	f800283a 	ret

00021854 <FOE_ServiceInd>:
UINT8 FOE_ServiceInd(TFOEMBX MBXMEM * pFoeInd)
{
    /* initialize the result of the service checking */
    UINT16 nextState = ECAT_FOE_ERRCODE_ILLEGAL;
    /* dataSize contains the size of the file data */
    UINT16 dataSize = SWAPWORD(pFoeInd->MbxHeader.Length) - FOE_HEADER_SIZE;
   21854:	2080000b 	ldhu	r2,0(r4)
   21858:	117ffe84 	addi	r5,r2,-6


    /* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
       great enough for the service header of the FoE service */
    if ( SWAPWORD(pFoeInd->MbxHeader.Length) < FOE_HEADER_SIZE )
   2185c:	10bfffcc 	andi	r2,r2,65535
   21860:	108001b0 	cmpltui	r2,r2,6
   21864:	1000e01e 	bne	r2,zero,21be8 <FOE_ServiceInd+0x394>
    {
        return MBXERR_SIZETOOSHORT;
    }

    switch ( SWAPWORD(pFoeInd->FoeHeader.OpCode) )
   21868:	2080018b 	ldhu	r2,6(r4)
{
   2186c:	defffe04 	addi	sp,sp,-8
   21870:	dc000015 	stw	r16,0(sp)
    switch ( SWAPWORD(pFoeInd->FoeHeader.OpCode) )
   21874:	10bfffc4 	addi	r2,r2,-1
   21878:	10bfffcc 	andi	r2,r2,65535
{
   2187c:	dfc00115 	stw	ra,4(sp)
    switch ( SWAPWORD(pFoeInd->FoeHeader.OpCode) )
   21880:	10c001a8 	cmpgeui	r3,r2,6
   21884:	2021883a 	mov	r16,r4
   21888:	1800c71e 	bne	r3,zero,21ba8 <FOE_ServiceInd+0x354>
   2188c:	100490ba 	slli	r2,r2,2
   21890:	00c000b4 	movhi	r3,2
   21894:	10c7883a 	add	r3,r2,r3
   21898:	18862817 	ldw	r2,6304(r3)
   2189c:	1000683a 	jmp	r2
   218a0:	000218b8 	rdprs	zero,zero,2146
   218a4:	000219b4 	movhi	zero,2150
   218a8:	00021a24 	muli	zero,zero,2152
   218ac:	00021a60 	cmpeqi	zero,zero,2153
   218b0:	00021acc 	andi	zero,zero,2155
   218b4:	00021aec 	andhi	zero,zero,2155
    {
    case ECAT_FOE_OPCODE_RRQ:
        /* file read is requested */
        if ( u16FileAccessState == FOE_READY )
   218b8:	d0a14d0b 	ldhu	r2,-31436(gp)
   218bc:	1000ba1e 	bne	r2,zero,21ba8 <FOE_ServiceInd+0x354>
        {
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   218c0:	2080028b 	ldhu	r2,10(r4)
   218c4:	21c0020b 	ldhu	r7,8(r4)
            /* last FoE sequence was finished, call application function */
            nextState = FOE_Read((UINT16 MBXMEM *)pFoeInd->Data, dataSize, (UINT16*)pFoeInd->Data, u32Password);
   218c8:	21800304 	addi	r6,r4,12
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   218cc:	1004943a 	slli	r2,r2,16
            nextState = FOE_Read((UINT16 MBXMEM *)pFoeInd->Data, dataSize, (UINT16*)pFoeInd->Data, u32Password);
   218d0:	3009883a 	mov	r4,r6
   218d4:	297fffcc 	andi	r5,r5,65535
   218d8:	11ceb03a 	or	r7,r2,r7
   218dc:	0023b940 	call	23b94 <FOE_Read>

            /* u32LastFileOffset contains the offset of the file which is sent now */
            u32LastFileOffset = 0;

            if (nextState <= FOE_MAXDATA)
   218e0:	10ffffcc 	andi	r3,r2,65535
            u32LastFileOffset = 0;
   218e4:	d0214e15 	stw	zero,-31432(gp)
            if (nextState <= FOE_MAXDATA)
   218e8:	191fe5a8 	cmpgeui	r4,r3,32662
   218ec:	2000241e 	bne	r4,zero,21980 <FOE_ServiceInd+0x12c>
            {
                /* the first data packet shall be sent */
                u32PacketNo    = 1;
   218f0:	01000044 	movi	r4,1
   218f4:	d1215015 	stw	r4,-31424(gp)
                /* u32FileOffset contains the offset of the file which shall be sent when the next FoE ACK is received */
                u32FileOffset = nextState;
   218f8:	d0e14f15 	stw	r3,-31428(gp)
    }

    if ( nextState <= FOE_MAXDATA )
    {
        /* we send DATA and wait for ACK */
        UINT32 d = SWAPDWORD(u32PacketNo);
   218fc:	d0e15017 	ldw	r3,-31424(gp)

        /* store the OpCode in the mailbox buffer */
        pFoeInd->FoeHeader.OpCode           = SWAPWORD(ECAT_FOE_OPCODE_DATA);
   21900:	010000c4 	movi	r4,3
   21904:	8100018d 	sth	r4,6(r16)
        /* store the packet number in the mailbox buffer */
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_LOWWORD] = ((d & 0x0000FFFF));
   21908:	80c0020d 	sth	r3,8(r16)
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   2190c:	1806d43a 	srli	r3,r3,16
   21910:	80c0028d 	sth	r3,10(r16)
     
        /* store the size of the mailbox data in the mailbox buffer */
        pFoeInd->MbxHeader.Length           = FOE_HEADER_SIZE + nextState;
   21914:	10c00184 	addi	r3,r2,6
   21918:	80c0000d 	sth	r3,0(r16)

        if ( nextState == u16SendMbxSize - FOE_HEADER_SIZE - MBX_HEADER_SIZE )
   2191c:	d0e16b8b 	ldhu	r3,-31314(gp)
   21920:	10bfffcc 	andi	r2,r2,65535
   21924:	18fffd04 	addi	r3,r3,-12
   21928:	10c09b1e 	bne	r2,r3,21b98 <FOE_ServiceInd+0x344>
        {
            /* packets still following, we wait for an ACK */
            u16FileAccessState = FOE_WAIT_FOR_ACK;
   2192c:	00800044 	movi	r2,1
        }
        else
        {
            /* it was the last Packet, we wait for the last ACK */
            u16FileAccessState = FOE_WAIT_FOR_LAST_ACK;
   21930:	d0a14d0d 	sth	r2,-31436(gp)

        /* the file transmission sequence is finished */
        u16FileAccessState = FOE_READY;
    }

    if ( bBootMode )
   21934:	d0a163c3 	ldbu	r2,-31345(gp)
   21938:	1000a426 	beq	r2,zero,21bcc <FOE_ServiceInd+0x378>
    {
        /* in BOOT mode the mailbox buffer is not sent via the mailbox functions
           because only FoE is allowed in BOOT mode, so we have to include the
            mailbox data link layer counter */
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
        if ( (u8MbxReadCounter & 0x07) == 0 )
   2193c:	d0e16943 	ldbu	r3,-31323(gp)
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   21940:	8080010b 	ldhu	r2,4(r16)
        if ( (u8MbxReadCounter & 0x07) == 0 )
   21944:	18c001cc 	andi	r3,r3,7
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   21948:	1083ffcc 	andi	r2,r2,4095
        if ( (u8MbxReadCounter & 0x07) == 0 )
   2194c:	1800021e 	bne	r3,zero,21958 <FOE_ServiceInd+0x104>
        {
            /* counter 0 is not allowed if mailbox data link layer is supported */
            u8MbxReadCounter = 1;
   21950:	00c00044 	movi	r3,1
   21954:	d0e16945 	stb	r3,-31323(gp)
        }
        /* store the counter in the mailbox header */
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   21958:	d0e16943 	ldbu	r3,-31323(gp)
   2195c:	19003fcc 	andi	r4,r3,255
   21960:	2008933a 	slli	r4,r4,12
        /* increment the counter for the next service */
          u8MbxReadCounter++;
   21964:	18c00044 	addi	r3,r3,1
   21968:	d0e16945 	stb	r3,-31323(gp)
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   2196c:	1104b03a 	or	r2,r2,r4
   21970:	8080010d 	sth	r2,4(r16)
        /* call the function to send the mailbox service directly,
           in BOOT mode we can be sure that the send mailbox is empty
           because no parallel services are allowed */
        MBX_CopyToSendMailbox((TMBX MBXMEM *) pFoeInd);
   21974:	8009883a 	mov	r4,r16
   21978:	0023ff00 	call	23ff0 <MBX_CopyToSendMailbox>
   2197c:	00004e06 	br	21ab8 <FOE_ServiceInd+0x264>
            else if (nextState <= FOE_MAXBUSY)
   21980:	18dffee8 	cmpgeui	r3,r3,32763
   21984:	1800681e 	bne	r3,zero,21b28 <FOE_ServiceInd+0x2d4>
                u16FileAccessState = FOE_WAIT_FOR_ACK;
   21988:	00c00044 	movi	r3,1
                u32PacketNo    = 0;
   2198c:	d0215015 	stw	zero,-31424(gp)
                u32FileOffset = 0;
   21990:	d0214f15 	stw	zero,-31428(gp)
                u16FileAccessState = FOE_WAIT_FOR_ACK;
   21994:	d0e14d0d 	sth	r3,-31436(gp)
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_BUSY);
   21998:	00c00184 	movi	r3,6
        pFoeInd->FoeHeader.Cmd.Busy.Done            = SWAPWORD(nextState-FOE_MAXBUSY_ZERO);
   2199c:	10a01a84 	addi	r2,r2,-32662
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_BUSY);
   219a0:	80c0018d 	sth	r3,6(r16)
        pFoeInd->FoeHeader.Cmd.Busy.Done            = SWAPWORD(nextState-FOE_MAXBUSY_ZERO);
   219a4:	8080020d 	sth	r2,8(r16)
        pFoeInd->FoeHeader.Cmd.Busy.Entire          = 0;
   219a8:	8000028d 	sth	zero,10(r16)
        pFoeInd->MbxHeader.Length                   = FOE_HEADER_SIZE;
   219ac:	80c0000d 	sth	r3,0(r16)
   219b0:	003fe006 	br	21934 <FOE_ServiceInd+0xe0>
        if ( u16FileAccessState == FOE_READY )
   219b4:	d0a14d0b 	ldhu	r2,-31436(gp)
   219b8:	10007b1e 	bne	r2,zero,21ba8 <FOE_ServiceInd+0x354>
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   219bc:	2080028b 	ldhu	r2,10(r4)
   219c0:	2180020b 	ldhu	r6,8(r4)
            nextState = FOE_Write((UINT16 MBXMEM *)pFoeInd->Data, dataSize, u32Password);
   219c4:	297fffcc 	andi	r5,r5,65535
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   219c8:	1004943a 	slli	r2,r2,16
            nextState = FOE_Write((UINT16 MBXMEM *)pFoeInd->Data, dataSize, u32Password);
   219cc:	21000304 	addi	r4,r4,12
   219d0:	118cb03a 	or	r6,r2,r6
   219d4:	0023bd00 	call	23bd0 <FOE_Write>
            if ( nextState == 0 )
   219d8:	10ffffcc 	andi	r3,r2,65535
            u32PacketNo    = 0;
   219dc:	d0215015 	stw	zero,-31424(gp)
            if ( nextState == 0 )
   219e0:	18004b1e 	bne	r3,zero,21b10 <FOE_ServiceInd+0x2bc>
                    nextState = FOE_ACK;
   219e4:	009fff44 	movi	r2,32765
        UINT32 d = SWAPDWORD(u32PacketNo);
   219e8:	d0e15017 	ldw	r3,-31424(gp)
        if ( nextState == FOE_ACK )
   219ec:	10bfffcc 	andi	r2,r2,65535
   219f0:	109fff58 	cmpnei	r2,r2,32765
        u32PacketNo++;
   219f4:	19000044 	addi	r4,r3,1
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_LOWWORD] = ((d & 0x0000FFFF));
   219f8:	80c0020d 	sth	r3,8(r16)
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   219fc:	1806d43a 	srli	r3,r3,16
        u32PacketNo++;
   21a00:	d1215015 	stw	r4,-31424(gp)
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_ACK);
   21a04:	01000104 	movi	r4,4
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   21a08:	80c0028d 	sth	r3,10(r16)
        pFoeInd->MbxHeader.Length                   = SIZEOF(TFOEHEADER);
   21a0c:	00c00184 	movi	r3,6
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_ACK);
   21a10:	8100018d 	sth	r4,6(r16)
        pFoeInd->MbxHeader.Length                   = SIZEOF(TFOEHEADER);
   21a14:	80c0000d 	sth	r3,0(r16)
        if ( nextState == FOE_ACK )
   21a18:	10006a1e 	bne	r2,zero,21bc4 <FOE_ServiceInd+0x370>
            u16FileAccessState = FOE_WAIT_FOR_DATA;
   21a1c:	00800084 	movi	r2,2
   21a20:	003fc306 	br	21930 <FOE_ServiceInd+0xdc>
        if ( u16FileAccessState == FOE_WAIT_FOR_DATA
   21a24:	d0a14d0b 	ldhu	r2,-31436(gp)
   21a28:	10bffecc 	andi	r2,r2,65531
   21a2c:	10800098 	cmpnei	r2,r2,2
   21a30:	10005d1e 	bne	r2,zero,21ba8 <FOE_ServiceInd+0x354>
            UINT32 u32CmdPacketNo = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD]) << 16));
   21a34:	2080028b 	ldhu	r2,10(r4)
   21a38:	20c0020b 	ldhu	r3,8(r4)
   21a3c:	1004943a 	slli	r2,r2,16
   21a40:	10c4b03a 	or	r2,r2,r3
            if ( u32CmdPacketNo == u32PacketNo )
   21a44:	d0e15017 	ldw	r3,-31424(gp)
   21a48:	1880551e 	bne	r3,r2,21ba0 <FOE_ServiceInd+0x34c>
                nextState = FOE_Data((UINT16 MBXMEM *)pFoeInd->Data, dataSize);
   21a4c:	297fffcc 	andi	r5,r5,65535
   21a50:	21000304 	addi	r4,r4,12
   21a54:	0023be80 	call	23be8 <FOE_Data>
                if ( nextState == 0 )
   21a58:	10ffffcc 	andi	r3,r2,65535
   21a5c:	003fe006 	br	219e0 <FOE_ServiceInd+0x18c>
        if ( u16FileAccessState == FOE_WAIT_FOR_ACK )
   21a60:	d0a14d0b 	ldhu	r2,-31436(gp)
   21a64:	10c00058 	cmpnei	r3,r2,1
   21a68:	18000e1e 	bne	r3,zero,21aa4 <FOE_ServiceInd+0x250>
            nextState = FOE_Ack( u32FileOffset, (UINT16 MBXMEM *)pFoeInd->Data );
   21a6c:	21400304 	addi	r5,r4,12
   21a70:	d1214f17 	ldw	r4,-31428(gp)
   21a74:	0023c440 	call	23c44 <FOE_Ack>
            u32LastFileOffset = u32FileOffset;
   21a78:	d1214f17 	ldw	r4,-31428(gp)
            if (nextState <= FOE_MAXDATA) 
   21a7c:	10ffffcc 	andi	r3,r2,65535
   21a80:	195fe5a8 	cmpgeui	r5,r3,32662
            u32LastFileOffset = u32FileOffset;
   21a84:	d1214e15 	stw	r4,-31432(gp)
            if (nextState <= FOE_MAXDATA) 
   21a88:	2800241e 	bne	r5,zero,21b1c <FOE_ServiceInd+0x2c8>
                u32FileOffset += nextState;
   21a8c:	1907883a 	add	r3,r3,r4
   21a90:	d0e14f15 	stw	r3,-31428(gp)
                u32PacketNo++;
   21a94:	d0e15017 	ldw	r3,-31424(gp)
   21a98:	18c00044 	addi	r3,r3,1
   21a9c:	d0e15015 	stw	r3,-31424(gp)
    if ( nextState <= FOE_MAXDATA )
   21aa0:	003f9606 	br	218fc <FOE_ServiceInd+0xa8>
        else if ( u16FileAccessState == FOE_WAIT_FOR_LAST_ACK )
   21aa4:	10800118 	cmpnei	r2,r2,4
   21aa8:	10003f1e 	bne	r2,zero,21ba8 <FOE_ServiceInd+0x354>
        APPL_FreeMailboxBuffer(pFoeInd);
   21aac:	8009883a 	mov	r4,r16
        u16FileAccessState = FOE_READY;
   21ab0:	d0214d0d 	sth	zero,-31436(gp)
        APPL_FreeMailboxBuffer(pFoeInd);
   21ab4:	002705c0 	call	2705c <free>
        return 0;
   21ab8:	0005883a 	mov	r2,zero
            pFoeSendStored = (TMBX MBXMEM *) pFoeInd;
        }
    }

    return 0;
}
   21abc:	dfc00117 	ldw	ra,4(sp)
   21ac0:	dc000017 	ldw	r16,0(sp)
   21ac4:	dec00204 	addi	sp,sp,8
   21ac8:	f800283a 	ret
        if ( u16FileAccessState != FOE_READY )
   21acc:	d0a14d0b 	ldhu	r2,-31436(gp)
   21ad0:	10003526 	beq	r2,zero,21ba8 <FOE_ServiceInd+0x354>
            UINT32 u32CmdErrorCode = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_HIGHWORD]) << 16));
   21ad4:	8080028b 	ldhu	r2,10(r16)
   21ad8:	2100020b 	ldhu	r4,8(r4)
   21adc:	1004943a 	slli	r2,r2,16
            FOE_Error( u32CmdErrorCode );
   21ae0:	1108b03a 	or	r4,r2,r4
   21ae4:	0023c6c0 	call	23c6c <FOE_Error>
    else if ( nextState < FOE_ERROR )
   21ae8:	003ff006 	br	21aac <FOE_ServiceInd+0x258>
        if ( u16FileAccessState == FOE_WAIT_FOR_ACK
   21aec:	d0a14d0b 	ldhu	r2,-31436(gp)
   21af0:	10c00060 	cmpeqi	r3,r2,1
   21af4:	1800021e 	bne	r3,zero,21b00 <FOE_ServiceInd+0x2ac>
          || u16FileAccessState == FOE_WAIT_FOR_LAST_ACK )
   21af8:	10800118 	cmpnei	r2,r2,4
   21afc:	10002a1e 	bne	r2,zero,21ba8 <FOE_ServiceInd+0x354>
            nextState = FOE_Busy( SWAPWORD(pFoeInd->FoeHeader.Cmd.Busy.Done), u32LastFileOffset, (UINT16 MBXMEM *)pFoeInd->Data );
   21b00:	d1614e17 	ldw	r5,-31432(gp)
   21b04:	8100020b 	ldhu	r4,8(r16)
   21b08:	81800304 	addi	r6,r16,12
   21b0c:	0023c600 	call	23c60 <FOE_Busy>
    if ( nextState <= FOE_MAXDATA )
   21b10:	10ffffcc 	andi	r3,r2,65535
   21b14:	18dfe5a8 	cmpgeui	r3,r3,32662
   21b18:	183f7826 	beq	r3,zero,218fc <FOE_ServiceInd+0xa8>
    else if ( nextState <= FOE_MAXBUSY )
   21b1c:	10ffffcc 	andi	r3,r2,65535
   21b20:	18dffee8 	cmpgeui	r3,r3,32763
   21b24:	183f9c26 	beq	r3,zero,21998 <FOE_ServiceInd+0x144>
    else if ( nextState == FOE_ACK || nextState == FOE_ACKFINISHED )
   21b28:	10e00104 	addi	r3,r2,-32764
   21b2c:	18ffffcc 	andi	r3,r3,65535
   21b30:	18c000a8 	cmpgeui	r3,r3,2
   21b34:	183fac26 	beq	r3,zero,219e8 <FOE_ServiceInd+0x194>
    else if ( nextState < FOE_ERROR )
   21b38:	10ffffcc 	andi	r3,r2,65535
   21b3c:	18e0001c 	xori	r3,r3,32768
   21b40:	18e00004 	addi	r3,r3,-32768
   21b44:	183fd90e 	bge	r3,zero,21aac <FOE_ServiceInd+0x258>
        pFoeInd->FoeHeader.OpCode                    = SWAPWORD(ECAT_FOE_OPCODE_ERR);
   21b48:	00c00144 	movi	r3,5
        pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_LOWWORD] = ((d & 0x0000FFFF));
   21b4c:	8080020d 	sth	r2,8(r16)
        pFoeInd->MbxHeader.Length                   = SIZEOF(TFOEHEADER);
   21b50:	00800184 	movi	r2,6
   21b54:	8080000d 	sth	r2,0(r16)
        pFoeInd->FoeHeader.OpCode                    = SWAPWORD(ECAT_FOE_OPCODE_ERR);
   21b58:	80c0018d 	sth	r3,6(r16)
        pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   21b5c:	8000028d 	sth	zero,10(r16)
        UINT8 b = 0;
   21b60:	0005883a 	mov	r2,zero
            UINT16 data = ((UINT16 MBXMEM *) pFoeInd->Data)[(b >> 1)];
   21b64:	10c03f8c 	andi	r3,r2,254
   21b68:	80c7883a 	add	r3,r16,r3
   21b6c:	18c0030b 	ldhu	r3,12(r3)
            if ((data & 0x00FF) == 0)
   21b70:	19003fcc 	andi	r4,r3,255
   21b74:	20000426 	beq	r4,zero,21b88 <FOE_ServiceInd+0x334>
            if ((data & 0xFF00) == 0)
   21b78:	18ffffcc 	andi	r3,r3,65535
   21b7c:	18c04028 	cmpgeui	r3,r3,256
   21b80:	18000b1e 	bne	r3,zero,21bb0 <FOE_ServiceInd+0x35c>
            b++;
   21b84:	10800044 	addi	r2,r2,1
            pFoeInd->MbxHeader.Length    += b+1;
   21b88:	108001c4 	addi	r2,r2,7
   21b8c:	10803fcc 	andi	r2,r2,255
   21b90:	8080000d 	sth	r2,0(r16)
   21b94:	00000b06 	br	21bc4 <FOE_ServiceInd+0x370>
            u16FileAccessState = FOE_WAIT_FOR_LAST_ACK;
   21b98:	00800104 	movi	r2,4
   21b9c:	003f6406 	br	21930 <FOE_ServiceInd+0xdc>
   21ba0:	00a00144 	movi	r2,-32763
   21ba4:	003fe806 	br	21b48 <FOE_ServiceInd+0x2f4>
   21ba8:	00a00104 	movi	r2,-32764
   21bac:	003fe606 	br	21b48 <FOE_ServiceInd+0x2f4>
            b++;
   21bb0:	10c00084 	addi	r3,r2,2
   21bb4:	1805883a 	mov	r2,r3
        while (b < 32)
   21bb8:	18c03fcc 	andi	r3,r3,255
   21bbc:	18c00818 	cmpnei	r3,r3,32
   21bc0:	183fe81e 	bne	r3,zero,21b64 <FOE_ServiceInd+0x310>
            u16FileAccessState = FOE_READY;
   21bc4:	d0214d0d 	sth	zero,-31436(gp)
   21bc8:	003f5a06 	br	21934 <FOE_ServiceInd+0xe0>
        if ( MBX_MailboxSendReq((TMBX MBXMEM *) pFoeInd, FOE_SERVICE) != 0 )
   21bcc:	01401004 	movi	r5,64
   21bd0:	8009883a 	mov	r4,r16
   21bd4:	00242640 	call	24264 <MBX_MailboxSendReq>
   21bd8:	10803fcc 	andi	r2,r2,255
   21bdc:	103fb626 	beq	r2,zero,21ab8 <FOE_ServiceInd+0x264>
            pFoeSendStored = (TMBX MBXMEM *) pFoeInd;
   21be0:	d4214c15 	stw	r16,-31440(gp)
   21be4:	003fb406 	br	21ab8 <FOE_ServiceInd+0x264>
        return MBXERR_SIZETOOSHORT;
   21be8:	00800184 	movi	r2,6
}
   21bec:	f800283a 	ret

00021bf0 <FOE_ContinueInd>:
 \brief    This function is called when the next mailbox fragment can be sent.
*////////////////////////////////////////////////////////////////////////////////////////

void FOE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if ( pFoeSendStored )
   21bf0:	d1214c17 	ldw	r4,-31440(gp)
   21bf4:	20000a26 	beq	r4,zero,21c20 <FOE_ContinueInd+0x30>
{
   21bf8:	deffff04 	addi	sp,sp,-4
    {
        /* send the stored FoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) FOE1*/
        if (MBX_MailboxSendReq(pFoeSendStored, FOE_SERVICE) == 0)
   21bfc:	01401004 	movi	r5,64
{
   21c00:	dfc00015 	stw	ra,0(sp)
        if (MBX_MailboxSendReq(pFoeSendStored, FOE_SERVICE) == 0)
   21c04:	00242640 	call	24264 <MBX_MailboxSendReq>
   21c08:	10803fcc 	andi	r2,r2,255
   21c0c:	1000011e 	bne	r2,zero,21c14 <FOE_ContinueInd+0x24>
        {
            pFoeSendStored = 0;
   21c10:	d0214c15 	stw	zero,-31440(gp)
        }
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   21c14:	dfc00017 	ldw	ra,0(sp)
   21c18:	dec00104 	addi	sp,sp,4
   21c1c:	f800283a 	ret
   21c20:	f800283a 	ret

00021c24 <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
   21c24:	defffd04 	addi	sp,sp,-12
   21c28:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c2c:	01800084 	movi	r6,2
{
   21c30:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c34:	01408104 	movi	r5,516
   21c38:	d9000084 	addi	r4,sp,2
{
   21c3c:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c40:	00205e00 	call	205e0 <HW_EscRead>
    
    mask &= intMask;
   21c44:	d880008b 	ldhu	r2,2(sp)


    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c48:	01800084 	movi	r6,2
   21c4c:	01408104 	movi	r5,516
    mask &= intMask;
   21c50:	80a0703a 	and	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c54:	d9000084 	addi	r4,sp,2
    mask &= intMask;
   21c58:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c5c:	00206640 	call	20664 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   21c60:	dfc00217 	ldw	ra,8(sp)
   21c64:	dc000117 	ldw	r16,4(sp)
   21c68:	dec00304 	addi	sp,sp,12
   21c6c:	f800283a 	ret

00021c70 <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
   21c70:	defffd04 	addi	sp,sp,-12
   21c74:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c78:	01800084 	movi	r6,2
{
   21c7c:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c80:	01408104 	movi	r5,516
   21c84:	d9000084 	addi	r4,sp,2
{
   21c88:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c8c:	00205e00 	call	205e0 <HW_EscRead>
    

    mask |= intMask;
   21c90:	d880008b 	ldhu	r2,2(sp)

    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c94:	01800084 	movi	r6,2
   21c98:	01408104 	movi	r5,516
    mask |= intMask;
   21c9c:	80a0b03a 	or	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21ca0:	d9000084 	addi	r4,sp,2
    mask |= intMask;
   21ca4:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21ca8:	00206640 	call	20664 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   21cac:	dfc00217 	ldw	ra,8(sp)
   21cb0:	dc000117 	ldw	r16,4(sp)
   21cb4:	dec00304 	addi	sp,sp,12
   21cb8:	f800283a 	ret

00021cbc <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
   21cbc:	defffe04 	addi	sp,sp,-8
    UINT16 TmpVar = 0;
    //read EEPROM loaded information
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21cc0:	01800084 	movi	r6,2
   21cc4:	01414084 	movi	r5,1282
   21cc8:	d9000084 	addi	r4,sp,2
{
   21ccc:	dfc00115 	stw	ra,4(sp)
    UINT16 TmpVar = 0;
   21cd0:	d800008d 	sth	zero,2(sp)
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21cd4:	00205e00 	call	205e0 <HW_EscRead>
    TmpVar = SWAPWORD(TmpVar);


    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
   21cd8:	d880008b 	ldhu	r2,2(sp)
   21cdc:	1086000c 	andi	r2,r2,6144
   21ce0:	1005003a 	cmpeq	r2,r2,zero
   21ce4:	d0a15105 	stb	r2,-31420(gp)
    }
    else
    {
        EepromLoaded = TRUE;
    }
}
   21ce8:	dfc00117 	ldw	ra,4(sp)
   21cec:	dec00204 	addi	sp,sp,8
   21cf0:	f800283a 	ret

00021cf4 <GetSyncMan>:
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21cf4:	21403fcc 	andi	r5,r4,255
   21cf8:	29404004 	addi	r5,r5,256
   21cfc:	280a90fa 	slli	r5,r5,3
{
   21d00:	deffff04 	addi	sp,sp,-4
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21d04:	01800204 	movi	r6,8
   21d08:	d1215184 	addi	r4,gp,-31418
{
   21d0c:	dfc00015 	stw	ra,0(sp)
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21d10:	00205e00 	call	205e0 <HW_EscRead>



    return &SyncManInfo;
}
   21d14:	d0a15184 	addi	r2,gp,-31418
   21d18:	dfc00017 	ldw	ra,0(sp)
   21d1c:	dec00104 	addi	sp,sp,4
   21d20:	f800283a 	ret

00021d24 <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
   21d24:	defffd04 	addi	sp,sp,-12
   21d28:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d2c:	24003fcc 	andi	r16,r4,255
   21d30:	802090fa 	slli	r16,r16,3
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21d34:	00800044 	movi	r2,1

    HW_EscWriteByte(smStatus,Offset);
   21d38:	01800044 	movi	r6,1
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d3c:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21d40:	843fffcc 	andi	r16,r16,65535
   21d44:	800b883a 	mov	r5,r16
   21d48:	d90000c4 	addi	r4,sp,3
{
   21d4c:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21d50:	d88000c5 	stb	r2,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21d54:	00206640 	call	20664 <HW_EscWrite>
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadByte(smStatus, Offset);
   21d58:	01800044 	movi	r6,1
   21d5c:	800b883a 	mov	r5,r16
   21d60:	d90000c4 	addi	r4,sp,3
   21d64:	00205e00 	call	205e0 <HW_EscRead>
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
   21d68:	d88000c3 	ldbu	r2,3(sp)
   21d6c:	1080004c 	andi	r2,r2,1
   21d70:	103ff926 	beq	r2,zero,21d58 <DisableSyncManChannel+0x34>
}
   21d74:	dfc00217 	ldw	ra,8(sp)
   21d78:	dc000117 	ldw	r16,4(sp)
   21d7c:	dec00304 	addi	sp,sp,12
   21d80:	f800283a 	ret

00021d84 <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
   21d84:	defffd04 	addi	sp,sp,-12
   21d88:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = 0x00;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d8c:	24003fcc 	andi	r16,r4,255
   21d90:	802090fa 	slli	r16,r16,3

    HW_EscWriteByte(smStatus,Offset);
   21d94:	01800044 	movi	r6,1
   21d98:	d90000c4 	addi	r4,sp,3
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d9c:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21da0:	843fffcc 	andi	r16,r16,65535
   21da4:	800b883a 	mov	r5,r16
{
   21da8:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = 0x00;
   21dac:	d80000c5 	stb	zero,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21db0:	00206640 	call	20664 <HW_EscWrite>
    
    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadByte(smStatus,Offset);
   21db4:	01800044 	movi	r6,1
   21db8:	800b883a 	mov	r5,r16
   21dbc:	d90000c4 	addi	r4,sp,3
   21dc0:	00205e00 	call	205e0 <HW_EscRead>
    }while((smStatus & SM_SETTING_PDI_DISABLE));
   21dc4:	d88000c3 	ldbu	r2,3(sp)
   21dc8:	1080004c 	andi	r2,r2,1
   21dcc:	103ff91e 	bne	r2,zero,21db4 <EnableSyncManChannel+0x30>
}
   21dd0:	dfc00217 	ldw	ra,8(sp)
   21dd4:	dc000117 	ldw	r16,4(sp)
   21dd8:	dec00304 	addi	sp,sp,12
   21ddc:	f800283a 	ret

00021de0 <CheckSmSettings>:
    UINT16 SMLength = 0;
    UINT16 SMAddress = 0;


        //Check if max address defines are within the available ESC address range
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21de0:	d0a1570b 	ldhu	r2,-31396(gp)
{
   21de4:	defffc04 	addi	sp,sp,-16
   21de8:	dfc00315 	stw	ra,12(sp)
   21dec:	dc800215 	stw	r18,8(sp)
   21df0:	dc400115 	stw	r17,4(sp)
   21df4:	dc000015 	stw	r16,0(sp)
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21df8:	108bfff0 	cmpltui	r2,r2,12287
   21dfc:	1000921e 	bne	r2,zero,22048 <CheckSmSettings+0x268>
   21e00:	2025883a 	mov	r18,r4
   21e04:	2023883a 	mov	r17,r4

                return ALSTATUSCODE_NOVALIDFIRMWARE;
        }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
   21e08:	0009883a 	mov	r4,zero
   21e0c:	0021cf40 	call	21cf4 <GetSyncMan>
    SMLength = pSyncMan->Length;
    SMAddress = pSyncMan->PhysicalStartAddress;



    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e10:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21e14:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21e18:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e1c:	2940004c 	andi	r5,r5,1
   21e20:	2800081e 	bne	r5,zero,21e44 <CheckSmSettings+0x64>
            result = SYNCMANCHSIZE + 1;
        }

        if ( result != 0 )
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21e24:	04000584 	movi	r16,22
            pSyncMan = GetSyncMan(i);
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
        }
    }
    return result;
}
   21e28:	8005883a 	mov	r2,r16
   21e2c:	dfc00317 	ldw	ra,12(sp)
   21e30:	dc800217 	ldw	r18,8(sp)
   21e34:	dc400117 	ldw	r17,4(sp)
   21e38:	dc000017 	ldw	r16,0(sp)
   21e3c:	dec00404 	addi	sp,sp,16
   21e40:	f800283a 	ret
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
   21e44:	10800103 	ldbu	r2,4(r2)
   21e48:	1140030c 	andi	r5,r2,12
   21e4c:	29400118 	cmpnei	r5,r5,4
   21e50:	283ff41e 	bne	r5,zero,21e24 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e54:	1080008c 	andi	r2,r2,2
   21e58:	103ff226 	beq	r2,zero,21e24 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21e5c:	20bff704 	addi	r2,r4,-36
   21e60:	10bfffcc 	andi	r2,r2,65535
   21e64:	10801768 	cmpgeui	r2,r2,93
   21e68:	103fee1e 	bne	r2,zero,21e24 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
   21e6c:	18bc0004 	addi	r2,r3,-4096
   21e70:	10bfffcc 	andi	r2,r2,65535
   21e74:	10880028 	cmpgeui	r2,r2,8192
   21e78:	103fea1e 	bne	r2,zero,21e24 <CheckSmSettings+0x44>
        pSyncMan = GetSyncMan(MAILBOX_READ);
   21e7c:	01000044 	movi	r4,1
   21e80:	0021cf40 	call	21cf4 <GetSyncMan>
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e84:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21e88:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21e8c:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e90:	2940004c 	andi	r5,r5,1
   21e94:	283fe326 	beq	r5,zero,21e24 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
   21e98:	10800103 	ldbu	r2,4(r2)
   21e9c:	1140030c 	andi	r5,r2,12
   21ea0:	2821883a 	mov	r16,r5
   21ea4:	283fdf1e 	bne	r5,zero,21e24 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21ea8:	1080008c 	andi	r2,r2,2
   21eac:	103fdd26 	beq	r2,zero,21e24 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21eb0:	20bff704 	addi	r2,r4,-36
   21eb4:	10bfffcc 	andi	r2,r2,65535
   21eb8:	10801768 	cmpgeui	r2,r2,93
   21ebc:	103fd91e 	bne	r2,zero,21e24 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_READ_ADDRESS)
   21ec0:	18bc0004 	addi	r2,r3,-4096
   21ec4:	10bfffcc 	andi	r2,r2,65535
   21ec8:	10880028 	cmpgeui	r2,r2,8192
   21ecc:	103fd51e 	bne	r2,zero,21e24 <CheckSmSettings+0x44>
    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
   21ed0:	94803fcc 	andi	r18,r18,255
   21ed4:	90800130 	cmpltui	r2,r18,4
   21ed8:	1000421e 	bne	r2,zero,21fe4 <CheckSmSettings+0x204>
        b3BufferMode = TRUE;
   21edc:	00800044 	movi	r2,1
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21ee0:	010000c4 	movi	r4,3
        b3BufferMode = TRUE;
   21ee4:	d0a15b05 	stb	r2,-31380(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21ee8:	0021cf40 	call	21cf4 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21eec:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21ef0:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21ef4:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21ef8:	2940004c 	andi	r5,r5,1
   21efc:	28003426 	beq	r5,zero,21fd0 <CheckSmSettings+0x1f0>
   21f00:	217fffc4 	addi	r5,r4,-1
   21f04:	297fffcc 	andi	r5,r5,65535
   21f08:	29408928 	cmpgeui	r5,r5,548
   21f0c:	28000d1e 	bne	r5,zero,21f44 <CheckSmSettings+0x164>
                if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
   21f10:	d161588b 	ldhu	r5,-31390(gp)
   21f14:	213fffcc 	andi	r4,r4,65535
   21f18:	21400a1e 	bne	r4,r5,21f44 <CheckSmSettings+0x164>
                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
   21f1c:	10800103 	ldbu	r2,4(r2)
   21f20:	1100030c 	andi	r4,r2,12
   21f24:	2000071e 	bne	r4,zero,21f44 <CheckSmSettings+0x164>
                        if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
   21f28:	d12156c3 	ldbu	r4,-31397(gp)
   21f2c:	21000098 	cmpnei	r4,r4,2
   21f30:	2000061e 	bne	r4,zero,21f4c <CheckSmSettings+0x16c>
   21f34:	18fc0004 	addi	r3,r3,-4096
   21f38:	18ffffcc 	andi	r3,r3,65535
   21f3c:	18c80030 	cmpltui	r3,r3,8192
   21f40:	1800051e 	bne	r3,zero,21f58 <CheckSmSettings+0x178>
            result = ALSTATUSCODE_INVALIDSMINCFG;
   21f44:	04000784 	movi	r16,30
   21f48:	003fb706 	br	21e28 <CheckSmSettings+0x48>
                            || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
   21f4c:	d121550b 	ldhu	r4,-31404(gp)
   21f50:	18ffffcc 	andi	r3,r3,65535
   21f54:	193ffb1e 	bne	r3,r4,21f44 <CheckSmSettings+0x164>
                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21f58:	1080008c 	andi	r2,r2,2
   21f5c:	10000126 	beq	r2,zero,21f64 <CheckSmSettings+0x184>
                                    b3BufferMode = FALSE;
   21f60:	d0215b05 	stb	zero,-31380(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21f64:	01000084 	movi	r4,2
   21f68:	0021cf40 	call	21cf4 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21f6c:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21f70:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21f74:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21f78:	2940004c 	andi	r5,r5,1
   21f7c:	28002d26 	beq	r5,zero,22034 <CheckSmSettings+0x254>
   21f80:	217fffc4 	addi	r5,r4,-1
   21f84:	297fffcc 	andi	r5,r5,65535
   21f88:	29400428 	cmpgeui	r5,r5,16
   21f8c:	28000e1e 	bne	r5,zero,21fc8 <CheckSmSettings+0x1e8>
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
   21f90:	d161580b 	ldhu	r5,-31392(gp)
   21f94:	213fffcc 	andi	r4,r4,65535
   21f98:	21400b1e 	bne	r4,r5,21fc8 <CheckSmSettings+0x1e8>
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
   21f9c:	10800103 	ldbu	r2,4(r2)
   21fa0:	1100030c 	andi	r4,r2,12
   21fa4:	21000118 	cmpnei	r4,r4,4
   21fa8:	2000071e 	bne	r4,zero,21fc8 <CheckSmSettings+0x1e8>
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
   21fac:	d12156c3 	ldbu	r4,-31397(gp)
   21fb0:	21000098 	cmpnei	r4,r4,2
   21fb4:	2000151e 	bne	r4,zero,2200c <CheckSmSettings+0x22c>
   21fb8:	18fc0004 	addi	r3,r3,-4096
   21fbc:	18ffffcc 	andi	r3,r3,65535
   21fc0:	18c80030 	cmpltui	r3,r3,8192
   21fc4:	1800141e 	bne	r3,zero,22018 <CheckSmSettings+0x238>
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21fc8:	04000744 	movi	r16,29
   21fcc:	003f9606 	br	21e28 <CheckSmSettings+0x48>
        else if (SMLength != 0 || nPdInputSize != 0)
   21fd0:	d0a1588b 	ldhu	r2,-31390(gp)
   21fd4:	1104b03a 	or	r2,r2,r4
   21fd8:	10bfffcc 	andi	r2,r2,65535
   21fdc:	103fe126 	beq	r2,zero,21f64 <CheckSmSettings+0x184>
   21fe0:	003fd806 	br	21f44 <CheckSmSettings+0x164>
    if (result == 0 && maxChannel > PROCESS_DATA_OUT)
   21fe4:	948000e0 	cmpeqi	r18,r18,3
   21fe8:	903fde1e 	bne	r18,zero,21f64 <CheckSmSettings+0x184>
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21fec:	d0a15783 	ldbu	r2,-31394(gp)
   21ff0:	89003fcc 	andi	r4,r17,255
   21ff4:	20bf8c2e 	bgeu	r4,r2,21e28 <CheckSmSettings+0x48>
            pSyncMan = GetSyncMan(i);
   21ff8:	0021cf40 	call	21cf4 <GetSyncMan>
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21ffc:	10800183 	ldbu	r2,6(r2)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   22000:	8c400044 	addi	r17,r17,1
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   22004:	d0a15385 	stb	r2,-31410(gp)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   22008:	003ff806 	br	21fec <CheckSmSettings+0x20c>
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
   2200c:	d121558b 	ldhu	r4,-31402(gp)
   22010:	18ffffcc 	andi	r3,r3,65535
   22014:	193fec1e 	bne	r3,r4,21fc8 <CheckSmSettings+0x1e8>
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   22018:	1006d1ba 	srli	r3,r2,6
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   2201c:	1080008c 	andi	r2,r2,2
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   22020:	18c0004c 	andi	r3,r3,1
                                bWdTrigger = TRUE;
   22024:	d0e162c5 	stb	r3,-31349(gp)
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   22028:	103ff026 	beq	r2,zero,21fec <CheckSmSettings+0x20c>
                                b3BufferMode = FALSE;
   2202c:	d0215b05 	stb	zero,-31380(gp)
   22030:	003fee06 	br	21fec <CheckSmSettings+0x20c>
        else if (SMLength != 0 || nPdOutputSize != 0)
   22034:	d0a1580b 	ldhu	r2,-31392(gp)
   22038:	1104b03a 	or	r2,r2,r4
   2203c:	10bfffcc 	andi	r2,r2,65535
   22040:	103fea26 	beq	r2,zero,21fec <CheckSmSettings+0x20c>
   22044:	003fe006 	br	21fc8 <CheckSmSettings+0x1e8>
                return ALSTATUSCODE_NOVALIDFIRMWARE;
   22048:	04000504 	movi	r16,20
   2204c:	003f7606 	br	21e28 <CheckSmSettings+0x48>

00022050 <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
   22050:	defff104 	addi	sp,sp,-60
   22054:	dc800715 	stw	r18,28(sp)
   22058:	dc000515 	stw	r16,20(sp)
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   2205c:	048000f4 	movhi	r18,3
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   22060:	040000f4 	movhi	r16,3
   22064:	84233204 	addi	r16,r16,-29496
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   22068:	94a32104 	addi	r18,r18,-29564
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   2206c:	01000084 	movi	r4,2
{
   22070:	dd000915 	stw	r20,36(sp)
   22074:	dcc00815 	stw	r19,32(sp)
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   22078:	9500030b 	ldhu	r20,12(r18)
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   2207c:	84c0030b 	ldhu	r19,12(r16)
{
   22080:	dfc00e15 	stw	ra,56(sp)
   22084:	df000d15 	stw	fp,52(sp)
   22088:	ddc00c15 	stw	r23,48(sp)
   2208c:	dd800b15 	stw	r22,44(sp)
   22090:	dd400a15 	stw	r21,40(sp)
   22094:	dc400615 	stw	r17,24(sp)
    UINT16     wdiv = 0;
   22098:	d800020d 	sth	zero,8(sp)
    UINT16     wd = 0;
   2209c:	d800028d 	sth	zero,10(sp)
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
   220a0:	d8000315 	stw	zero,12(sp)
    UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
   220a4:	d8000415 	stw	zero,16(sp)
    u16ALEventMask = 0;
   220a8:	d021548d 	sth	zero,-31406(gp)
    bEcatFirstOutputsReceived = FALSE;
   220ac:	d0216305 	stb	zero,-31348(gp)
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   220b0:	0021cf40 	call	21cf4 <GetSyncMan>
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   220b4:	10c0000b 	ldhu	r3,0(r2)
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220b8:	10800103 	ldbu	r2,4(r2)
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   220bc:	d0e1558d 	sth	r3,-31402(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220c0:	1080008c 	andi	r2,r2,2
   220c4:	1000491e 	bne	r2,zero,221ec <StartInputHandler+0x19c>
    UINT16    nPdOutputBuffer = 3;
   220c8:	070000c4 	movi	fp,3
       nPdOutputBuffer = 1;
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   220cc:	010000c4 	movi	r4,3
   220d0:	0021cf40 	call	21cf4 <GetSyncMan>
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   220d4:	1440000b 	ldhu	r17,0(r2)


    /* get the number of input buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220d8:	10800103 	ldbu	r2,4(r2)
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   220dc:	d461550d 	sth	r17,-31404(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220e0:	1080008c 	andi	r2,r2,2
   220e4:	1000431e 	bne	r2,zero,221f4 <StartInputHandler+0x1a4>
    UINT16    nPdInputBuffer = 3;
   220e8:	010000c4 	movi	r4,3
        nPdInputBuffer = 1;
    }
    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   220ec:	d5a1588b 	ldhu	r22,-31390(gp)
   220f0:	210000cc 	andi	r4,r4,3
   220f4:	8c7fffcc 	andi	r17,r17,65535
   220f8:	b00b883a 	mov	r5,r22
   220fc:	00270240 	call	27024 <__mulsi3>
   22100:	d0e16a0b 	ldhu	r3,-31320(gp)
   22104:	1445883a 	add	r2,r2,r17
   22108:	1880030e 	bge	r3,r2,22118 <StartInputHandler+0xc8>
   2210c:	d1216b8b 	ldhu	r4,-31314(gp)
   22110:	20c9883a 	add	r4,r4,r3
   22114:	8901a316 	blt	r17,r4,227a4 <StartInputHandler+0x754>
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   22118:	d5e16a8b 	ldhu	r23,-31318(gp)
   2211c:	b880030e 	bge	r23,r2,2212c <StartInputHandler+0xdc>
   22120:	d0a16b0b 	ldhu	r2,-31316(gp)
   22124:	15c5883a 	add	r2,r2,r23
   22128:	88819e16 	blt	r17,r2,227a4 <StartInputHandler+0x754>
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   2212c:	d121580b 	ldhu	r4,-31392(gp)
   22130:	e14000cc 	andi	r5,fp,3
   22134:	d8c00015 	stw	r3,0(sp)
   22138:	d561558b 	ldhu	r21,-31402(gp)
   2213c:	00270240 	call	27024 <__mulsi3>
    if (
   22140:	d8c00017 	ldw	r3,0(sp)
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   22144:	1545883a 	add	r2,r2,r21
    if (
   22148:	1880030e 	bge	r3,r2,22158 <StartInputHandler+0x108>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   2214c:	d1216b8b 	ldhu	r4,-31314(gp)
   22150:	20c7883a 	add	r3,r4,r3
   22154:	a8c19516 	blt	r21,r3,227ac <StartInputHandler+0x75c>
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   22158:	b880030e 	bge	r23,r2,22168 <StartInputHandler+0x118>
   2215c:	d0e16b0b 	ldhu	r3,-31316(gp)
   22160:	1dc7883a 	add	r3,r3,r23
   22164:	a8c19116 	blt	r21,r3,227ac <StartInputHandler+0x75c>
        ||
   22168:	8880020e 	bge	r17,r2,22174 <StartInputHandler+0x124>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
   2216c:	8da3883a 	add	r17,r17,r22
   22170:	ac418e16 	blt	r21,r17,227ac <StartInputHandler+0x75c>
        --- Check configured synchronization ---
    */

    /* Get the DC Control/Activation register value*/
    /*Read register 0x981 (corresponding masks are adapted)*/
    HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
   22174:	01800044 	movi	r6,1
   22178:	01426044 	movi	r5,2433
   2217c:	d9000184 	addi	r4,sp,6
   22180:	00205e00 	call	205e0 <HW_EscRead>

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
   22184:	01800104 	movi	r6,4
   22188:	01426804 	movi	r5,2464
   2218c:	d9000304 	addi	r4,sp,12
   22190:	00205e00 	call	205e0 <HW_EscRead>
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);

    // Cycle time for Sync1
        HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
   22194:	01800104 	movi	r6,4
   22198:	01426904 	movi	r5,2468
   2219c:	d9000404 	addi	r4,sp,16
   221a0:	00205e00 	call	205e0 <HW_EscRead>
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   221a4:	d9400183 	ldbu	r5,6(sp)
        shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
   221a8:	dd400417 	ldw	r21,16(sp)
    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
   221ac:	80c0008b 	ldhu	r3,2(r16)
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
   221b0:	2980024c 	andi	r6,r5,9
   221b4:	9080008b 	ldhu	r2,2(r18)
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   221b8:	3000101e 	bne	r6,zero,221fc <StartInputHandler+0x1ac>


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
   221bc:	d1216d83 	ldbu	r4,-31306(gp)
   221c0:	21403fcc 	andi	r5,r4,255
   221c4:	28003f1e 	bne	r5,zero,222c4 <StartInputHandler+0x274>
            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
                
                if (nPdInputSize > 0)
   221c8:	d0a1588b 	ldhu	r2,-31390(gp)
            if (nPdOutputSize > 0)
   221cc:	d161580b 	ldhu	r5,-31392(gp)
   221d0:	10ffffcc 	andi	r3,r2,65535
   221d4:	28005826 	beq	r5,zero,22338 <StartInputHandler+0x2e8>
                if (nPdInputSize > 0)
   221d8:	1800c21e 	bne	r3,zero,224e4 <StartInputHandler+0x494>
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
   221dc:	d0e15b03 	ldbu	r3,-31380(gp)
   221e0:	1800a426 	beq	r3,zero,22474 <StartInputHandler+0x424>
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
   221e4:	00c00044 	movi	r3,1
   221e8:	00007d06 	br	223e0 <StartInputHandler+0x390>
       nPdOutputBuffer = 1;
   221ec:	07000044 	movi	fp,1
   221f0:	003fb606 	br	220cc <StartInputHandler+0x7c>
        nPdInputBuffer = 1;
   221f4:	01000044 	movi	r4,1
   221f8:	003fbc06 	br	220ec <StartInputHandler+0x9c>
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
   221fc:	2900008c 	andi	r4,r5,2
   22200:	20004926 	beq	r4,zero,22328 <StartInputHandler+0x2d8>
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   22204:	9d08703a 	and	r4,r19,r20
        if(u16MinSuppSyncType != 0)
   22208:	21bfffcc 	andi	r6,r4,65535
   2220c:	30000626 	beq	r6,zero,22228 <StartInputHandler+0x1d8>
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
   22210:	2180010c 	andi	r6,r4,4
   22214:	30004426 	beq	r6,zero,22328 <StartInputHandler+0x2d8>
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
   22218:	2180020c 	andi	r6,r4,8
   2221c:	3000021e 	bne	r6,zero,22228 <StartInputHandler+0x1d8>
   22220:	2980010c 	andi	r6,r5,4
   22224:	3000401e 	bne	r6,zero,22328 <StartInputHandler+0x2d8>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   22228:	d9c00317 	ldw	r7,12(sp)
            curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
   2222c:	82000417 	ldw	r8,16(r16)
   22230:	2980018c 	andi	r6,r5,6
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   22234:	3800131e 	bne	r7,zero,22284 <StartInputHandler+0x234>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   22238:	31800198 	cmpnei	r6,r6,6
   2223c:	3000011e 	bne	r6,zero,22244 <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   22240:	a800171e 	bne	r21,zero,222a0 <StartInputHandler+0x250>
    if(bSyncSetByUser)
   22244:	d1216d83 	ldbu	r4,-31306(gp)
   22248:	2000391e 	bne	r4,zero,22330 <StartInputHandler+0x2e0>
            if (nPdOutputSize > 0)
   2224c:	d0a1580b 	ldhu	r2,-31392(gp)
   22250:	1000701e 	bne	r2,zero,22414 <StartInputHandler+0x3c4>
   22254:	0009883a 	mov	r4,zero
            if (nPdInputSize > 0)
   22258:	d0e1588b 	ldhu	r3,-31390(gp)
   2225c:	d0a15b03 	ldbu	r2,-31380(gp)
   22260:	18003726 	beq	r3,zero,22340 <StartInputHandler+0x2f0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22264:	2940010c 	andi	r5,r5,4
   22268:	2800911e 	bne	r5,zero,224b0 <StartInputHandler+0x460>
    if ( !b3BufferMode )
   2226c:	10008126 	beq	r2,zero,22474 <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   22270:	00800084 	movi	r2,2

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
   22274:	00c00044 	movi	r3,1
   22278:	d0e15b45 	stb	r3,-31379(gp)
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
   2227c:	0007883a 	mov	r3,zero
   22280:	00005906 	br	223e8 <StartInputHandler+0x398>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   22284:	3a014b36 	bltu	r7,r8,227b4 <StartInputHandler+0x764>
   22288:	0230d434 	movhi	r8,50000
   2228c:	41c14936 	bltu	r8,r7,227b4 <StartInputHandler+0x764>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   22290:	318001a0 	cmpeqi	r6,r6,6
   22294:	303feb26 	beq	r6,zero,22244 <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   22298:	a83fea26 	beq	r21,zero,22244 <StartInputHandler+0x1f4>
   2229c:	a9ffe936 	bltu	r21,r7,22244 <StartInputHandler+0x1f4>
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
   222a0:	2100040c 	andi	r4,r4,16
   222a4:	20002026 	beq	r4,zero,22328 <StartInputHandler+0x2d8>
    if(bSyncSetByUser)
   222a8:	d1216d83 	ldbu	r4,-31306(gp)
   222ac:	2000151e 	bne	r4,zero,22304 <StartInputHandler+0x2b4>
            if (nPdOutputSize > 0)
   222b0:	d0e1580b 	ldhu	r3,-31392(gp)
                if (nPdInputSize > 0)
   222b4:	d0a1588b 	ldhu	r2,-31390(gp)
            if (nPdOutputSize > 0)
   222b8:	18003c1e 	bne	r3,zero,223ac <StartInputHandler+0x35c>
                bSubordinatedCycles = TRUE;
   222bc:	01000044 	movi	r4,1
   222c0:	003fe506 	br	22258 <StartInputHandler+0x208>
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   222c4:	193fff84 	addi	r4,r3,-2
   222c8:	213fffcc 	andi	r4,r4,65535
   222cc:	210000b0 	cmpltui	r4,r4,2
   222d0:	2000151e 	bne	r4,zero,22328 <StartInputHandler+0x2d8>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
   222d4:	113fff84 	addi	r4,r2,-2
   222d8:	213fffcc 	andi	r4,r4,65535
   222dc:	210000b0 	cmpltui	r4,r4,2
   222e0:	2000111e 	bne	r4,zero,22328 <StartInputHandler+0x2d8>
   222e4:	3009883a 	mov	r4,r6
    if ( !b3BufferMode )
   222e8:	d1a15b03 	ldbu	r6,-31380(gp)
   222ec:	197fffcc 	andi	r5,r3,65535
   222f0:	3000761e 	bne	r6,zero,224cc <StartInputHandler+0x47c>
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
   222f4:	28005f26 	beq	r5,zero,22474 <StartInputHandler+0x424>
   222f8:	117fffcc 	andi	r5,r2,65535
   222fc:	2800381e 	bne	r5,zero,223e0 <StartInputHandler+0x390>
   22300:	00005c06 	br	22474 <StartInputHandler+0x424>
                bSubordinatedCycles = TRUE;
   22304:	01000044 	movi	r4,1
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
   22308:	2940010c 	andi	r5,r5,4
   2230c:	19bfffcc 	andi	r6,r3,65535
   22310:	2800491e 	bne	r5,zero,22438 <StartInputHandler+0x3e8>
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
   22314:	314000e0 	cmpeqi	r5,r6,3
   22318:	2800031e 	bne	r5,zero,22328 <StartInputHandler+0x2d8>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
   2231c:	117fffcc 	andi	r5,r2,65535
   22320:	294000e0 	cmpeqi	r5,r5,3
   22324:	28004626 	beq	r5,zero,22440 <StartInputHandler+0x3f0>
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
   22328:	00800c04 	movi	r2,48
   2232c:	00005206 	br	22478 <StartInputHandler+0x428>
    BOOL bSubordinatedCycles = FALSE;
   22330:	0009883a 	mov	r4,zero
   22334:	003ff406 	br	22308 <StartInputHandler+0x2b8>
            else if (nPdInputSize > 0)
   22338:	d0a15b03 	ldbu	r2,-31380(gp)
   2233c:	18004c1e 	bne	r3,zero,22470 <StartInputHandler+0x420>
    if ( !b3BufferMode )
   22340:	10004c26 	beq	r2,zero,22474 <StartInputHandler+0x424>
        if(bEscIntEnabled)
   22344:	d0a15b43 	ldbu	r2,-31379(gp)
   22348:	1000681e 	bne	r2,zero,224ec <StartInputHandler+0x49c>
   2234c:	0007883a 	mov	r3,zero
            }
        }



    sSyncManOutPar.u16SyncType = SyncType0x1C32;
   22350:	80c0008d 	sth	r3,2(r16)
    LatchInputSync0Counter = 0;
    u16SmSync0Value = 0;
    u16SmSync0Counter = 0;


    if(bSubordinatedCycles == TRUE)
   22354:	24003fcc 	andi	r16,r4,255
    sSyncManInPar.u16SyncType = SyncType0x1C33;
   22358:	9080008d 	sth	r2,2(r18)
    LatchInputSync0Value = 0;
   2235c:	d0215c8d 	sth	zero,-31374(gp)
    LatchInputSync0Counter = 0;
   22360:	d0215c0d 	sth	zero,-31376(gp)
    u16SmSync0Value = 0;
   22364:	d021608d 	sth	zero,-31358(gp)
    u16SmSync0Counter = 0;
   22368:	d021610d 	sth	zero,-31356(gp)
    if(bSubordinatedCycles == TRUE)
   2236c:	81000058 	cmpnei	r4,r16,1
   22370:	2000d31e 	bne	r4,zero,226c0 <StartInputHandler+0x670>
    {
        
        UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
   22374:	dc800317 	ldw	r18,12(sp)
   22378:	aca7883a 	add	r19,r21,r18

        /* get the number of Sync0 event within on SM cycle */
        if(shiftTimeSync1 >= cycleTimeSync0)
        {

            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   2237c:	900b883a 	mov	r5,r18
   22380:	9809883a 	mov	r4,r19
   22384:	0026f640 	call	26f64 <__udivsi3>
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22388:	900b883a 	mov	r5,r18
   2238c:	9809883a 	mov	r4,r19
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   22390:	1023883a 	mov	r17,r2
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22394:	0026fc80 	call	26fc8 <__umodsi3>
        if(shiftTimeSync1 >= cycleTimeSync0)
   22398:	ac80c636 	bltu	r21,r18,226b4 <StartInputHandler+0x664>
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   2239c:	10006c26 	beq	r2,zero,22550 <StartInputHandler+0x500>
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   223a0:	d461608d 	sth	r17,-31358(gp)
        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);

        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
        {
            LatchInputSync0Value++;
   223a4:	8c400044 	addi	r17,r17,1
   223a8:	00006b06 	br	22558 <StartInputHandler+0x508>
            if (nPdInputSize > 0)
   223ac:	10ffffcc 	andi	r3,r2,65535
   223b0:	18000326 	beq	r3,zero,223c0 <StartInputHandler+0x370>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   223b4:	2940010c 	andi	r5,r5,4
   223b8:	28002b26 	beq	r5,zero,22468 <StartInputHandler+0x418>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   223bc:	008000c4 	movi	r2,3
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   223c0:	01000044 	movi	r4,1
    if ( !b3BufferMode )
   223c4:	d0e15b03 	ldbu	r3,-31380(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   223c8:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   223cc:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   223d0:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   223d4:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   223d8:	18003826 	beq	r3,zero,224bc <StartInputHandler+0x46c>
   223dc:	00c000c4 	movi	r3,3
        bEscIntEnabled = TRUE;
   223e0:	01400044 	movi	r5,1
   223e4:	d1615b45 	stb	r5,-31379(gp)
            if(nPdOutputSize > 0)
   223e8:	d1a1580b 	ldhu	r6,-31392(gp)
   223ec:	197fff84 	addi	r5,r3,-2
   223f0:	30004026 	beq	r6,zero,224f4 <StartInputHandler+0x4a4>
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   223f4:	01810004 	movi	r6,1024
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   223f8:	297fffcc 	andi	r5,r5,65535
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   223fc:	d1a1548d 	sth	r6,-31406(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22400:	294000a8 	cmpgeui	r5,r5,2
   22404:	2800461e 	bne	r5,zero,22520 <StartInputHandler+0x4d0>
            bDcSyncActive = TRUE;
   22408:	01400044 	movi	r5,1
   2240c:	d1616285 	stb	r5,-31350(gp)
            if (nPdOutputSize == 0)
   22410:	003fcf06 	br	22350 <StartInputHandler+0x300>
            if (nPdInputSize > 0)
   22414:	d0a1588b 	ldhu	r2,-31390(gp)
   22418:	10ffffcc 	andi	r3,r2,65535
   2241c:	18000426 	beq	r3,zero,22430 <StartInputHandler+0x3e0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22420:	2940010c 	andi	r5,r5,4
   22424:	2809883a 	mov	r4,r5
   22428:	28001f26 	beq	r5,zero,224a8 <StartInputHandler+0x458>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   2242c:	008000c4 	movi	r2,3
            if (nPdInputSize > 0)
   22430:	0009883a 	mov	r4,zero
   22434:	00000406 	br	22448 <StartInputHandler+0x3f8>
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22438:	314000d8 	cmpnei	r5,r6,3
   2243c:	283fe126 	beq	r5,zero,223c4 <StartInputHandler+0x374>
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   22440:	31800098 	cmpnei	r6,r6,2
   22444:	303fa81e 	bne	r6,zero,222e8 <StartInputHandler+0x298>
    if ( !b3BufferMode )
   22448:	d0e15b03 	ldbu	r3,-31380(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   2244c:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22450:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22454:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22458:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   2245c:	18001926 	beq	r3,zero,224c4 <StartInputHandler+0x474>
   22460:	00c00084 	movi	r3,2
   22464:	003fde06 	br	223e0 <StartInputHandler+0x390>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   22468:	00800084 	movi	r2,2
   2246c:	003fd406 	br	223c0 <StartInputHandler+0x370>
    if ( !b3BufferMode )
   22470:	10001a1e 	bne	r2,zero,224dc <StartInputHandler+0x48c>
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
   22474:	00800a44 	movi	r2,41

    /*write initial input data*/
    PDO_InputMapping();

    return ALSTATUSCODE_NOERROR;
}
   22478:	dfc00e17 	ldw	ra,56(sp)
   2247c:	df000d17 	ldw	fp,52(sp)
   22480:	ddc00c17 	ldw	r23,48(sp)
   22484:	dd800b17 	ldw	r22,44(sp)
   22488:	dd400a17 	ldw	r21,40(sp)
   2248c:	dd000917 	ldw	r20,36(sp)
   22490:	dcc00817 	ldw	r19,32(sp)
   22494:	dc800717 	ldw	r18,28(sp)
   22498:	dc400617 	ldw	r17,24(sp)
   2249c:	dc000517 	ldw	r16,20(sp)
   224a0:	dec00f04 	addi	sp,sp,60
   224a4:	f800283a 	ret
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   224a8:	00800084 	movi	r2,2
   224ac:	003fe606 	br	22448 <StartInputHandler+0x3f8>
    if ( !b3BufferMode )
   224b0:	103ff026 	beq	r2,zero,22474 <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   224b4:	008000c4 	movi	r2,3
   224b8:	003f6e06 	br	22274 <StartInputHandler+0x224>
    if ( !b3BufferMode )
   224bc:	00c000c4 	movi	r3,3
   224c0:	003f8d06 	br	222f8 <StartInputHandler+0x2a8>
   224c4:	00c00084 	movi	r3,2
   224c8:	003f8b06 	br	222f8 <StartInputHandler+0x2a8>
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
   224cc:	283fc41e 	bne	r5,zero,223e0 <StartInputHandler+0x390>
   224d0:	10ffffcc 	andi	r3,r2,65535
   224d4:	183f9b26 	beq	r3,zero,22344 <StartInputHandler+0x2f4>
   224d8:	003f6606 	br	22274 <StartInputHandler+0x224>
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
   224dc:	00800044 	movi	r2,1
   224e0:	003f6406 	br	22274 <StartInputHandler+0x224>
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
   224e4:	00800884 	movi	r2,34
   224e8:	003f3e06 	br	221e4 <StartInputHandler+0x194>
        if(bEscIntEnabled)
   224ec:	0005883a 	mov	r2,zero
   224f0:	003f6206 	br	2227c <StartInputHandler+0x22c>
            else if(nPdInputSize > 0)
   224f4:	d1a1588b 	ldhu	r6,-31390(gp)
   224f8:	30000226 	beq	r6,zero,22504 <StartInputHandler+0x4b4>
                u16ALEventMask = PROCESS_INPUT_EVENT;
   224fc:	01820004 	movi	r6,2048
   22500:	d1a1548d 	sth	r6,-31406(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22504:	297fffcc 	andi	r5,r5,65535
   22508:	294000b0 	cmpltui	r5,r5,2
   2250c:	28000a26 	beq	r5,zero,22538 <StartInputHandler+0x4e8>
            bDcSyncActive = TRUE;
   22510:	01400044 	movi	r5,1
   22514:	d1616285 	stb	r5,-31350(gp)
               u16ALEventMask = 0;
   22518:	d021548d 	sth	zero,-31406(gp)
   2251c:	003f8c06 	br	22350 <StartInputHandler+0x300>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
   22520:	117fffcc 	andi	r5,r2,65535
   22524:	29800098 	cmpnei	r6,r5,2
   22528:	303fb726 	beq	r6,zero,22408 <StartInputHandler+0x3b8>
   2252c:	294000d8 	cmpnei	r5,r5,3
   22530:	283fb526 	beq	r5,zero,22408 <StartInputHandler+0x3b8>
   22534:	003f8606 	br	22350 <StartInputHandler+0x300>
   22538:	117fffcc 	andi	r5,r2,65535
   2253c:	298000a0 	cmpeqi	r6,r5,2
   22540:	303ff31e 	bne	r6,zero,22510 <StartInputHandler+0x4c0>
   22544:	294000d8 	cmpnei	r5,r5,3
   22548:	283ff126 	beq	r5,zero,22510 <StartInputHandler+0x4c0>
   2254c:	003f8006 	br	22350 <StartInputHandler+0x300>
                u16SmSync0Value ++;
   22550:	88800044 	addi	r2,r17,1
   22554:	d0a1608d 	sth	r2,-31358(gp)
            LatchInputSync0Value++;
   22558:	d4615c8d 	sth	r17,-31374(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   2255c:	01800084 	movi	r6,2
   22560:	01410804 	movi	r5,1056
   22564:	d9000284 	addi	r4,sp,10
    sCycleDiag.syncFailedCounter = 0;
   22568:	d0216d0d 	sth	zero,-31308(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   2256c:	00205e00 	call	205e0 <HW_EscRead>
    if (nPdOutputSize > 0 &&  wd != 0 )
   22570:	d0e1580b 	ldhu	r3,-31392(gp)
    wd = SWAPWORD(wd);
   22574:	d880028b 	ldhu	r2,10(sp)
    if (nPdOutputSize > 0 &&  wd != 0 )
   22578:	18005f26 	beq	r3,zero,226f8 <StartInputHandler+0x6a8>
   2257c:	10bfffcc 	andi	r2,r2,65535
   22580:	10005d26 	beq	r2,zero,226f8 <StartInputHandler+0x6a8>
    HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
   22584:	01410004 	movi	r5,1024
   22588:	01800084 	movi	r6,2
   2258c:	d9000204 	addi	r4,sp,8
   22590:	00205e00 	call	205e0 <HW_EscRead>
        if ( wdiv != 0 )
   22594:	d940020b 	ldhu	r5,8(sp)
   22598:	28005426 	beq	r5,zero,226ec <StartInputHandler+0x69c>
            d *= wd;
   2259c:	d900028b 	ldhu	r4,10(sp)
   225a0:	29400084 	addi	r5,r5,2
   225a4:	00270240 	call	27024 <__mulsi3>
            d /= 25000;
   225a8:	01586a04 	movi	r5,25000
   225ac:	111869c4 	addi	r4,r2,24999
   225b0:	0026f640 	call	26f64 <__udivsi3>
            EcatWdValue = (UINT16) d;
   225b4:	d0a1560d 	sth	r2,-31400(gp)
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   225b8:	10bfffcc 	andi	r2,r2,65535
   225bc:	d0e162c3 	ldbu	r3,-31349(gp)
   225c0:	10004f1e 	bne	r2,zero,22700 <StartInputHandler+0x6b0>
   225c4:	d0a162c3 	ldbu	r2,-31349(gp)
   225c8:	10004f1e 	bne	r2,zero,22708 <StartInputHandler+0x6b8>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   225cc:	d0a15b43 	ldbu	r2,-31379(gp)
   225d0:	10004f1e 	bne	r2,zero,22710 <StartInputHandler+0x6c0>
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   225d4:	01800044 	movi	r6,1
   225d8:	01405444 	movi	r5,337
   225dc:	d90001c4 	addi	r4,sp,7
    Sync0WdValue = 0;
   225e0:	d0215e0d 	sth	zero,-31368(gp)
    Sync0WdCounter = 0;
   225e4:	d0215e8d 	sth	zero,-31366(gp)
    Sync1WdCounter = 0;
   225e8:	d0215d8d 	sth	zero,-31370(gp)
    Sync1WdValue = 0;
   225ec:	d0215d0d 	sth	zero,-31372(gp)
    bDcRunning = FALSE;
   225f0:	d0216185 	stb	zero,-31354(gp)
    bSmSyncSequenceValid = FALSE;
   225f4:	d0216005 	stb	zero,-31360(gp)
    i16WaitForPllRunningTimeout = 0;
   225f8:	d0215f8d 	sth	zero,-31362(gp)
        UINT8 u8TmpVar = 0;
   225fc:	d80001c5 	stb	zero,7(sp)
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   22600:	00205e00 	call	205e0 <HW_EscRead>
        if ((u8TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
   22604:	d88001c3 	ldbu	r2,7(sp)
   22608:	10c0020c 	andi	r3,r2,8
   2260c:	18000326 	beq	r3,zero,2261c <StartInputHandler+0x5cc>
            u16ALEventMask |= SYNC0_EVENT;
   22610:	d0e1548b 	ldhu	r3,-31406(gp)
   22614:	18c00114 	ori	r3,r3,4
   22618:	d0e1548d 	sth	r3,-31406(gp)
        if ((u8TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
   2261c:	10803fcc 	andi	r2,r2,255
   22620:	1080201c 	xori	r2,r2,128
   22624:	10bfe004 	addi	r2,r2,-128
   22628:	1000030e 	bge	r2,zero,22638 <StartInputHandler+0x5e8>
            u16ALEventMask |= SYNC1_EVENT;
   2262c:	d0a1548b 	ldhu	r2,-31406(gp)
   22630:	10800214 	ori	r2,r2,8
   22634:	d0a1548d 	sth	r2,-31406(gp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22638:	008000f4 	movhi	r2,3
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   2263c:	dc400183 	ldbu	r17,6(sp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22640:	10232b15 	stw	zero,-29524(r2)
    sSyncManInPar.u8SyncError = 0;
   22644:	008000f4 	movhi	r2,3
   22648:	10233105 	stb	zero,-29500(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   2264c:	008000f4 	movhi	r2,3
   22650:	10233c15 	stw	zero,-29456(r2)
    sSyncManOutPar.u8SyncError = 0;
   22654:	008000f4 	movhi	r2,3
   22658:	10234205 	stb	zero,-29432(r2)
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   2265c:	8880008c 	andi	r2,r17,2
   22660:	10004126 	beq	r2,zero,22768 <StartInputHandler+0x718>
        if(cycleTimeSync0 == 0)
   22664:	dc000317 	ldw	r16,12(sp)
   22668:	8c40010c 	andi	r17,r17,4
   2266c:	80002e1e 	bne	r16,zero,22728 <StartInputHandler+0x6d8>
            Sync0WdValue = 0;
   22670:	d0215e0d 	sth	zero,-31368(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   22674:	88003c26 	beq	r17,zero,22768 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   22678:	d8c00417 	ldw	r3,16(sp)
                if(Sync1Cycle < 5)
   2267c:	00800234 	movhi	r2,8
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   22680:	80c9883a 	add	r4,r16,r3
                if(Sync1Cycle < 5)
   22684:	10a847c4 	addi	r2,r2,-24289
   22688:	1100442e 	bgeu	r2,r4,2279c <StartInputHandler+0x74c>
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   2268c:	014000b4 	movhi	r5,2
   22690:	2961a804 	addi	r5,r5,-31072
   22694:	0026f640 	call	26f64 <__udivsi3>
                    Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
   22698:	1008907a 	slli	r4,r2,1
   2269c:	01400284 	movi	r5,10
   226a0:	0026f640 	call	26f64 <__udivsi3>
                Sync1WdValue += Sync0WdValue/2;
   226a4:	d0e15e0b 	ldhu	r3,-31368(gp)
   226a8:	1806d07a 	srli	r3,r3,1
   226ac:	1885883a 	add	r2,r3,r2
   226b0:	00002c06 	br	22764 <StartInputHandler+0x714>
            u16SmSync0Value = 1;
   226b4:	d421608d 	sth	r16,-31358(gp)
        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
   226b8:	103f3a1e 	bne	r2,zero,223a4 <StartInputHandler+0x354>
   226bc:	003fa606 	br	22558 <StartInputHandler+0x508>
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   226c0:	18ffffcc 	andi	r3,r3,65535
   226c4:	18c00098 	cmpnei	r3,r3,2
   226c8:	1800021e 	bne	r3,zero,226d4 <StartInputHandler+0x684>
            u16SmSync0Value = 1;
   226cc:	00c00044 	movi	r3,1
   226d0:	d0e1608d 	sth	r3,-31358(gp)
        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
   226d4:	10bfffcc 	andi	r2,r2,65535
   226d8:	108000e0 	cmpeqi	r2,r2,3
   226dc:	103f9f1e 	bne	r2,zero,2255c <StartInputHandler+0x50c>
            LatchInputSync0Value = 1;
   226e0:	00800044 	movi	r2,1
   226e4:	d0a15c8d 	sth	r2,-31374(gp)
   226e8:	003f9c06 	br	2255c <StartInputHandler+0x50c>
            wd = 0;
   226ec:	d800028d 	sth	zero,10(sp)
        EcatWdValue = 0;
   226f0:	d021560d 	sth	zero,-31400(gp)
   226f4:	003fb306 	br	225c4 <StartInputHandler+0x574>
        wdiv = 0;
   226f8:	d800020d 	sth	zero,8(sp)
   226fc:	003ffc06 	br	226f0 <StartInputHandler+0x6a0>
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   22700:	18803fcc 	andi	r2,r3,255
   22704:	103fb11e 	bne	r2,zero,225cc <StartInputHandler+0x57c>
        return ALSTATUSCODE_INVALIDWDCFG;
   22708:	008007c4 	movi	r2,31
   2270c:	003f5a06 	br	22478 <StartInputHandler+0x428>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   22710:	d0a1580b 	ldhu	r2,-31392(gp)
   22714:	103faf26 	beq	r2,zero,225d4 <StartInputHandler+0x584>
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
   22718:	d0a1548b 	ldhu	r2,-31406(gp)
   2271c:	10810014 	ori	r2,r2,1024
   22720:	d0a1548d 	sth	r2,-31406(gp)
   22724:	003fab06 	br	225d4 <StartInputHandler+0x584>
            if(Sync0Cycle < 5)
   22728:	00800234 	movhi	r2,8
   2272c:	10a847c4 	addi	r2,r2,-24289
   22730:	1400182e 	bgeu	r2,r16,22794 <StartInputHandler+0x744>
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
   22734:	014000b4 	movhi	r5,2
   22738:	2961a804 	addi	r5,r5,-31072
   2273c:	8009883a 	mov	r4,r16
   22740:	0026f640 	call	26f64 <__udivsi3>
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
   22744:	1008907a 	slli	r4,r2,1
   22748:	01400284 	movi	r5,10
   2274c:	213fff8c 	andi	r4,r4,65534
   22750:	0026f640 	call	26f64 <__udivsi3>
   22754:	d0a15e0d 	sth	r2,-31368(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   22758:	88000326 	beq	r17,zero,22768 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   2275c:	d8c00417 	ldw	r3,16(sp)
   22760:	1c3fc62e 	bgeu	r3,r16,2267c <StartInputHandler+0x62c>
                Sync1WdValue += Sync0WdValue/2;
   22764:	d0a15d0d 	sth	r2,-31372(gp)
    if(nPdOutputSize > 0)
   22768:	d0a1580b 	ldhu	r2,-31392(gp)
   2276c:	10000226 	beq	r2,zero,22778 <StartInputHandler+0x728>
        EnableSyncManChannel(PROCESS_DATA_OUT);
   22770:	01000084 	movi	r4,2
   22774:	0021d840 	call	21d84 <EnableSyncManChannel>
    if(nPdInputSize > 0)
   22778:	d0a1588b 	ldhu	r2,-31390(gp)
   2277c:	10000226 	beq	r2,zero,22788 <StartInputHandler+0x738>
        EnableSyncManChannel(PROCESS_DATA_IN);
   22780:	010000c4 	movi	r4,3
   22784:	0021d840 	call	21d84 <EnableSyncManChannel>
    PDO_InputMapping();
   22788:	0020d640 	call	20d64 <PDO_InputMapping>
    return ALSTATUSCODE_NOERROR;
   2278c:	0005883a 	mov	r2,zero
   22790:	003f3906 	br	22478 <StartInputHandler+0x428>
   22794:	00800044 	movi	r2,1
   22798:	003fee06 	br	22754 <StartInputHandler+0x704>
   2279c:	00800044 	movi	r2,1
   227a0:	003fc006 	br	226a4 <StartInputHandler+0x654>
        return ALSTATUSCODE_INVALIDSMINCFG;
   227a4:	00800784 	movi	r2,30
   227a8:	003f3306 	br	22478 <StartInputHandler+0x428>
        return ALSTATUSCODE_INVALIDSMOUTCFG;
   227ac:	00800744 	movi	r2,29
   227b0:	003f3106 	br	22478 <StartInputHandler+0x428>
                    return ALSTATUSCODE_DCSYNC0CYCLETIME;
   227b4:	00800d84 	movi	r2,54
   227b8:	003f2f06 	br	22478 <StartInputHandler+0x428>

000227bc <StartOutputHandler>:
    /* by default the SO transition should be completed in AlControlRes().
       required to support also masters which starts to send process data after the SO transition was triggered
       (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
    UINT16 result = NOERROR_INWORK;
    /*ECATCHANGE_START(V5.13) ESM1*/
    if(STATE_VALID(u8LocalErrorState))
   227bc:	d0e15a03 	ldbu	r3,-31384(gp)
   227c0:	00804584 	movi	r2,278
   227c4:	18c003cc 	andi	r3,r3,15
   227c8:	10c4d83a 	srl	r2,r2,r3
   227cc:	1080004c 	andi	r2,r2,1
   227d0:	10000226 	beq	r2,zero,227dc <StartOutputHandler+0x20>
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
        return u16LocalErrorCode;
   227d4:	d0a15a8b 	ldhu	r2,-31382(gp)
   227d8:	f800283a 	ret
    }
/*The application ESM function is separated from this function to handle pending transitions*/


    /*DC synchronisation is active wait until pll is valid*/
    if(bDcSyncActive)
   227dc:	d0a16283 	ldbu	r2,-31350(gp)
   227e0:	10000326 	beq	r2,zero,227f0 <StartOutputHandler+0x34>
    {
        i16WaitForPllRunningTimeout = 200;
   227e4:	00803204 	movi	r2,200
   227e8:	d0a15f8d 	sth	r2,-31362(gp)

        i16WaitForPllRunningCnt = 0;
   227ec:	d0215f0d 	sth	zero,-31364(gp)
    }



    sSyncManOutPar.u16SmEventMissedCounter = 0;
   227f0:	008000f4 	movhi	r2,3
   227f4:	10233c0d 	sth	zero,-29456(r2)
    sSyncManOutPar.u8SyncError = 0;
   227f8:	008000f4 	movhi	r2,3
   227fc:	10234205 	stb	zero,-29432(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   22800:	008000f4 	movhi	r2,3
   22804:	10232b0d 	sth	zero,-29524(r2)
    sSyncManInPar.u8SyncError = 0;
   22808:	008000f4 	movhi	r2,3
   2280c:	10233105 	stb	zero,-29500(r2)
   22810:	00803fc4 	movi	r2,255


    return result;
}
   22814:	f800283a 	ret

00022818 <StopOutputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

void StopOutputHandler(void)
{
    /* reset the flags that outputs were received and that the slave is in OP */
    bEcatFirstOutputsReceived = FALSE;
   22818:	d0216305 	stb	zero,-31348(gp)
    bEcatOutputUpdateRunning = FALSE;
   2281c:	d0216385 	stb	zero,-31346(gp)
}
   22820:	f800283a 	ret

00022824 <StopInputHandler>:

*////////////////////////////////////////////////////////////////////////////////////////

void StopInputHandler(void)
{
    if(nPdOutputSize > 0)
   22824:	d0a1580b 	ldhu	r2,-31392(gp)
{
   22828:	deffff04 	addi	sp,sp,-4
   2282c:	dfc00015 	stw	ra,0(sp)
    if(nPdOutputSize > 0)
   22830:	10000226 	beq	r2,zero,2283c <StopInputHandler+0x18>
    {
        /* disable the Sync Manager Channel 2 (outputs) */
        DisableSyncManChannel(PROCESS_DATA_OUT);
   22834:	01000084 	movi	r4,2
   22838:	0021d240 	call	21d24 <DisableSyncManChannel>
    }

    if(nPdInputSize > 0)
   2283c:	d0a1588b 	ldhu	r2,-31390(gp)
   22840:	10000226 	beq	r2,zero,2284c <StopInputHandler+0x28>
    {
        /*disable Sync Manager 3 (inputs) if no outputs available*/
        DisableSyncManChannel(PROCESS_DATA_IN);
   22844:	010000c4 	movi	r4,3
   22848:	0021d240 	call	21d24 <DisableSyncManChannel>
    {
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
        ResetMask |= PROCESS_OUTPUT_EVENT;
        ResetMask |= PROCESS_INPUT_EVENT;

    ResetALEventMask( ~(ResetMask) );
   2284c:	013cfcd4 	movui	r4,62451
   22850:	0021c240 	call	21c24 <ResetALEventMask>
    Sync1WdValue = 0;
    LatchInputSync0Value = 0;
    LatchInputSync0Counter = 0;


    sSyncManOutPar.u16SmEventMissedCounter = 0;
   22854:	008000f4 	movhi	r2,3
   22858:	10233c15 	stw	zero,-29456(r2)
    sSyncManOutPar.u16CycleExceededCounter = 0;
    sSyncManOutPar.u8SyncError = 0;
   2285c:	008000f4 	movhi	r2,3
   22860:	10234205 	stb	zero,-29432(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   22864:	008000f4 	movhi	r2,3
   22868:	10232b15 	stw	zero,-29524(r2)
    sSyncManInPar.u16CycleExceededCounter = 0;
    sSyncManInPar.u8SyncError = 0;
   2286c:	008000f4 	movhi	r2,3
    bEcatFirstOutputsReceived = FALSE;
   22870:	d0216305 	stb	zero,-31348(gp)
    bEscIntEnabled = FALSE;
   22874:	d0215b45 	stb	zero,-31379(gp)
    bDcSyncActive = FALSE;
   22878:	d0216285 	stb	zero,-31350(gp)
    bDcRunning = FALSE;
   2287c:	d0216185 	stb	zero,-31354(gp)
    bSmSyncSequenceValid = FALSE;
   22880:	d0216005 	stb	zero,-31360(gp)
    u16SmSync0Value = 0;
   22884:	d021608d 	sth	zero,-31358(gp)
    u16SmSync0Counter = 0;
   22888:	d021610d 	sth	zero,-31356(gp)
    Sync0WdValue = 0;
   2288c:	d0215e0d 	sth	zero,-31368(gp)
    Sync0WdCounter = 0;
   22890:	d0215e8d 	sth	zero,-31366(gp)
    Sync1WdCounter = 0;
   22894:	d0215d8d 	sth	zero,-31370(gp)
    Sync1WdValue = 0;
   22898:	d0215d0d 	sth	zero,-31372(gp)
    LatchInputSync0Value = 0;
   2289c:	d0215c8d 	sth	zero,-31374(gp)
    LatchInputSync0Counter = 0;
   228a0:	d0215c0d 	sth	zero,-31376(gp)
    sSyncManInPar.u8SyncError = 0;
   228a4:	10233105 	stb	zero,-29500(r2)

    i16WaitForPllRunningTimeout = 0;
   228a8:	d0215f8d 	sth	zero,-31362(gp)

    bWdTrigger = FALSE;
   228ac:	d02162c5 	stb	zero,-31349(gp)
    bEcatInputUpdateRunning = FALSE;
   228b0:	d0216345 	stb	zero,-31347(gp)

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
   228b4:	d0216d85 	stb	zero,-31306(gp)
}
   228b8:	dfc00017 	ldw	ra,0(sp)
   228bc:	dec00104 	addi	sp,sp,4
   228c0:	f800283a 	ret

000228c4 <BackToInitTransition>:
*////////////////////////////////////////////////////////////////////////////////////////

void BackToInitTransition(void)
{
    /* Reset indication that the user has written a sync mode*/
    bSyncSetByUser = FALSE;
   228c4:	d0216d85 	stb	zero,-31306(gp)
}
   228c8:	f800283a 	ret

000228cc <SetALStatus>:
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
    UINT16 Value = alStatusCode;

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
   228cc:	d0e156c3 	ldbu	r3,-31397(gp)
{
   228d0:	defffe04 	addi	sp,sp,-8
   228d4:	dfc00115 	stw	ra,4(sp)
    UINT16 Value = alStatusCode;
   228d8:	d940008d 	sth	r5,2(sp)
    if(nAlStatus != alStatus)
   228dc:	20803fcc 	andi	r2,r4,255
   228e0:	18800126 	beq	r3,r2,228e8 <SetALStatus+0x1c>
    {
        nAlStatus = alStatus;
   228e4:	d12156c5 	stb	r4,-31397(gp)
    }

    /*Handle Explicit Device ID is requested*/
    if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
   228e8:	d0e15683 	ldbu	r3,-31398(gp)
   228ec:	d0a156c3 	ldbu	r2,-31397(gp)
   228f0:	297fffcc 	andi	r5,r5,65535
   228f4:	18001126 	beq	r3,zero,2293c <SetALStatus+0x70>
   228f8:	10c0040c 	andi	r3,r2,16
   228fc:	18000f1e 	bne	r3,zero,2293c <SetALStatus+0x70>
   22900:	28000e1e 	bne	r5,zero,2293c <SetALStatus+0x70>
   22904:	10c003cc 	andi	r3,r2,15
   22908:	18c000e0 	cmpeqi	r3,r3,3
   2290c:	1800091e 	bne	r3,zero,22934 <SetALStatus+0x68>
    {
/*ECATCHANGE_START(V5.13) ECAT2*/
        Value = u16IdValue;
   22910:	d0e1540b 	ldhu	r3,-31408(gp)
/*ECATCHANGE_END(V5.13) ECAT2*/
        nAlStatus |= STATE_DEVID;
   22914:	10800814 	ori	r2,r2,32
        Value = u16IdValue;
   22918:	d8c0008d 	sth	r3,2(sp)
    }
    else
    {
        nAlStatus &= ~STATE_DEVID;
   2291c:	d0a156c5 	stb	r2,-31397(gp)

    if (alStatusCode != 0xFFFF)
    {
        Value = SWAPWORD(Value);

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
   22920:	01800084 	movi	r6,2
   22924:	01404d04 	movi	r5,308
   22928:	d9000084 	addi	r4,sp,2
   2292c:	00206640 	call	20664 <HW_EscWrite>
   22930:	00000606 	br	2294c <SetALStatus+0x80>
        nAlStatus &= ~STATE_DEVID;
   22934:	108037cc 	andi	r2,r2,223
   22938:	003ff806 	br	2291c <SetALStatus+0x50>
   2293c:	108037cc 	andi	r2,r2,223
   22940:	d0a156c5 	stb	r2,-31397(gp)
    if (alStatusCode != 0xFFFF)
   22944:	00bfffd4 	movui	r2,65535
   22948:	28bff51e 	bne	r5,r2,22920 <SetALStatus+0x54>
    }

    Value = nAlStatus;
   2294c:	d0a156c3 	ldbu	r2,-31397(gp)
    Value = SWAPWORD(Value);
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   22950:	01800084 	movi	r6,2
   22954:	01404c04 	movi	r5,304
   22958:	d9000084 	addi	r4,sp,2
    Value = nAlStatus;
   2295c:	d880008d 	sth	r2,2(sp)
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   22960:	00206640 	call	20664 <HW_EscWrite>

}
   22964:	dfc00117 	ldw	ra,4(sp)
   22968:	dec00204 	addi	sp,sp,8
   2296c:	f800283a 	ret

00022970 <AL_ControlInd>:
{
    UINT16        result = 0;
    UINT8            bErrAck = 0;
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
   22970:	00bfffc4 	movi	r2,-1
{
   22974:	defff704 	addi	sp,sp,-36
    EsmTimeoutCounter = -1;
   22978:	d0a1620d 	sth	r2,-31352(gp)
    bApplEsmPending = TRUE;
   2297c:	00800044 	movi	r2,1
{
   22980:	dd800615 	stw	r22,24(sp)
   22984:	dd400515 	stw	r21,20(sp)
   22988:	dd000415 	stw	r20,16(sp)
   2298c:	dcc00315 	stw	r19,12(sp)
   22990:	dc400115 	stw	r17,4(sp)
    bApplEsmPending = TRUE;
   22994:	d0a159c5 	stb	r2,-31385(gp)
   22998:	24c003cc 	andi	r19,r4,15
{
   2299c:	dfc00815 	stw	ra,32(sp)
   229a0:	ddc00715 	stw	r23,28(sp)
   229a4:	dc800215 	stw	r18,8(sp)
   229a8:	dc000015 	stw	r16,0(sp)
   229ac:	2080040c 	andi	r2,r4,16

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
    {
        bErrAck = 1;
        nAlStatus &= ~STATE_CHANGE;
   229b0:	d46156c3 	ldbu	r17,-31397(gp)
{
   229b4:	2829883a 	mov	r20,r5
   229b8:	282d883a 	mov	r22,r5
   229bc:	982b883a 	mov	r21,r19
    if ( alControl & STATE_CHANGE )
   229c0:	10005126 	beq	r2,zero,22b08 <AL_ControlInd+0x198>
        nAlStatus &= ~STATE_CHANGE;
   229c4:	00bffbc4 	movi	r2,-17
   229c8:	1462703a 	and	r17,r2,r17
        bErrAck = 1;
   229cc:	05c00044 	movi	r23,1
        nAlStatus &= ~STATE_CHANGE;
   229d0:	d46156c5 	stb	r17,-31397(gp)

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
    stateTrans = nAlStatus;
    stateTrans <<= 4;
   229d4:	8822913a 	slli	r17,r17,4
    stateTrans += alControl;
   229d8:	9c63883a 	add	r17,r19,r17

    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
   229dc:	8c803fcc 	andi	r18,r17,255
   229e0:	908010a0 	cmpeqi	r2,r18,66
   229e4:	1000951e 	bne	r2,zero,22c3c <AL_ControlInd+0x2cc>
   229e8:	908010e8 	cmpgeui	r2,r18,67
   229ec:	1000551e 	bne	r2,zero,22b44 <AL_ControlInd+0x1d4>
   229f0:	90800920 	cmpeqi	r2,r18,36
   229f4:	1000b01e 	bne	r2,zero,22cb8 <AL_ControlInd+0x348>
   229f8:	90800970 	cmpltui	r2,r18,37
   229fc:	1000491e 	bne	r2,zero,22b24 <AL_ControlInd+0x1b4>
    }

    if ( result == 0 )
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
   22a00:	d021590d 	sth	zero,-31388(gp)
        switch ( stateTrans )
   22a04:	8c7ffbc4 	addi	r17,r17,-17
   22a08:	8c403fcc 	andi	r17,r17,255
   22a0c:	88800e28 	cmpgeui	r2,r17,56
   22a10:	10005b1e 	bne	r2,zero,22b80 <AL_ControlInd+0x210>
   22a14:	882290ba 	slli	r17,r17,2
   22a18:	008000b4 	movhi	r2,2
   22a1c:	8885883a 	add	r2,r17,r2
   22a20:	108a8a17 	ldw	r2,10792(r2)
   22a24:	1000683a 	jmp	r2
   22a28:	000230fc 	xorhi	zero,zero,2243
   22a2c:	00022f04 	movi	zero,2236
   22a30:	00022cf4 	movhi	zero,2227
   22a34:	00023230 	cmpltui	zero,zero,2248
   22a38:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a3c:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a40:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a44:	00023230 	cmpltui	zero,zero,2248
   22a48:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a4c:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a50:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a54:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a58:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a5c:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a60:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a64:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a68:	000230d0 	cmplti	zero,zero,2243
   22a6c:	00023100 	call	2310 <__reset-0x1dcf0>
   22a70:	00023230 	cmpltui	zero,zero,2248
   22a74:	00022f74 	movhi	zero,2237
   22a78:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a7c:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a80:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a84:	00023230 	cmpltui	zero,zero,2248
   22a88:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a8c:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a90:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a94:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a98:	00022b80 	call	22b8 <__reset-0x1dd48>
   22a9c:	00022b80 	call	22b8 <__reset-0x1dd48>
   22aa0:	00022b80 	call	22b8 <__reset-0x1dd48>
   22aa4:	00022b80 	call	22b8 <__reset-0x1dd48>
   22aa8:	00022eac 	andhi	zero,zero,2234
   22aac:	00023230 	cmpltui	zero,zero,2248
   22ab0:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ab4:	00023230 	cmpltui	zero,zero,2248
   22ab8:	00022b80 	call	22b8 <__reset-0x1dd48>
   22abc:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ac0:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ac4:	00023230 	cmpltui	zero,zero,2248
   22ac8:	00022b80 	call	22b8 <__reset-0x1dd48>
   22acc:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ad0:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ad4:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ad8:	00022b80 	call	22b8 <__reset-0x1dd48>
   22adc:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ae0:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ae4:	00022b80 	call	22b8 <__reset-0x1dd48>
   22ae8:	000230a0 	cmpeqi	zero,zero,2242
   22aec:	00022b80 	call	22b8 <__reset-0x1dd48>
   22af0:	00023230 	cmpltui	zero,zero,2248
   22af4:	00023100 	call	2310 <__reset-0x1dcf0>
   22af8:	00022b80 	call	22b8 <__reset-0x1dd48>
   22afc:	00022b80 	call	22b8 <__reset-0x1dd48>
   22b00:	00022b80 	call	22b8 <__reset-0x1dd48>
   22b04:	00022fec 	andhi	zero,zero,2239
   22b08:	102f883a 	mov	r23,r2
    else if ((nAlStatus & STATE_CHANGE)
   22b0c:	8880040c 	andi	r2,r17,16
   22b10:	10000226 	beq	r2,zero,22b1c <AL_ControlInd+0x1ac>
        && (alControl & STATE_MASK) != STATE_INIT)
   22b14:	98800058 	cmpnei	r2,r19,1
   22b18:	1000d91e 	bne	r2,zero,22e80 <AL_ControlInd+0x510>
        nAlStatus &= STATE_MASK;
   22b1c:	8c4003cc 	andi	r17,r17,15
   22b20:	003fab06 	br	229d0 <AL_ControlInd+0x60>
    switch ( stateTrans )
   22b24:	908004a0 	cmpeqi	r2,r18,18
   22b28:	10004d1e 	bne	r2,zero,22c60 <AL_ControlInd+0x2f0>
   22b2c:	908008a0 	cmpeqi	r2,r18,34
   22b30:	10004b1e 	bne	r2,zero,22c60 <AL_ControlInd+0x2f0>
        nEcatStateTrans = 0;
   22b34:	d021590d 	sth	zero,-31388(gp)
        switch ( stateTrans )
   22b38:	90800468 	cmpgeui	r2,r18,17
   22b3c:	10001026 	beq	r2,zero,22b80 <AL_ControlInd+0x210>
   22b40:	003fb006 	br	22a04 <AL_ControlInd+0x94>
    switch ( stateTrans )
   22b44:	908020a0 	cmpeqi	r2,r18,130
   22b48:	1000281e 	bne	r2,zero,22bec <AL_ControlInd+0x27c>
   22b4c:	908020e8 	cmpgeui	r2,r18,131
   22b50:	1000101e 	bne	r2,zero,22b94 <AL_ControlInd+0x224>
   22b54:	90801120 	cmpeqi	r2,r18,68
   22b58:	10005d1e 	bne	r2,zero,22cd0 <AL_ControlInd+0x360>
   22b5c:	90801220 	cmpeqi	r2,r18,72
   22b60:	10005b1e 	bne	r2,zero,22cd0 <AL_ControlInd+0x360>
        nEcatStateTrans = 0;
   22b64:	d021590d 	sth	zero,-31388(gp)
        switch ( stateTrans )
   22b68:	90801270 	cmpltui	r2,r18,73
   22b6c:	103fa51e 	bne	r2,zero,22a04 <AL_ControlInd+0x94>
   22b70:	8c401fc4 	addi	r17,r17,127
   22b74:	8c403fcc 	andi	r17,r17,255
   22b78:	8c400228 	cmpgeui	r17,r17,8
   22b7c:	88014226 	beq	r17,zero,23088 <AL_ControlInd+0x718>
                break;
        }
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22b80:	d12156c3 	ldbu	r4,-31397(gp)
   22b84:	208003cc 	andi	r2,r4,15
   22b88:	98806426 	beq	r19,r2,22d1c <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
   22b8c:	04000484 	movi	r16,18
   22b90:	00009606 	br	22dec <AL_ControlInd+0x47c>
    switch ( stateTrans )
   22b94:	90802120 	cmpeqi	r2,r18,132
   22b98:	10004d1e 	bne	r2,zero,22cd0 <AL_ControlInd+0x360>
   22b9c:	90802220 	cmpeqi	r2,r18,136
   22ba0:	10004b1e 	bne	r2,zero,22cd0 <AL_ControlInd+0x360>
        nEcatStateTrans = 0;
   22ba4:	d021590d 	sth	zero,-31388(gp)
        switch ( stateTrans )
   22ba8:	8c401fc4 	addi	r17,r17,127
   22bac:	8c403fcc 	andi	r17,r17,255
   22bb0:	88800228 	cmpgeui	r2,r17,8
   22bb4:	103ff21e 	bne	r2,zero,22b80 <AL_ControlInd+0x210>
   22bb8:	882290ba 	slli	r17,r17,2
   22bbc:	008000b4 	movhi	r2,2
   22bc0:	8885883a 	add	r2,r17,r2
   22bc4:	108af317 	ldw	r2,11212(r2)
   22bc8:	1000683a 	jmp	r2
   22bcc:	00023088 	cmpgei	zero,zero,2242
   22bd0:	00022c04 	movi	zero,2224
   22bd4:	00023230 	cmpltui	zero,zero,2248
   22bd8:	00023078 	rdprs	zero,zero,2241
   22bdc:	00022b80 	call	22b8 <__reset-0x1dd48>
   22be0:	00022b80 	call	22b8 <__reset-0x1dd48>
   22be4:	00022b80 	call	22b8 <__reset-0x1dd48>
   22be8:	00023100 	call	2310 <__reset-0x1dcf0>
        result = CheckSmSettings(MAILBOX_READ+1);
   22bec:	01000084 	movi	r4,2
   22bf0:	0021de00 	call	21de0 <CheckSmSettings>
   22bf4:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22bf8:	10803fcc 	andi	r2,r2,255
   22bfc:	10001d1e 	bne	r2,zero,22c74 <AL_ControlInd+0x304>
        nEcatStateTrans = 0;
   22c00:	d021590d 	sth	zero,-31388(gp)
            result = APPL_StopOutputHandler();
   22c04:	00200b00 	call	200b0 <APPL_StopOutputHandler>
   22c08:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22c0c:	00228180 	call	22818 <StopOutputHandler>
            if (result != 0)
   22c10:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22c14:	d02159c5 	stb	zero,-31385(gp)
            if (result != 0)
   22c18:	10000e26 	beq	r2,zero,22c54 <AL_ControlInd+0x2e4>
    if ( result == NOERROR_INWORK )
   22c1c:	10803fd8 	cmpnei	r2,r2,255
   22c20:	10006f1e 	bne	r2,zero,22de0 <AL_ControlInd+0x470>
        bEcatWaitForAlControlRes = TRUE;
   22c24:	00800044 	movi	r2,1
   22c28:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   22c2c:	00802084 	movi	r2,130
   22c30:	d0a1590d 	sth	r2,-31388(gp)
                break;
   22c34:	04003204 	movi	r16,200
   22c38:	00008c06 	br	22e6c <AL_ControlInd+0x4fc>
        result = CheckSmSettings(MAILBOX_READ+1);
   22c3c:	01000084 	movi	r4,2
   22c40:	0021de00 	call	21de0 <CheckSmSettings>
   22c44:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22c48:	10803fcc 	andi	r2,r2,255
   22c4c:	1000091e 	bne	r2,zero,22c74 <AL_ControlInd+0x304>
        nEcatStateTrans = 0;
   22c50:	d021590d 	sth	zero,-31388(gp)
            APPL_StopInputHandler();
   22c54:	00200a00 	call	200a0 <APPL_StopInputHandler>
            StopInputHandler();
   22c58:	00228240 	call	22824 <StopInputHandler>
   22c5c:	00010806 	br	23080 <AL_ControlInd+0x710>
        result = CheckSmSettings(MAILBOX_READ+1);
   22c60:	01000084 	movi	r4,2
   22c64:	0021de00 	call	21de0 <CheckSmSettings>
   22c68:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22c6c:	10803fcc 	andi	r2,r2,255
   22c70:	103fb026 	beq	r2,zero,22b34 <AL_ControlInd+0x1c4>
        switch (nAlStatus)
   22c74:	d12156c3 	ldbu	r4,-31397(gp)
   22c78:	85ffffcc 	andi	r23,r16,65535
   22c7c:	20803fcc 	andi	r2,r4,255
   22c80:	10c00120 	cmpeqi	r3,r2,4
   22c84:	1801351e 	bne	r3,zero,2315c <AL_ControlInd+0x7ec>
   22c88:	10c00220 	cmpeqi	r3,r2,8
   22c8c:	1801311e 	bne	r3,zero,23154 <AL_ControlInd+0x7e4>
   22c90:	10c000a0 	cmpeqi	r3,r2,2
   22c94:	1801331e 	bne	r3,zero,23164 <AL_ControlInd+0x7f4>
    if ( result == NOERROR_INWORK )
   22c98:	bdc03fe0 	cmpeqi	r23,r23,255
   22c9c:	b801561e 	bne	r23,zero,231f8 <AL_ControlInd+0x888>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ca0:	20c003cc 	andi	r3,r4,15
   22ca4:	98c0511e 	bne	r19,r3,22dec <AL_ControlInd+0x47c>
   22ca8:	1009883a 	mov	r4,r2
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
   22cac:	d0215985 	stb	zero,-31386(gp)

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
   22cb0:	000b883a 	mov	r5,zero
   22cb4:	00003606 	br	22d90 <AL_ControlInd+0x420>
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
   22cb8:	d1615804 	addi	r5,gp,-31392
   22cbc:	d1215884 	addi	r4,gp,-31390
   22cc0:	00200b80 	call	200b8 <APPL_GenerateMapping>
   22cc4:	1021883a 	mov	r16,r2
            if (result != 0)
   22cc8:	10bfffcc 	andi	r2,r2,65535
   22ccc:	103fe91e 	bne	r2,zero,22c74 <AL_ControlInd+0x304>
        result = CheckSmSettings(nMaxSyncMan);
   22cd0:	d1215783 	ldbu	r4,-31394(gp)
   22cd4:	0021de00 	call	21de0 <CheckSmSettings>
   22cd8:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22cdc:	10803fcc 	andi	r2,r2,255
   22ce0:	103fe41e 	bne	r2,zero,22c74 <AL_ControlInd+0x304>
        nEcatStateTrans = 0;
   22ce4:	d021590d 	sth	zero,-31388(gp)
        switch ( stateTrans )
   22ce8:	90801268 	cmpgeui	r2,r18,73
   22cec:	103f9226 	beq	r2,zero,22b38 <AL_ControlInd+0x1c8>
   22cf0:	003fad06 	br	22ba8 <AL_ControlInd+0x238>
            bBootMode = TRUE;
   22cf4:	04400044 	movi	r17,1
            if ( CheckSmSettings(MAILBOX_READ+1) != 0 )
   22cf8:	01000084 	movi	r4,2
            bBootMode = TRUE;
   22cfc:	d46163c5 	stb	r17,-31345(gp)
            if ( CheckSmSettings(MAILBOX_READ+1) != 0 )
   22d00:	0021de00 	call	21de0 <CheckSmSettings>
   22d04:	10803fcc 	andi	r2,r2,255
   22d08:	10000626 	beq	r2,zero,22d24 <AL_ControlInd+0x3b4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d0c:	d12156c3 	ldbu	r4,-31397(gp)
                bBootMode = FALSE;
   22d10:	d02163c5 	stb	zero,-31345(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d14:	208003cc 	andi	r2,r4,15
   22d18:	98814a1e 	bne	r19,r2,23244 <AL_ControlInd+0x8d4>
   22d1c:	21003fcc 	andi	r4,r4,255
   22d20:	003fe206 	br	22cac <AL_ControlInd+0x33c>
            ResetALEventMask(0);
   22d24:	0009883a 	mov	r4,zero
   22d28:	0021c240 	call	21c24 <ResetALEventMask>
            result = MBX_StartMailboxHandler();
   22d2c:	0023dc00 	call	23dc0 <MBX_StartMailboxHandler>
   22d30:	1021883a 	mov	r16,r2
            if (result == 0)
   22d34:	10bfffcc 	andi	r2,r2,65535
   22d38:	1000201e 	bne	r2,zero,22dbc <AL_ControlInd+0x44c>
                bApplEsmPending = FALSE;
   22d3c:	d02159c5 	stb	zero,-31385(gp)
                result = APPL_StartMailboxHandler();
   22d40:	00200880 	call	20088 <APPL_StartMailboxHandler>
   22d44:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22d48:	10bfffcc 	andi	r2,r2,65535
   22d4c:	10001b1e 	bne	r2,zero,22dbc <AL_ControlInd+0x44c>
            BL_Start( STATE_BOOT );
   22d50:	010000c4 	movi	r4,3
                    bMbxRunning = TRUE;
   22d54:	d4616c45 	stb	r17,-31311(gp)
            BL_Start( STATE_BOOT );
   22d58:	00207480 	call	20748 <BL_Start>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d5c:	d12156c3 	ldbu	r4,-31397(gp)
   22d60:	208003cc 	andi	r2,r4,15
   22d64:	98bfed26 	beq	r19,r2,22d1c <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22d68:	a0bfffcc 	andi	r2,r20,65535
   22d6c:	10014326 	beq	r2,zero,2327c <AL_ControlInd+0x90c>
   22d70:	9908b03a 	or	r4,r19,r4
   22d74:	2100020c 	andi	r4,r4,8
   22d78:	2001381e 	bne	r4,zero,2325c <AL_ControlInd+0x8ec>
                alControl |= STATE_CHANGE;
   22d7c:	9d400414 	ori	r21,r19,16
            nAlStatus |= STATE_CHANGE;
   22d80:	d56156c5 	stb	r21,-31397(gp)
        bEcatWaitForAlControlRes = FALSE;
   22d84:	d0215985 	stb	zero,-31386(gp)
        SetALStatus(nAlStatus, result);
   22d88:	b17fffcc 	andi	r5,r22,65535
   22d8c:	a9003fcc 	andi	r4,r21,255
    }
    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 state machine from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/

}
   22d90:	dfc00817 	ldw	ra,32(sp)
   22d94:	ddc00717 	ldw	r23,28(sp)
   22d98:	dd800617 	ldw	r22,24(sp)
   22d9c:	dd400517 	ldw	r21,20(sp)
   22da0:	dd000417 	ldw	r20,16(sp)
   22da4:	dcc00317 	ldw	r19,12(sp)
   22da8:	dc800217 	ldw	r18,8(sp)
   22dac:	dc400117 	ldw	r17,4(sp)
   22db0:	dc000017 	ldw	r16,0(sp)
   22db4:	dec00904 	addi	sp,sp,36
        SetALStatus(nAlStatus, 0);
   22db8:	00228cc1 	jmpi	228cc <SetALStatus>
            if(result != 0 && result != NOERROR_INWORK)
   22dbc:	80bfffcc 	andi	r2,r16,65535
   22dc0:	10803fe0 	cmpeqi	r2,r2,255
   22dc4:	1000211e 	bne	r2,zero,22e4c <AL_ControlInd+0x4dc>
                    if (!bApplEsmPending)
   22dc8:	d0a159c3 	ldbu	r2,-31385(gp)
   22dcc:	10001d26 	beq	r2,zero,22e44 <AL_ControlInd+0x4d4>
                 MBX_StopMailboxHandler();
   22dd0:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
            BL_Start( STATE_BOOT );
   22dd4:	010000c4 	movi	r4,3
   22dd8:	00207480 	call	20748 <BL_Start>
                bBootMode = FALSE;
   22ddc:	d02163c5 	stb	zero,-31345(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22de0:	d12156c3 	ldbu	r4,-31397(gp)
   22de4:	208003cc 	andi	r2,r4,15
   22de8:	98bfcc26 	beq	r19,r2,22d1c <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22dec:	9908b03a 	or	r4,r19,r4
   22df0:	2100020c 	andi	r4,r4,8
   22df4:	20000a26 	beq	r4,zero,22e20 <AL_ControlInd+0x4b0>
            if(bEcatOutputUpdateRunning)
   22df8:	d0a16383 	ldbu	r2,-31346(gp)
   22dfc:	10000226 	beq	r2,zero,22e08 <AL_ControlInd+0x498>
                APPL_StopOutputHandler();
   22e00:	00200b00 	call	200b0 <APPL_StopOutputHandler>
                StopOutputHandler();
   22e04:	00228180 	call	22818 <StopOutputHandler>
            if(nPdOutputSize > 0)
   22e08:	d0a1580b 	ldhu	r2,-31392(gp)
   22e0c:	10011526 	beq	r2,zero,23264 <AL_ControlInd+0x8f4>
                DisableSyncManChannel(PROCESS_DATA_OUT);
   22e10:	01000084 	movi	r4,2
                DisableSyncManChannel(PROCESS_DATA_IN);
   22e14:	0021d240 	call	21d24 <DisableSyncManChannel>
        if ( result != 0 )
   22e18:	80bfffcc 	andi	r2,r16,65535
   22e1c:	10011526 	beq	r2,zero,23274 <AL_ControlInd+0x904>
                if (nAlStatus == STATE_OP)
   22e20:	d0a156c3 	ldbu	r2,-31397(gp)
   22e24:	10800218 	cmpnei	r2,r2,8
   22e28:	1000021e 	bne	r2,zero,22e34 <AL_ControlInd+0x4c4>
                    nAlStatus = STATE_SAFEOP;
   22e2c:	00800104 	movi	r2,4
   22e30:	d0a156c5 	stb	r2,-31397(gp)
            nAlStatus |= STATE_CHANGE;
   22e34:	d56156c3 	ldbu	r21,-31397(gp)
   22e38:	802d883a 	mov	r22,r16
   22e3c:	ad400414 	ori	r21,r21,16
   22e40:	003fcf06 	br	22d80 <AL_ControlInd+0x410>
                        APPL_StopMailboxHandler();
   22e44:	00200900 	call	20090 <APPL_StopMailboxHandler>
   22e48:	003fe106 	br	22dd0 <AL_ControlInd+0x460>
            BL_Start( STATE_BOOT );
   22e4c:	010000c4 	movi	r4,3
   22e50:	00207480 	call	20748 <BL_Start>
        bEcatWaitForAlControlRes = TRUE;
   22e54:	00800044 	movi	r2,1
   22e58:	d0a15985 	stb	r2,-31386(gp)
                bBootMode = FALSE;
   22e5c:	d02163c5 	stb	zero,-31345(gp)
        nEcatStateTrans = stateTrans;
   22e60:	008004c4 	movi	r2,19
   22e64:	d0a1590d 	sth	r2,-31388(gp)
            break;
   22e68:	0401f404 	movi	r16,2000
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
   22e6c:	813fffcc 	andi	r4,r16,65535
   22e70:	01400284 	movi	r5,10
   22e74:	0026f640 	call	26f64 <__udivsi3>
   22e78:	80a1c83a 	sub	r16,r16,r2
   22e7c:	d421620d 	sth	r16,-31352(gp)
}
   22e80:	dfc00817 	ldw	ra,32(sp)
   22e84:	ddc00717 	ldw	r23,28(sp)
   22e88:	dd800617 	ldw	r22,24(sp)
   22e8c:	dd400517 	ldw	r21,20(sp)
   22e90:	dd000417 	ldw	r20,16(sp)
   22e94:	dcc00317 	ldw	r19,12(sp)
   22e98:	dc800217 	ldw	r18,8(sp)
   22e9c:	dc400117 	ldw	r17,4(sp)
   22ea0:	dc000017 	ldw	r16,0(sp)
   22ea4:	dec00904 	addi	sp,sp,36
   22ea8:	f800283a 	ret
            if(bBootMode)
   22eac:	d0a163c3 	ldbu	r2,-31345(gp)
   22eb0:	1000031e 	bne	r2,zero,22ec0 <AL_ControlInd+0x550>
            BL_Stop();
   22eb4:	002074c0 	call	2074c <BL_Stop>
    bSyncSetByUser = FALSE;
   22eb8:	d0216d85 	stb	zero,-31306(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ebc:	003fa706 	br	22d5c <AL_ControlInd+0x3ec>
                ResetALEventMask(0);
   22ec0:	0009883a 	mov	r4,zero
                bBootMode = FALSE;
   22ec4:	d02163c5 	stb	zero,-31345(gp)
                ResetALEventMask(0);
   22ec8:	0021c240 	call	21c24 <ResetALEventMask>
                MBX_StopMailboxHandler();
   22ecc:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
                result = APPL_StopMailboxHandler();
   22ed0:	00200900 	call	20090 <APPL_StopMailboxHandler>
   22ed4:	1021883a 	mov	r16,r2
            BL_Stop();
   22ed8:	002074c0 	call	2074c <BL_Stop>
    if ( result == NOERROR_INWORK )
   22edc:	80bfffcc 	andi	r2,r16,65535
    bSyncSetByUser = FALSE;
   22ee0:	d0216d85 	stb	zero,-31306(gp)
    if ( result == NOERROR_INWORK )
   22ee4:	10803fe0 	cmpeqi	r2,r2,255
   22ee8:	1000bf1e 	bne	r2,zero,231e8 <AL_ControlInd+0x878>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22eec:	d12156c3 	ldbu	r4,-31397(gp)
   22ef0:	208003cc 	andi	r2,r4,15
   22ef4:	98bf8926 	beq	r19,r2,22d1c <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22ef8:	80bfffcc 	andi	r2,r16,65535
   22efc:	103f9a26 	beq	r2,zero,22d68 <AL_ControlInd+0x3f8>
   22f00:	003fba06 	br	22dec <AL_ControlInd+0x47c>
           UpdateEEPROMLoadedState();
   22f04:	0021cbc0 	call	21cbc <UpdateEEPROMLoadedState>
            if (EepromLoaded == FALSE)
   22f08:	d0a15103 	ldbu	r2,-31420(gp)
   22f0c:	1000ab26 	beq	r2,zero,231bc <AL_ControlInd+0x84c>
            result = MBX_StartMailboxHandler();
   22f10:	0023dc00 	call	23dc0 <MBX_StartMailboxHandler>
   22f14:	1021883a 	mov	r16,r2
            if (result == 0)
   22f18:	10bfffcc 	andi	r2,r2,65535
   22f1c:	1000081e 	bne	r2,zero,22f40 <AL_ControlInd+0x5d0>
                bApplEsmPending = FALSE;
   22f20:	d02159c5 	stb	zero,-31385(gp)
                result = APPL_StartMailboxHandler();
   22f24:	00200880 	call	20088 <APPL_StartMailboxHandler>
   22f28:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22f2c:	10bfffcc 	andi	r2,r2,65535
   22f30:	1000031e 	bne	r2,zero,22f40 <AL_ControlInd+0x5d0>
                    bMbxRunning = TRUE;
   22f34:	00800044 	movi	r2,1
   22f38:	d0a16c45 	stb	r2,-31311(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22f3c:	003f8706 	br	22d5c <AL_ControlInd+0x3ec>
            if(result != 0 && result != NOERROR_INWORK)
   22f40:	80bfffcc 	andi	r2,r16,65535
   22f44:	10803fd8 	cmpnei	r2,r2,255
   22f48:	1000041e 	bne	r2,zero,22f5c <AL_ControlInd+0x5ec>
        bEcatWaitForAlControlRes = TRUE;
   22f4c:	00800044 	movi	r2,1
   22f50:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   22f54:	00800484 	movi	r2,18
   22f58:	003fc206 	br	22e64 <AL_ControlInd+0x4f4>
                    if (!bApplEsmPending)
   22f5c:	d0a159c3 	ldbu	r2,-31385(gp)
   22f60:	10000226 	beq	r2,zero,22f6c <AL_ControlInd+0x5fc>
                 MBX_StopMailboxHandler();
   22f64:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
   22f68:	003f9d06 	br	22de0 <AL_ControlInd+0x470>
                        APPL_StopMailboxHandler();
   22f6c:	00200900 	call	20090 <APPL_StopMailboxHandler>
   22f70:	003ffc06 	br	22f64 <AL_ControlInd+0x5f4>
            result = StartInputHandler();
   22f74:	00220500 	call	22050 <StartInputHandler>
   22f78:	1021883a 	mov	r16,r2
            if ( result == 0 )
   22f7c:	10bfffcc 	andi	r2,r2,65535
   22f80:	10000b1e 	bne	r2,zero,22fb0 <AL_ControlInd+0x640>
                result = APPL_StartInputHandler(&u16ALEventMask);
   22f84:	d1215484 	addi	r4,gp,-31406
                bApplEsmPending = FALSE;
   22f88:	d02159c5 	stb	zero,-31385(gp)
                result = APPL_StartInputHandler(&u16ALEventMask);
   22f8c:	00200980 	call	20098 <APPL_StartInputHandler>
   22f90:	1021883a 	mov	r16,r2
                if(result == 0)
   22f94:	10bfffcc 	andi	r2,r2,65535
   22f98:	1000051e 	bne	r2,zero,22fb0 <AL_ControlInd+0x640>
                    SetALEventMask( u16ALEventMask );
   22f9c:	d121548b 	ldhu	r4,-31406(gp)
   22fa0:	0021c700 	call	21c70 <SetALEventMask>
                    bEcatInputUpdateRunning = TRUE;
   22fa4:	00800044 	movi	r2,1
   22fa8:	d0a16345 	stb	r2,-31347(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22fac:	003f6b06 	br	22d5c <AL_ControlInd+0x3ec>
            if(result != 0 && result != NOERROR_INWORK)
   22fb0:	80bfffcc 	andi	r2,r16,65535
   22fb4:	10803fd8 	cmpnei	r2,r2,255
   22fb8:	1000061e 	bne	r2,zero,22fd4 <AL_ControlInd+0x664>
        bEcatWaitForAlControlRes = TRUE;
   22fbc:	00800044 	movi	r2,1
   22fc0:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   22fc4:	00800904 	movi	r2,36
   22fc8:	d0a1590d 	sth	r2,-31388(gp)
                break;
   22fcc:	0408ca04 	movi	r16,9000
   22fd0:	003fa606 	br	22e6c <AL_ControlInd+0x4fc>
                if(!bApplEsmPending)
   22fd4:	d0a159c3 	ldbu	r2,-31385(gp)
   22fd8:	10000226 	beq	r2,zero,22fe4 <AL_ControlInd+0x674>
                StopInputHandler();
   22fdc:	00228240 	call	22824 <StopInputHandler>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22fe0:	003f7f06 	br	22de0 <AL_ControlInd+0x470>
                    APPL_StopInputHandler();
   22fe4:	00200a00 	call	200a0 <APPL_StopInputHandler>
   22fe8:	003ffc06 	br	22fdc <AL_ControlInd+0x66c>
            if (bErrAck)
   22fec:	bdc03fcc 	andi	r23,r23,255
   22ff0:	b8000426 	beq	r23,zero,23004 <AL_ControlInd+0x694>
                if (nPdOutputSize > 0)
   22ff4:	d0a1580b 	ldhu	r2,-31392(gp)
   22ff8:	10000e26 	beq	r2,zero,23034 <AL_ControlInd+0x6c4>
                    EnableSyncManChannel(PROCESS_DATA_OUT);
   22ffc:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   23000:	0021d840 	call	21d84 <EnableSyncManChannel>
            result = StartOutputHandler();
   23004:	00227bc0 	call	227bc <StartOutputHandler>
   23008:	1021883a 	mov	r16,r2
            if(result == 0)
   2300c:	10bfffcc 	andi	r2,r2,65535
   23010:	10000c1e 	bne	r2,zero,23044 <AL_ControlInd+0x6d4>
                bApplEsmPending = FALSE;
   23014:	d02159c5 	stb	zero,-31385(gp)
                result = APPL_StartOutputHandler();
   23018:	00200a80 	call	200a8 <APPL_StartOutputHandler>
   2301c:	1021883a 	mov	r16,r2
                if(result == 0)
   23020:	10bfffcc 	andi	r2,r2,65535
   23024:	1000071e 	bne	r2,zero,23044 <AL_ControlInd+0x6d4>
                    bEcatOutputUpdateRunning = TRUE;
   23028:	00800044 	movi	r2,1
   2302c:	d0a16385 	stb	r2,-31346(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23030:	003f4a06 	br	22d5c <AL_ControlInd+0x3ec>
                    if (nPdInputSize > 0)
   23034:	d0a1588b 	ldhu	r2,-31390(gp)
   23038:	103ff226 	beq	r2,zero,23004 <AL_ControlInd+0x694>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   2303c:	010000c4 	movi	r4,3
   23040:	003fef06 	br	23000 <AL_ControlInd+0x690>
            if ( result != 0 && result != NOERROR_INWORK)
   23044:	80bfffcc 	andi	r2,r16,65535
   23048:	10803fd8 	cmpnei	r2,r2,255
   2304c:	1000041e 	bne	r2,zero,23060 <AL_ControlInd+0x6f0>
        bEcatWaitForAlControlRes = TRUE;
   23050:	00800044 	movi	r2,1
   23054:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   23058:	00801204 	movi	r2,72
   2305c:	003fda06 	br	22fc8 <AL_ControlInd+0x658>
                    if (!bApplEsmPending)
   23060:	d0a159c3 	ldbu	r2,-31385(gp)
   23064:	10000226 	beq	r2,zero,23070 <AL_ControlInd+0x700>
                StopOutputHandler();
   23068:	00228180 	call	22818 <StopOutputHandler>
    if ( result == NOERROR_INWORK )
   2306c:	003f5c06 	br	22de0 <AL_ControlInd+0x470>
                        APPL_StopOutputHandler();
   23070:	00200b00 	call	200b0 <APPL_StopOutputHandler>
   23074:	003ffc06 	br	23068 <AL_ControlInd+0x6f8>
            APPL_StopOutputHandler();
   23078:	00200b00 	call	200b0 <APPL_StopOutputHandler>
            StopOutputHandler();
   2307c:	00228180 	call	22818 <StopOutputHandler>
            bApplEsmPending = FALSE;
   23080:	d02159c5 	stb	zero,-31385(gp)
   23084:	003f3506 	br	22d5c <AL_ControlInd+0x3ec>
            result = APPL_StopOutputHandler();
   23088:	00200b00 	call	200b0 <APPL_StopOutputHandler>
   2308c:	1021883a 	mov	r16,r2
            StopOutputHandler();
   23090:	00228180 	call	22818 <StopOutputHandler>
            if (result != 0)
   23094:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   23098:	d02159c5 	stb	zero,-31385(gp)
            if (result != 0)
   2309c:	10004c1e 	bne	r2,zero,231d0 <AL_ControlInd+0x860>
            result = APPL_StopInputHandler();
   230a0:	00200a00 	call	200a0 <APPL_StopInputHandler>
   230a4:	1021883a 	mov	r16,r2
            StopInputHandler();
   230a8:	00228240 	call	22824 <StopInputHandler>
            if (result != 0)
   230ac:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   230b0:	d02159c5 	stb	zero,-31385(gp)
            if (result != 0)
   230b4:	10000626 	beq	r2,zero,230d0 <AL_ControlInd+0x760>
    if ( result == NOERROR_INWORK )
   230b8:	10803fd8 	cmpnei	r2,r2,255
   230bc:	103f481e 	bne	r2,zero,22de0 <AL_ControlInd+0x470>
        bEcatWaitForAlControlRes = TRUE;
   230c0:	00800044 	movi	r2,1
   230c4:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   230c8:	00801044 	movi	r2,65
   230cc:	003ed806 	br	22c30 <AL_ControlInd+0x2c0>
            MBX_StopMailboxHandler();
   230d0:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
   230d4:	00200900 	call	20090 <APPL_StopMailboxHandler>
   230d8:	1021883a 	mov	r16,r2
    if ( result == NOERROR_INWORK )
   230dc:	10bfffcc 	andi	r2,r2,65535
    bSyncSetByUser = FALSE;
   230e0:	d0216d85 	stb	zero,-31306(gp)
    if ( result == NOERROR_INWORK )
   230e4:	10803fe0 	cmpeqi	r2,r2,255
   230e8:	103f8026 	beq	r2,zero,22eec <AL_ControlInd+0x57c>
        bEcatWaitForAlControlRes = TRUE;
   230ec:	00800044 	movi	r2,1
   230f0:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   230f4:	00800844 	movi	r2,33
   230f8:	003ecd06 	br	22c30 <AL_ControlInd+0x2c0>
    bSyncSetByUser = FALSE;
   230fc:	d0216d85 	stb	zero,-31306(gp)
            if(bErrAck)
   23100:	bdc03fcc 	andi	r23,r23,255
   23104:	b8000226 	beq	r23,zero,23110 <AL_ControlInd+0x7a0>
                APPL_AckErrorInd(stateTrans);
   23108:	9009883a 	mov	r4,r18
   2310c:	00200840 	call	20084 <APPL_AckErrorInd>
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
   23110:	d12156c3 	ldbu	r4,-31397(gp)
   23114:	9c003fcc 	andi	r16,r19,255
   23118:	2080030c 	andi	r2,r4,12
   2311c:	10000526 	beq	r2,zero,23134 <AL_ControlInd+0x7c4>
                    if(nPdOutputSize > 0)
   23120:	d0a1580b 	ldhu	r2,-31392(gp)
   23124:	10000726 	beq	r2,zero,23144 <AL_ControlInd+0x7d4>
                        EnableSyncManChannel(PROCESS_DATA_OUT);
   23128:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   2312c:	0021d840 	call	21d84 <EnableSyncManChannel>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23130:	d12156c3 	ldbu	r4,-31397(gp)
   23134:	208003cc 	andi	r2,r4,15
   23138:	80bef826 	beq	r16,r2,22d1c <AL_ControlInd+0x3ac>
            result = NOERROR_NOSTATECHANGE;
   2313c:	04003f84 	movi	r16,254
   23140:	003f2a06 	br	22dec <AL_ControlInd+0x47c>
                    if(nPdInputSize > 0)
   23144:	d0a1588b 	ldhu	r2,-31390(gp)
   23148:	103ffa26 	beq	r2,zero,23134 <AL_ControlInd+0x7c4>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   2314c:	010000c4 	movi	r4,3
   23150:	003ff606 	br	2312c <AL_ControlInd+0x7bc>
            APPL_StopOutputHandler();
   23154:	00200b00 	call	200b0 <APPL_StopOutputHandler>
            StopOutputHandler();
   23158:	00228180 	call	22818 <StopOutputHandler>
            APPL_StopInputHandler();
   2315c:	00200a00 	call	200a0 <APPL_StopInputHandler>
            StopInputHandler();
   23160:	00228240 	call	22824 <StopInputHandler>
            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
   23164:	b8800598 	cmpnei	r2,r23,22
   23168:	10000c1e 	bne	r2,zero,2319c <AL_ControlInd+0x82c>
                MBX_StopMailboxHandler();
   2316c:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
   23170:	00200900 	call	20090 <APPL_StopMailboxHandler>
                DisableSyncManChannel(MAILBOX_WRITE);
   23174:	0009883a 	mov	r4,zero
   23178:	0021d240 	call	21d24 <DisableSyncManChannel>
                DisableSyncManChannel(MAILBOX_READ);
   2317c:	01000044 	movi	r4,1
   23180:	0021d240 	call	21d24 <DisableSyncManChannel>
                nAlStatus = STATE_INIT;
   23184:	00800044 	movi	r2,1
   23188:	d0a156c5 	stb	r2,-31397(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   2318c:	98800058 	cmpnei	r2,r19,1
   23190:	10002e1e 	bne	r2,zero,2324c <AL_ControlInd+0x8dc>
   23194:	01000044 	movi	r4,1
   23198:	003ec406 	br	22cac <AL_ControlInd+0x33c>
                nAlStatus = STATE_PREOP;
   2319c:	00800084 	movi	r2,2
   231a0:	d0a156c5 	stb	r2,-31397(gp)
    if ( result == NOERROR_INWORK )
   231a4:	bdc03fe0 	cmpeqi	r23,r23,255
   231a8:	b800131e 	bne	r23,zero,231f8 <AL_ControlInd+0x888>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   231ac:	98800098 	cmpnei	r2,r19,2
   231b0:	1000281e 	bne	r2,zero,23254 <AL_ControlInd+0x8e4>
   231b4:	01000084 	movi	r4,2
   231b8:	003ebc06 	br	22cac <AL_ControlInd+0x33c>
   231bc:	d12156c3 	ldbu	r4,-31397(gp)
   231c0:	208003cc 	andi	r2,r4,15
   231c4:	98bed526 	beq	r19,r2,22d1c <AL_ControlInd+0x3ac>
                result = ALSTATUSCODE_EE_ERROR;
   231c8:	04001444 	movi	r16,81
   231cc:	003f0706 	br	22dec <AL_ControlInd+0x47c>
    if ( result == NOERROR_INWORK )
   231d0:	10803fd8 	cmpnei	r2,r2,255
   231d4:	103f021e 	bne	r2,zero,22de0 <AL_ControlInd+0x470>
        bEcatWaitForAlControlRes = TRUE;
   231d8:	00800044 	movi	r2,1
   231dc:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   231e0:	00802044 	movi	r2,129
   231e4:	003e9206 	br	22c30 <AL_ControlInd+0x2c0>
        bEcatWaitForAlControlRes = TRUE;
   231e8:	00800044 	movi	r2,1
   231ec:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   231f0:	00800c44 	movi	r2,49
   231f4:	003e8e06 	br	22c30 <AL_ControlInd+0x2c0>
        bEcatWaitForAlControlRes = TRUE;
   231f8:	00800044 	movi	r2,1
        nEcatStateTrans = stateTrans;
   231fc:	8c403fcc 	andi	r17,r17,255
        bEcatWaitForAlControlRes = TRUE;
   23200:	d0a15985 	stb	r2,-31386(gp)
        nEcatStateTrans = stateTrans;
   23204:	d461590d 	sth	r17,-31388(gp)
        switch(nEcatStateTrans)
   23208:	90800528 	cmpgeui	r2,r18,20
   2320c:	1000031e 	bne	r2,zero,2321c <AL_ControlInd+0x8ac>
   23210:	948004a8 	cmpgeui	r18,r18,18
   23214:	903f141e 	bne	r18,zero,22e68 <AL_ControlInd+0x4f8>
   23218:	003e8606 	br	22c34 <AL_ControlInd+0x2c4>
   2321c:	90800920 	cmpeqi	r2,r18,36
   23220:	103f6a1e 	bne	r2,zero,22fcc <AL_ControlInd+0x65c>
   23224:	94801220 	cmpeqi	r18,r18,72
   23228:	903f681e 	bne	r18,zero,22fcc <AL_ControlInd+0x65c>
   2322c:	003e8106 	br	22c34 <AL_ControlInd+0x2c4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23230:	d12156c3 	ldbu	r4,-31397(gp)
   23234:	208003cc 	andi	r2,r4,15
   23238:	98beb826 	beq	r19,r2,22d1c <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_INVALIDALCONTROL;
   2323c:	04000444 	movi	r16,17
   23240:	003eea06 	br	22dec <AL_ControlInd+0x47c>
                result = ALSTATUSCODE_INVALIDMBXCFGINBOOT;
   23244:	04000544 	movi	r16,21
   23248:	003ee806 	br	22dec <AL_ControlInd+0x47c>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   2324c:	01000044 	movi	r4,1
   23250:	003ee606 	br	22dec <AL_ControlInd+0x47c>
   23254:	01000084 	movi	r4,2
   23258:	003ee406 	br	22dec <AL_ControlInd+0x47c>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   2325c:	0021883a 	mov	r16,zero
   23260:	003ee506 	br	22df8 <AL_ControlInd+0x488>
                if(nPdInputSize > 0)
   23264:	d0a1588b 	ldhu	r2,-31390(gp)
   23268:	103eeb26 	beq	r2,zero,22e18 <AL_ControlInd+0x4a8>
                DisableSyncManChannel(PROCESS_DATA_IN);
   2326c:	010000c4 	movi	r4,3
   23270:	003ee806 	br	22e14 <AL_ControlInd+0x4a4>
            if ( alStatusCode != 0 )
   23274:	a53fffcc 	andi	r20,r20,65535
   23278:	a03ec01e 	bne	r20,zero,22d7c <AL_ControlInd+0x40c>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   2327c:	002d883a 	mov	r22,zero
            nAlStatus = alControl;
   23280:	003ebf06 	br	22d80 <AL_ControlInd+0x410>

00023284 <AL_ControlRes>:
 \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the application specific state transition function is called.
 \brief    If the pending state transition is triggered by the application the transition need to be completed by the application (ECAT_StateChange())
  *////////////////////////////////////////////////////////////////////////////////////////
void AL_ControlRes(void)
{
    if(bEcatWaitForAlControlRes)
   23284:	d0a15983 	ldbu	r2,-31386(gp)
   23288:	1000bf26 	beq	r2,zero,23588 <AL_ControlRes+0x304>
        UINT8 Status = 0;
        UINT16 StatusCode = 0;

        if(EsmTimeoutCounter == 0)
        {
            Status =  (UINT8)(nEcatStateTrans >> 4);
   2328c:	d0a1590b 	ldhu	r2,-31388(gp)
        if(EsmTimeoutCounter == 0)
   23290:	d121620f 	ldh	r4,-31352(gp)
{
   23294:	defffc04 	addi	sp,sp,-16
   23298:	dfc00315 	stw	ra,12(sp)
   2329c:	dc800215 	stw	r18,8(sp)
   232a0:	dc400115 	stw	r17,4(sp)
   232a4:	dc000015 	stw	r16,0(sp)
   232a8:	10ffffcc 	andi	r3,r2,65535
        if(EsmTimeoutCounter == 0)
   232ac:	2000551e 	bne	r4,zero,23404 <AL_ControlRes+0x180>
            Status =  (UINT8)(nEcatStateTrans >> 4);
   232b0:	1822d13a 	srli	r17,r3,4

            /* ESM timeout expired*/
            switch(nEcatStateTrans)
   232b4:	19000920 	cmpeqi	r4,r3,36
            Status =  (UINT8)(nEcatStateTrans >> 4);
   232b8:	8825883a 	mov	r18,r17
            switch(nEcatStateTrans)
   232bc:	2000331e 	bne	r4,zero,2338c <AL_ControlRes+0x108>
   232c0:	19000968 	cmpgeui	r4,r3,37
   232c4:	2000091e 	bne	r4,zero,232ec <AL_ControlRes+0x68>
   232c8:	10bffb84 	addi	r2,r2,-18
   232cc:	10bfffcc 	andi	r2,r2,65535
   232d0:	108000a8 	cmpgeui	r2,r2,2
   232d4:	10001e26 	beq	r2,zero,23350 <AL_ControlRes+0xcc>
                    }             
                break;
            }//Switch - transition
        }

        if(Status != 0)
   232d8:	8c403fcc 	andi	r17,r17,255
   232dc:	88005126 	beq	r17,zero,23424 <AL_ControlRes+0x1a0>
        {
            /*Pending state transition finished => write AL Status and AL Status Code*/
            bEcatWaitForAlControlRes = FALSE;
   232e0:	d0215985 	stb	zero,-31386(gp)
        UINT16 StatusCode = 0;
   232e4:	0021883a 	mov	r16,zero
   232e8:	00001106 	br	23330 <AL_ControlRes+0xac>
            switch(nEcatStateTrans)
   232ec:	18c01220 	cmpeqi	r3,r3,72
   232f0:	183ff926 	beq	r3,zero,232d8 <AL_ControlRes+0x54>
                    if(bDcSyncActive)
   232f4:	d0a16283 	ldbu	r2,-31350(gp)
   232f8:	10002c26 	beq	r2,zero,233ac <AL_ControlRes+0x128>
                        if(!bDcRunning)
   232fc:	d0a16183 	ldbu	r2,-31354(gp)
   23300:	10003a26 	beq	r2,zero,233ec <AL_ControlRes+0x168>
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
   23304:	d0a16303 	ldbu	r2,-31348(gp)
   23308:	1000021e 	bne	r2,zero,23314 <AL_ControlRes+0x90>
   2330c:	d0a1580b 	ldhu	r2,-31392(gp)
   23310:	1000381e 	bne	r2,zero,233f4 <AL_ControlRes+0x170>
                        else if (!bSmSyncSequenceValid)
   23314:	d0a16003 	ldbu	r2,-31360(gp)
   23318:	10003826 	beq	r2,zero,233fc <AL_ControlRes+0x178>
                            bEcatOutputUpdateRunning = TRUE;
   2331c:	00800044 	movi	r2,1
   23320:	d0a16385 	stb	r2,-31346(gp)
            bEcatWaitForAlControlRes = FALSE;
   23324:	d0215985 	stb	zero,-31386(gp)
                            StatusCode = 0;
   23328:	0021883a 	mov	r16,zero
                            Status = STATE_OP;
   2332c:	04800204 	movi	r18,8
            if (StatusCode != 0)
            {
                Status |= STATE_CHANGE;
            }

            SetALStatus(Status,StatusCode);
   23330:	817fffcc 	andi	r5,r16,65535
   23334:	91003fcc 	andi	r4,r18,255
        }
    }// Pending state transition (bEcatWaitForAlControlRes == true)
}
   23338:	dfc00317 	ldw	ra,12(sp)
   2333c:	dc800217 	ldw	r18,8(sp)
   23340:	dc400117 	ldw	r17,4(sp)
   23344:	dc000017 	ldw	r16,0(sp)
   23348:	dec00404 	addi	sp,sp,16
            SetALStatus(Status,StatusCode);
   2334c:	00228cc1 	jmpi	228cc <SetALStatus>
                        if (!bApplEsmPending)
   23350:	d0a159c3 	ldbu	r2,-31385(gp)
   23354:	1000011e 	bne	r2,zero,2335c <AL_ControlRes+0xd8>
                            APPL_StopMailboxHandler();
   23358:	00200900 	call	20090 <APPL_StopMailboxHandler>
                    MBX_StopMailboxHandler();
   2335c:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
                    if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
   23360:	d0a15a03 	ldbu	r2,-31384(gp)
   23364:	108003cc 	andi	r2,r2,15
   23368:	10800058 	cmpnei	r2,r2,1
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   2336c:	1000811e 	bne	r2,zero,23574 <AL_ControlRes+0x2f0>
        if(Status != 0)
   23370:	88803fcc 	andi	r2,r17,255
                        StatusCode = u16LocalErrorCode;
   23374:	d4215a8b 	ldhu	r16,-31382(gp)
        if(Status != 0)
   23378:	10002a26 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   2337c:	d0215985 	stb	zero,-31386(gp)
            if (StatusCode != 0)
   23380:	80bfffcc 	andi	r2,r16,65535
   23384:	1000171e 	bne	r2,zero,233e4 <AL_ControlRes+0x160>
   23388:	003fe906 	br	23330 <AL_ControlRes+0xac>
                        if (!bApplEsmPending)
   2338c:	d0a159c3 	ldbu	r2,-31385(gp)
   23390:	1000011e 	bne	r2,zero,23398 <AL_ControlRes+0x114>
                            APPL_StopInputHandler();
   23394:	00200a00 	call	200a0 <APPL_StopInputHandler>
                    StopInputHandler();
   23398:	00228240 	call	22824 <StopInputHandler>
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   2339c:	d0a15a03 	ldbu	r2,-31384(gp)
   233a0:	108003cc 	andi	r2,r2,15
   233a4:	10800098 	cmpnei	r2,r2,2
   233a8:	003ff006 	br	2336c <AL_ControlRes+0xe8>
                            if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
   233ac:	d0a15a03 	ldbu	r2,-31384(gp)
   233b0:	108003cc 	andi	r2,r2,15
   233b4:	10800118 	cmpnei	r2,r2,4
   233b8:	103fd81e 	bne	r2,zero,2331c <AL_ControlRes+0x98>
                                StatusCode = u16LocalErrorCode;
   233bc:	d4215a8b 	ldhu	r16,-31382(gp)
                    if(StatusCode != 0)
   233c0:	80bfffcc 	andi	r2,r16,65535
   233c4:	103fc426 	beq	r2,zero,232d8 <AL_ControlRes+0x54>
                            if (!bApplEsmPending)
   233c8:	d0a159c3 	ldbu	r2,-31385(gp)
   233cc:	1000011e 	bne	r2,zero,233d4 <AL_ControlRes+0x150>
                                APPL_StopOutputHandler();
   233d0:	00200b00 	call	200b0 <APPL_StopOutputHandler>
                        StopOutputHandler();
   233d4:	00228180 	call	22818 <StopOutputHandler>
        if(Status != 0)
   233d8:	88803fcc 	andi	r2,r17,255
   233dc:	10001126 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   233e0:	d0215985 	stb	zero,-31386(gp)
                Status |= STATE_CHANGE;
   233e4:	8c800414 	ori	r18,r17,16
   233e8:	003fd106 	br	23330 <AL_ControlRes+0xac>
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
   233ec:	04000b44 	movi	r16,45
   233f0:	003ff506 	br	233c8 <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
   233f4:	040006c4 	movi	r16,27
   233f8:	003ff306 	br	233c8 <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SYNCERROR;
   233fc:	04000684 	movi	r16,26
   23400:	003ff106 	br	233c8 <AL_ControlRes+0x144>
            switch(nEcatStateTrans)
   23404:	19000920 	cmpeqi	r4,r3,36
   23408:	20003d1e 	bne	r4,zero,23500 <AL_ControlRes+0x27c>
   2340c:	19000968 	cmpgeui	r4,r3,37
   23410:	20000a1e 	bne	r4,zero,2343c <AL_ControlRes+0x1b8>
   23414:	10bffb84 	addi	r2,r2,-18
   23418:	10bfffcc 	andi	r2,r2,65535
   2341c:	108000a8 	cmpgeui	r2,r2,2
   23420:	10001f26 	beq	r2,zero,234a0 <AL_ControlRes+0x21c>
}
   23424:	dfc00317 	ldw	ra,12(sp)
   23428:	dc800217 	ldw	r18,8(sp)
   2342c:	dc400117 	ldw	r17,4(sp)
   23430:	dc000017 	ldw	r16,0(sp)
   23434:	dec00404 	addi	sp,sp,16
   23438:	f800283a 	ret
            switch(nEcatStateTrans)
   2343c:	18c01220 	cmpeqi	r3,r3,72
   23440:	183ff826 	beq	r3,zero,23424 <AL_ControlRes+0x1a0>
                   if(bApplEsmPending)
   23444:	d0a159c3 	ldbu	r2,-31385(gp)
   23448:	103ff626 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
                        if(bDcSyncActive)
   2344c:	d0a16283 	ldbu	r2,-31350(gp)
   23450:	10004126 	beq	r2,zero,23558 <AL_ControlRes+0x2d4>
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
   23454:	d0a15f8f 	ldh	r2,-31362(gp)
   23458:	00bff20e 	bge	zero,r2,23424 <AL_ControlRes+0x1a0>
   2345c:	d0e15f0f 	ldh	r3,-31364(gp)
   23460:	18bff016 	blt	r3,r2,23424 <AL_ControlRes+0x1a0>
                                i16WaitForPllRunningTimeout = 0;
   23464:	d0215f8d 	sth	zero,-31362(gp)
                                i16WaitForPllRunningCnt = 0;
   23468:	d0215f0d 	sth	zero,-31364(gp)
                                bApplEsmPending = FALSE;
   2346c:	d02159c5 	stb	zero,-31385(gp)
                                result = APPL_StartOutputHandler();
   23470:	00200a80 	call	200a8 <APPL_StartOutputHandler>
                                if(result == 0)
   23474:	10bfffcc 	andi	r2,r2,65535
   23478:	103fa826 	beq	r2,zero,2331c <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   2347c:	10803fe0 	cmpeqi	r2,r2,255
   23480:	103fe81e 	bne	r2,zero,23424 <AL_ControlRes+0x1a0>
                                        APPL_StopOutputHandler();
   23484:	00200b00 	call	200b0 <APPL_StopOutputHandler>
}
   23488:	dfc00317 	ldw	ra,12(sp)
   2348c:	dc800217 	ldw	r18,8(sp)
   23490:	dc400117 	ldw	r17,4(sp)
   23494:	dc000017 	ldw	r16,0(sp)
   23498:	dec00404 	addi	sp,sp,16
                                        StopOutputHandler();
   2349c:	00228181 	jmpi	22818 <StopOutputHandler>
                    if(bApplEsmPending)
   234a0:	d0a159c3 	ldbu	r2,-31385(gp)
   234a4:	103fdf26 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
                        bApplEsmPending = FALSE;
   234a8:	d02159c5 	stb	zero,-31385(gp)
                        result = APPL_StartMailboxHandler();
   234ac:	00200880 	call	20088 <APPL_StartMailboxHandler>
   234b0:	1021883a 	mov	r16,r2
                        if(result == 0)
   234b4:	10bfffcc 	andi	r2,r2,65535
   234b8:	1000081e 	bne	r2,zero,234dc <AL_ControlRes+0x258>
                            bMbxRunning = TRUE;
   234bc:	00800044 	movi	r2,1
   234c0:	d0a16c45 	stb	r2,-31311(gp)
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   234c4:	d0a15903 	ldbu	r2,-31388(gp)
   234c8:	108003cc 	andi	r2,r2,15
   234cc:	1025883a 	mov	r18,r2
        if(Status != 0)
   234d0:	103fd426 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   234d4:	d0215985 	stb	zero,-31386(gp)
            if (StatusCode != 0)
   234d8:	003f9506 	br	23330 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   234dc:	10803fe0 	cmpeqi	r2,r2,255
   234e0:	103fd01e 	bne	r2,zero,23424 <AL_ControlRes+0x1a0>
                                APPL_StopMailboxHandler();
   234e4:	00200900 	call	20090 <APPL_StopMailboxHandler>
}
   234e8:	dfc00317 	ldw	ra,12(sp)
   234ec:	dc800217 	ldw	r18,8(sp)
   234f0:	dc400117 	ldw	r17,4(sp)
   234f4:	dc000017 	ldw	r16,0(sp)
   234f8:	dec00404 	addi	sp,sp,16
                                MBX_StopMailboxHandler();
   234fc:	0023e9c1 	jmpi	23e9c <MBX_StopMailboxHandler>
                    if(bApplEsmPending)
   23500:	d0a159c3 	ldbu	r2,-31385(gp)
   23504:	103fc726 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23508:	d1215484 	addi	r4,gp,-31406
                        bApplEsmPending = FALSE;
   2350c:	d02159c5 	stb	zero,-31385(gp)
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23510:	00200980 	call	20098 <APPL_StartInputHandler>
   23514:	1021883a 	mov	r16,r2
                        if(result == 0)
   23518:	10bfffcc 	andi	r2,r2,65535
   2351c:	1000051e 	bne	r2,zero,23534 <AL_ControlRes+0x2b0>
                            bEcatInputUpdateRunning = TRUE;
   23520:	00800044 	movi	r2,1
   23524:	d0a16345 	stb	r2,-31347(gp)
            bEcatWaitForAlControlRes = FALSE;
   23528:	d0215985 	stb	zero,-31386(gp)
                            Status = STATE_SAFEOP;
   2352c:	04800104 	movi	r18,4
   23530:	003f7f06 	br	23330 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   23534:	10803fe0 	cmpeqi	r2,r2,255
   23538:	103fba1e 	bne	r2,zero,23424 <AL_ControlRes+0x1a0>
                                APPL_StopInputHandler();
   2353c:	00200a00 	call	200a0 <APPL_StopInputHandler>
}
   23540:	dfc00317 	ldw	ra,12(sp)
   23544:	dc800217 	ldw	r18,8(sp)
   23548:	dc400117 	ldw	r17,4(sp)
   2354c:	dc000017 	ldw	r16,0(sp)
   23550:	dec00404 	addi	sp,sp,16
                                StopInputHandler();
   23554:	00228241 	jmpi	22824 <StopInputHandler>
                                bApplEsmPending = FALSE;  
   23558:	d02159c5 	stb	zero,-31385(gp)
                                result = APPL_StartOutputHandler();
   2355c:	00200a80 	call	200a8 <APPL_StartOutputHandler>
                                if(result == 0)
   23560:	10bfffcc 	andi	r2,r2,65535
   23564:	103f6d26 	beq	r2,zero,2331c <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   23568:	10803fd8 	cmpnei	r2,r2,255
   2356c:	103fad26 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
   23570:	003fc406 	br	23484 <AL_ControlRes+0x200>
        if(Status != 0)
   23574:	88803fcc 	andi	r2,r17,255
   23578:	103faa26 	beq	r2,zero,23424 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   2357c:	d0215985 	stb	zero,-31386(gp)
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
   23580:	04000044 	movi	r16,1
   23584:	003f9706 	br	233e4 <AL_ControlRes+0x160>
   23588:	f800283a 	ret

0002358c <DC_CheckWatchdog>:

*////////////////////////////////////////////////////////////////////////////////////////
void DC_CheckWatchdog(void)
{

    if(bDcSyncActive && bEcatInputUpdateRunning)
   2358c:	d0a16283 	ldbu	r2,-31350(gp)
   23590:	10002d26 	beq	r2,zero,23648 <DC_CheckWatchdog+0xbc>
   23594:	d0a16343 	ldbu	r2,-31347(gp)
   23598:	10002b26 	beq	r2,zero,23648 <DC_CheckWatchdog+0xbc>
    {
        /*If Sync0 watchdog is enabled and expired*/
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
   2359c:	d0e15e0b 	ldhu	r3,-31368(gp)
   235a0:	18000926 	beq	r3,zero,235c8 <DC_CheckWatchdog+0x3c>
   235a4:	d0a15e8b 	ldhu	r2,-31366(gp)
   235a8:	113fffcc 	andi	r4,r2,65535
   235ac:	20c00436 	bltu	r4,r3,235c0 <DC_CheckWatchdog+0x34>
                {
                    i16WaitForPllRunningCnt = 0;
                }
            }
        }
        else if(bSmSyncSequenceValid)
   235b0:	d0a16003 	ldbu	r2,-31360(gp)
                bDcRunning = FALSE;        
   235b4:	d0216185 	stb	zero,-31354(gp)
        else if(bSmSyncSequenceValid)
   235b8:	1000211e 	bne	r2,zero,23640 <DC_CheckWatchdog+0xb4>
   235bc:	f800283a 	ret
                Sync0WdCounter ++;
   235c0:	10800044 	addi	r2,r2,1
   235c4:	d0a15e8d 	sth	r2,-31366(gp)
            if(Sync1WdValue > 0)
   235c8:	d0e15d0b 	ldhu	r3,-31372(gp)
            bDcRunning = TRUE;
   235cc:	00800044 	movi	r2,1
   235d0:	d0a16185 	stb	r2,-31354(gp)
            if(Sync1WdValue > 0)
   235d4:	18000526 	beq	r3,zero,235ec <DC_CheckWatchdog+0x60>
                if(Sync1WdCounter < Sync1WdValue)
   235d8:	d0a15d8b 	ldhu	r2,-31370(gp)
   235dc:	113fffcc 	andi	r4,r2,65535
   235e0:	20fff32e 	bgeu	r4,r3,235b0 <DC_CheckWatchdog+0x24>
                    Sync1WdCounter ++;
   235e4:	10800044 	addi	r2,r2,1
   235e8:	d0a15d8d 	sth	r2,-31370(gp)
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
   235ec:	008000f4 	movhi	r2,3
   235f0:	10a0db0b 	ldhu	r2,-31892(r2)
   235f4:	10000326 	beq	r2,zero,23604 <DC_CheckWatchdog+0x78>
   235f8:	00c000f4 	movhi	r3,3
   235fc:	18e33c0b 	ldhu	r3,-29456(r3)
   23600:	1880082e 	bgeu	r3,r2,23624 <DC_CheckWatchdog+0x98>
                bSmSyncSequenceValid = TRUE;
   23604:	00800044 	movi	r2,1
   23608:	d0a16005 	stb	r2,-31360(gp)
                if (i16WaitForPllRunningTimeout > 0)
   2360c:	d0a15f8f 	ldh	r2,-31362(gp)
   23610:	00800d0e 	bge	zero,r2,23648 <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt++;
   23614:	d0a15f0b 	ldhu	r2,-31364(gp)
   23618:	10800044 	addi	r2,r2,1
   2361c:	d0a15f0d 	sth	r2,-31364(gp)
   23620:	f800283a 	ret
            else if (bSmSyncSequenceValid)
   23624:	d0a16003 	ldbu	r2,-31360(gp)
   23628:	10000726 	beq	r2,zero,23648 <DC_CheckWatchdog+0xbc>
                if (i16WaitForPllRunningTimeout > 0)
   2362c:	d0a15f8f 	ldh	r2,-31362(gp)
                    bSmSyncSequenceValid = FALSE;
   23630:	d0216005 	stb	zero,-31360(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23634:	0080040e 	bge	zero,r2,23648 <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt = 0;
   23638:	d0215f0d 	sth	zero,-31364(gp)
   2363c:	f800283a 	ret
        {
           bSmSyncSequenceValid = FALSE;
   23640:	d0216005 	stb	zero,-31360(gp)
        }
    }
}
   23644:	f800283a 	ret
   23648:	f800283a 	ret

0002364c <CheckIfEcatError>:
*////////////////////////////////////////////////////////////////////////////////////////
void CheckIfEcatError(void)
{
   /*if the watchdog is enabled check the process data watchdog in the ESC
   and set the AL status code 0x1B if the watchdog expired*/
   if (EcatWdValue != 0)
   2364c:	d0a1560b 	ldhu	r2,-31400(gp)
   23650:	10002626 	beq	r2,zero,236ec <CheckIfEcatError+0xa0>
{
   23654:	defffe04 	addi	sp,sp,-8
   {
      /*watchdog time is set => watchdog is active*/
      UINT16 WdStatusOK = 0;

      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   23658:	01800084 	movi	r6,2
   2365c:	01411004 	movi	r5,1088
   23660:	d9000084 	addi	r4,sp,2
{
   23664:	dfc00115 	stw	ra,4(sp)
      UINT16 WdStatusOK = 0;
   23668:	d800008d 	sth	zero,2(sp)
      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   2366c:	00205e00 	call	205e0 <HW_EscRead>
      WdStatusOK = SWAPWORD(WdStatusOK);

      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
   23670:	d880008b 	ldhu	r2,2(sp)
   23674:	1080004c 	andi	r2,r2,1
   23678:	10000d1e 	bne	r2,zero,236b0 <CheckIfEcatError+0x64>
   2367c:	d0a1580b 	ldhu	r2,-31392(gp)
   23680:	10000b26 	beq	r2,zero,236b0 <CheckIfEcatError+0x64>
      {
         /*The device is in OP state*/

         if (bEcatOutputUpdateRunning
   23684:	d0a16383 	ldbu	r2,-31346(gp)
   23688:	10000826 	beq	r2,zero,236ac <CheckIfEcatError+0x60>
            && bEcatFirstOutputsReceived
   2368c:	d0a16303 	ldbu	r2,-31348(gp)
   23690:	10000626 	beq	r2,zero,236ac <CheckIfEcatError+0x60>
            )
         {
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
   23694:	014006c4 	movi	r5,27
   23698:	01000104 	movi	r4,4
   2369c:	00229700 	call	22970 <AL_ControlInd>
               return;
           }
        
       }
   }
}
   236a0:	dfc00117 	ldw	ra,4(sp)
   236a4:	dec00204 	addi	sp,sp,8
   236a8:	f800283a 	ret
            bEcatFirstOutputsReceived = FALSE;
   236ac:	d0216305 	stb	zero,-31348(gp)
   if(bDcSyncActive)
   236b0:	d0a16283 	ldbu	r2,-31350(gp)
   236b4:	103ffa26 	beq	r2,zero,236a0 <CheckIfEcatError+0x54>
       if(bEcatOutputUpdateRunning)
   236b8:	d0a16383 	ldbu	r2,-31346(gp)
   236bc:	103ff826 	beq	r2,zero,236a0 <CheckIfEcatError+0x54>
           if(!bDcRunning)
   236c0:	d0a16183 	ldbu	r2,-31354(gp)
   236c4:	1000051e 	bne	r2,zero,236dc <CheckIfEcatError+0x90>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   236c8:	01400b04 	movi	r5,44
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   236cc:	01000104 	movi	r4,4
}
   236d0:	dfc00117 	ldw	ra,4(sp)
   236d4:	dec00204 	addi	sp,sp,8
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   236d8:	00229701 	jmpi	22970 <AL_ControlInd>
           else if(!bSmSyncSequenceValid)
   236dc:	d0a16003 	ldbu	r2,-31360(gp)
   236e0:	103fef1e 	bne	r2,zero,236a0 <CheckIfEcatError+0x54>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   236e4:	01400684 	movi	r5,26
   236e8:	003ff806 	br	236cc <CheckIfEcatError+0x80>
   if(bDcSyncActive)
   236ec:	d0a16283 	ldbu	r2,-31350(gp)
   236f0:	10000b26 	beq	r2,zero,23720 <CheckIfEcatError+0xd4>
       if(bEcatOutputUpdateRunning)
   236f4:	d0a16383 	ldbu	r2,-31346(gp)
   236f8:	10000926 	beq	r2,zero,23720 <CheckIfEcatError+0xd4>
           if(!bDcRunning)
   236fc:	d0a16183 	ldbu	r2,-31354(gp)
   23700:	1000031e 	bne	r2,zero,23710 <CheckIfEcatError+0xc4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   23704:	01400b04 	movi	r5,44
   23708:	01000104 	movi	r4,4
   2370c:	003ff206 	br	236d8 <CheckIfEcatError+0x8c>
           else if(!bSmSyncSequenceValid)
   23710:	d0a16003 	ldbu	r2,-31360(gp)
   23714:	1000021e 	bne	r2,zero,23720 <CheckIfEcatError+0xd4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   23718:	01400684 	movi	r5,26
   2371c:	003ffa06 	br	23708 <CheckIfEcatError+0xbc>
   23720:	f800283a 	ret

00023724 <ECAT_StateChange>:
 \brief    This function changes the state of the EtherCAT slave if the requested state
             is lower than the actual state, otherwise the error condition will be reset.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
{
   23724:	defffe04 	addi	sp,sp,-8
   23728:	dc000015 	stw	r16,0(sp)
   2372c:	dfc00115 	stw	ra,4(sp)
    UINT8 Status = alStatus;

    /*ECATCHANGE_START(V5.13) ESM1*/
    /*return in case of invalid parameters*/
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23730:	2c3fffcc 	andi	r16,r5,65535
   23734:	8000201e 	bne	r16,zero,237b8 <ECAT_StateChange+0x94>
    {
        return;
    }

    /* call the application requested state transition only once*/
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   23738:	d0a15983 	ldbu	r2,-31386(gp)
   2373c:	10000a1e 	bne	r2,zero,23768 <ECAT_StateChange+0x44>
   23740:	d0a15a03 	ldbu	r2,-31384(gp)
   23744:	21003fcc 	andi	r4,r4,255
   23748:	2080021e 	bne	r4,r2,23754 <ECAT_StateChange+0x30>
   2374c:	d0a15a8b 	ldhu	r2,-31382(gp)
   23750:	10002526 	beq	r2,zero,237e8 <ECAT_StateChange+0xc4>
               /* no error pending and the target state is lower than the current one*/
                AL_ControlInd(alStatus, alStatusCode);
            }
        }
        /*ECATCHANGE_START(V5.13) ESM1*/
        else if (u8LocalErrorState != 0)
   23754:	d0a15a03 	ldbu	r2,-31384(gp)
   23758:	10002326 	beq	r2,zero,237e8 <ECAT_StateChange+0xc4>
                u8LocalErrorState = 0;
   2375c:	d0215a05 	stb	zero,-31384(gp)
                u16LocalErrorCode = alStatusCode;
   23760:	d0215a8d 	sth	zero,-31382(gp)
   23764:	00002006 	br	237e8 <ECAT_StateChange+0xc4>
        if(bApplEsmPending)
   23768:	d0a159c3 	ldbu	r2,-31385(gp)
   2376c:	103ffb1e 	bne	r2,zero,2375c <ECAT_StateChange+0x38>
                switch(nEcatStateTrans)
   23770:	d0a1590b 	ldhu	r2,-31388(gp)
   23774:	10ffffcc 	andi	r3,r2,65535
   23778:	19000920 	cmpeqi	r4,r3,36
   2377c:	20004b1e 	bne	r4,zero,238ac <ECAT_StateChange+0x188>
   23780:	19000968 	cmpgeui	r4,r3,37
   23784:	2000411e 	bne	r4,zero,2388c <ECAT_StateChange+0x168>
   23788:	10bffb84 	addi	r2,r2,-18
   2378c:	10bfffcc 	andi	r2,r2,65535
   23790:	108000a8 	cmpgeui	r2,r2,2
   23794:	10004226 	beq	r2,zero,238a0 <ECAT_StateChange+0x17c>
                else if (u8LocalErrorState != 0)
   23798:	d0a15a03 	ldbu	r2,-31384(gp)
                bEcatWaitForAlControlRes = FALSE;
   2379c:	d0215985 	stb	zero,-31386(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   237a0:	d121590b 	ldhu	r4,-31388(gp)
                else if (u8LocalErrorState != 0)
   237a4:	10000226 	beq	r2,zero,237b0 <ECAT_StateChange+0x8c>
                    u8LocalErrorState = 0;
   237a8:	d0215a05 	stb	zero,-31384(gp)
                    u16LocalErrorCode = 0x00;
   237ac:	d0215a8d 	sth	zero,-31382(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   237b0:	210003cc 	andi	r4,r4,15
   237b4:	00002406 	br	23848 <ECAT_StateChange+0x124>
   237b8:	208003cc 	andi	r2,r4,15
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   237bc:	00c04584 	movi	r3,278
   237c0:	1886d83a 	srl	r3,r3,r2
   237c4:	18c0004c 	andi	r3,r3,1
   237c8:	18000726 	beq	r3,zero,237e8 <ECAT_StateChange+0xc4>
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   237cc:	d0e15983 	ldbu	r3,-31386(gp)
   237d0:	1800091e 	bne	r3,zero,237f8 <ECAT_StateChange+0xd4>
   237d4:	d0e15a03 	ldbu	r3,-31384(gp)
   237d8:	21003fcc 	andi	r4,r4,255
   237dc:	1900381e 	bne	r3,r4,238c0 <ECAT_StateChange+0x19c>
   237e0:	d0e15a8b 	ldhu	r3,-31382(gp)
   237e4:	80c0361e 	bne	r16,r3,238c0 <ECAT_StateChange+0x19c>
            u8LocalErrorState = 0;
            u16LocalErrorCode = 0x00;
        }
        /*ECATCHANGE_END(V5.13) ESM1*/
    }
}
   237e8:	dfc00117 	ldw	ra,4(sp)
   237ec:	dc000017 	ldw	r16,0(sp)
   237f0:	dec00204 	addi	sp,sp,8
   237f4:	f800283a 	ret
        if(bApplEsmPending)
   237f8:	d0e159c3 	ldbu	r3,-31385(gp)
                u8LocalErrorState = (alStatus & STATE_MASK);
   237fc:	d0a15a05 	stb	r2,-31384(gp)
                u16LocalErrorCode = alStatusCode;
   23800:	d1615a8d 	sth	r5,-31382(gp)
        if(bApplEsmPending)
   23804:	18000226 	beq	r3,zero,23810 <ECAT_StateChange+0xec>
                EsmTimeoutCounter = 0;
   23808:	d021620d 	sth	zero,-31352(gp)
   2380c:	003ff606 	br	237e8 <ECAT_StateChange+0xc4>
                switch(nEcatStateTrans)
   23810:	d0a1590b 	ldhu	r2,-31388(gp)
   23814:	10ffffcc 	andi	r3,r2,65535
   23818:	19000920 	cmpeqi	r4,r3,36
   2381c:	2000181e 	bne	r4,zero,23880 <ECAT_StateChange+0x15c>
   23820:	19000968 	cmpgeui	r4,r3,37
   23824:	20000e1e 	bne	r4,zero,23860 <ECAT_StateChange+0x13c>
   23828:	10bffb84 	addi	r2,r2,-18
   2382c:	10bfffcc 	andi	r2,r2,65535
   23830:	108000a8 	cmpgeui	r2,r2,2
   23834:	10000f26 	beq	r2,zero,23874 <ECAT_StateChange+0x150>
                Status =  (UINT8)(nEcatStateTrans >> 4);
   23838:	d121590b 	ldhu	r4,-31388(gp)
                bEcatWaitForAlControlRes = FALSE;
   2383c:	d0215985 	stb	zero,-31386(gp)
                Status =  (UINT8)(nEcatStateTrans >> 4);
   23840:	2008d13a 	srli	r4,r4,4
                    Status |= STATE_CHANGE;
   23844:	21000414 	ori	r4,r4,16
                SetALStatus(Status,alStatusCode);
   23848:	800b883a 	mov	r5,r16
   2384c:	21003fcc 	andi	r4,r4,255
}
   23850:	dfc00117 	ldw	ra,4(sp)
   23854:	dc000017 	ldw	r16,0(sp)
   23858:	dec00204 	addi	sp,sp,8
                SetALStatus(Status,alStatusCode);
   2385c:	00228cc1 	jmpi	228cc <SetALStatus>
                switch(nEcatStateTrans)
   23860:	18c01220 	cmpeqi	r3,r3,72
   23864:	183ff426 	beq	r3,zero,23838 <ECAT_StateChange+0x114>
                          APPL_StopOutputHandler();
   23868:	00200b00 	call	200b0 <APPL_StopOutputHandler>
                          StopOutputHandler();
   2386c:	00228180 	call	22818 <StopOutputHandler>
                    break;
   23870:	003ff106 	br	23838 <ECAT_StateChange+0x114>
                          APPL_StopMailboxHandler();
   23874:	00200900 	call	20090 <APPL_StopMailboxHandler>
                          MBX_StopMailboxHandler();
   23878:	0023e9c0 	call	23e9c <MBX_StopMailboxHandler>
                    break;
   2387c:	003fee06 	br	23838 <ECAT_StateChange+0x114>
                          APPL_StopInputHandler();
   23880:	00200a00 	call	200a0 <APPL_StopInputHandler>
                          StopInputHandler();
   23884:	00228240 	call	22824 <StopInputHandler>
                    break;
   23888:	003feb06 	br	23838 <ECAT_StateChange+0x114>
                switch(nEcatStateTrans)
   2388c:	18c01220 	cmpeqi	r3,r3,72
   23890:	183fc126 	beq	r3,zero,23798 <ECAT_StateChange+0x74>
                          bEcatOutputUpdateRunning = TRUE;
   23894:	00800044 	movi	r2,1
   23898:	d0a16385 	stb	r2,-31346(gp)
                    break;
   2389c:	003fbe06 	br	23798 <ECAT_StateChange+0x74>
                        bMbxRunning = TRUE;
   238a0:	00800044 	movi	r2,1
   238a4:	d0a16c45 	stb	r2,-31311(gp)
                    break;
   238a8:	003fbb06 	br	23798 <ECAT_StateChange+0x74>
                        SetALEventMask(u16ALEventMask);
   238ac:	d121548b 	ldhu	r4,-31406(gp)
   238b0:	0021c700 	call	21c70 <SetALEventMask>
                        bEcatInputUpdateRunning = TRUE;
   238b4:	00800044 	movi	r2,1
   238b8:	d0a16345 	stb	r2,-31347(gp)
                    break;
   238bc:	003fb606 	br	23798 <ECAT_StateChange+0x74>
        if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
   238c0:	10c00220 	cmpeqi	r3,r2,8
   238c4:	11803fcc 	andi	r6,r2,255
   238c8:	183fa21e 	bne	r3,zero,23754 <ECAT_StateChange+0x30>
   238cc:	00c00584 	movi	r3,22
   238d0:	1986d83a 	srl	r3,r3,r6
   238d4:	18c0004c 	andi	r3,r3,1
   238d8:	183f9e26 	beq	r3,zero,23754 <ECAT_StateChange+0x30>
            u8LocalErrorState = (alStatus & STATE_MASK);
   238dc:	d0a15a05 	stb	r2,-31384(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   238e0:	d0a156c3 	ldbu	r2,-31397(gp)
            u16LocalErrorCode = alStatusCode;
   238e4:	d1615a8d 	sth	r5,-31382(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   238e8:	108003cc 	andi	r2,r2,15
   238ec:	10800218 	cmpnei	r2,r2,8
   238f0:	103fbd1e 	bne	r2,zero,237e8 <ECAT_StateChange+0xc4>
                AL_ControlInd(alStatus, alStatusCode);
   238f4:	800b883a 	mov	r5,r16
}
   238f8:	dfc00117 	ldw	ra,4(sp)
   238fc:	dc000017 	ldw	r16,0(sp)
   23900:	dec00204 	addi	sp,sp,8
                AL_ControlInd(alStatus, alStatusCode);
   23904:	00229701 	jmpi	22970 <AL_ControlInd>

00023908 <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
   23908:	defffe04 	addi	sp,sp,-8
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   2390c:	01800044 	movi	r6,1
   23910:	01400144 	movi	r5,5
   23914:	d1215784 	addi	r4,gp,-31394
{
   23918:	dfc00115 	stw	ra,4(sp)
   2391c:	dc000015 	stw	r16,0(sp)
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23920:	00205e00 	call	205e0 <HW_EscRead>

    HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
   23924:	01800084 	movi	r6,2
   23928:	01400184 	movi	r5,6
   2392c:	d1215704 	addi	r4,gp,-31396
   23930:	00205e00 	call	205e0 <HW_EscRead>
    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23934:	d0a1570b 	ldhu	r2,-31396(gp)

/*ECATCHANGE_START(V5.13) ECAT2*/
    u16IdValue = 0;
   23938:	d021540d 	sth	zero,-31408(gp)

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
   2393c:	0021883a 	mov	r16,zero
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23940:	100492ba 	slli	r2,r2,10
   23944:	1083ffc4 	addi	r2,r2,4095
   23948:	d0a1570d 	sth	r2,-31396(gp)
    UpdateEEPROMLoadedState();
   2394c:	0021cbc0 	call	21cbc <UpdateEEPROMLoadedState>
    for (i = 0; i < nMaxSyncMan; i++)
   23950:	d0a15783 	ldbu	r2,-31394(gp)
   23954:	81003fcc 	andi	r4,r16,255
   23958:	20802136 	bltu	r4,r2,239e0 <ECAT_Init+0xd8>
    {
        DisableSyncManChannel(i);
    }

    /* initialize the mailbox handler */
    MBX_Init();
   2395c:	0023d100 	call	23d10 <MBX_Init>
    u16ALEventMask = 0;
    nPdOutputSize = 0;
    nPdInputSize = 0;

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
   23960:	00800044 	movi	r2,1
    SetALStatus(nAlStatus, 0);
   23964:	000b883a 	mov	r5,zero
   23968:	01000044 	movi	r4,1
    nAlStatus    = STATE_INIT;
   2396c:	d0a156c5 	stb	r2,-31397(gp)
    bBootMode = FALSE;
   23970:	d02163c5 	stb	zero,-31345(gp)
    bApplEsmPending = FALSE;
   23974:	d02159c5 	stb	zero,-31385(gp)
    bEcatWaitForAlControlRes = FALSE;
   23978:	d0215985 	stb	zero,-31386(gp)
    bEcatFirstOutputsReceived = FALSE;
   2397c:	d0216305 	stb	zero,-31348(gp)
     bEcatOutputUpdateRunning = FALSE;
   23980:	d0216385 	stb	zero,-31346(gp)
     bEcatInputUpdateRunning = FALSE;
   23984:	d0216345 	stb	zero,-31347(gp)
     bExplicitDevIdRequested = FALSE;
   23988:	d0215685 	stb	zero,-31398(gp)
    bWdTrigger = FALSE;
   2398c:	d02162c5 	stb	zero,-31349(gp)
    EcatWdValue = 0;
   23990:	d021560d 	sth	zero,-31400(gp)
    Sync0WdCounter = 0;
   23994:	d0215e8d 	sth	zero,-31366(gp)
    Sync0WdValue = 0;
   23998:	d0215e0d 	sth	zero,-31368(gp)
    Sync1WdCounter = 0;
   2399c:	d0215d8d 	sth	zero,-31370(gp)
    Sync1WdValue = 0;
   239a0:	d0215d0d 	sth	zero,-31372(gp)
    bDcSyncActive = FALSE;
   239a4:	d0216285 	stb	zero,-31350(gp)
    u8LocalErrorState = 0;
   239a8:	d0215a05 	stb	zero,-31384(gp)
    u16LocalErrorCode = 0x00;
   239ac:	d0215a8d 	sth	zero,-31382(gp)
    u16ALEventMask = 0;
   239b0:	d021548d 	sth	zero,-31406(gp)
    nPdOutputSize = 0;
   239b4:	d021580d 	sth	zero,-31392(gp)
    nPdInputSize = 0;
   239b8:	d021588d 	sth	zero,-31390(gp)
    SetALStatus(nAlStatus, 0);
   239bc:	00228cc0 	call	228cc <SetALStatus>
    nEcatStateTrans = 0;
   239c0:	d021590d 	sth	zero,-31388(gp)

    bEscIntEnabled = FALSE;
   239c4:	d0215b45 	stb	zero,-31379(gp)

    /* initialize the COE part */
    COE_Init();
   239c8:	00217880 	call	21788 <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
   239cc:	0009883a 	mov	r4,zero
}
   239d0:	dfc00117 	ldw	ra,4(sp)
   239d4:	dc000017 	ldw	r16,0(sp)
   239d8:	dec00204 	addi	sp,sp,8
    ResetALEventMask(0);
   239dc:	0021c241 	jmpi	21c24 <ResetALEventMask>
        DisableSyncManChannel(i);
   239e0:	0021d240 	call	21d24 <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
   239e4:	84000044 	addi	r16,r16,1
   239e8:	003fd906 	br	23950 <ECAT_Init+0x48>

000239ec <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
   239ec:	defffc04 	addi	sp,sp,-16
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
/*ECATCHANGE_START(V5.13) MBX1*/
    UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
   239f0:	00800044 	movi	r2,1
   239f4:	d8800005 	stb	r2,0(sp)
{
   239f8:	dfc00315 	stw	ra,12(sp)
   239fc:	dc400215 	stw	r17,8(sp)
   23a00:	dc000115 	stw	r16,4(sp)
    UINT16 EscAlControl = 0x0000;
   23a04:	d800008d 	sth	zero,2(sp)
    UINT8 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
   23a08:	d8000045 	stb	zero,1(sp)
/*ECATCHANGE_END(V5.13) MBX1*/


    /* check if services are stored in the mailbox */
    MBX_Main();
   23a0c:	00245580 	call	24558 <MBX_Main>


    if ( bMbxRunning )
   23a10:	d0a16c43 	ldbu	r2,-31311(gp)
   23a14:	10000826 	beq	r2,zero,23a38 <ECAT_Main+0x4c>
    {
        /* Slave is at least in PREOP, Mailbox is running */

/*ECATCHANGE_START(V5.13) MBX1*/
        /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
        HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
   23a18:	01800044 	movi	r6,1
   23a1c:	01420384 	movi	r5,2062
   23a20:	d809883a 	mov	r4,sp
   23a24:	00205e00 	call	205e0 <HW_EscRead>

        HW_EscReadByte(sm1Status, (ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23a28:	01800044 	movi	r6,1
   23a2c:	01420344 	movi	r5,2061
   23a30:	d9000044 	addi	r4,sp,1
   23a34:	00205e00 	call	205e0 <HW_EscRead>
/*ECATCHANGE_END(V5.13) MBX1*/
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
   23a38:	00206180 	call	20618 <HW_GetALEventRegister>
   23a3c:	1021883a 	mov	r16,r2
    ALEventReg = SWAPWORD(ALEventReg);


    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
   23a40:	8080004c 	andi	r2,r16,1
   23a44:	10001526 	beq	r2,zero,23a9c <ECAT_Main+0xb0>
   23a48:	d4615983 	ldbu	r17,-31386(gp)
   23a4c:	88803fcc 	andi	r2,r17,255
   23a50:	1000121e 	bne	r2,zero,23a9c <ECAT_Main+0xb0>
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */

        HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
   23a54:	01800044 	movi	r6,1
   23a58:	01404804 	movi	r5,288
   23a5c:	d9000084 	addi	r4,sp,2
   23a60:	00205e00 	call	205e0 <HW_EscRead>
        EscAlControl = SWAPWORD(EscAlControl);


            /*ECATCHANGE_START(V5.13) ECAT2*/
                /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
            if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
   23a64:	d880008b 	ldhu	r2,2(sp)
   23a68:	1080080c 	andi	r2,r2,32
   23a6c:	10000526 	beq	r2,zero,23a84 <ECAT_Main+0x98>
            {
                if (bExplicitDevIdRequested == FALSE)
   23a70:	d0a15683 	ldbu	r2,-31398(gp)
   23a74:	1000021e 	bne	r2,zero,23a80 <ECAT_Main+0x94>
                {
                    u16IdValue = APPL_GetDeviceID();
   23a78:	002031c0 	call	2031c <APPL_GetDeviceID>
   23a7c:	d0a1540d 	sth	r2,-31408(gp)
                }

                bExplicitDevIdRequested = TRUE;
   23a80:	04400044 	movi	r17,1

        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));

            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23a84:	d9000083 	ldbu	r4,2(sp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   23a88:	00bffb84 	movi	r2,-18
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23a8c:	000b883a 	mov	r5,zero
                bExplicitDevIdRequested = TRUE;
   23a90:	d4615685 	stb	r17,-31398(gp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   23a94:	1420703a 	and	r16,r2,r16
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23a98:	00229700 	call	22970 <AL_ControlInd>

            /* SM-Change-Event was handled too */

    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   23a9c:	8400040c 	andi	r16,r16,16
   23aa0:	d0a15983 	ldbu	r2,-31386(gp)
   23aa4:	80002e26 	beq	r16,zero,23b60 <ECAT_Main+0x174>
   23aa8:	10803fcc 	andi	r2,r2,255
   23aac:	10002326 	beq	r2,zero,23b3c <ECAT_Main+0x150>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
    }

    if(bEcatWaitForAlControlRes)
    {
        AL_ControlRes();
   23ab0:	00232840 	call	23284 <AL_ControlRes>
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
   23ab4:	d0a16c43 	ldbu	r2,-31311(gp)
   23ab8:	10001b26 	beq	r2,zero,23b28 <ECAT_Main+0x13c>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
            if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
   23abc:	d8800003 	ldbu	r2,0(sp)
   23ac0:	1080004c 	andi	r2,r2,1
   23ac4:	1000041e 	bne	r2,zero,23ad8 <ECAT_Main+0xec>
            {
                AL_ControlInd(nAlStatus & STATE_MASK, 0);
   23ac8:	d12156c3 	ldbu	r4,-31397(gp)
   23acc:	000b883a 	mov	r5,zero
   23ad0:	210003cc 	andi	r4,r4,15
   23ad4:	00229700 	call	22970 <AL_ControlInd>
            }

/*ECATCHANGE_START(V5.13) MBX1*/
        if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
   23ad8:	d8800043 	ldbu	r2,1(sp)
   23adc:	1080020c 	andi	r2,r2,8
   23ae0:	1000081e 	bne	r2,zero,23b04 <ECAT_Main+0x118>
            && bSendMbxIsFull) 
   23ae4:	d0a16c83 	ldbu	r2,-31310(gp)
   23ae8:	10000626 	beq	r2,zero,23b04 <ECAT_Main+0x118>
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u8dummy = 0;
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   23aec:	d1616a0b 	ldhu	r5,-31320(gp)
   23af0:	01800044 	movi	r6,1
   23af4:	d12153c4 	addi	r4,gp,-31409
            u8dummy = 0;
   23af8:	d02153c5 	stb	zero,-31409(gp)
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   23afc:	00206640 	call	20664 <HW_EscWrite>

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
            MBX_MailboxReadInd();
   23b00:	002413c0 	call	2413c <MBX_MailboxReadInd>
        }

            /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

            if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
   23b04:	d8800003 	ldbu	r2,0(sp)
   23b08:	d0e16c03 	ldbu	r3,-31312(gp)
   23b0c:	1080008c 	andi	r2,r2,2
   23b10:	10001626 	beq	r2,zero,23b6c <ECAT_Main+0x180>
   23b14:	18001626 	beq	r3,zero,23b70 <ECAT_Main+0x184>
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
            }


        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
   23b18:	00206180 	call	20618 <HW_GetALEventRegister>
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
   23b1c:	1080400c 	andi	r2,r2,256
   23b20:	10000126 	beq	r2,zero,23b28 <ECAT_Main+0x13c>
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
            MBX_CheckAndCopyMailbox();
   23b24:	00244240 	call	24424 <MBX_CheckAndCopyMailbox>

        }
    }
}
   23b28:	dfc00317 	ldw	ra,12(sp)
   23b2c:	dc400217 	ldw	r17,8(sp)
   23b30:	dc000117 	ldw	r16,4(sp)
   23b34:	dec00404 	addi	sp,sp,16
   23b38:	f800283a 	ret
    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   23b3c:	d12156c3 	ldbu	r4,-31397(gp)
   23b40:	2080040c 	andi	r2,r4,16
   23b44:	103fdb1e 	bne	r2,zero,23ab4 <ECAT_Main+0xc8>
   23b48:	20803bcc 	andi	r2,r4,239
   23b4c:	10800060 	cmpeqi	r2,r2,1
   23b50:	103fd81e 	bne	r2,zero,23ab4 <ECAT_Main+0xc8>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
   23b54:	000b883a 	mov	r5,zero
   23b58:	210003cc 	andi	r4,r4,15
   23b5c:	00229700 	call	22970 <AL_ControlInd>
    if(bEcatWaitForAlControlRes)
   23b60:	d0a15983 	ldbu	r2,-31386(gp)
   23b64:	103fd326 	beq	r2,zero,23ab4 <ECAT_Main+0xc8>
   23b68:	003fd106 	br	23ab0 <ECAT_Main+0xc4>
                || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
   23b6c:	183fea26 	beq	r3,zero,23b18 <ECAT_Main+0x12c>
                MBX_MailboxRepeatReq();
   23b70:	00241fc0 	call	241fc <MBX_MailboxRepeatReq>
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23b74:	d8800003 	ldbu	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23b78:	01800044 	movi	r6,1
   23b7c:	014203c4 	movi	r5,2063
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23b80:	1080008c 	andi	r2,r2,2
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23b84:	d809883a 	mov	r4,sp
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23b88:	d8800005 	stb	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23b8c:	00206640 	call	20664 <HW_EscWrite>
   23b90:	003fe106 	br	23b18 <ECAT_Main+0x12c>

00023b94 <FOE_Read>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Read(UINT16 MBXMEM * pName, UINT16 nameSize, UINT16 MBXMEM * pData, UINT32 password)
{
    
    if (pAPPL_FoeRead != NULL)
   23b94:	d0e14817 	ldw	r3,-31456(gp)
   23b98:	18000b26 	beq	r3,zero,23bc8 <FOE_Read+0x34>
   23b9c:	3005883a 	mov	r2,r6
   23ba0:	380d883a 	mov	r6,r7
    {
        return  pAPPL_FoeRead(pName, nameSize, password, u16FoeMaxSendBlockSize, pData);
   23ba4:	d1e14b0b 	ldhu	r7,-31444(gp)
{
   23ba8:	defffe04 	addi	sp,sp,-8
   23bac:	dfc00115 	stw	ra,4(sp)
        return  pAPPL_FoeRead(pName, nameSize, password, u16FoeMaxSendBlockSize, pData);
   23bb0:	d8800015 	stw	r2,0(sp)
   23bb4:	297fffcc 	andi	r5,r5,65535
   23bb8:	183ee83a 	callr	r3
    }


    return ECAT_FOE_ERRCODE_NOTDEFINED;
}
   23bbc:	dfc00117 	ldw	ra,4(sp)
   23bc0:	dec00204 	addi	sp,sp,8
   23bc4:	f800283a 	ret
    return ECAT_FOE_ERRCODE_NOTDEFINED;
   23bc8:	00a00004 	movi	r2,-32768
}
   23bcc:	f800283a 	ret

00023bd0 <FOE_Write>:

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Write(UINT16 MBXMEM * pName, UINT16 nameSize, UINT32 password)
{
    if (pAPPL_FoeWrite != NULL)
   23bd0:	d0a14517 	ldw	r2,-31468(gp)
   23bd4:	10000226 	beq	r2,zero,23be0 <FOE_Write+0x10>
    {
        return pAPPL_FoeWrite(pName,nameSize,password);
   23bd8:	297fffcc 	andi	r5,r5,65535
   23bdc:	1000683a 	jmp	r2
    }

    return ECAT_FOE_ERRCODE_NOTDEFINED;
}
   23be0:	00a00004 	movi	r2,-32768
   23be4:	f800283a 	ret

00023be8 <FOE_Data>:
 \brief    The function is called to write the next part of a file

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Data(UINT16 MBXMEM * pData, UINT16 Size)
{
   23be8:	defffd04 	addi	sp,sp,-12
   23bec:	dc400115 	stw	r17,4(sp)
    BOOL bDataFollowing = FALSE;

    if(Size == (u16ReceiveMbxSize - MBX_HEADER_SIZE - FOE_HEADER_SIZE) )
   23bf0:	d4616b0b 	ldhu	r17,-31316(gp)
    {
        bDataFollowing = TRUE;
    }

    if(pAPPL_FoeWriteData != NULL)
   23bf4:	d0a14417 	ldw	r2,-31472(gp)
{
   23bf8:	dc000015 	stw	r16,0(sp)
    if(Size == (u16ReceiveMbxSize - MBX_HEADER_SIZE - FOE_HEADER_SIZE) )
   23bfc:	8c7ffd04 	addi	r17,r17,-12
   23c00:	2c3fffcc 	andi	r16,r5,65535
{
   23c04:	dfc00215 	stw	ra,8(sp)
    if(Size == (u16ReceiveMbxSize - MBX_HEADER_SIZE - FOE_HEADER_SIZE) )
   23c08:	844d003a 	cmpeq	r6,r16,r17
    if(pAPPL_FoeWriteData != NULL)
   23c0c:	10000b26 	beq	r2,zero,23c3c <FOE_Data+0x54>
    {
        UINT16 error = 0;
        error = pAPPL_FoeWriteData(pData, Size, bDataFollowing);
   23c10:	800b883a 	mov	r5,r16
   23c14:	103ee83a 	callr	r2

        if (error > 0)
   23c18:	10ffffcc 	andi	r3,r2,65535
   23c1c:	1800021e 	bne	r3,zero,23c28 <FOE_Data+0x40>
        {
            return error;
        }
        else if (bDataFollowing == FALSE)
   23c20:	84400126 	beq	r16,r17,23c28 <FOE_Data+0x40>
        {
            return FOE_ACKFINISHED;
   23c24:	009fff04 	movi	r2,32764
    }


    return ECAT_FOE_ERRCODE_NOTDEFINED;

}
   23c28:	dfc00217 	ldw	ra,8(sp)
   23c2c:	dc400117 	ldw	r17,4(sp)
   23c30:	dc000017 	ldw	r16,0(sp)
   23c34:	dec00304 	addi	sp,sp,12
   23c38:	f800283a 	ret
    return ECAT_FOE_ERRCODE_NOTDEFINED;
   23c3c:	00a00004 	movi	r2,-32768
   23c40:	003ff906 	br	23c28 <FOE_Data+0x40>

00023c44 <FOE_Ack>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Ack(UINT32 fileOffset, UINT16 MBXMEM * pData)
{

    if (pAPPL_FoeReadData != NULL)
   23c44:	d0a14717 	ldw	r2,-31460(gp)
{
   23c48:	280d883a 	mov	r6,r5
    if (pAPPL_FoeReadData != NULL)
   23c4c:	10000226 	beq	r2,zero,23c58 <FOE_Ack+0x14>
    {
        return pAPPL_FoeReadData(fileOffset, u16FoeMaxSendBlockSize, pData);
   23c50:	d1614b0b 	ldhu	r5,-31444(gp)
   23c54:	1000683a 	jmp	r2
    }

    return ECAT_FOE_ERRCODE_NOTDEFINED;
}
   23c58:	00a00004 	movi	r2,-32768
   23c5c:	f800283a 	ret

00023c60 <FOE_Busy>:
 \brief    The function is called when the reading of a part of a file should be repeated

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Busy(UINT16 done, UINT32 fileOffset, UINT16 MBXMEM * pData)
{
   23c60:	2809883a 	mov	r4,r5
   23c64:	300b883a 	mov	r5,r6
    /* send last part again */
    return FOE_Ack(fileOffset, pData);
   23c68:	0023c441 	jmpi	23c44 <FOE_Ack>

00023c6c <FOE_Error>:

*////////////////////////////////////////////////////////////////////////////////////////

void FOE_Error(UINT32 errorCode)
{
    if (pAPPL_FoeError != NULL)
   23c6c:	d0a14617 	ldw	r2,-31464(gp)
   23c70:	10000126 	beq	r2,zero,23c78 <FOE_Error+0xc>
    {
        pAPPL_FoeError(errorCode);
   23c74:	1000683a 	jmp	r2
    }
}
   23c78:	f800283a 	ret

00023c7c <PutInMbxQueue>:
{
    UINT16 lastInQueue;
    ENTER_MBX_CRITICAL;


    lastInQueue = pQueue->lastInQueue+1;
   23c7c:	2880008b 	ldhu	r2,2(r5)
    if (lastInQueue == pQueue->maxQueueSize)
   23c80:	29c0010b 	ldhu	r7,4(r5)
    lastInQueue = pQueue->lastInQueue+1;
   23c84:	10c00044 	addi	r3,r2,1
   23c88:	180d883a 	mov	r6,r3
    if (lastInQueue == pQueue->maxQueueSize)
   23c8c:	18ffffcc 	andi	r3,r3,65535
   23c90:	38c0011e 	bne	r7,r3,23c98 <PutInMbxQueue+0x1c>
    {
        // Umbruch der Queue
        lastInQueue = 0;
   23c94:	000d883a 	mov	r6,zero
    }

    if (pQueue->firstInQueue == lastInQueue)
   23c98:	29c0000b 	ldhu	r7,0(r5)
   23c9c:	30ffffcc 	andi	r3,r6,65535
   23ca0:	38c00826 	beq	r7,r3,23cc4 <PutInMbxQueue+0x48>
        // Ueberlauf der Queue -> letztes Element wieder herausnehmen
        LEAVE_MBX_CRITICAL;
        return MBXERR_NOMOREMEMORY;
    }

    pQueue->queue[pQueue->lastInQueue] = pMbx;
   23ca4:	10bfffcc 	andi	r2,r2,65535
   23ca8:	10800084 	addi	r2,r2,2
   23cac:	100490ba 	slli	r2,r2,2
   23cb0:	2885883a 	add	r2,r5,r2
   23cb4:	11000015 	stw	r4,0(r2)
    pQueue->lastInQueue = lastInQueue;
   23cb8:	2980008d 	sth	r6,2(r5)

    LEAVE_MBX_CRITICAL;

    return 0;
   23cbc:	0005883a 	mov	r2,zero
   23cc0:	f800283a 	ret
        return MBXERR_NOMOREMEMORY;
   23cc4:	008001c4 	movi	r2,7
}
   23cc8:	f800283a 	ret

00023ccc <GetOutOfMbxQueue>:
TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
   23ccc:	20c0000b 	ldhu	r3,0(r4)
   23cd0:	2140008b 	ldhu	r5,2(r4)
   23cd4:	18bfffcc 	andi	r2,r3,65535
   23cd8:	11400b26 	beq	r2,r5,23d08 <GetOutOfMbxQueue+0x3c>
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
        pMbx = pQueue->queue[firstInQueue];
   23cdc:	10800084 	addi	r2,r2,2
   23ce0:	100490ba 	slli	r2,r2,2
        firstInQueue++;
        pQueue->firstInQueue = firstInQueue;
        
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23ce4:	2140010b 	ldhu	r5,4(r4)
        firstInQueue++;
   23ce8:	18c00044 	addi	r3,r3,1
        pMbx = pQueue->queue[firstInQueue];
   23cec:	2085883a 	add	r2,r4,r2
   23cf0:	10800017 	ldw	r2,0(r2)
        pQueue->firstInQueue = firstInQueue;
   23cf4:	20c0000d 	sth	r3,0(r4)
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23cf8:	18ffffcc 	andi	r3,r3,65535
   23cfc:	28c0031e 	bne	r5,r3,23d0c <GetOutOfMbxQueue+0x40>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
   23d00:	2000000d 	sth	zero,0(r4)
   23d04:	f800283a 	ret
        }
    }
    else
    {
        pMbx = 0;
   23d08:	0005883a 	mov	r2,zero


    LEAVE_MBX_CRITICAL;

    return pMbx;
}
   23d0c:	f800283a 	ret

00023d10 <MBX_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
   23d10:	00800904 	movi	r2,36
   23d14:	d0a16b0d 	sth	r2,-31316(gp)
    u16SendMbxSize = MAX_MBX_SIZE;
   23d18:	00802004 	movi	r2,128
   23d1c:	d0a16b8d 	sth	r2,-31314(gp)
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
   23d20:	00840004 	movi	r2,4096
   23d24:	d0a16a8d 	sth	r2,-31318(gp)
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
   23d28:	d0a16a0d 	sth	r2,-31320(gp)

    sMbxReceiveQueue.firstInQueue    = 0;
   23d2c:	008000f4 	movhi	r2,3
   23d30:	10230715 	stw	zero,-29668(r2)
    sMbxReceiveQueue.lastInQueue     = 0;
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   23d34:	00c000f4 	movhi	r3,3
   23d38:	00800284 	movi	r2,10
{
   23d3c:	defffe04 	addi	sp,sp,-8
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   23d40:	18a3080d 	sth	r2,-29664(r3)
    sMbxSendQueue.firstInQueue        = 0;
   23d44:	00c000f4 	movhi	r3,3

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d48:	d90000c4 	addi	r4,sp,3
    sMbxSendQueue.firstInQueue        = 0;
   23d4c:	18231415 	stw	zero,-29616(r3)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d50:	01800044 	movi	r6,1
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   23d54:	00c000f4 	movhi	r3,3
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d58:	014203c4 	movi	r5,2063
{
   23d5c:	dfc00115 	stw	ra,4(sp)
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   23d60:	18a3150d 	sth	r2,-29612(r3)
        UINT8 sm1Activate = 0;
   23d64:	d80000c5 	stb	zero,3(sp)
    psWriteMbx  = NULL;
   23d68:	d0216815 	stw	zero,-31328(gp)
    psRepeatMbx = NULL;
   23d6c:	d0216615 	stw	zero,-31336(gp)
    psReadMbx    = NULL;
   23d70:	d0216715 	stw	zero,-31332(gp)
    psStoreMbx    = NULL;
   23d74:	d0216515 	stw	zero,-31340(gp)
    bMbxRepeatToggle    = FALSE;
   23d78:	d0216c05 	stb	zero,-31312(gp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d7c:	00205e00 	call	205e0 <HW_EscRead>
        sm1Activate &= ~0x02;
   23d80:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d84:	01800044 	movi	r6,1
   23d88:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23d8c:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d90:	d90000c4 	addi	r4,sp,3
        sm1Activate &= ~0x02;
   23d94:	d88000c5 	stb	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d98:	00206640 	call	20664 <HW_EscWrite>
    }
    bMbxRunning = FALSE;
   23d9c:	d0216c45 	stb	zero,-31311(gp)
    bSendMbxIsFull = FALSE;
   23da0:	d0216c85 	stb	zero,-31310(gp)
    bReceiveMbxIsLocked = FALSE;
   23da4:	d0216cc5 	stb	zero,-31309(gp)
    u8MailboxSendReqStored    = 0;
   23da8:	d0216905 	stb	zero,-31324(gp)
    u8MbxWriteCounter = 0;
   23dac:	d0216985 	stb	zero,-31322(gp)
    u8MbxReadCounter    = 0;
   23db0:	d0216945 	stb	zero,-31323(gp)
}
   23db4:	dfc00117 	ldw	ra,4(sp)
   23db8:	dec00204 	addi	sp,sp,8
   23dbc:	f800283a 	ret

00023dc0 <MBX_StartMailboxHandler>:
 \brief     it is checked if the mailbox areas overlaps each other
 \brief     and the Sync Manager channels 0 and 1 are enabled.
 \brief     This function shall only be called if mailbox is supported.
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 MBX_StartMailboxHandler(void)
{
   23dc0:	defffe04 	addi	sp,sp,-8
    UINT16 result = 0;
    
    /* get address of the receive mailbox sync manager (SM0) */
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   23dc4:	0009883a 	mov	r4,zero
{
   23dc8:	dfc00115 	stw	ra,4(sp)
   23dcc:	dc000015 	stw	r16,0(sp)
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   23dd0:	0021cf40 	call	21cf4 <GetSyncMan>

    /* store size of the receive mailbox */
    u16ReceiveMbxSize     = pSyncMan->Length;
   23dd4:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the receive mailbox */
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23dd8:	1080000b 	ldhu	r2,0(r2)

    /* get address of the send mailbox sync manager (SM1) */
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23ddc:	01000044 	movi	r4,1
    u16ReceiveMbxSize     = pSyncMan->Length;
   23de0:	d0e16b0d 	sth	r3,-31316(gp)
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23de4:	d0a16a8d 	sth	r2,-31318(gp)
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23de8:	0021cf40 	call	21cf4 <GetSyncMan>

    /* store the size of the send mailbox */
    u16SendMbxSize = pSyncMan->Length;
   23dec:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the send mailbox */
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;

    // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23df0:	d1616a8b 	ldhu	r5,-31318(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23df4:	1080000b 	ldhu	r2,0(r2)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23df8:	d1216b0b 	ldhu	r4,-31316(gp)
    u16SendMbxSize = pSyncMan->Length;
   23dfc:	d0e16b8d 	sth	r3,-31314(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23e00:	d0a16a0d 	sth	r2,-31320(gp)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23e04:	2149883a 	add	r4,r4,r5
   23e08:	10bfffcc 	andi	r2,r2,65535
   23e0c:	1100030e 	bge	r2,r4,23e1c <MBX_StartMailboxHandler+0x5c>
   23e10:	193fffcc 	andi	r4,r3,65535
   23e14:	2085883a 	add	r2,r4,r2
   23e18:	28801e16 	blt	r5,r2,23e94 <MBX_StartMailboxHandler+0xd4>
    {
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
    }

    u16FoeMaxSendBlockSize = (u16SendMbxSize - SIZEOF(TFOEHEADER) - MBX_HEADER_SIZE);
   23e1c:	18fffd04 	addi	r3,r3,-12

    /* enable the receive mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_WRITE);
   23e20:	0009883a 	mov	r4,zero
    u16FoeMaxSendBlockSize = (u16SendMbxSize - SIZEOF(TFOEHEADER) - MBX_HEADER_SIZE);
   23e24:	d0e14b0d 	sth	r3,-31444(gp)
    EnableSyncManChannel(MAILBOX_WRITE);
   23e28:	0021d840 	call	21d84 <EnableSyncManChannel>
    /* enable the send mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_READ);
   23e2c:	01000044 	movi	r4,1
   23e30:	0021d840 	call	21d84 <EnableSyncManChannel>

        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   23e34:	d1216b0b 	ldhu	r4,-31316(gp)
   23e38:	002704c0 	call	2704c <malloc>
   23e3c:	d0a16815 	stw	r2,-31328(gp)
   23e40:	1009883a 	mov	r4,r2
        if(psWriteMbx == NULL)
   23e44:	10000e1e 	bne	r2,zero,23e80 <MBX_StartMailboxHandler+0xc0>
        {
            bNoMbxMemoryAvailable = TRUE;
   23e48:	00800044 	movi	r2,1

            //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23e4c:	01000284 	movi	r4,10
            bNoMbxMemoryAvailable = TRUE;
   23e50:	d0a16405 	stb	r2,-31344(gp)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23e54:	002704c0 	call	2704c <malloc>
            if(psWriteMbx == NULL)
   23e58:	1021003a 	cmpeq	r16,r2,zero
   23e5c:	8020907a 	slli	r16,r16,1
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23e60:	1009883a 	mov	r4,r2
            {
                result = ALSTATUSCODE_NOMEMORY;
            }

            APPL_FreeMailboxBuffer(psWriteMbx);
   23e64:	002705c0 	call	2705c <free>
            psWriteMbx = NULL;
   23e68:	d0216815 	stw	zero,-31328(gp)
            APPL_FreeMailboxBuffer(psWriteMbx);
            psWriteMbx = NULL;
        }

    return result;
}
   23e6c:	8005883a 	mov	r2,r16
   23e70:	dfc00117 	ldw	ra,4(sp)
   23e74:	dc000017 	ldw	r16,0(sp)
   23e78:	dec00204 	addi	sp,sp,8
   23e7c:	f800283a 	ret
            bNoMbxMemoryAvailable = FALSE;
   23e80:	d0216405 	stb	zero,-31344(gp)
    UINT16 result = 0;
   23e84:	0021883a 	mov	r16,zero
            APPL_FreeMailboxBuffer(psWriteMbx);
   23e88:	002705c0 	call	2705c <free>
            psWriteMbx = NULL;
   23e8c:	d0216815 	stw	zero,-31328(gp)
   23e90:	003ff606 	br	23e6c <MBX_StartMailboxHandler+0xac>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
   23e94:	04000584 	movi	r16,22
   23e98:	003ff406 	br	23e6c <MBX_StartMailboxHandler+0xac>

00023e9c <MBX_StopMailboxHandler>:
 \brief  local management service Stop Mailbox Handler
 \brief  the Sync Manager channels 0 and 1 are disabled
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_StopMailboxHandler(void)
{
   23e9c:	defffd04 	addi	sp,sp,-12
    TMBX MBXMEM * pMbx;

    /* mailbox handler is stopped */
    bMbxRunning = FALSE;
    /* disable the receive mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_WRITE);
   23ea0:	0009883a 	mov	r4,zero
{
   23ea4:	dfc00215 	stw	ra,8(sp)
   23ea8:	dc000115 	stw	r16,4(sp)
    bMbxRunning = FALSE;
   23eac:	d0216c45 	stb	zero,-31311(gp)
    DisableSyncManChannel(MAILBOX_WRITE);
   23eb0:	0021d240 	call	21d24 <DisableSyncManChannel>
    /* disable the send mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_READ);
   23eb4:	01000044 	movi	r4,1
   23eb8:	0021d240 	call	21d24 <DisableSyncManChannel>
    /* initialize variables again */


    if (psRepeatMbx != NULL)
   23ebc:	d1216617 	ldw	r4,-31336(gp)
   23ec0:	20000126 	beq	r4,zero,23ec8 <MBX_StopMailboxHandler+0x2c>
    {
        APPL_FreeMailboxBuffer(psRepeatMbx);
   23ec4:	002705c0 	call	2705c <free>
    }

    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
   23ec8:	d1216517 	ldw	r4,-31340(gp)
   23ecc:	20000326 	beq	r4,zero,23edc <MBX_StopMailboxHandler+0x40>
   23ed0:	d0a16617 	ldw	r2,-31336(gp)
   23ed4:	20800126 	beq	r4,r2,23edc <MBX_StopMailboxHandler+0x40>
    {
        APPL_FreeMailboxBuffer(psStoreMbx);
   23ed8:	002705c0 	call	2705c <free>
    }

    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
   23edc:	d1216717 	ldw	r4,-31332(gp)
   23ee0:	20000526 	beq	r4,zero,23ef8 <MBX_StopMailboxHandler+0x5c>
   23ee4:	d0a16617 	ldw	r2,-31336(gp)
   23ee8:	20800326 	beq	r4,r2,23ef8 <MBX_StopMailboxHandler+0x5c>
   23eec:	d0a16517 	ldw	r2,-31340(gp)
   23ef0:	20800126 	beq	r4,r2,23ef8 <MBX_StopMailboxHandler+0x5c>
    {
        APPL_FreeMailboxBuffer(psReadMbx);
   23ef4:	002705c0 	call	2705c <free>
    }


    SDOS_ClearPendingResponse();
   23ef8:	00266dc0 	call	266dc <SDOS_ClearPendingResponse>


    FOE_Init();
   23efc:	00218440 	call	21844 <FOE_Init>

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f00:	01800044 	movi	r6,1
   23f04:	014203c4 	movi	r5,2063
   23f08:	d90000c4 	addi	r4,sp,3
    psWriteMbx = NULL;
   23f0c:	d0216815 	stw	zero,-31328(gp)
    psRepeatMbx = NULL;
   23f10:	d0216615 	stw	zero,-31336(gp)
    psReadMbx = NULL;
   23f14:	d0216715 	stw	zero,-31332(gp)
    psStoreMbx = NULL;
   23f18:	d0216515 	stw	zero,-31340(gp)
    bMbxRepeatToggle    = FALSE;
   23f1c:	d0216c05 	stb	zero,-31312(gp)
        UINT8 sm1Activate = 0;
   23f20:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f24:	00205e00 	call	205e0 <HW_EscRead>
        sm1Activate &= ~0x02;
   23f28:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f2c:	01800044 	movi	r6,1
   23f30:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23f34:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f38:	d90000c4 	addi	r4,sp,3
    u8MbxWriteCounter         = 0;
    u8MbxReadCounter        = 0;

    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23f3c:	040000f4 	movhi	r16,3
        sm1Activate &= ~0x02;
   23f40:	d88000c5 	stb	r2,3(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23f44:	84230704 	addi	r16,r16,-29668
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f48:	00206640 	call	20664 <HW_EscWrite>
    bSendMbxIsFull         = FALSE;
   23f4c:	d0216c85 	stb	zero,-31310(gp)
    bReceiveMbxIsLocked = FALSE;
   23f50:	d0216cc5 	stb	zero,-31309(gp)
    u8MailboxSendReqStored    = 0;
   23f54:	d0216905 	stb	zero,-31324(gp)
    u8MbxWriteCounter         = 0;
   23f58:	d0216985 	stb	zero,-31322(gp)
    u8MbxReadCounter        = 0;
   23f5c:	d0216945 	stb	zero,-31323(gp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23f60:	8009883a 	mov	r4,r16
   23f64:	0023ccc0 	call	23ccc <GetOutOfMbxQueue>
   23f68:	1009883a 	mov	r4,r2
        if (pMbx)
   23f6c:	1000081e 	bne	r2,zero,23f90 <MBX_StopMailboxHandler+0xf4>
        }
    } while (pMbx != NULL);
    
    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23f70:	040000f4 	movhi	r16,3
   23f74:	84231404 	addi	r16,r16,-29616
   23f78:	8009883a 	mov	r4,r16
   23f7c:	0023ccc0 	call	23ccc <GetOutOfMbxQueue>
   23f80:	1009883a 	mov	r4,r2
        if (pMbx)
   23f84:	10000426 	beq	r2,zero,23f98 <MBX_StopMailboxHandler+0xfc>
        {
            APPL_FreeMailboxBuffer(pMbx);
   23f88:	002705c0 	call	2705c <free>
        }
    } while (pMbx != NULL);
   23f8c:	003ffa06 	br	23f78 <MBX_StopMailboxHandler+0xdc>
            APPL_FreeMailboxBuffer(pMbx);
   23f90:	002705c0 	call	2705c <free>
    } while (pMbx != NULL);
   23f94:	003ff206 	br	23f60 <MBX_StopMailboxHandler+0xc4>

}
   23f98:	dfc00217 	ldw	ra,8(sp)
   23f9c:	dc000117 	ldw	r16,4(sp)
   23fa0:	dec00304 	addi	sp,sp,12
   23fa4:	f800283a 	ret

00023fa8 <MailboxServiceInd>:
UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
{
    UINT8 result;

    /*only FoE is allowed in Boot mode*/
    if(bBootMode == TRUE && (MBX_TYPE_FOE != ((pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )))
   23fa8:	2080010b 	ldhu	r2,4(r4)
   23fac:	d16163c3 	ldbu	r5,-31345(gp)
{
   23fb0:	2007883a 	mov	r3,r4
    if(bBootMode == TRUE && (MBX_TYPE_FOE != ((pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )))
   23fb4:	1005d23a 	srai	r2,r2,8
   23fb8:	29400058 	cmpnei	r5,r5,1
   23fbc:	108003cc 	andi	r2,r2,15
   23fc0:	2800041e 	bne	r5,zero,23fd4 <MailboxServiceInd+0x2c>
   23fc4:	10800118 	cmpnei	r2,r2,4
   23fc8:	10000626 	beq	r2,zero,23fe4 <MailboxServiceInd+0x3c>
        result = MBXERR_UNSUPPORTEDPROTOCOL;
        break;
    }

    return result;
}
   23fcc:	00800084 	movi	r2,2
   23fd0:	f800283a 	ret
    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
   23fd4:	114000e0 	cmpeqi	r5,r2,3
   23fd8:	2800041e 	bne	r5,zero,23fec <MailboxServiceInd+0x44>
   23fdc:	10800120 	cmpeqi	r2,r2,4
   23fe0:	103ffa26 	beq	r2,zero,23fcc <MailboxServiceInd+0x24>
        result = FOE_ServiceInd((TFOEMBX MBXMEM *) pMbx);
   23fe4:	1809883a 	mov	r4,r3
   23fe8:	00218541 	jmpi	21854 <FOE_ServiceInd>
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
   23fec:	00217941 	jmpi	21794 <COE_ServiceInd>

00023ff0 <MBX_CopyToSendMailbox>:
 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23ff0:	d0a156c3 	ldbu	r2,-31397(gp)
{
   23ff4:	defff804 	addi	sp,sp,-32
   23ff8:	dfc00715 	stw	ra,28(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23ffc:	108003cc 	andi	r2,r2,15
{
   24000:	dd400615 	stw	r21,24(sp)
   24004:	dd000515 	stw	r20,20(sp)
   24008:	dcc00415 	stw	r19,16(sp)
   2400c:	dc800315 	stw	r18,12(sp)
   24010:	dc400215 	stw	r17,8(sp)
   24014:	dc000115 	stw	r16,4(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   24018:	10800060 	cmpeqi	r2,r2,1
   2401c:	1000431e 	bne	r2,zero,2412c <MBX_CopyToSendMailbox+0x13c>
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }


    if ( !bMbxRunning )
   24020:	d0a16c43 	ldbu	r2,-31311(gp)
   24024:	10004126 	beq	r2,zero,2412c <MBX_CopyToSendMailbox+0x13c>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }

    if ( bSendMbxIsFull )
   24028:	d4e16c83 	ldbu	r19,-31310(gp)
   2402c:	98803fcc 	andi	r2,r19,255
   24030:	1000401e 	bne	r2,zero,24134 <MBX_CopyToSendMailbox+0x144>
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
/*ECATCHANGE_START(V5.13) MBX2*/
        /*Reset the not used mailbox memory*/
        {
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   24034:	d4216a0b 	ldhu	r16,-31320(gp)
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   24038:	d5216b8b 	ldhu	r20,-31314(gp)
        UINT16 mbxSize = pMbx->MbxHeader.Length;
   2403c:	2440000b 	ldhu	r17,0(r4)
   24040:	2025883a 	mov	r18,r4
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   24044:	a429883a 	add	r20,r20,r16
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   24048:	84000184 	addi	r16,r16,6
            LastAddrToReset = LastAddrToReset - 1;
   2404c:	a53fffc4 	addi	r20,r20,-1
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   24050:	8461883a 	add	r16,r16,r17
            u8dummy = 0;
   24054:	d02153c5 	stb	zero,-31409(gp)

            /*clear all unused bytes*/
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   24058:	843fffcc 	andi	r16,r16,65535
   2405c:	a53fffcc 	andi	r20,r20,65535
            {
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   24060:	d56153c4 	addi	r21,gp,-31409
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   24064:	80bfffcc 	andi	r2,r16,65535
   24068:	15002a36 	bltu	r2,r20,24114 <MBX_CopyToSendMailbox+0x124>
                LastUsedAddr = LastUsedAddr + 1;
            }
        }
/*ECATCHANGE_END(V5.13) MBX2*/

        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
   2406c:	d1616a0b 	ldhu	r5,-31320(gp)
   24070:	89800184 	addi	r6,r17,6
   24074:	31bfffcc 	andi	r6,r6,65535
   24078:	9009883a 	mov	r4,r18
   2407c:	00206640 	call	20664 <HW_EscWrite>


        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT8 smstate = 0x00;
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   24080:	01800044 	movi	r6,1
   24084:	01420344 	movi	r5,2061
   24088:	d90000c4 	addi	r4,sp,3
        VARVOLATILE UINT8 smstate = 0x00;
   2408c:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   24090:	00205e00 	call	205e0 <HW_EscRead>

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
   24094:	d88000c3 	ldbu	r2,3(sp)
   24098:	1080020c 	andi	r2,r2,8
   2409c:	10000d1e 	bne	r2,zero,240d4 <MBX_CopyToSendMailbox+0xe4>
        {
            UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
   240a0:	d0a16b8b 	ldhu	r2,-31314(gp)
   240a4:	1463c83a 	sub	r17,r2,r17

            /*in case of a slow ESC the buffer status may not indicate 'full' even if the complete buffer was written, trigger an additional write access only if not the complete buffer was written*/
            if (BytesLeft > 0)
   240a8:	8c7fffcc 	andi	r17,r17,65535
   240ac:	8c4001a0 	cmpeqi	r17,r17,6
   240b0:	8800081e 	bne	r17,zero,240d4 <MBX_CopyToSendMailbox+0xe4>
            {
                /*Write last Byte to trigger mailbox full flag*/
            u8dummy = 0;
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   240b4:	d1616a0b 	ldhu	r5,-31320(gp)
   240b8:	01800044 	movi	r6,1
   240bc:	d12153c4 	addi	r4,gp,-31409
   240c0:	288b883a 	add	r5,r5,r2
   240c4:	297fffc4 	addi	r5,r5,-1
   240c8:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   240cc:	d02153c5 	stb	zero,-31409(gp)
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   240d0:	00206640 	call	20664 <HW_EscWrite>
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
   240d4:	d0a16717 	ldw	r2,-31332(gp)
   240d8:	10000126 	beq	r2,zero,240e0 <MBX_CopyToSendMailbox+0xf0>
        {
            psWriteMbx = NULL;
   240dc:	d0216815 	stw	zero,-31328(gp)
        }
        psReadMbx = pMbx;

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
   240e0:	00800044 	movi	r2,1
        psReadMbx = pMbx;
   240e4:	d4a16715 	stw	r18,-31332(gp)
        bSendMbxIsFull = TRUE;
   240e8:	d0a16c85 	stb	r2,-31310(gp)


        return 0;
    }
}
   240ec:	9805883a 	mov	r2,r19
   240f0:	dfc00717 	ldw	ra,28(sp)
   240f4:	dd400617 	ldw	r21,24(sp)
   240f8:	dd000517 	ldw	r20,20(sp)
   240fc:	dcc00417 	ldw	r19,16(sp)
   24100:	dc800317 	ldw	r18,12(sp)
   24104:	dc400217 	ldw	r17,8(sp)
   24108:	dc000117 	ldw	r16,4(sp)
   2410c:	dec00804 	addi	sp,sp,32
   24110:	f800283a 	ret
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   24114:	800b883a 	mov	r5,r16
   24118:	01800044 	movi	r6,1
   2411c:	a809883a 	mov	r4,r21
   24120:	00206640 	call	20664 <HW_EscWrite>
                LastUsedAddr = LastUsedAddr + 1;
   24124:	84000044 	addi	r16,r16,1
   24128:	003fce06 	br	24064 <MBX_CopyToSendMailbox+0x74>
        return( ERROR_INVALIDSTATE );
   2412c:	04fffc04 	movi	r19,-16
   24130:	003fee06 	br	240ec <MBX_CopyToSendMailbox+0xfc>
        return MBXERR_NOMOREMEMORY;
   24134:	04c001c4 	movi	r19,7
   24138:	003fec06 	br	240ec <MBX_CopyToSendMailbox+0xfc>

0002413c <MBX_MailboxReadInd>:
    if (psRepeatMbx && psStoreMbx == NULL)
   2413c:	d1216617 	ldw	r4,-31336(gp)
{
   24140:	deffff04 	addi	sp,sp,-4
   24144:	dfc00015 	stw	ra,0(sp)
    bSendMbxIsFull = FALSE;
   24148:	d0216c85 	stb	zero,-31310(gp)
    if (psRepeatMbx && psStoreMbx == NULL)
   2414c:	20000526 	beq	r4,zero,24164 <MBX_MailboxReadInd+0x28>
   24150:	d0a16517 	ldw	r2,-31340(gp)
   24154:	1000031e 	bne	r2,zero,24164 <MBX_MailboxReadInd+0x28>
        if (psReadMbx != psRepeatMbx)
   24158:	d0a16717 	ldw	r2,-31332(gp)
   2415c:	20800126 	beq	r4,r2,24164 <MBX_MailboxReadInd+0x28>
            APPL_FreeMailboxBuffer(psRepeatMbx);
   24160:	002705c0 	call	2705c <free>
    psRepeatMbx = psReadMbx;
   24164:	d0a16717 	ldw	r2,-31332(gp)
      if ( psStoreMbx )
   24168:	d1216517 	ldw	r4,-31340(gp)
    psRepeatMbx = psReadMbx;
   2416c:	d0a16615 	stw	r2,-31336(gp)
      if ( psStoreMbx )
   24170:	20001326 	beq	r4,zero,241c0 <MBX_MailboxReadInd+0x84>
        MBX_CopyToSendMailbox(psStoreMbx);
   24174:	0023ff00 	call	23ff0 <MBX_CopyToSendMailbox>
        psStoreMbx = NULL;
   24178:	d0216515 	stw	zero,-31340(gp)
      if ( u8MailboxSendReqStored )
   2417c:	d0a16903 	ldbu	r2,-31324(gp)
   24180:	10c03fcc 	andi	r3,r2,255
   24184:	18000b26 	beq	r3,zero,241b4 <MBX_MailboxReadInd+0x78>
        if ( u8MailboxSendReqStored & COE_SERVICE )
   24188:	10c0008c 	andi	r3,r2,2
   2418c:	18001326 	beq	r3,zero,241dc <MBX_MailboxReadInd+0xa0>
            result = COE_ContinueInd(psWriteMbx);
   24190:	d1216817 	ldw	r4,-31328(gp)
            u8MailboxSendReqStored &= ~COE_SERVICE;
   24194:	10803f4c 	andi	r2,r2,253
   24198:	d0a16905 	stb	r2,-31324(gp)
            result = COE_ContinueInd(psWriteMbx);
   2419c:	00217dc0 	call	217dc <COE_ContinueInd>
            if (result != 0)
   241a0:	10803fcc 	andi	r2,r2,255
   241a4:	10000326 	beq	r2,zero,241b4 <MBX_MailboxReadInd+0x78>
                u8MailboxSendReqStored |= COE_SERVICE;
   241a8:	d0a16903 	ldbu	r2,-31324(gp)
   241ac:	10800094 	ori	r2,r2,2
   241b0:	d0a16905 	stb	r2,-31324(gp)
}
   241b4:	dfc00017 	ldw	ra,0(sp)
   241b8:	dec00104 	addi	sp,sp,4
   241bc:	f800283a 	ret
        TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   241c0:	010000f4 	movhi	r4,3
   241c4:	21231404 	addi	r4,r4,-29616
   241c8:	0023ccc0 	call	23ccc <GetOutOfMbxQueue>
   241cc:	1009883a 	mov	r4,r2
        if (pMbx)
   241d0:	103fea26 	beq	r2,zero,2417c <MBX_MailboxReadInd+0x40>
            MBX_CopyToSendMailbox(pMbx);
   241d4:	0023ff00 	call	23ff0 <MBX_CopyToSendMailbox>
   241d8:	003fe806 	br	2417c <MBX_MailboxReadInd+0x40>
        if ( u8MailboxSendReqStored & FOE_SERVICE )
   241dc:	10c0100c 	andi	r3,r2,64
   241e0:	183ff426 	beq	r3,zero,241b4 <MBX_MailboxReadInd+0x78>
            FOE_ContinueInd(psWriteMbx);
   241e4:	d1216817 	ldw	r4,-31328(gp)
            u8MailboxSendReqStored &= ~FOE_SERVICE;
   241e8:	10802fcc 	andi	r2,r2,191
   241ec:	d0a16905 	stb	r2,-31324(gp)
}
   241f0:	dfc00017 	ldw	ra,0(sp)
   241f4:	dec00104 	addi	sp,sp,4
            FOE_ContinueInd(psWriteMbx);
   241f8:	0021bf01 	jmpi	21bf0 <FOE_ContinueInd>

000241fc <MBX_MailboxRepeatReq>:
{
   241fc:	defffe04 	addi	sp,sp,-8
   24200:	dc000015 	stw	r16,0(sp)
    if (psRepeatMbx)
   24204:	d4216617 	ldw	r16,-31336(gp)
{
   24208:	dfc00115 	stw	ra,4(sp)
    if (psRepeatMbx)
   2420c:	80000e26 	beq	r16,zero,24248 <MBX_MailboxRepeatReq+0x4c>
       if (bSendMbxIsFull && psStoreMbx == NULL)
   24210:	d0a16c83 	ldbu	r2,-31310(gp)
   24214:	10000926 	beq	r2,zero,2423c <MBX_MailboxRepeatReq+0x40>
   24218:	d0a16517 	ldw	r2,-31340(gp)
   2421c:	1000071e 	bne	r2,zero,2423c <MBX_MailboxRepeatReq+0x40>
            DisableSyncManChannel(MAILBOX_READ);
   24220:	01000044 	movi	r4,1
   24224:	0021d240 	call	21d24 <DisableSyncManChannel>
            psStoreMbx = psReadMbx;
   24228:	d0a16717 	ldw	r2,-31332(gp)
            EnableSyncManChannel(MAILBOX_READ);
   2422c:	01000044 	movi	r4,1
            psStoreMbx = psReadMbx;
   24230:	d0a16515 	stw	r2,-31340(gp)
            EnableSyncManChannel(MAILBOX_READ);
   24234:	0021d840 	call	21d84 <EnableSyncManChannel>
            bSendMbxIsFull = FALSE;
   24238:	d0216c85 	stb	zero,-31310(gp)
        MBX_CopyToSendMailbox(pMbx);
   2423c:	8009883a 	mov	r4,r16
   24240:	0023ff00 	call	23ff0 <MBX_CopyToSendMailbox>
        psRepeatMbx = NULL;
   24244:	d0216615 	stw	zero,-31336(gp)
    bMbxRepeatToggle = !bMbxRepeatToggle;
   24248:	d0a16c03 	ldbu	r2,-31312(gp)
   2424c:	1005003a 	cmpeq	r2,r2,zero
   24250:	d0a16c05 	stb	r2,-31312(gp)
}
   24254:	dfc00117 	ldw	ra,4(sp)
   24258:	dc000017 	ldw	r16,0(sp)
   2425c:	dec00204 	addi	sp,sp,8
   24260:	f800283a 	ret

00024264 <MBX_MailboxSendReq>:
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
   24264:	d0a156c3 	ldbu	r2,-31397(gp)
   24268:	108003cc 	andi	r2,r2,15
   2426c:	10800060 	cmpeqi	r2,r2,1
   24270:	1000321e 	bne	r2,zero,2433c <MBX_MailboxSendReq+0xd8>
    if ( (u8MbxReadCounter & 0x07) == 0 )
   24274:	d0e16943 	ldbu	r3,-31323(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   24278:	2080010b 	ldhu	r2,4(r4)
{
   2427c:	defffc04 	addi	sp,sp,-16
   24280:	dc800215 	stw	r18,8(sp)
   24284:	dc400115 	stw	r17,4(sp)
   24288:	dc000015 	stw	r16,0(sp)
   2428c:	dfc00315 	stw	ra,12(sp)
    if ( (u8MbxReadCounter & 0x07) == 0 )
   24290:	18c001cc 	andi	r3,r3,7
   24294:	2025883a 	mov	r18,r4
   24298:	2823883a 	mov	r17,r5
   2429c:	2821883a 	mov	r16,r5
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   242a0:	1083ffcc 	andi	r2,r2,4095
    if ( (u8MbxReadCounter & 0x07) == 0 )
   242a4:	1800021e 	bne	r3,zero,242b0 <MBX_MailboxSendReq+0x4c>
        u8MbxReadCounter = 1;
   242a8:	00c00044 	movi	r3,1
   242ac:	d0e16945 	stb	r3,-31323(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   242b0:	d0e16943 	ldbu	r3,-31323(gp)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   242b4:	9009883a 	mov	r4,r18
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   242b8:	1806933a 	slli	r3,r3,12
   242bc:	10c4b03a 	or	r2,r2,r3
   242c0:	9080010d 	sth	r2,4(r18)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   242c4:	0023ff00 	call	23ff0 <MBX_CopyToSendMailbox>
   242c8:	10803fcc 	andi	r2,r2,255
   242cc:	10000d26 	beq	r2,zero,24304 <MBX_MailboxSendReq+0xa0>
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
   242d0:	014000f4 	movhi	r5,3
   242d4:	29631404 	addi	r5,r5,-29616
   242d8:	9009883a 	mov	r4,r18
   242dc:	0023c7c0 	call	23c7c <PutInMbxQueue>
        if (result != 0)
   242e0:	10c03fcc 	andi	r3,r2,255
   242e4:	18000726 	beq	r3,zero,24304 <MBX_MailboxSendReq+0xa0>
            flags |= FRAGMENTS_FOLLOW;
   242e8:	043fe004 	movi	r16,-128
   242ec:	8c20b03a 	or	r16,r17,r16
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
   242f0:	d0e16903 	ldbu	r3,-31324(gp)
   242f4:	84001fcc 	andi	r16,r16,127
   242f8:	80e0b03a 	or	r16,r16,r3
   242fc:	d4216905 	stb	r16,-31324(gp)
   24300:	00000806 	br	24324 <MBX_MailboxSendReq+0xc0>
        u8MbxReadCounter++;
   24304:	d0a16943 	ldbu	r2,-31323(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   24308:	8c403fcc 	andi	r17,r17,255
   2430c:	8c40201c 	xori	r17,r17,128
        u8MbxReadCounter++;
   24310:	10800044 	addi	r2,r2,1
   24314:	d0a16945 	stb	r2,-31323(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   24318:	8c7fe004 	addi	r17,r17,-128
   2431c:	0005883a 	mov	r2,zero
   24320:	883ff316 	blt	r17,zero,242f0 <MBX_MailboxSendReq+0x8c>
}
   24324:	dfc00317 	ldw	ra,12(sp)
   24328:	dc800217 	ldw	r18,8(sp)
   2432c:	dc400117 	ldw	r17,4(sp)
   24330:	dc000017 	ldw	r16,0(sp)
   24334:	dec00404 	addi	sp,sp,16
   24338:	f800283a 	ret
        return ERROR_INVALIDSTATE;
   2433c:	00bffc04 	movi	r2,-16
}
   24340:	f800283a 	ret

00024344 <MBX_MailboxWriteInd>:
    if(MbxLen > MAX_MBX_SIZE)
   24344:	2080000b 	ldhu	r2,0(r4)
{
   24348:	defffd04 	addi	sp,sp,-12
   2434c:	dc400115 	stw	r17,4(sp)
   24350:	dc000015 	stw	r16,0(sp)
   24354:	dfc00215 	stw	ra,8(sp)
    if(MbxLen > MAX_MBX_SIZE)
   24358:	10802070 	cmpltui	r2,r2,129
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   2435c:	2440010b 	ldhu	r17,4(r4)
{
   24360:	2021883a 	mov	r16,r4
    if(MbxLen > MAX_MBX_SIZE)
   24364:	10000e1e 	bne	r2,zero,243a0 <MBX_MailboxWriteInd+0x5c>
        pMbx->MbxHeader.Length     = 4;
   24368:	00800104 	movi	r2,4
   2436c:	2080000d 	sth	r2,0(r4)
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24370:	00800044 	movi	r2,1
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   24374:	8c7c3fcc 	andi	r17,r17,61695
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24378:	2080018d 	sth	r2,6(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   2437c:	00800204 	movi	r2,8
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   24380:	2440010d 	sth	r17,4(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   24384:	2080020d 	sth	r2,8(r4)
        MBX_MailboxSendReq(pMbx, 0);
   24388:	000b883a 	mov	r5,zero
}
   2438c:	dfc00217 	ldw	ra,8(sp)
   24390:	dc400117 	ldw	r17,4(sp)
   24394:	dc000017 	ldw	r16,0(sp)
   24398:	dec00304 	addi	sp,sp,12
            MBX_MailboxSendReq(pMbx, 0);
   2439c:	00242641 	jmpi	24264 <MBX_MailboxSendReq>
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   243a0:	88bfffcc 	andi	r2,r17,65535
   243a4:	1006d33a 	srli	r3,r2,12
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
   243a8:	18000226 	beq	r3,zero,243b4 <MBX_MailboxWriteInd+0x70>
   243ac:	d0a16983 	ldbu	r2,-31322(gp)
   243b0:	10c01226 	beq	r2,r3,243fc <MBX_MailboxWriteInd+0xb8>
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   243b4:	014000f4 	movhi	r5,3
   243b8:	29630704 	addi	r5,r5,-29668
   243bc:	8009883a 	mov	r4,r16
        u8MbxWriteCounter = mbxCounter;
   243c0:	d0e16985 	stb	r3,-31322(gp)
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   243c4:	0023c7c0 	call	23c7c <PutInMbxQueue>
        if ( result != 0 )
   243c8:	10c03fcc 	andi	r3,r2,255
   243cc:	18001026 	beq	r3,zero,24410 <MBX_MailboxWriteInd+0xcc>
            pMbx->MbxHeader.Length     = 4;
   243d0:	00c00104 	movi	r3,4
   243d4:	80c0000d 	sth	r3,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   243d8:	8c7c3fcc 	andi	r17,r17,61695
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   243dc:	00c00044 	movi	r3,1
            pMbx->Data[1]                        = SWAPWORD(result);
   243e0:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   243e4:	8440010d 	sth	r17,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   243e8:	80c0018d 	sth	r3,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   243ec:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   243f0:	000b883a 	mov	r5,zero
   243f4:	8009883a 	mov	r4,r16
   243f8:	003fe406 	br	2438c <MBX_MailboxWriteInd+0x48>
}
   243fc:	dfc00217 	ldw	ra,8(sp)
   24400:	dc400117 	ldw	r17,4(sp)
   24404:	dc000017 	ldw	r16,0(sp)
   24408:	dec00304 	addi	sp,sp,12
        APPL_FreeMailboxBuffer(pMbx);
   2440c:	002705c1 	jmpi	2705c <free>
}
   24410:	dfc00217 	ldw	ra,8(sp)
   24414:	dc400117 	ldw	r17,4(sp)
   24418:	dc000017 	ldw	r16,0(sp)
   2441c:	dec00304 	addi	sp,sp,12
   24420:	f800283a 	ret

00024424 <MBX_CheckAndCopyMailbox>:
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   24424:	d1616a8b 	ldhu	r5,-31318(gp)
{
   24428:	defffc04 	addi	sp,sp,-16
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   2442c:	01800084 	movi	r6,2
   24430:	d9000084 	addi	r4,sp,2
{
   24434:	dc400215 	stw	r17,8(sp)
   24438:	dfc00315 	stw	ra,12(sp)
   2443c:	dc000115 	stw	r16,4(sp)
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   24440:	00205e00 	call	205e0 <HW_EscRead>
    if(bNoMbxMemoryAvailable == TRUE)
   24444:	d4616403 	ldbu	r17,-31344(gp)
   24448:	88800060 	cmpeqi	r2,r17,1
   2444c:	10001226 	beq	r2,zero,24498 <MBX_CheckAndCopyMailbox+0x74>
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   24450:	01000284 	movi	r4,10
   24454:	002704c0 	call	2704c <malloc>
   24458:	1021883a 	mov	r16,r2
        if(pMbx != NULL)
   2445c:	10000e26 	beq	r2,zero,24498 <MBX_CheckAndCopyMailbox+0x74>
            HMEMSET(pMbx,0x00,10);
   24460:	01800204 	movi	r6,8
   24464:	000b883a 	mov	r5,zero
   24468:	11000084 	addi	r4,r2,2
   2446c:	002737c0 	call	2737c <memset>
            pMbx->MbxHeader.Length     = 4;
   24470:	00800104 	movi	r2,4
   24474:	8080000d 	sth	r2,0(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   24478:	008001c4 	movi	r2,7
            MBX_MailboxSendReq(pMbx, 0);
   2447c:	8009883a 	mov	r4,r16
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24480:	8440018d 	sth	r17,6(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   24484:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   24488:	000b883a 	mov	r5,zero
   2448c:	00242640 	call	24264 <MBX_MailboxSendReq>
            APPL_FreeMailboxBuffer(pMbx);
   24490:	8009883a 	mov	r4,r16
   24494:	002705c0 	call	2705c <free>
    mbxLen += MBX_HEADER_SIZE;
   24498:	d880008b 	ldhu	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   2449c:	d0e16c83 	ldbu	r3,-31310(gp)
   244a0:	d1216903 	ldbu	r4,-31324(gp)
    mbxLen += MBX_HEADER_SIZE;
   244a4:	10800184 	addi	r2,r2,6
   244a8:	d880008d 	sth	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   244ac:	1906b03a 	or	r3,r3,r4
   244b0:	18c03fcc 	andi	r3,r3,255
   244b4:	18000726 	beq	r3,zero,244d4 <MBX_CheckAndCopyMailbox+0xb0>
            bReceiveMbxIsLocked = TRUE;
   244b8:	00800044 	movi	r2,1
   244bc:	d0a16cc5 	stb	r2,-31309(gp)
}
   244c0:	dfc00317 	ldw	ra,12(sp)
   244c4:	dc400217 	ldw	r17,8(sp)
   244c8:	dc000117 	ldw	r16,4(sp)
   244cc:	dec00404 	addi	sp,sp,16
   244d0:	f800283a 	ret
        if (mbxLen > u16ReceiveMbxSize)
   244d4:	d0e16b0b 	ldhu	r3,-31316(gp)
        bReceiveMbxIsLocked = FALSE;
   244d8:	d0216cc5 	stb	zero,-31309(gp)
        if (mbxLen > u16ReceiveMbxSize)
   244dc:	10bfffcc 	andi	r2,r2,65535
   244e0:	193fffcc 	andi	r4,r3,65535
   244e4:	2080012e 	bgeu	r4,r2,244ec <MBX_CheckAndCopyMailbox+0xc8>
            mbxLen = u16ReceiveMbxSize;
   244e8:	d8c0008d 	sth	r3,2(sp)
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   244ec:	002704c0 	call	2704c <malloc>
   244f0:	d0a16815 	stw	r2,-31328(gp)
   244f4:	1009883a 	mov	r4,r2
        if (psWriteMbx == NULL)
   244f8:	103fef26 	beq	r2,zero,244b8 <MBX_CheckAndCopyMailbox+0x94>
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
   244fc:	d980008b 	ldhu	r6,2(sp)
   24500:	d1616a8b 	ldhu	r5,-31318(gp)
   24504:	00205e00 	call	205e0 <HW_EscRead>
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   24508:	01800044 	movi	r6,1
   2450c:	01420144 	movi	r5,2053
   24510:	d9000044 	addi	r4,sp,1
        VARVOLATILE UINT8 smstate = 0x00;
   24514:	d8000045 	stb	zero,1(sp)
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   24518:	00205e00 	call	205e0 <HW_EscRead>
        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
   2451c:	d8800043 	ldbu	r2,1(sp)
   24520:	1080020c 	andi	r2,r2,8
   24524:	10000926 	beq	r2,zero,2454c <MBX_CheckAndCopyMailbox+0x128>
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   24528:	d1616a8b 	ldhu	r5,-31318(gp)
   2452c:	d0a16b0b 	ldhu	r2,-31316(gp)
   24530:	01800044 	movi	r6,1
   24534:	d12153c4 	addi	r4,gp,-31409
   24538:	288b883a 	add	r5,r5,r2
   2453c:	297fffc4 	addi	r5,r5,-1
   24540:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   24544:	d02153c5 	stb	zero,-31409(gp)
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   24548:	00205e00 	call	205e0 <HW_EscRead>
        MBX_MailboxWriteInd( psWriteMbx );
   2454c:	d1216817 	ldw	r4,-31328(gp)
   24550:	00243440 	call	24344 <MBX_MailboxWriteInd>
   24554:	003fda06 	br	244c0 <MBX_CheckAndCopyMailbox+0x9c>

00024558 <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
   24558:	defffa04 	addi	sp,sp,-24
   2455c:	dc400115 	stw	r17,4(sp)

    do
    {
        UINT8 result = 0;

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24560:	044000f4 	movhi	r17,3
{
   24564:	dd000415 	stw	r20,16(sp)
   24568:	dcc00315 	stw	r19,12(sp)
   2456c:	dc800215 	stw	r18,8(sp)
   24570:	dfc00515 	stw	ra,20(sp)
   24574:	dc000015 	stw	r16,0(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24578:	8c630704 	addi	r17,r17,-29668
        }

        if ( result != 0 )
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
   2457c:	05000104 	movi	r20,4
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   24580:	04fc3fc4 	movi	r19,-3841
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24584:	04800044 	movi	r18,1
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24588:	8809883a 	mov	r4,r17
   2458c:	0023ccc0 	call	23ccc <GetOutOfMbxQueue>
   24590:	1021883a 	mov	r16,r2
        if ( pMbx )
   24594:	10000a1e 	bne	r2,zero,245c0 <MBX_Main+0x68>
        }
    }
    while ( pMbx != NULL );


    if (bReceiveMbxIsLocked)
   24598:	d0a16cc3 	ldbu	r2,-31309(gp)
   2459c:	10001726 	beq	r2,zero,245fc <MBX_Main+0xa4>
    if (u8MailboxSendReqStored)
    {
        /* there are mailbox services stored to be sent */
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   245a0:	dfc00517 	ldw	ra,20(sp)
   245a4:	dd000417 	ldw	r20,16(sp)
   245a8:	dcc00317 	ldw	r19,12(sp)
   245ac:	dc800217 	ldw	r18,8(sp)
   245b0:	dc400117 	ldw	r17,4(sp)
   245b4:	dc000017 	ldw	r16,0(sp)
   245b8:	dec00604 	addi	sp,sp,24
        MBX_CheckAndCopyMailbox();
   245bc:	00244241 	jmpi	24424 <MBX_CheckAndCopyMailbox>
            result = MailboxServiceInd(pMbx);
   245c0:	1009883a 	mov	r4,r2
   245c4:	0023fa80 	call	23fa8 <MailboxServiceInd>
        if ( result != 0 )
   245c8:	10c03fcc 	andi	r3,r2,255
   245cc:	183fee26 	beq	r3,zero,24588 <MBX_Main+0x30>
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   245d0:	80c0010b 	ldhu	r3,4(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   245d4:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Length     = 4;
   245d8:	8500000d 	sth	r20,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   245dc:	1cc6703a 	and	r3,r3,r19
   245e0:	80c0010d 	sth	r3,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   245e4:	8480018d 	sth	r18,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   245e8:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   245ec:	000b883a 	mov	r5,zero
   245f0:	8009883a 	mov	r4,r16
   245f4:	00242640 	call	24264 <MBX_MailboxSendReq>
   245f8:	003fe306 	br	24588 <MBX_Main+0x30>
}
   245fc:	dfc00517 	ldw	ra,20(sp)
   24600:	dd000417 	ldw	r20,16(sp)
   24604:	dcc00317 	ldw	r19,12(sp)
   24608:	dc800217 	ldw	r18,8(sp)
   2460c:	dc400117 	ldw	r17,4(sp)
   24610:	dc000017 	ldw	r16,0(sp)
   24614:	dec00604 	addi	sp,sp,24
   24618:	f800283a 	ret

0002461c <OBJ_GetObjectHandle>:
             and returns a handle if found.

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
{
   2461c:	defffe04 	addi	sp,sp,-8
   24620:	dc000015 	stw	r16,0(sp)
   24624:	2021883a 	mov	r16,r4
   24628:	dfc00115 	stw	ra,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();

    while (pObjEntry!= NULL)
    {
        
        if (pObjEntry->Index == index)
   2462c:	843fffcc 	andi	r16,r16,65535
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24630:	00208600 	call	20860 <COE_GetObjectDictionary>
    while (pObjEntry!= NULL)
   24634:	1000041e 	bne	r2,zero,24648 <OBJ_GetObjectHandle+0x2c>
            return pObjEntry;
        }
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
    }
    return 0;
}
   24638:	dfc00117 	ldw	ra,4(sp)
   2463c:	dc000017 	ldw	r16,0(sp)
   24640:	dec00204 	addi	sp,sp,8
   24644:	f800283a 	ret
        if (pObjEntry->Index == index)
   24648:	10c0020b 	ldhu	r3,8(r2)
   2464c:	1c3ffa26 	beq	r3,r16,24638 <OBJ_GetObjectHandle+0x1c>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24650:	10800117 	ldw	r2,4(r2)
   24654:	003ff706 	br	24634 <OBJ_GetObjectHandle+0x18>

00024658 <OBJ_GetObjectLength>:

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24658:	30c0030b 	ldhu	r3,12(r6)
{
   2465c:	defffe04 	addi	sp,sp,-8
   24660:	dc000015 	stw	r16,0(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24664:	1804d23a 	srli	r2,r3,8
{
   24668:	dfc00115 	stw	ra,4(sp)
    
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
    UINT32 size = 0;

    if ( bCompleteAccess )
   2466c:	39c03fcc 	andi	r7,r7,255
{
   24670:	2821883a 	mov	r16,r5
   24674:	108003cc 	andi	r2,r2,15
    if ( bCompleteAccess )
   24678:	38002026 	beq	r7,zero,246fc <OBJ_GetObjectLength+0xa4>
    {
        if ( objCode == OBJCODE_VAR )
   2467c:	110001e0 	cmpeqi	r4,r2,7
   24680:	2000361e 	bne	r4,zero,2475c <OBJ_GetObjectLength+0x104>
        {
            return 0;
        }
        else if ((objCode == OBJCODE_ARR)
   24684:	10800218 	cmpnei	r2,r2,8
   24688:	1000171e 	bne	r2,zero,246e8 <OBJ_GetObjectLength+0x90>
            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   2468c:	30800417 	ldw	r2,16(r6)
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   24690:	30c00617 	ldw	r3,24(r6)
            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   24694:	1100020b 	ldhu	r4,8(r2)
   24698:	19400003 	ldbu	r5,0(r3)
   2469c:	00270240 	call	27024 <__mulsi3>
            for (i = 1; i <= maxSubindex; i++)
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
   246a0:	108001c4 	addi	r2,r2,7

            if ( subindex == 0 )
   246a4:	81403fcc 	andi	r5,r16,255
            size = BIT2BYTE(size);
   246a8:	1004d0fa 	srli	r2,r2,3
            if ( subindex == 0 )
   246ac:	2800011e 	bne	r5,zero,246b4 <OBJ_GetObjectLength+0x5c>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
   246b0:	10800084 	addi	r2,r2,2
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
                }
            }
        }
    }
}
   246b4:	dfc00117 	ldw	ra,4(sp)
   246b8:	dc000017 	ldw	r16,0(sp)
   246bc:	dec00204 	addi	sp,sp,8
   246c0:	f800283a 	ret
                size += pObjEntry->pEntryDesc[i].BitLength;
   246c4:	31c00417 	ldw	r7,16(r6)
            for (i = 1; i <= maxSubindex; i++)
   246c8:	21000044 	addi	r4,r4,1
                size += pObjEntry->pEntryDesc[i].BitLength;
   246cc:	394f883a 	add	r7,r7,r5
   246d0:	39c0008b 	ldhu	r7,2(r7)
   246d4:	29400184 	addi	r5,r5,6
   246d8:	11c5883a 	add	r2,r2,r7
            for (i = 1; i <= maxSubindex; i++)
   246dc:	21ffffcc 	andi	r7,r4,65535
   246e0:	19fff82e 	bgeu	r3,r7,246c4 <OBJ_GetObjectLength+0x6c>
   246e4:	003fee06 	br	246a0 <OBJ_GetObjectLength+0x48>
   246e8:	01400184 	movi	r5,6
   246ec:	01000044 	movi	r4,1
    UINT32 size = 0;
   246f0:	0005883a 	mov	r2,zero
            for (i = 1; i <= maxSubindex; i++)
   246f4:	18c03fcc 	andi	r3,r3,255
   246f8:	003ff806 	br	246dc <OBJ_GetObjectLength+0x84>
        if ( objCode == OBJCODE_VAR )
   246fc:	110001d8 	cmpnei	r4,r2,7
   24700:	2000031e 	bne	r4,zero,24710 <OBJ_GetObjectLength+0xb8>
            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
   24704:	30800417 	ldw	r2,16(r6)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24708:	1080008b 	ldhu	r2,2(r2)
   2470c:	00000606 	br	24728 <OBJ_GetObjectLength+0xd0>
        else if ( subindex == 0 )
   24710:	29403fcc 	andi	r5,r5,255
   24714:	28000f26 	beq	r5,zero,24754 <OBJ_GetObjectLength+0xfc>
        else if((objCode == OBJCODE_ARR)
   24718:	10800218 	cmpnei	r2,r2,8
   2471c:	1000051e 	bne	r2,zero,24734 <OBJ_GetObjectLength+0xdc>
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
   24720:	30800417 	ldw	r2,16(r6)
   24724:	1080020b 	ldhu	r2,8(r2)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24728:	108001c4 	addi	r2,r2,7
   2472c:	1005d0fa 	srai	r2,r2,3
   24730:	003fe006 	br	246b4 <OBJ_GetObjectLength+0x5c>
                if (maxSubindex < subindex)
   24734:	18c03fcc 	andi	r3,r3,255
   24738:	19400836 	bltu	r3,r5,2475c <OBJ_GetObjectLength+0x104>
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   2473c:	2804907a 	slli	r2,r5,1
   24740:	30c00417 	ldw	r3,16(r6)
   24744:	1145883a 	add	r2,r2,r5
   24748:	1004907a 	slli	r2,r2,1
   2474c:	1885883a 	add	r2,r3,r2
   24750:	003fed06 	br	24708 <OBJ_GetObjectLength+0xb0>
            return 1;
   24754:	00800044 	movi	r2,1
   24758:	003fd606 	br	246b4 <OBJ_GetObjectLength+0x5c>
            return 0;
   2475c:	0005883a 	mov	r2,zero
   24760:	003fd406 	br	246b4 <OBJ_GetObjectLength+0x5c>

00024764 <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
   24764:	defffd04 	addi	sp,sp,-12
   24768:	dc400115 	stw	r17,4(sp)
    UINT8 Modulo;

    pStr[2] = '0';
    pStr[0] += (Number / 100);
   2476c:	2c403fcc 	andi	r17,r5,255
{
   24770:	dc000015 	stw	r16,0(sp)
    pStr[0] += (Number / 100);
   24774:	01401904 	movi	r5,100
{
   24778:	2021883a 	mov	r16,r4
    pStr[0] += (Number / 100);
   2477c:	8809883a 	mov	r4,r17
{
   24780:	dfc00215 	stw	ra,8(sp)
    pStr[0] += (Number / 100);
   24784:	0026f640 	call	26f64 <__udivsi3>
   24788:	80c00003 	ldbu	r3,0(r16)
    Modulo = Number % 100;
   2478c:	8809883a 	mov	r4,r17
   24790:	01401904 	movi	r5,100
    pStr[0] += (Number / 100);
   24794:	10c5883a 	add	r2,r2,r3
   24798:	80800005 	stb	r2,0(r16)
    Modulo = Number % 100;
   2479c:	0026fc80 	call	26fc8 <__umodsi3>
    pStr[1] += (Modulo / 10);
   247a0:	14403fcc 	andi	r17,r2,255
   247a4:	8809883a 	mov	r4,r17
   247a8:	01400284 	movi	r5,10
   247ac:	0026f640 	call	26f64 <__udivsi3>
   247b0:	80c00043 	ldbu	r3,1(r16)
    pStr[2] += (Modulo % 10);
   247b4:	01400284 	movi	r5,10
   247b8:	8809883a 	mov	r4,r17
    pStr[1] += (Modulo / 10);
   247bc:	10c5883a 	add	r2,r2,r3
   247c0:	80800045 	stb	r2,1(r16)
    pStr[2] += (Modulo % 10);
   247c4:	0026fc80 	call	26fc8 <__umodsi3>
   247c8:	10800c04 	addi	r2,r2,48
   247cc:	80800085 	stb	r2,2(r16)
}
   247d0:	dfc00217 	ldw	ra,8(sp)
   247d4:	dc400117 	ldw	r17,4(sp)
   247d8:	dc000017 	ldw	r16,0(sp)
   247dc:	dec00304 	addi	sp,sp,12
   247e0:	f800283a 	ret

000247e4 <OBJ_GetDesc>:
                0xFF                                            <br>
            }
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
{
   247e4:	defff604 	addi	sp,sp,-40
   247e8:	dcc00715 	stw	r19,28(sp)
   247ec:	dc800615 	stw	r18,24(sp)
   247f0:	dc000415 	stw	r16,16(sp)
   247f4:	dfc00915 	stw	ra,36(sp)
   247f8:	dd000815 	stw	r20,32(sp)
   247fc:	dc400515 	stw	r17,20(sp)
/* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;



    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24800:	2cc03fcc 	andi	r19,r5,255
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
   24804:	34000517 	ldw	r16,20(r6)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24808:	3080030b 	ldhu	r2,12(r6)
{
   2480c:	3825883a 	mov	r18,r7
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24810:	98000426 	beq	r19,zero,24824 <OBJ_GetDesc+0x40>
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24814:	1004d23a 	srli	r2,r2,8
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24818:	108003cc 	andi	r2,r2,15
   2481c:	10c001d8 	cmpnei	r3,r2,7
   24820:	1800091e 	bne	r3,zero,24848 <OBJ_GetDesc+0x64>
    {
        // Get object description length
       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
   24824:	8009883a 	mov	r4,r16
   24828:	002739c0 	call	2739c <strlen>
   2482c:	1023883a 	mov	r17,r2

        // If there is a pointer given, copy data:
        if ( pData )
   24830:	90001a26 	beq	r18,zero,2489c <OBJ_GetDesc+0xb8>
        {
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
   24834:	11bfffcc 	andi	r6,r2,65535
                if ( i == tmpSubindex )
                {
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
                    if ( pData && strSize )
                    {
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   24838:	800b883a 	mov	r5,r16
   2483c:	9009883a 	mov	r4,r18
   24840:	00273540 	call	27354 <memcpy>
            }
            }
            }
        }

        if ( strSize == 0 )
   24844:	00001506 	br	2489c <OBJ_GetDesc+0xb8>
        if ( objCode == OBJCODE_REC )
   24848:	10800258 	cmpnei	r2,r2,9
   2484c:	1000251e 	bne	r2,zero,248e4 <OBJ_GetDesc+0x100>
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24850:	8009883a 	mov	r4,r16
            UINT16 tmpSubindex = subindex;
   24854:	2c403fcc 	andi	r17,r5,255
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24858:	002739c0 	call	2739c <strlen>
   2485c:	10800044 	addi	r2,r2,1
   24860:	80a1883a 	add	r16,r16,r2
            UINT16 i = 1;
   24864:	05000044 	movi	r20,1
                if ( i == tmpSubindex )
   24868:	8c7fffcc 	andi	r17,r17,65535
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   2486c:	80800003 	ldbu	r2,0(r16)
   24870:	10803fb0 	cmpltui	r2,r2,254
   24874:	10001b26 	beq	r2,zero,248e4 <OBJ_GetDesc+0x100>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   24878:	8009883a 	mov	r4,r16
   2487c:	002739c0 	call	2739c <strlen>
                if ( i == tmpSubindex )
   24880:	a0ffffcc 	andi	r3,r20,65535
   24884:	88c0111e 	bne	r17,r3,248cc <OBJ_GetDesc+0xe8>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   24888:	1023883a 	mov	r17,r2
                    if ( pData && strSize )
   2488c:	10ffffcc 	andi	r3,r2,65535
   24890:	90000b1e 	bne	r18,zero,248c0 <OBJ_GetDesc+0xdc>
        if ( strSize == 0 )
   24894:	1800011e 	bne	r3,zero,2489c <OBJ_GetDesc+0xb8>
        {
            // no string found for subindex x -> name is Subindex x
            strSize =    12;
   24898:	04400304 	movi	r17,12
            }
        }
    }

    return strSize;
}
   2489c:	8805883a 	mov	r2,r17
   248a0:	dfc00917 	ldw	ra,36(sp)
   248a4:	dd000817 	ldw	r20,32(sp)
   248a8:	dcc00717 	ldw	r19,28(sp)
   248ac:	dc800617 	ldw	r18,24(sp)
   248b0:	dc400517 	ldw	r17,20(sp)
   248b4:	dc000417 	ldw	r16,16(sp)
   248b8:	dec00a04 	addi	sp,sp,40
   248bc:	f800283a 	ret
                    if ( pData && strSize )
   248c0:	18000926 	beq	r3,zero,248e8 <OBJ_GetDesc+0x104>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   248c4:	11bfffcc 	andi	r6,r2,65535
   248c8:	003fdb06 	br	24838 <OBJ_GetDesc+0x54>
                    i++;
   248cc:	a0c00044 	addi	r3,r20,1
   248d0:	1829883a 	mov	r20,r3
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   248d4:	10800044 	addi	r2,r2,1
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   248d8:	18ffffcc 	andi	r3,r3,65535
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   248dc:	80a1883a 	add	r16,r16,r2
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   248e0:	88ffe22e 	bgeu	r17,r3,2486c <OBJ_GetDesc+0x88>
            if ( pData )
   248e4:	903fec26 	beq	r18,zero,24898 <OBJ_GetDesc+0xb4>
                MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
   248e8:	014000f4 	movhi	r5,3
   248ec:	01800344 	movi	r6,13
   248f0:	d90000c4 	addi	r4,sp,3
   248f4:	2960d504 	addi	r5,r5,-31916
   248f8:	00273540 	call	27354 <memcpy>
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
   248fc:	980b883a 	mov	r5,r19
   24900:	d9000304 	addi	r4,sp,12
   24904:	00247640 	call	24764 <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
   24908:	01800344 	movi	r6,13
   2490c:	d94000c4 	addi	r5,sp,3
   24910:	9009883a 	mov	r4,r18
   24914:	00273540 	call	27354 <memcpy>
   24918:	003fdf06 	br	24898 <OBJ_GetDesc+0xb4>

0002491c <OBJ_GetEntryDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2491c:	20c0030b 	ldhu	r3,12(r4)
   24920:	20800417 	ldw	r2,16(r4)
   24924:	29403fcc 	andi	r5,r5,255
   24928:	1807d23a 	srai	r3,r3,8

    if ((objCode == OBJCODE_ARR)
   2492c:	18c003cc 	andi	r3,r3,15
   24930:	18c00218 	cmpnei	r3,r3,8
   24934:	1800031e 	bne	r3,zero,24944 <OBJ_GetEntryDesc+0x28>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
   24938:	28000626 	beq	r5,zero,24954 <OBJ_GetEntryDesc+0x38>
            pEntry = &pObjEntry->pEntryDesc[0];
        }
        else
        {
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
   2493c:	10800184 	addi	r2,r2,6
   24940:	f800283a 	ret
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
   24944:	2806907a 	slli	r3,r5,1
   24948:	1947883a 	add	r3,r3,r5
   2494c:	1806907a 	slli	r3,r3,1
   24950:	10c5883a 	add	r2,r2,r3
        }
    }

    return pEntry;
}
   24954:	f800283a 	ret

00024958 <OBJ_GetNoOfObjects>:
{
   24958:	defff904 	addi	sp,sp,-28
   2495c:	dd000415 	stw	r20,16(sp)
   24960:	dcc00315 	stw	r19,12(sp)
   24964:	2029883a 	mov	r20,r4
    UINT16 listFlags = 0x0020 << listType;
   24968:	04c00804 	movi	r19,32
   2496c:	21003fcc 	andi	r4,r4,255
{
   24970:	dc800215 	stw	r18,8(sp)
   24974:	dc000015 	stw	r16,0(sp)
    UINT16 listFlags = 0x0020 << listType;
   24978:	9926983a 	sll	r19,r19,r4
{
   2497c:	dfc00615 	stw	ra,24(sp)
   24980:	dd400515 	stw	r21,20(sp)
   24984:	dc400115 	stw	r17,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24988:	00208600 	call	20860 <COE_GetObjectDictionary>
   2498c:	1021883a 	mov	r16,r2
    UINT16 n = 0;
   24990:	0025883a 	mov	r18,zero
            if ( t )
   24994:	a5003fcc 	andi	r20,r20,255
    while (pObjEntry != NULL)
   24998:	80000a1e 	bne	r16,zero,249c4 <OBJ_GetNoOfObjects+0x6c>
}
   2499c:	9005883a 	mov	r2,r18
   249a0:	dfc00617 	ldw	ra,24(sp)
   249a4:	dd400517 	ldw	r21,20(sp)
   249a8:	dd000417 	ldw	r20,16(sp)
   249ac:	dcc00317 	ldw	r19,12(sp)
   249b0:	dc800217 	ldw	r18,8(sp)
   249b4:	dc400117 	ldw	r17,4(sp)
   249b8:	dc000017 	ldw	r16,0(sp)
   249bc:	dec00704 	addi	sp,sp,28
   249c0:	f800283a 	ret
        if ( pObjEntry->Index >= 0x1000 )
   249c4:	8080020b 	ldhu	r2,8(r16)
   249c8:	10840030 	cmpltui	r2,r2,4096
   249cc:	10000c1e 	bne	r2,zero,24a00 <OBJ_GetNoOfObjects+0xa8>
            if ( t )
   249d0:	a0000d26 	beq	r20,zero,24a08 <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   249d4:	85400303 	ldbu	r21,12(r16)
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   249d8:	0023883a 	mov	r17,zero
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
   249dc:	880b883a 	mov	r5,r17
   249e0:	8009883a 	mov	r4,r16
   249e4:	002491c0 	call	2491c <OBJ_GetEntryDesc>
   249e8:	1080010b 	ldhu	r2,4(r2)
   249ec:	14c4703a 	and	r2,r2,r19
   249f0:	1000051e 	bne	r2,zero,24a08 <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   249f4:	8c400044 	addi	r17,r17,1
   249f8:	88bfffcc 	andi	r2,r17,65535
   249fc:	a8bff72e 	bgeu	r21,r2,249dc <OBJ_GetNoOfObjects+0x84>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24a00:	84000117 	ldw	r16,4(r16)
   24a04:	003fe406 	br	24998 <OBJ_GetNoOfObjects+0x40>
                n++;
   24a08:	94800044 	addi	r18,r18,1
   24a0c:	003ffc06 	br	24a00 <OBJ_GetNoOfObjects+0xa8>

00024a10 <OBJ_GetObjectList>:
    if ( pIndex[0] == 0x1000 )
   24a10:	2880000b 	ldhu	r2,0(r5)
{
   24a14:	defff604 	addi	sp,sp,-40
   24a18:	ddc00715 	stw	r23,28(sp)
   24a1c:	dd800615 	stw	r22,24(sp)
   24a20:	dd400515 	stw	r21,20(sp)
   24a24:	dd000415 	stw	r20,16(sp)
   24a28:	dcc00315 	stw	r19,12(sp)
   24a2c:	dc800215 	stw	r18,8(sp)
   24a30:	dc400115 	stw	r17,4(sp)
   24a34:	dfc00915 	stw	ra,36(sp)
   24a38:	df000815 	stw	fp,32(sp)
   24a3c:	dc000015 	stw	r16,0(sp)
    if ( pIndex[0] == 0x1000 )
   24a40:	10840018 	cmpnei	r2,r2,4096
{
   24a44:	ddc00a17 	ldw	r23,40(sp)
   24a48:	2025883a 	mov	r18,r4
   24a4c:	2827883a 	mov	r19,r5
   24a50:	3023883a 	mov	r17,r6
   24a54:	3829883a 	mov	r20,r7
   24a58:	202d883a 	mov	r22,r4
   24a5c:	302b883a 	mov	r21,r6
    if ( pIndex[0] == 0x1000 )
   24a60:	10001c1e 	bne	r2,zero,24ad4 <OBJ_GetObjectList+0xc4>
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24a64:	00208600 	call	20860 <COE_GetObjectDictionary>
   24a68:	1021883a 	mov	r16,r2
        if((pObjEntry == NULL) && (pAbort != NULL))
   24a6c:	10001326 	beq	r2,zero,24abc <OBJ_GetObjectList+0xac>
        while (pObjEntry != NULL && size > 1 )
   24a70:	8c7fffcc 	andi	r17,r17,65535
   24a74:	8c4000a8 	cmpgeui	r17,r17,2
   24a78:	8800191e 	bne	r17,zero,24ae0 <OBJ_GetObjectList+0xd0>
            pIndex[0] = pObjEntry->Index;
   24a7c:	8080020b 	ldhu	r2,8(r16)
   24a80:	9880000d 	sth	r2,0(r19)
}
   24a84:	a805883a 	mov	r2,r21
    pSdoInfoObjEntry = pObjEntry;
   24a88:	d4217515 	stw	r16,-31276(gp)
}
   24a8c:	dfc00917 	ldw	ra,36(sp)
   24a90:	df000817 	ldw	fp,32(sp)
   24a94:	ddc00717 	ldw	r23,28(sp)
   24a98:	dd800617 	ldw	r22,24(sp)
   24a9c:	dd400517 	ldw	r21,20(sp)
   24aa0:	dd000417 	ldw	r20,16(sp)
   24aa4:	dcc00317 	ldw	r19,12(sp)
   24aa8:	dc800217 	ldw	r18,8(sp)
   24aac:	dc400117 	ldw	r17,4(sp)
   24ab0:	dc000017 	ldw	r16,0(sp)
   24ab4:	dec00a04 	addi	sp,sp,40
   24ab8:	f800283a 	ret
        if((pObjEntry == NULL) && (pAbort != NULL))
   24abc:	b8000226 	beq	r23,zero,24ac8 <OBJ_GetObjectList+0xb8>
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
   24ac0:	008006c4 	movi	r2,27
   24ac4:	b8800005 	stb	r2,0(r23)
            pIndex[0] = 0xFFFF;
   24ac8:	00bfffc4 	movi	r2,-1
   24acc:	0021883a 	mov	r16,zero
   24ad0:	003feb06 	br	24a80 <OBJ_GetObjectList+0x70>
        pObjEntry = pSdoInfoObjEntry;
   24ad4:	d4217517 	ldw	r16,-31276(gp)
    if ( pObjEntry != NULL )
   24ad8:	803fe51e 	bne	r16,zero,24a70 <OBJ_GetObjectList+0x60>
   24adc:	003ffa06 	br	24ac8 <OBJ_GetObjectList+0xb8>
    UINT16 listFlags = 0x0020 << listType;
   24ae0:	94bfffcc 	andi	r18,r18,65535
   24ae4:	00800804 	movi	r2,32
   24ae8:	14a4983a 	sll	r18,r2,r18
                if ( t )
   24aec:	b5bfffcc 	andi	r22,r22,65535
            if ( pObjEntry->Index >= 0x1000 )
   24af0:	85c0020b 	ldhu	r23,8(r16)
   24af4:	b8bfffcc 	andi	r2,r23,65535
   24af8:	10840030 	cmpltui	r2,r2,4096
   24afc:	10000c1e 	bne	r2,zero,24b30 <OBJ_GetObjectList+0x120>
                if ( t )
   24b00:	b0001126 	beq	r22,zero,24b48 <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   24b04:	87000303 	ldbu	fp,12(r16)
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   24b08:	0023883a 	mov	r17,zero
                        if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
   24b0c:	880b883a 	mov	r5,r17
   24b10:	8009883a 	mov	r4,r16
   24b14:	002491c0 	call	2491c <OBJ_GetEntryDesc>
   24b18:	1080010b 	ldhu	r2,4(r2)
   24b1c:	1484703a 	and	r2,r2,r18
   24b20:	1000091e 	bne	r2,zero,24b48 <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   24b24:	8c400044 	addi	r17,r17,1
   24b28:	88bfffcc 	andi	r2,r17,65535
   24b2c:	e0bff72e 	bgeu	fp,r2,24b0c <OBJ_GetObjectList+0xfc>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24b30:	84000117 	ldw	r16,4(r16)
        while (pObjEntry != NULL && size > 1 )
   24b34:	803fe426 	beq	r16,zero,24ac8 <OBJ_GetObjectList+0xb8>
   24b38:	a8bfffcc 	andi	r2,r21,65535
   24b3c:	108000a8 	cmpgeui	r2,r2,2
   24b40:	103feb1e 	bne	r2,zero,24af0 <OBJ_GetObjectList+0xe0>
   24b44:	003fcd06 	br	24a7c <OBJ_GetObjectList+0x6c>
                    *pData = SWAPWORD(pObjEntry->Index);
   24b48:	a5c0000d 	sth	r23,0(r20)
                    size -= 2;
   24b4c:	ad7fff84 	addi	r21,r21,-2
                    pData++;
   24b50:	a5000084 	addi	r20,r20,2
                    size -= 2;
   24b54:	003ff606 	br	24b30 <OBJ_GetObjectList+0x120>

00024b58 <OBJ_GetObjDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    return &pObjEntry->ObjDesc;
}
   24b58:	20800284 	addi	r2,r4,10
   24b5c:	f800283a 	ret

00024b60 <OBJ_GetEntryOffset>:
UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    UINT16 i;
    /* bitOffset will be initialized with the bit offset of subindex 1 */
    UINT16 bitOffset = 0;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24b60:	28c0030b 	ldhu	r3,12(r5)
   24b64:	1807d23a 	srai	r3,r3,8
   24b68:	18c003cc 	andi	r3,r3,15
   24b6c:	1811883a 	mov	r8,r3
    {
        /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
        bitOffset +=16;
    }

    if (objCode == OBJCODE_VAR)
   24b70:	18c001e0 	cmpeqi	r3,r3,7
   24b74:	1800531e 	bne	r3,zero,24cc4 <OBJ_GetEntryOffset+0x164>
   24b78:	20803fcc 	andi	r2,r4,255
    {
        return 0;
    }

    for (i = 1; i <= subindex; i++)
   24b7c:	02800044 	movi	r10,1
   24b80:	1004c03a 	cmpne	r2,r2,zero
    {
        /* get the entry description */
        if ((objCode == OBJCODE_ARR)
   24b84:	42003fcc 	andi	r8,r8,255
        else
        {
            pEntry = &pObjEntry->pEntryDesc[i];
        }

        switch (pEntry->DataType)
   24b88:	02d00074 	movhi	r11,16385
   24b8c:	03080034 	movhi	r12,8192
    for (i = 1; i <= subindex; i++)
   24b90:	21003fcc 	andi	r4,r4,255
   24b94:	51bfffcc 	andi	r6,r10,65535
   24b98:	1004913a 	slli	r2,r2,4
   24b9c:	02400184 	movi	r9,6
        if ((objCode == OBJCODE_ARR)
   24ba0:	42000218 	cmpnei	r8,r8,8
        case    DEFTYPE_ARRAY_OF_INT :

#if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
            /* the 16-bit variables in the structure are word-aligned,
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
   24ba4:	03fffc04 	movi	r15,-16
        case    DEFTYPE_ARRAY_OF_DINT :
        case    DEFTYPE_ARRAY_OF_UDINT:
#if OBJ_DWORD_ALIGN
            /* the 32-bit variables in the structure are dword-aligned,
               align the actual bitOffset to a dword */
            bitOffset = (bitOffset+31) & 0xFFE0;
   24ba8:	037ff804 	movi	r13,-32
   24bac:	03800044 	movi	r14,1
        switch (pEntry->DataType)
   24bb0:	5ae00004 	addi	r11,r11,-32768
   24bb4:	63100004 	addi	r12,r12,16384
    for (i = 1; i <= subindex; i++)
   24bb8:	2180462e 	bgeu	r4,r6,24cd4 <OBJ_GetEntryOffset+0x174>
            break;
        }
    }

    return bitOffset;
}
   24bbc:	f800283a 	ret
            pEntry = &pObjEntry->pEntryDesc[i];
   24bc0:	3a4f883a 	add	r7,r7,r9
   24bc4:	00004906 	br	24cec <OBJ_GetEntryOffset+0x18c>
        switch (pEntry->DataType)
   24bc8:	18fffbc4 	addi	r3,r3,-17
   24bcc:	18ffffcc 	andi	r3,r3,65535
   24bd0:	70c6983a 	sll	r3,r14,r3
   24bd4:	1c01044c 	andi	r16,r3,1041
   24bd8:	8000341e 	bne	r16,zero,24cac <OBJ_GetEntryOffset+0x14c>
   24bdc:	1ae0703a 	and	r16,r3,r11
   24be0:	80002b1e 	bne	r16,zero,24c90 <OBJ_GetEntryOffset+0x130>
   24be4:	1b06703a 	and	r3,r3,r12
   24be8:	18004a26 	beq	r3,zero,24d14 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24bec:	108003c4 	addi	r2,r2,15
   24bf0:	00fffc04 	movi	r3,-16
   24bf4:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24bf8:	31003436 	bltu	r6,r4,24ccc <OBJ_GetEntryOffset+0x16c>
    for (i = 1; i <= subindex; i++)
   24bfc:	52800044 	addi	r10,r10,1
   24c00:	51bfffcc 	andi	r6,r10,65535
   24c04:	4a400184 	addi	r9,r9,6
   24c08:	2180352e 	bgeu	r4,r6,24ce0 <OBJ_GetEntryOffset+0x180>
}
   24c0c:	dfc00117 	ldw	ra,4(sp)
   24c10:	dc000017 	ldw	r16,0(sp)
   24c14:	dec00204 	addi	sp,sp,8
   24c18:	f800283a 	ret
   24c1c:	77c6983a 	sll	r3,r14,ra
        switch (pEntry->DataType)
   24c20:	1c00640c 	andi	r16,r3,400
   24c24:	80001a1e 	bne	r16,zero,24c90 <OBJ_GetEntryOffset+0x130>
   24c28:	18c2120c 	andi	r3,r3,2120
   24c2c:	18003926 	beq	r3,zero,24d14 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24c30:	108003c4 	addi	r2,r2,15
   24c34:	00fffc04 	movi	r3,-16
   24c38:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24c3c:	313fef2e 	bgeu	r6,r4,24bfc <OBJ_GetEntryOffset+0x9c>
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
   24c40:	ffc002d8 	cmpnei	ra,ra,11
   24c44:	f800211e 	bne	ra,zero,24ccc <OBJ_GetEntryOffset+0x16c>
                bitOffset += pEntry->BitLength;
   24c48:	38c0008b 	ldhu	r3,2(r7)
   24c4c:	00000b06 	br	24c7c <OBJ_GetEntryOffset+0x11c>
        switch (pEntry->DataType)
   24c50:	ffc09820 	cmpeqi	ra,ra,608
   24c54:	f8000b1e 	bne	ra,zero,24c84 <OBJ_GetEntryOffset+0x124>
   24c58:	18ff6784 	addi	r3,r3,-610
   24c5c:	18ffffcc 	andi	r3,r3,65535
   24c60:	18c000a8 	cmpgeui	r3,r3,2
   24c64:	18002b1e 	bne	r3,zero,24d14 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24c68:	10c007c4 	addi	r3,r2,31
   24c6c:	1b46703a 	and	r3,r3,r13
   24c70:	1805883a 	mov	r2,r3
            if (i < subindex)
   24c74:	313fe12e 	bgeu	r6,r4,24bfc <OBJ_GetEntryOffset+0x9c>
                    bitOffset += pEntry->BitLength;
   24c78:	3880008b 	ldhu	r2,2(r7)
                bitOffset += pEntry->BitLength;
   24c7c:	1885883a 	add	r2,r3,r2
   24c80:	003fde06 	br	24bfc <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24c84:	108003c4 	addi	r2,r2,15
   24c88:	13c4703a 	and	r2,r2,r15
            if (i < subindex)
   24c8c:	00002106 	br	24d14 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24c90:	10c007c4 	addi	r3,r2,31
   24c94:	00bff804 	movi	r2,-32
   24c98:	1886703a 	and	r3,r3,r2
   24c9c:	1805883a 	mov	r2,r3
            if (i < subindex)
   24ca0:	313fd62e 	bgeu	r6,r4,24bfc <OBJ_GetEntryOffset+0x9c>
                   bitOffset += 32;
   24ca4:	18800804 	addi	r2,r3,32
   24ca8:	003fd406 	br	24bfc <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset + 31) & 0xFFE0;
   24cac:	10c007c4 	addi	r3,r2,31
   24cb0:	1b46703a 	and	r3,r3,r13
   24cb4:	1805883a 	mov	r2,r3
            if (i < subindex)
   24cb8:	313fd02e 	bgeu	r6,r4,24bfc <OBJ_GetEntryOffset+0x9c>
                bitOffset += 64;
   24cbc:	18801004 	addi	r2,r3,64
   24cc0:	003fce06 	br	24bfc <OBJ_GetEntryOffset+0x9c>
        return 0;
   24cc4:	0005883a 	mov	r2,zero
   24cc8:	f800283a 	ret
                    bitOffset += 16;
   24ccc:	10800404 	addi	r2,r2,16
   24cd0:	003fca06 	br	24bfc <OBJ_GetEntryOffset+0x9c>
{
   24cd4:	defffe04 	addi	sp,sp,-8
   24cd8:	dfc00115 	stw	ra,4(sp)
   24cdc:	dc000015 	stw	r16,0(sp)
            pEntry = &pObjEntry->pEntryDesc[1];
   24ce0:	29c00417 	ldw	r7,16(r5)
        if ((objCode == OBJCODE_ARR)
   24ce4:	403fb61e 	bne	r8,zero,24bc0 <OBJ_GetEntryOffset+0x60>
            pEntry = &pObjEntry->pEntryDesc[1];
   24ce8:	39c00184 	addi	r7,r7,6
        switch (pEntry->DataType)
   24cec:	38c0000b 	ldhu	r3,0(r7)
   24cf0:	1fffffcc 	andi	ra,r3,65535
   24cf4:	fc000c28 	cmpgeui	r16,ra,48
   24cf8:	803fd51e 	bne	r16,zero,24c50 <OBJ_GetEntryOffset+0xf0>
   24cfc:	fc000468 	cmpgeui	r16,ra,17
   24d00:	803fb11e 	bne	r16,zero,24bc8 <OBJ_GetEntryOffset+0x68>
   24d04:	18ffff44 	addi	r3,r3,-3
   24d08:	18ffffcc 	andi	r3,r3,65535
   24d0c:	18c00268 	cmpgeui	r3,r3,9
   24d10:	183fc226 	beq	r3,zero,24c1c <OBJ_GetEntryOffset+0xbc>
            if (i < subindex)
   24d14:	313fb92e 	bgeu	r6,r4,24bfc <OBJ_GetEntryOffset+0x9c>
   24d18:	003fcb06 	br	24c48 <OBJ_GetEntryOffset+0xe8>

00024d1c <CheckSyncTypeValue>:

 \brief    Checks if the new Sync type value is valid
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
{
    switch (NewSyncType)
   24d1c:	297fffcc 	andi	r5,r5,65535
   24d20:	288000a0 	cmpeqi	r2,r5,2
   24d24:	1000281e 	bne	r2,zero,24dc8 <CheckSyncTypeValue+0xac>
   24d28:	288000e8 	cmpgeui	r2,r5,3
   24d2c:	1000031e 	bne	r2,zero,24d3c <CheckSyncTypeValue+0x20>
   24d30:	2800081e 	bne	r5,zero,24d54 <CheckSyncTypeValue+0x38>
    {
    case SYNCTYPE_FREERUN:
        return 0; //free run sync mode is always accepted
   24d34:	0005883a 	mov	r2,zero
   24d38:	f800283a 	ret
    switch (NewSyncType)
   24d3c:	288000e0 	cmpeqi	r2,r5,3
   24d40:	10002d1e 	bne	r2,zero,24df8 <CheckSyncTypeValue+0xdc>
   24d44:	294008a0 	cmpeqi	r5,r5,34
   24d48:	2800161e 	bne	r5,zero,24da4 <CheckSyncTypeValue+0x88>
        {
            return 0;
        }
        break;
    } //switch 
    return ABORTIDX_VALUE_EXCEEDED;
   24d4c:	00800484 	movi	r2,18

}
   24d50:	f800283a 	ret
        if ((index == 0x1C32) 
   24d54:	213fffcc 	andi	r4,r4,65535
   24d58:	20870c98 	cmpnei	r2,r4,7218
   24d5c:	1000071e 	bne	r2,zero,24d7c <CheckSyncTypeValue+0x60>
            && (nPdOutputSize > 0) 
   24d60:	d0a1580b 	ldhu	r2,-31392(gp)
   24d64:	103ff926 	beq	r2,zero,24d4c <CheckSyncTypeValue+0x30>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
   24d68:	008000f4 	movhi	r2,3
   24d6c:	10a3350b 	ldhu	r2,-29484(r2)
   24d70:	1080008c 	andi	r2,r2,2
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24d74:	103ff526 	beq	r2,zero,24d4c <CheckSyncTypeValue+0x30>
   24d78:	003fee06 	br	24d34 <CheckSyncTypeValue+0x18>
        if ((index == 0x1C33) 
   24d7c:	21070cd8 	cmpnei	r4,r4,7219
   24d80:	203ff21e 	bne	r4,zero,24d4c <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24d84:	008000f4 	movhi	r2,3
   24d88:	10a3240b 	ldhu	r2,-29552(r2)
   24d8c:	1080008c 	andi	r2,r2,2
   24d90:	103fee26 	beq	r2,zero,24d4c <CheckSyncTypeValue+0x30>
            && (nPdOutputSize == 0) 
   24d94:	d0a1580b 	ldhu	r2,-31392(gp)
   24d98:	103fec1e 	bne	r2,zero,24d4c <CheckSyncTypeValue+0x30>
            && (nPdInputSize > 0))
   24d9c:	d0a1588b 	ldhu	r2,-31390(gp)
   24da0:	003ff406 	br	24d74 <CheckSyncTypeValue+0x58>
        if ((index == 0x1C33) 
   24da4:	213fffcc 	andi	r4,r4,65535
   24da8:	21070cd8 	cmpnei	r4,r4,7219
   24dac:	203fe71e 	bne	r4,zero,24d4c <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24db0:	008000f4 	movhi	r2,3
   24db4:	10a3240b 	ldhu	r2,-29552(r2)
   24db8:	1080008c 	andi	r2,r2,2
   24dbc:	103fe326 	beq	r2,zero,24d4c <CheckSyncTypeValue+0x30>
            && (nPdOutputSize > 0))
   24dc0:	d0a1580b 	ldhu	r2,-31392(gp)
   24dc4:	003feb06 	br	24d74 <CheckSyncTypeValue+0x58>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   24dc8:	213fffcc 	andi	r4,r4,65535
   24dcc:	20870c98 	cmpnei	r2,r4,7218
   24dd0:	1000041e 	bne	r2,zero,24de4 <CheckSyncTypeValue+0xc8>
   24dd4:	008000f4 	movhi	r2,3
   24dd8:	10a3350b 	ldhu	r2,-29484(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   24ddc:	1080010c 	andi	r2,r2,4
   24de0:	003fe406 	br	24d74 <CheckSyncTypeValue+0x58>
   24de4:	21070cd8 	cmpnei	r4,r4,7219
   24de8:	203fd81e 	bne	r4,zero,24d4c <CheckSyncTypeValue+0x30>
   24dec:	008000f4 	movhi	r2,3
   24df0:	10a3240b 	ldhu	r2,-29552(r2)
   24df4:	003ff906 	br	24ddc <CheckSyncTypeValue+0xc0>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24df8:	213fffcc 	andi	r4,r4,65535
   24dfc:	20870c98 	cmpnei	r2,r4,7218
   24e00:	1000041e 	bne	r2,zero,24e14 <CheckSyncTypeValue+0xf8>
   24e04:	008000f4 	movhi	r2,3
   24e08:	10a3350b 	ldhu	r2,-29484(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24e0c:	1080020c 	andi	r2,r2,8
   24e10:	003fd806 	br	24d74 <CheckSyncTypeValue+0x58>
   24e14:	21070cd8 	cmpnei	r4,r4,7219
   24e18:	203fcc1e 	bne	r4,zero,24d4c <CheckSyncTypeValue+0x30>
   24e1c:	008000f4 	movhi	r2,3
   24e20:	10a3240b 	ldhu	r2,-29552(r2)
   24e24:	003ff906 	br	24e0c <CheckSyncTypeValue+0xf0>

00024e28 <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
   24e28:	defff004 	addi	sp,sp,-64
   24e2c:	dd400b15 	stw	r21,44(sp)
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e30:	3d40030b 	ldhu	r21,12(r7)
{
   24e34:	df000e15 	stw	fp,56(sp)
   24e38:	ddc00d15 	stw	r23,52(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e3c:	a804d23a 	srli	r2,r21,8
{
   24e40:	dd800c15 	stw	r22,48(sp)
   24e44:	dd000a15 	stw	r20,40(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e48:	108003cc 	andi	r2,r2,15
{
   24e4c:	dcc00915 	stw	r19,36(sp)
   24e50:	dc400715 	stw	r17,28(sp)
   24e54:	dc000615 	stw	r16,24(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e58:	102f883a 	mov	r23,r2
{
   24e5c:	dfc00f15 	stw	ra,60(sp)
   24e60:	dc800815 	stw	r18,32(sp)
   24e64:	d9800115 	stw	r6,4(sp)
   24e68:	d900008d 	sth	r4,2(sp)
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24e6c:	108001e0 	cmpeqi	r2,r2,7
{
   24e70:	dd801017 	ldw	r22,64(sp)
   24e74:	dcc01103 	ldbu	r19,68(sp)
   24e78:	2023883a 	mov	r17,r4
   24e7c:	2839883a 	mov	fp,r5
   24e80:	3821883a 	mov	r16,r7
    UINT16 i = subindex;
   24e84:	2d003fcc 	andi	r20,r5,255
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   24e88:	ad403fcc 	andi	r21,r21,255
    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24e8c:	1000191e 	bne	r2,zero,24ef4 <OBJ_Read+0xcc>
   24e90:	20bfffcc 	andi	r2,r4,65535
   24e94:	10840030 	cmpltui	r2,r2,4096
   24e98:	1000161e 	bne	r2,zero,24ef4 <OBJ_Read+0xcc>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
   24e9c:	38800617 	ldw	r2,24(r7)
   24ea0:	14800003 	ldbu	r18,0(r2)
   24ea4:	902b883a 	mov	r21,r18

    }

    if ( bCompleteAccess )
   24ea8:	9800211e 	bne	r19,zero,24f30 <OBJ_Read+0x108>

        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
    }
    else
        if ( subindex > maxSubindex )
   24eac:	a0bfffcc 	andi	r2,r20,65535
   24eb0:	a93fffcc 	andi	r4,r21,65535
   24eb4:	20815c36 	bltu	r4,r2,25428 <OBJ_Read+0x600>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   24eb8:	8009883a 	mov	r4,r16
   24ebc:	e1403fcc 	andi	r5,fp,255
   24ec0:	002491c0 	call	2491c <OBJ_GetEntryDesc>

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
   24ec4:	1100010b 	ldhu	r4,4(r2)
   24ec8:	20bfffcc 	andi	r2,r4,65535
   24ecc:	10000a26 	beq	r2,zero,24ef8 <OBJ_Read+0xd0>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
   24ed0:	2004907a 	slli	r2,r4,1
   24ed4:	d16156c3 	ldbu	r5,-31397(gp)
   24ed8:	1144703a 	and	r2,r2,r5
   24edc:	1080038c 	andi	r2,r2,14
   24ee0:	1000191e 	bne	r2,zero,24f48 <OBJ_Read+0x120>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   24ee4:	210001cc 	andi	r4,r4,7
   24ee8:	2001511e 	bne	r4,zero,25430 <OBJ_Read+0x608>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
   24eec:	07000184 	movi	fp,6
   24ef0:	00000206 	br	24efc <OBJ_Read+0xd4>
    if ( bCompleteAccess )
   24ef4:	983fed26 	beq	r19,zero,24eac <OBJ_Read+0x84>
            return ABORTIDX_UNSUPPORTED_ACCESS;
   24ef8:	07000144 	movi	fp,5
                return result;
            }
        }

    return 0;
}
   24efc:	e005883a 	mov	r2,fp
   24f00:	dfc00f17 	ldw	ra,60(sp)
   24f04:	df000e17 	ldw	fp,56(sp)
   24f08:	ddc00d17 	ldw	r23,52(sp)
   24f0c:	dd800c17 	ldw	r22,48(sp)
   24f10:	dd400b17 	ldw	r21,44(sp)
   24f14:	dd000a17 	ldw	r20,40(sp)
   24f18:	dcc00917 	ldw	r19,36(sp)
   24f1c:	dc800817 	ldw	r18,32(sp)
   24f20:	dc400717 	ldw	r17,28(sp)
   24f24:	dc000617 	ldw	r16,24(sp)
   24f28:	dec01004 	addi	sp,sp,64
   24f2c:	f800283a 	ret
        if (pAPPL_CoeReadInd != NULL)
   24f30:	d0a14317 	ldw	r2,-31476(gp)
   24f34:	1000071e 	bne	r2,zero,24f54 <OBJ_Read+0x12c>
        if ( pObjEntry->Read != NULL )
   24f38:	38800717 	ldw	r2,28(r7)
   24f3c:	10000b1e 	bne	r2,zero,24f6c <OBJ_Read+0x144>
    UINT16 i = subindex;
   24f40:	a023883a 	mov	r17,r20
   24f44:	00002006 	br	24fc8 <OBJ_Read+0x1a0>
        if (pAPPL_CoeReadInd != NULL)
   24f48:	d0a14317 	ldw	r2,-31476(gp)
    UINT16 lastSubindex = subindex;
   24f4c:	a025883a 	mov	r18,r20
        if (pAPPL_CoeReadInd != NULL)
   24f50:	10000426 	beq	r2,zero,24f64 <OBJ_Read+0x13c>
            pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
   24f54:	980d883a 	mov	r6,r19
   24f58:	e1403fcc 	andi	r5,fp,255
   24f5c:	893fffcc 	andi	r4,r17,65535
   24f60:	103ee83a 	callr	r2
        if ( pObjEntry->Read != NULL )
   24f64:	80800717 	ldw	r2,28(r16)
   24f68:	10001126 	beq	r2,zero,24fb0 <OBJ_Read+0x188>
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24f6c:	d9800117 	ldw	r6,4(sp)
   24f70:	b00f883a 	mov	r7,r22
   24f74:	e1403fcc 	andi	r5,fp,255
   24f78:	893fffcc 	andi	r4,r17,65535
   24f7c:	dcc01015 	stw	r19,64(sp)
}
   24f80:	dfc00f17 	ldw	ra,60(sp)
   24f84:	df000e17 	ldw	fp,56(sp)
   24f88:	ddc00d17 	ldw	r23,52(sp)
   24f8c:	dd800c17 	ldw	r22,48(sp)
   24f90:	dd400b17 	ldw	r21,44(sp)
   24f94:	dd000a17 	ldw	r20,40(sp)
   24f98:	dcc00917 	ldw	r19,36(sp)
   24f9c:	dc800817 	ldw	r18,32(sp)
   24fa0:	dc400717 	ldw	r17,28(sp)
   24fa4:	dc000617 	ldw	r16,24(sp)
   24fa8:	dec01004 	addi	sp,sp,64
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24fac:	1000683a 	jmp	r2
        else if ( index < 0x1000 && subindex != 0 )
   24fb0:	88ffffcc 	andi	r3,r17,65535
   24fb4:	18c40028 	cmpgeui	r3,r3,4096
   24fb8:	183fe11e 	bne	r3,zero,24f40 <OBJ_Read+0x118>
   24fbc:	e7003fcc 	andi	fp,fp,255
   24fc0:	e000111e 	bne	fp,zero,25008 <OBJ_Read+0x1e0>
            for (i = subindex; i <= lastSubindex; i++)
   24fc4:	0023883a 	mov	r17,zero
                else if ( index >= 0x1000 )
   24fc8:	d880008b 	ldhu	r2,2(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24fcc:	bdc03fcc 	andi	r23,r23,255
   24fd0:	8c7fffcc 	andi	r17,r17,65535
                else if ( index >= 0x1000 )
   24fd4:	10840030 	cmpltui	r2,r2,4096
   24fd8:	d8800215 	stw	r2,8(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24fdc:	b88001e0 	cmpeqi	r2,r23,7
                            bRead = 1;
   24fe0:	0039883a 	mov	fp,zero
   24fe4:	000d883a 	mov	r6,zero
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24fe8:	d8800315 	stw	r2,12(sp)
            for (i = subindex; i <= lastSubindex; i++)
   24fec:	dc40008d 	sth	r17,2(sp)
   24ff0:	88bfffcc 	andi	r2,r17,65535
   24ff4:	90ffffcc 	andi	r3,r18,65535
   24ff8:	1880392e 	bgeu	r3,r2,250e0 <OBJ_Read+0x2b8>
            if(bRead == 0)
   24ffc:	30803fcc 	andi	r2,r6,255
   25000:	1000221e 	bne	r2,zero,2508c <OBJ_Read+0x264>
   25004:	003fbd06 	br	24efc <OBJ_Read+0xd4>
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   25008:	e00b883a 	mov	r5,fp
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   2500c:	84400617 	ldw	r17,24(r16)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   25010:	e03890ba 	slli	fp,fp,2
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   25014:	8009883a 	mov	r4,r16
   25018:	002491c0 	call	2491c <OBJ_GetEntryDesc>
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   2501c:	8f23883a 	add	r17,r17,fp
            size = BIT2BYTE(pEntry->BitLength);
   25020:	1180008b 	ldhu	r6,2(r2)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   25024:	897fff17 	ldw	r5,-4(r17)
            size = BIT2BYTE(pEntry->BitLength);
   25028:	318001c4 	addi	r6,r6,7
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   2502c:	2880004c 	andi	r2,r5,1
            size = BIT2BYTE(pEntry->BitLength);
   25030:	300dd0fa 	srai	r6,r6,3
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   25034:	10002126 	beq	r2,zero,250bc <OBJ_Read+0x294>
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   25038:	00bfff84 	movi	r2,-2
                for(cnt = 0; cnt < (size / 2);cnt++)
   2503c:	3006d07a 	srli	r3,r6,1
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   25040:	288a703a 	and	r5,r5,r2
                for(cnt = 0; cnt < (size / 2);cnt++)
   25044:	b009883a 	mov	r4,r22
   25048:	0011883a 	mov	r8,zero
   2504c:	2d95c83a 	sub	r10,r5,r22
   25050:	40bfffcc 	andi	r2,r8,65535
   25054:	2293883a 	add	r9,r4,r10
   25058:	18800e1e 	bne	r3,r2,25094 <OBJ_Read+0x26c>
                if((size % 2) == 1)
   2505c:	3180004c 	andi	r6,r6,1
   25060:	30000a26 	beq	r6,zero,2508c <OBJ_Read+0x264>
   25064:	1806907a 	slli	r3,r3,1
   25068:	b0cf883a 	add	r7,r22,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   2506c:	3880000b 	ldhu	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   25070:	28cb883a 	add	r5,r5,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   25074:	10bfc00c 	andi	r2,r2,65280
   25078:	3880000d 	sth	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   2507c:	28c0000b 	ldhu	r3,0(r5)
   25080:	1806d23a 	srli	r3,r3,8
   25084:	10c4b03a 	or	r2,r2,r3
   25088:	3880000d 	sth	r2,0(r7)
    return 0;
   2508c:	0039883a 	mov	fp,zero
   25090:	003f9a06 	br	24efc <OBJ_Read+0xd4>
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   25094:	4880000b 	ldhu	r2,0(r9)
                    pData++;
   25098:	21000084 	addi	r4,r4,2
                for(cnt = 0; cnt < (size / 2);cnt++)
   2509c:	42000044 	addi	r8,r8,1
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   250a0:	1004d23a 	srli	r2,r2,8
   250a4:	20bfff8d 	sth	r2,-2(r4)
                    pData[0] |= (pVarPtr[1] & 0xFF) << 8;
   250a8:	4a40008b 	ldhu	r9,2(r9)
   250ac:	4812923a 	slli	r9,r9,8
   250b0:	1244b03a 	or	r2,r2,r9
   250b4:	20bfff8d 	sth	r2,-2(r4)
                for(cnt = 0; cnt < (size / 2);cnt++)
   250b8:	003fe506 	br	25050 <OBJ_Read+0x228>
            pData[0] = pVarPtr[0];
   250bc:	2880000b 	ldhu	r2,0(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   250c0:	31bfff04 	addi	r6,r6,-4
   250c4:	29400104 	addi	r5,r5,4
            pData[0] = pVarPtr[0];
   250c8:	b080000d 	sth	r2,0(r22)
            pData[1] = pVarPtr[1];
   250cc:	28bfff8b 	ldhu	r2,-2(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   250d0:	b1000104 	addi	r4,r22,4
            pData[1] = pVarPtr[1];
   250d4:	b080008d 	sth	r2,2(r22)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   250d8:	00273540 	call	27354 <memcpy>
   250dc:	003feb06 	br	2508c <OBJ_Read+0x264>
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   250e0:	80c00617 	ldw	r3,24(r16)
   250e4:	d8c00115 	stw	r3,4(sp)
                if (i == 0)
   250e8:	10002226 	beq	r2,zero,25174 <OBJ_Read+0x34c>
                else if ( index >= 0x1000 )
   250ec:	d8800217 	ldw	r2,8(sp)
   250f0:	1000221e 	bne	r2,zero,2517c <OBJ_Read+0x354>
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   250f4:	800b883a 	mov	r5,r16
   250f8:	8809883a 	mov	r4,r17
   250fc:	d9800415 	stw	r6,16(sp)
   25100:	0024b600 	call	24b60 <OBJ_GetEntryOffset>
   25104:	d9800417 	ldw	r6,16(sp)
   25108:	1007883a 	mov	r3,r2
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   2510c:	8009883a 	mov	r4,r16
   25110:	880b883a 	mov	r5,r17
   25114:	d8c00515 	stw	r3,20(sp)
   25118:	d9800415 	stw	r6,16(sp)
   2511c:	002491c0 	call	2491c <OBJ_GetEntryDesc>
   25120:	102f883a 	mov	r23,r2
                if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
   25124:	10800103 	ldbu	r2,4(r2)
   25128:	d12156c3 	ldbu	r4,-31397(gp)
   2512c:	d9800417 	ldw	r6,16(sp)
   25130:	1004907a 	slli	r2,r2,1
   25134:	d8c00517 	ldw	r3,20(sp)
   25138:	1104703a 	and	r2,r2,r4
   2513c:	1080038c 	andi	r2,r2,14
   25140:	10009e26 	beq	r2,zero,253bc <OBJ_Read+0x594>
                    if ( i == subindex                                     /* requested entry */
   25144:	d880008b 	ldhu	r2,2(sp)
   25148:	a13fffcc 	andi	r4,r20,65535
   2514c:	11000226 	beq	r2,r4,25158 <OBJ_Read+0x330>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25150:	98000626 	beq	r19,zero,2516c <OBJ_Read+0x344>
   25154:	11000536 	bltu	r2,r4,2516c <OBJ_Read+0x344>
                        if ( i == 0 && objCode != OBJCODE_VAR )
   25158:	10000a1e 	bne	r2,zero,25184 <OBJ_Read+0x35c>
   2515c:	d8800317 	ldw	r2,12(sp)
   25160:	1000081e 	bne	r2,zero,25184 <OBJ_Read+0x35c>
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
   25164:	b540000d 	sth	r21,0(r22)
                            pData++;
   25168:	b5800084 	addi	r22,r22,2
            for (i = subindex; i <= lastSubindex; i++)
   2516c:	8c400044 	addi	r17,r17,1
   25170:	003f9e06 	br	24fec <OBJ_Read+0x1c4>
                UINT16 bitOffset = 0;
   25174:	8807883a 	mov	r3,r17
   25178:	003fe406 	br	2510c <OBJ_Read+0x2e4>
   2517c:	0007883a 	mov	r3,zero
   25180:	003fe206 	br	2510c <OBJ_Read+0x2e4>
                pVarPtr += (bitOffset >> 4);
   25184:	180ad0fa 	srli	r5,r3,3
   25188:	d8800117 	ldw	r2,4(sp)
                            UINT16 dataType = pEntry->DataType;
   2518c:	b900000b 	ldhu	r4,0(r23)
                pVarPtr += (bitOffset >> 4);
   25190:	2947ff8c 	andi	r5,r5,8190
   25194:	114b883a 	add	r5,r2,r5
                            if (pEntry->DataType >= 0x700)
   25198:	20bfffcc 	andi	r2,r4,65535
   2519c:	1181c030 	cmpltui	r6,r2,1792
   251a0:	3000201e 	bne	r6,zero,25224 <OBJ_Read+0x3fc>
                                if ( pEntry->BitLength <= 8 )
   251a4:	b900008b 	ldhu	r4,2(r23)
   251a8:	20bfffcc 	andi	r2,r4,65535
   251ac:	11800268 	cmpgeui	r6,r2,9
   251b0:	3000161e 	bne	r6,zero,2520c <OBJ_Read+0x3e4>
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   251b4:	21000bc4 	addi	r4,r4,47
                            switch (dataType)
   251b8:	213ff884 	addi	r4,r4,-30
   251bc:	213fffcc 	andi	r4,r4,65535
   251c0:	00800044 	movi	r2,1
   251c4:	1104983a 	sll	r2,r2,r4
   251c8:	0100ff74 	movhi	r4,1021
   251cc:	21200044 	addi	r4,r4,-32767
   251d0:	1108703a 	and	r4,r2,r4
   251d4:	2000591e 	bne	r4,zero,2533c <OBJ_Read+0x514>
   251d8:	010000b4 	movhi	r4,2
   251dc:	21000104 	addi	r4,r4,4
   251e0:	1108703a 	and	r4,r2,r4
   251e4:	20006d1e 	bne	r4,zero,2539c <OBJ_Read+0x574>
   251e8:	01000074 	movhi	r4,1
   251ec:	21000084 	addi	r4,r4,2
   251f0:	1104703a 	and	r2,r2,r4
   251f4:	10000926 	beq	r2,zero,2521c <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   251f8:	18c003cc 	andi	r3,r3,15
   251fc:	183f3e1e 	bne	r3,zero,24ef8 <OBJ_Read+0xd0>
                                pData[0] = SWAPWORD(pVarPtr[0]);
   25200:	2880000b 	ldhu	r2,0(r5)
   25204:	b080000d 	sth	r2,0(r22)
   25208:	00005f06 	br	25388 <OBJ_Read+0x560>
                                else if ( pEntry->BitLength == 16 )
   2520c:	11000420 	cmpeqi	r4,r2,16
   25210:	203ff91e 	bne	r4,zero,251f8 <OBJ_Read+0x3d0>
                                else if ( pEntry->BitLength == 32 )
   25214:	10800820 	cmpeqi	r2,r2,32
   25218:	1000601e 	bne	r2,zero,2539c <OBJ_Read+0x574>
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   2521c:	07000604 	movi	fp,24
   25220:	003f3606 	br	24efc <OBJ_Read+0xd4>
                            switch (dataType)
   25224:	11800328 	cmpgeui	r6,r2,12
   25228:	30000d1e 	bne	r6,zero,25260 <OBJ_Read+0x438>
   2522c:	110002a8 	cmpgeui	r4,r2,10
   25230:	2000241e 	bne	r4,zero,252c4 <OBJ_Read+0x49c>
   25234:	11000260 	cmpeqi	r4,r2,9
   25238:	2000221e 	bne	r4,zero,252c4 <OBJ_Read+0x49c>
   2523c:	10003126 	beq	r2,zero,25304 <OBJ_Read+0x4dc>
   25240:	01000044 	movi	r4,1
   25244:	2084983a 	sll	r2,r4,r2
   25248:	1100640c 	andi	r4,r2,400
   2524c:	2000531e 	bne	r4,zero,2539c <OBJ_Read+0x574>
   25250:	1100098c 	andi	r4,r2,38
   25254:	2000391e 	bne	r4,zero,2533c <OBJ_Read+0x514>
   25258:	1080120c 	andi	r2,r2,72
   2525c:	003fe506 	br	251f4 <OBJ_Read+0x3cc>
   25260:	11800e28 	cmpgeui	r6,r2,56
   25264:	3000131e 	bne	r6,zero,252b4 <OBJ_Read+0x48c>
   25268:	118007a8 	cmpgeui	r6,r2,30
   2526c:	303fd21e 	bne	r6,zero,251b8 <OBJ_Read+0x390>
   25270:	213ffecc 	andi	r4,r4,65531
   25274:	21000460 	cmpeqi	r4,r4,17
   25278:	2000021e 	bne	r4,zero,25284 <OBJ_Read+0x45c>
   2527c:	108006e0 	cmpeqi	r2,r2,27
   25280:	103fe626 	beq	r2,zero,2521c <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   25284:	18c003cc 	andi	r3,r3,15
   25288:	183f1b1e 	bne	r3,zero,24ef8 <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   2528c:	2880000b 	ldhu	r2,0(r5)
                                pData += 4;
   25290:	b5800204 	addi	r22,r22,8
                                pData[0] = pVarPtr[0];
   25294:	b0bffe0d 	sth	r2,-8(r22)
                                pData[1] = pVarPtr[1];
   25298:	2880008b 	ldhu	r2,2(r5)
   2529c:	b0bffe8d 	sth	r2,-6(r22)
                                pData[2] = pVarPtr[2];
   252a0:	2880010b 	ldhu	r2,4(r5)
   252a4:	b0bfff0d 	sth	r2,-4(r22)
                                pData[3] = pVarPtr[3];
   252a8:	2880018b 	ldhu	r2,6(r5)
   252ac:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   252b0:	00002006 	br	25334 <OBJ_Read+0x50c>
                            switch (dataType)
   252b4:	213f6804 	addi	r4,r4,-608
   252b8:	213fffcc 	andi	r4,r4,65535
   252bc:	21000128 	cmpgeui	r4,r4,4
   252c0:	203fd61e 	bne	r4,zero,2521c <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   252c4:	18c003cc 	andi	r3,r3,15
   252c8:	183f0b1e 	bne	r3,zero,24ef8 <OBJ_Read+0xd0>
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
   252cc:	b980008b 	ldhu	r6,2(r23)
   252d0:	b009883a 	mov	r4,r22
   252d4:	318001c4 	addi	r6,r6,7
   252d8:	300cd0fa 	srli	r6,r6,3
   252dc:	00273540 	call	27354 <memcpy>
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   252e0:	b880008b 	ldhu	r2,2(r23)
   252e4:	10fffc0c 	andi	r3,r2,65520
   252e8:	1806d0fa 	srli	r3,r3,3
                                if((pEntry->BitLength & 0xF) != 0)
   252ec:	108003cc 	andi	r2,r2,15
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   252f0:	b0ed883a 	add	r22,r22,r3
                                if((pEntry->BitLength & 0xF) != 0)
   252f4:	10000f26 	beq	r2,zero,25334 <OBJ_Read+0x50c>
                                    *pData &= 0xFF;
   252f8:	b0800003 	ldbu	r2,0(r22)
   252fc:	b080000d 	sth	r2,0(r22)
   25300:	00000c06 	br	25334 <OBJ_Read+0x50c>
                                if(bCompleteAccess)
   25304:	983fc526 	beq	r19,zero,2521c <OBJ_Read+0x3f4>
                                    if (((pEntry->BitLength & 0xF) > 0)
   25308:	b880008b 	ldhu	r2,2(r23)
   2530c:	114003cc 	andi	r5,r2,15
   25310:	113fffcc 	andi	r4,r2,65535
   25314:	28000426 	beq	r5,zero,25328 <OBJ_Read+0x500>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25318:	10c5883a 	add	r2,r2,r3
   2531c:	108003cc 	andi	r2,r2,15
   25320:	1000011e 	bne	r2,zero,25328 <OBJ_Read+0x500>
                                        pData++;
   25324:	b5800084 	addi	r22,r22,2
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
   25328:	2004d0fa 	srli	r2,r4,3
   2532c:	1080078c 	andi	r2,r2,30
   25330:	b0ad883a 	add	r22,r22,r2
                            bRead = 1;
   25334:	01800044 	movi	r6,1
   25338:	003f8c06 	br	2516c <OBJ_Read+0x344>
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   2533c:	b900008b 	ldhu	r4,2(r23)
   25340:	008000b4 	movhi	r2,2
   25344:	198003cc 	andi	r6,r3,15
   25348:	2008907a 	slli	r4,r4,1
                                    TmpValue = SWAPWORD(pVarPtr[0]);
   2534c:	2940000b 	ldhu	r5,0(r5)
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25350:	2085883a 	add	r2,r4,r2
   25354:	109fce0b 	ldhu	r2,32568(r2)
   25358:	1184983a 	sll	r2,r2,r6
                                    if ((bitOffset & 0x0F) == 0) 
   2535c:	3000011e 	bne	r6,zero,25364 <OBJ_Read+0x53c>
                                        pData[0] = 0;
   25360:	b000000d 	sth	zero,0(r22)
                                    pData[0] = SWAPWORD(pData[0]);
   25364:	b100000b 	ldhu	r4,0(r22)
                                        pData[0] |= TmpValue & bitMask;
   25368:	1144703a 	and	r2,r2,r5
                                    if (bCompleteAccess) 
   2536c:	98000826 	beq	r19,zero,25390 <OBJ_Read+0x568>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   25370:	1104b03a 	or	r2,r2,r4
                                        pData[0] |= TmpValue & bitMask;
   25374:	b080000d 	sth	r2,0(r22)
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
   25378:	b880008b 	ldhu	r2,2(r23)
   2537c:	10c5883a 	add	r2,r2,r3
   25380:	108003cc 	andi	r2,r2,15
   25384:	103feb1e 	bne	r2,zero,25334 <OBJ_Read+0x50c>
                                pData++;
   25388:	b5800084 	addi	r22,r22,2
                                break;
   2538c:	003fe906 	br	25334 <OBJ_Read+0x50c>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   25390:	10bfffcc 	andi	r2,r2,65535
   25394:	1185d83a 	sra	r2,r2,r6
   25398:	003ff506 	br	25370 <OBJ_Read+0x548>
                                if(bitOffset & 0xF)
   2539c:	18c003cc 	andi	r3,r3,15
   253a0:	183ed51e 	bne	r3,zero,24ef8 <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   253a4:	2880000b 	ldhu	r2,0(r5)
                                pData += 2;
   253a8:	b5800104 	addi	r22,r22,4
                                pData[0] = pVarPtr[0];
   253ac:	b0bfff0d 	sth	r2,-4(r22)
                                pData[1] = pVarPtr[1];
   253b0:	2880008b 	ldhu	r2,2(r5)
   253b4:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   253b8:	003fde06 	br	25334 <OBJ_Read+0x50c>
                    if ((bitOffset & 0x0F) == 0) 
   253bc:	188003cc 	andi	r2,r3,15
   253c0:	1000011e 	bne	r2,zero,253c8 <OBJ_Read+0x5a0>
                        *pData = 0;
   253c4:	b000000d 	sth	zero,0(r22)
                    if (((pEntry->BitLength & 0xF) > 0)
   253c8:	b880008b 	ldhu	r2,2(r23)
   253cc:	110003cc 	andi	r4,r2,15
   253d0:	20000526 	beq	r4,zero,253e8 <OBJ_Read+0x5c0>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   253d4:	10c5883a 	add	r2,r2,r3
   253d8:	108003cc 	andi	r2,r2,15
   253dc:	1000021e 	bne	r2,zero,253e8 <OBJ_Read+0x5c0>
                        *pData = 0;
   253e0:	b000008d 	sth	zero,2(r22)
                        pData++;
   253e4:	b5800084 	addi	r22,r22,2
   253e8:	0007883a 	mov	r3,zero
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   253ec:	b880008b 	ldhu	r2,2(r23)
   253f0:	1005d13a 	srai	r2,r2,4
   253f4:	108003cc 	andi	r2,r2,15
   253f8:	18800516 	blt	r3,r2,25410 <OBJ_Read+0x5e8>
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   253fc:	b880010b 	ldhu	r2,4(r23)
   25400:	108001cc 	andi	r2,r2,7
   25404:	1000061e 	bne	r2,zero,25420 <OBJ_Read+0x5f8>
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
   25408:	07000184 	movi	fp,6
   2540c:	003f5706 	br	2516c <OBJ_Read+0x344>
                        pData++;
   25410:	b5800084 	addi	r22,r22,2
                        *pData = 0;
   25414:	18c00044 	addi	r3,r3,1
   25418:	b000000d 	sth	zero,0(r22)
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   2541c:	003ff306 	br	253ec <OBJ_Read+0x5c4>
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25420:	07000684 	movi	fp,26
   25424:	003f5106 	br	2516c <OBJ_Read+0x344>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25428:	07000444 	movi	fp,17
   2542c:	003eb306 	br	24efc <OBJ_Read+0xd4>
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25430:	07000684 	movi	fp,26
   25434:	003eb106 	br	24efc <OBJ_Read+0xd4>

00025438 <OBJ_Write>:

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   25438:	3880030b 	ldhu	r2,12(r7)
{
   2543c:	deffec04 	addi	sp,sp,-80
   25440:	ddc01115 	stw	r23,68(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   25444:	1006d23a 	srli	r3,r2,8
    UINT16 maxSubindex = 0;
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   25448:	10803fcc 	andi	r2,r2,255
{
   2544c:	dd801015 	stw	r22,64(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   25450:	18c003cc 	andi	r3,r3,15
{
   25454:	dd400f15 	stw	r21,60(sp)
   25458:	dd000e15 	stw	r20,56(sp)
   2545c:	dc800c15 	stw	r18,48(sp)
   25460:	dc000a15 	stw	r16,40(sp)
   25464:	3825883a 	mov	r18,r7
   25468:	dfc01315 	stw	ra,76(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2546c:	180f883a 	mov	r7,r3
{
   25470:	df001215 	stw	fp,72(sp)
   25474:	dcc00d15 	stw	r19,52(sp)
   25478:	dc400b15 	stw	r17,44(sp)
   2547c:	d900010d 	sth	r4,4(sp)
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   25480:	d880038d 	sth	r2,14(sp)
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
   25484:	18c001d8 	cmpnei	r3,r3,7
{
   25488:	dc001417 	ldw	r16,80(sp)
   2548c:	dd001503 	ldbu	r20,84(sp)
   25490:	202f883a 	mov	r23,r4
   25494:	282d883a 	mov	r22,r5
   25498:	302b883a 	mov	r21,r6
    UINT16 i = subindex;
   2549c:	2a003fcc 	andi	r8,r5,255
    if ( objCode != OBJCODE_VAR )
   254a0:	1800271e 	bne	r3,zero,25540 <OBJ_Write+0x108>
            maxSubindex = maxConfiguredSubindex;
        }
    }


    if ( bCompleteAccess )
   254a4:	a0007e26 	beq	r20,zero,256a0 <OBJ_Write+0x268>
    {
        if ( objCode == OBJCODE_VAR )
        {
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
   254a8:	07000144 	movi	fp,5
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
    }
    /* ECATCHANGE_END(V5.13) COE4*/

    return 0;
}
   254ac:	e005883a 	mov	r2,fp
   254b0:	dfc01317 	ldw	ra,76(sp)
   254b4:	df001217 	ldw	fp,72(sp)
   254b8:	ddc01117 	ldw	r23,68(sp)
   254bc:	dd801017 	ldw	r22,64(sp)
   254c0:	dd400f17 	ldw	r21,60(sp)
   254c4:	dd000e17 	ldw	r20,56(sp)
   254c8:	dcc00d17 	ldw	r19,52(sp)
   254cc:	dc800c17 	ldw	r18,48(sp)
   254d0:	dc400b17 	ldw	r17,44(sp)
   254d4:	dc000a17 	ldw	r16,40(sp)
   254d8:	dec01404 	addi	sp,sp,80
   254dc:	f800283a 	ret
    if ( bCompleteAccess )
   254e0:	a001a21e 	bne	r20,zero,25b6c <OBJ_Write+0x734>
   254e4:	d9c00415 	stw	r7,16(sp)
    if (subindex > maxSubindex)
   254e8:	40bfffcc 	andi	r2,r8,65535
   254ec:	da000215 	stw	r8,8(sp)
   254f0:	8c7fffcc 	andi	r17,r17,65535
   254f4:	88819536 	bltu	r17,r2,25b4c <OBJ_Write+0x714>
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   254f8:	b4403fcc 	andi	r17,r22,255
   254fc:	880b883a 	mov	r5,r17
   25500:	9009883a 	mov	r4,r18
   25504:	002491c0 	call	2491c <OBJ_GetEntryDesc>
        if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25508:	10c0010b 	ldhu	r3,4(r2)
   2550c:	d16156c3 	ldbu	r5,-31397(gp)
   25510:	da000217 	ldw	r8,8(sp)
   25514:	193fffcc 	andi	r4,r3,65535
   25518:	2005d0ba 	srai	r2,r4,2
   2551c:	d9c00417 	ldw	r7,16(sp)
   25520:	1144703a 	and	r2,r2,r5
   25524:	1080038c 	andi	r2,r2,14
   25528:	1000611e 	bne	r2,zero,256b0 <OBJ_Write+0x278>
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
   2552c:	18c00e0c 	andi	r3,r3,56
   25530:	1801881e 	bne	r3,zero,25b54 <OBJ_Write+0x71c>
                if (pEntry->ObjAccess == 0)
   25534:	203fdc26 	beq	r4,zero,254a8 <OBJ_Write+0x70>
                        return ABORTIDX_READ_ONLY_ENTRY;
   25538:	070001c4 	movi	fp,7
   2553c:	003fdb06 	br	254ac <OBJ_Write+0x74>
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   25540:	90c00617 	ldw	r3,24(r18)
   25544:	18c00003 	ldbu	r3,0(r3)
   25548:	1823883a 	mov	r17,r3
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   2554c:	1800331e 	bne	r3,zero,2561c <OBJ_Write+0x1e4>
   25550:	20f8fc04 	addi	r3,r4,-7184
   25554:	18ffffcc 	andi	r3,r3,65535
   25558:	18c00830 	cmpltui	r3,r3,32
   2555c:	1800081e 	bne	r3,zero,25580 <OBJ_Write+0x148>
   25560:	20fa8004 	addi	r3,r4,-5632
   25564:	18ffffcc 	andi	r3,r3,65535
   25568:	18c08030 	cmpltui	r3,r3,512
   2556c:	1800041e 	bne	r3,zero,25580 <OBJ_Write+0x148>
   25570:	20f98004 	addi	r3,r4,-6656
   25574:	18ffffcc 	andi	r3,r3,65535
   25578:	18c08028 	cmpgeui	r3,r3,512
   2557c:	18001b1e 	bne	r3,zero,255ec <OBJ_Write+0x1b4>
    if ( bCompleteAccess )
   25580:	a0004926 	beq	r20,zero,256a8 <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   25584:	b0c03fcc 	andi	r3,r22,255
   25588:	18002726 	beq	r3,zero,25628 <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   2558c:	1023883a 	mov	r17,r2
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
   25590:	90800617 	ldw	r2,24(r18)
        if(Subindex0 != 0x00)
   25594:	14c00003 	ldbu	r19,0(r2)
   25598:	9826c03a 	cmpne	r19,r19,zero
    if ( pObjEntry->Write != NULL )
   2559c:	90800817 	ldw	r2,32(r18)
   255a0:	10005526 	beq	r2,zero,256f8 <OBJ_Write+0x2c0>
        result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
   255a4:	bdffffcc 	andi	r23,r23,65535
   255a8:	b5803fcc 	andi	r22,r22,255
   255ac:	dd000015 	stw	r20,0(sp)
   255b0:	800f883a 	mov	r7,r16
   255b4:	a80d883a 	mov	r6,r21
   255b8:	b00b883a 	mov	r5,r22
   255bc:	b809883a 	mov	r4,r23
   255c0:	103ee83a 	callr	r2
   255c4:	1039883a 	mov	fp,r2
        if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
   255c8:	10803fcc 	andi	r2,r2,255
   255cc:	103fb71e 	bne	r2,zero,254ac <OBJ_Write+0x74>
   255d0:	d0a14217 	ldw	r2,-31480(gp)
   255d4:	10001726 	beq	r2,zero,25634 <OBJ_Write+0x1fc>
            pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   255d8:	a00d883a 	mov	r6,r20
   255dc:	b00b883a 	mov	r5,r22
   255e0:	b809883a 	mov	r4,r23
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   255e4:	103ee83a 	callr	r2
   255e8:	00001206 	br	25634 <OBJ_Write+0x1fc>
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   255ec:	20ffffcc 	andi	r3,r4,65535
   255f0:	013c0c14 	movui	r4,61488
   255f4:	193fba1e 	bne	r3,r4,254e0 <OBJ_Write+0xa8>
    if ( bCompleteAccess )
   255f8:	a0002b26 	beq	r20,zero,256a8 <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   255fc:	28c03fcc 	andi	r3,r5,255
   25600:	18000926 	beq	r3,zero,25628 <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   25604:	1023883a 	mov	r17,r2
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   25608:	b8bfffcc 	andi	r2,r23,65535
   2560c:	00fc0c14 	movui	r3,61488
   25610:	10ffdf26 	beq	r2,r3,25590 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   25614:	0027883a 	mov	r19,zero
   25618:	003fe006 	br	2559c <OBJ_Write+0x164>
    if ( bCompleteAccess )
   2561c:	a03fb126 	beq	r20,zero,254e4 <OBJ_Write+0xac>
        if ((subindex == 0) && (dataSize > 0))
   25620:	28803fcc 	andi	r2,r5,255
   25624:	1000241e 	bne	r2,zero,256b8 <OBJ_Write+0x280>
    if ( pObjEntry->Write != NULL )
   25628:	90800817 	ldw	r2,32(r18)
        if ((subindex == 0) && (dataSize > 0))
   2562c:	a800031e 	bne	r21,zero,2563c <OBJ_Write+0x204>
    if ( pObjEntry->Write != NULL )
   25630:	103fdc1e 	bne	r2,zero,255a4 <OBJ_Write+0x16c>
           return 0; //no error
   25634:	0039883a 	mov	fp,zero
   25638:	003f9c06 	br	254ac <OBJ_Write+0x74>
    if ( pObjEntry->Write != NULL )
   2563c:	103fd91e 	bne	r2,zero,255a4 <OBJ_Write+0x16c>
   25640:	84400003 	ldbu	r17,0(r16)
    BOOL bClearSubindex0Required = FALSE;
   25644:	0027883a 	mov	r19,zero
        for (i = subindex; i <= lastSubindex; i++)
   25648:	88bfffcc 	andi	r2,r17,65535
   2564c:	d8800415 	stw	r2,16(sp)
   25650:	40bfffcc 	andi	r2,r8,65535
   25654:	d8800215 	stw	r2,8(sp)
                    if (i == 0 && objCode != OBJCODE_VAR)
   25658:	38803fcc 	andi	r2,r7,255
   2565c:	108001e0 	cmpeqi	r2,r2,7
   25660:	b5403fcc 	andi	r21,r22,255
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
   25664:	070001c4 	movi	fp,7
        UINT8 bWritten = 0;
   25668:	000d883a 	mov	r6,zero
                    if (i == 0 && objCode != OBJCODE_VAR)
   2566c:	d8800515 	stw	r2,20(sp)
        for (i = subindex; i <= lastSubindex; i++)
   25670:	d8800417 	ldw	r2,16(sp)
   25674:	ab7fffcc 	andi	r13,r21,65535
   25678:	a819883a 	mov	r12,r21
   2567c:	1340202e 	bgeu	r2,r13,25700 <OBJ_Write+0x2c8>
        if (bWritten == 0)
   25680:	31803fcc 	andi	r6,r6,255
   25684:	303f8926 	beq	r6,zero,254ac <OBJ_Write+0x74>
    if (pAPPL_CoeWriteInd != NULL)
   25688:	d0a14217 	ldw	r2,-31480(gp)
   2568c:	103fe926 	beq	r2,zero,25634 <OBJ_Write+0x1fc>
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   25690:	a00d883a 	mov	r6,r20
   25694:	b1403fcc 	andi	r5,r22,255
   25698:	b93fffcc 	andi	r4,r23,65535
   2569c:	003fd106 	br	255e4 <OBJ_Write+0x1ac>
    UINT16 maxSubindex = 0;
   256a0:	0023883a 	mov	r17,zero
   256a4:	003f8f06 	br	254e4 <OBJ_Write+0xac>
            maxSubindex = maxConfiguredSubindex;
   256a8:	1023883a 	mov	r17,r2
   256ac:	003f8d06 	br	254e4 <OBJ_Write+0xac>
    if((subindex > 0) &&
   256b0:	88000e26 	beq	r17,zero,256ec <OBJ_Write+0x2b4>
    UINT16 lastSubindex = subindex;
   256b4:	4023883a 	mov	r17,r8
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   256b8:	b8b8fc04 	addi	r2,r23,-7184
    if((subindex > 0) &&
   256bc:	10bfffcc 	andi	r2,r2,65535
   256c0:	10800830 	cmpltui	r2,r2,32
   256c4:	103fb21e 	bne	r2,zero,25590 <OBJ_Write+0x158>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   256c8:	b8ba8004 	addi	r2,r23,-5632
   256cc:	10bfffcc 	andi	r2,r2,65535
   256d0:	10808030 	cmpltui	r2,r2,512
   256d4:	103fae1e 	bne	r2,zero,25590 <OBJ_Write+0x158>
   256d8:	b8b98004 	addi	r2,r23,-6656
   256dc:	10bfffcc 	andi	r2,r2,65535
   256e0:	10808030 	cmpltui	r2,r2,512
   256e4:	103fc826 	beq	r2,zero,25608 <OBJ_Write+0x1d0>
   256e8:	003fa906 	br	25590 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   256ec:	b027883a 	mov	r19,r22
    UINT16 lastSubindex = subindex;
   256f0:	0023883a 	mov	r17,zero
   256f4:	003fa906 	br	2559c <OBJ_Write+0x164>
        if (dataSize == 0)
   256f8:	a83fd31e 	bne	r21,zero,25648 <OBJ_Write+0x210>
   256fc:	003fcd06 	br	25634 <OBJ_Write+0x1fc>
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   25700:	91c00617 	ldw	r7,24(r18)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25704:	a80b883a 	mov	r5,r21
   25708:	9009883a 	mov	r4,r18
   2570c:	db400915 	stw	r13,36(sp)
   25710:	d9800715 	stw	r6,28(sp)
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   25714:	db000815 	stw	r12,32(sp)
   25718:	d9c00615 	stw	r7,24(sp)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   2571c:	002491c0 	call	2491c <OBJ_GetEntryDesc>
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25720:	900b883a 	mov	r5,r18
   25724:	a809883a 	mov	r4,r21
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25728:	1023883a 	mov	r17,r2
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   2572c:	0024b600 	call	24b60 <OBJ_GetEntryOffset>
            if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25730:	8900010b 	ldhu	r4,4(r17)
   25734:	d16156c3 	ldbu	r5,-31397(gp)
   25738:	d9800717 	ldw	r6,28(sp)
   2573c:	2009d0ba 	srai	r4,r4,2
   25740:	db400917 	ldw	r13,36(sp)
   25744:	2148703a 	and	r4,r4,r5
   25748:	2100038c 	andi	r4,r4,14
   2574c:	2000f026 	beq	r4,zero,25b10 <OBJ_Write+0x6d8>
                if (i != 0)
   25750:	d9c00617 	ldw	r7,24(sp)
   25754:	db000817 	ldw	r12,32(sp)
   25758:	68000926 	beq	r13,zero,25780 <OBJ_Write+0x348>
                    pVarPtr += (bitOffset >> 4);
   2575c:	1008d0fa 	srli	r4,r2,3
                if ( i == subindex                                     /* requested entry */
   25760:	d8c00217 	ldw	r3,8(sp)
                    pVarPtr += (bitOffset >> 4);
   25764:	2107ff8c 	andi	r4,r4,8190
   25768:	390f883a 	add	r7,r7,r4
                if ( i == subindex                                     /* requested entry */
   2576c:	1b400f26 	beq	r3,r13,257ac <OBJ_Write+0x374>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25770:	a0000126 	beq	r20,zero,25778 <OBJ_Write+0x340>
   25774:	68c00d2e 	bgeu	r13,r3,257ac <OBJ_Write+0x374>
        for (i = subindex; i <= lastSubindex; i++)
   25778:	ad400044 	addi	r21,r21,1
   2577c:	003fbc06 	br	25670 <OBJ_Write+0x238>
                if ( i == subindex                                     /* requested entry */
   25780:	d8c00217 	ldw	r3,8(sp)
   25784:	183ffc1e 	bne	r3,zero,25778 <OBJ_Write+0x340>
                    if (i == 0 && objCode != OBJCODE_VAR)
   25788:	d8c00517 	ldw	r3,20(sp)
   2578c:	1800071e 	bne	r3,zero,257ac <OBJ_Write+0x374>
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25790:	8100000b 	ldhu	r4,0(r16)
                        if(maxConfiguredSubindex < NewSubindex0)
   25794:	d880038b 	ldhu	r2,14(sp)
   25798:	21403fcc 	andi	r5,r4,255
   2579c:	1140ef36 	bltu	r2,r5,25b5c <OBJ_Write+0x724>
                        pVarPtr[0] = SWAPWORD(pData[0]);
   257a0:	3900000d 	sth	r4,0(r7)
                            pData++;
   257a4:	84000084 	addi	r16,r16,2
                            break;
   257a8:	00008d06 	br	259e0 <OBJ_Write+0x5a8>
                        UINT16 dataType = pEntry->DataType;
   257ac:	8980000b 	ldhu	r6,0(r17)
                        if (pEntry->DataType >= 0x700)
   257b0:	313fffcc 	andi	r4,r6,65535
   257b4:	2141c030 	cmpltui	r5,r4,1792
   257b8:	2800341e 	bne	r5,zero,2588c <OBJ_Write+0x454>
                            if ( pEntry->BitLength <= 8 )
   257bc:	8980008b 	ldhu	r6,2(r17)
   257c0:	313fffcc 	andi	r4,r6,65535
   257c4:	21400268 	cmpgeui	r5,r4,9
   257c8:	28002a1e 	bne	r5,zero,25874 <OBJ_Write+0x43c>
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   257cc:	31800bc4 	addi	r6,r6,47
                        switch (dataType)
   257d0:	31bff884 	addi	r6,r6,-30
   257d4:	31bfffcc 	andi	r6,r6,65535
   257d8:	01000044 	movi	r4,1
   257dc:	2188983a 	sll	r4,r4,r6
   257e0:	0140ff74 	movhi	r5,1021
   257e4:	29600044 	addi	r5,r5,-32767
   257e8:	214a703a 	and	r5,r4,r5
   257ec:	2800681e 	bne	r5,zero,25990 <OBJ_Write+0x558>
   257f0:	014000b4 	movhi	r5,2
   257f4:	29400104 	addi	r5,r5,4
   257f8:	214a703a 	and	r5,r4,r5
   257fc:	2800b41e 	bne	r5,zero,25ad0 <OBJ_Write+0x698>
   25800:	01400074 	movhi	r5,1
   25804:	29400084 	addi	r5,r5,2
   25808:	2148703a 	and	r4,r4,r5
   2580c:	20001d26 	beq	r4,zero,25884 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25810:	108003cc 	andi	r2,r2,15
   25814:	103f241e 	bne	r2,zero,254a8 <OBJ_Write+0x70>
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25818:	98803fcc 	andi	r2,r19,255
                            UINT16 u16NewData = SWAPWORD(pData[0]);
   2581c:	8440000b 	ldhu	r17,0(r16)
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25820:	10000326 	beq	r2,zero,25830 <OBJ_Write+0x3f8>
   25824:	3900000b 	ldhu	r4,0(r7)
   25828:	88bfffcc 	andi	r2,r17,65535
   2582c:	2080cd1e 	bne	r4,r2,25b64 <OBJ_Write+0x72c>
                            if(IS_PDO_ASSIGN(index))  //PDO assign
   25830:	d8800117 	ldw	r2,4(sp)
   25834:	10b8fc04 	addi	r2,r2,-7184
   25838:	10bfffcc 	andi	r2,r2,65535
   2583c:	10800828 	cmpgeui	r2,r2,32
   25840:	1000721e 	bne	r2,zero,25a0c <OBJ_Write+0x5d4>
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
   25844:	88ba8004 	addi	r2,r17,-5632
   25848:	10bfffcc 	andi	r2,r2,65535
   2584c:	10808030 	cmpltui	r2,r2,512
   25850:	1000821e 	bne	r2,zero,25a5c <OBJ_Write+0x624>
   25854:	88b98004 	addi	r2,r17,-6656
   25858:	10bfffcc 	andi	r2,r2,65535
   2585c:	10808030 	cmpltui	r2,r2,512
   25860:	10007e1e 	bne	r2,zero,25a5c <OBJ_Write+0x624>
   25864:	88bfffcc 	andi	r2,r17,65535
   25868:	10007c26 	beq	r2,zero,25a5c <OBJ_Write+0x624>
                                    return ABORTIDX_VALUE_EXCEEDED;
   2586c:	07000484 	movi	fp,18
   25870:	003f0e06 	br	254ac <OBJ_Write+0x74>
                            else if ( pEntry->BitLength == 16 )
   25874:	21400420 	cmpeqi	r5,r4,16
   25878:	283fe51e 	bne	r5,zero,25810 <OBJ_Write+0x3d8>
                            else if ( pEntry->BitLength == 32 )
   2587c:	21000820 	cmpeqi	r4,r4,32
   25880:	2000931e 	bne	r4,zero,25ad0 <OBJ_Write+0x698>
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25884:	07000604 	movi	fp,24
   25888:	003f0806 	br	254ac <OBJ_Write+0x74>
                        switch (dataType)
   2588c:	21400328 	cmpgeui	r5,r4,12
   25890:	28000d1e 	bne	r5,zero,258c8 <OBJ_Write+0x490>
   25894:	214002a8 	cmpgeui	r5,r4,10
   25898:	2800241e 	bne	r5,zero,2592c <OBJ_Write+0x4f4>
   2589c:	21400260 	cmpeqi	r5,r4,9
   258a0:	2800221e 	bne	r5,zero,2592c <OBJ_Write+0x4f4>
   258a4:	20002d26 	beq	r4,zero,2595c <OBJ_Write+0x524>
   258a8:	01400044 	movi	r5,1
   258ac:	2908983a 	sll	r4,r5,r4
   258b0:	2140640c 	andi	r5,r4,400
   258b4:	2800861e 	bne	r5,zero,25ad0 <OBJ_Write+0x698>
   258b8:	2140098c 	andi	r5,r4,38
   258bc:	2800341e 	bne	r5,zero,25990 <OBJ_Write+0x558>
   258c0:	2100120c 	andi	r4,r4,72
   258c4:	003fd106 	br	2580c <OBJ_Write+0x3d4>
   258c8:	21400e28 	cmpgeui	r5,r4,56
   258cc:	2800131e 	bne	r5,zero,2591c <OBJ_Write+0x4e4>
   258d0:	214007a8 	cmpgeui	r5,r4,30
   258d4:	283fbe1e 	bne	r5,zero,257d0 <OBJ_Write+0x398>
   258d8:	31bffecc 	andi	r6,r6,65531
   258dc:	31800460 	cmpeqi	r6,r6,17
   258e0:	3000021e 	bne	r6,zero,258ec <OBJ_Write+0x4b4>
   258e4:	210006e0 	cmpeqi	r4,r4,27
   258e8:	203fe626 	beq	r4,zero,25884 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   258ec:	108003cc 	andi	r2,r2,15
   258f0:	103eed1e 	bne	r2,zero,254a8 <OBJ_Write+0x70>
                            pVarPtr[0] = pData[0];
   258f4:	8080000b 	ldhu	r2,0(r16)
                            pData += 4;
   258f8:	84000204 	addi	r16,r16,8
                            pVarPtr[0] = pData[0];
   258fc:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   25900:	80bffe8b 	ldhu	r2,-6(r16)
   25904:	3880008d 	sth	r2,2(r7)
                            pVarPtr[2] = pData[2];
   25908:	80bfff0b 	ldhu	r2,-4(r16)
   2590c:	3880010d 	sth	r2,4(r7)
                            pVarPtr[3] = pData[3];
   25910:	80bfff8b 	ldhu	r2,-2(r16)
   25914:	3880018d 	sth	r2,6(r7)
                            break;
   25918:	00003106 	br	259e0 <OBJ_Write+0x5a8>
                        switch (dataType)
   2591c:	31bf6804 	addi	r6,r6,-608
   25920:	31bfffcc 	andi	r6,r6,65535
   25924:	31800128 	cmpgeui	r6,r6,4
   25928:	303fd61e 	bne	r6,zero,25884 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   2592c:	108003cc 	andi	r2,r2,15
   25930:	103edd1e 	bne	r2,zero,254a8 <OBJ_Write+0x70>
                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
   25934:	8980008b 	ldhu	r6,2(r17)
   25938:	800b883a 	mov	r5,r16
   2593c:	3809883a 	mov	r4,r7
   25940:	318001c4 	addi	r6,r6,7
   25944:	300cd0fa 	srli	r6,r6,3
   25948:	00273540 	call	27354 <memcpy>
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   2594c:	8880008b 	ldhu	r2,2(r17)
   25950:	1004d13a 	srli	r2,r2,4
   25954:	1004907a 	slli	r2,r2,1
   25958:	00000b06 	br	25988 <OBJ_Write+0x550>
                            if(bCompleteAccess)
   2595c:	a03fc926 	beq	r20,zero,25884 <OBJ_Write+0x44c>
                                if (((pEntry->BitLength & 0xF) > 0)
   25960:	8900008b 	ldhu	r4,2(r17)
   25964:	218003cc 	andi	r6,r4,15
   25968:	217fffcc 	andi	r5,r4,65535
   2596c:	30000426 	beq	r6,zero,25980 <OBJ_Write+0x548>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25970:	2089883a 	add	r4,r4,r2
   25974:	210003cc 	andi	r4,r4,15
   25978:	2000011e 	bne	r4,zero,25980 <OBJ_Write+0x548>
                                    pData++;
   2597c:	84000084 	addi	r16,r16,2
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
   25980:	2804d0fa 	srli	r2,r5,3
   25984:	1080078c 	andi	r2,r2,30
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25988:	80a1883a 	add	r16,r16,r2
                            break;
   2598c:	00001406 	br	259e0 <OBJ_Write+0x5a8>
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25990:	8940008b 	ldhu	r5,2(r17)
   25994:	010000b4 	movhi	r4,2
   25998:	130003cc 	andi	r12,r2,15
   2599c:	280a907a 	slli	r5,r5,1
                            TmpValue &= ~bitMask;
   259a0:	3b80000b 	ldhu	r14,0(r7)
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   259a4:	2909883a 	add	r4,r5,r4
   259a8:	211fce0b 	ldhu	r4,32568(r4)
   259ac:	217fffcc 	andi	r5,r4,65535
   259b0:	2b1a983a 	sll	r13,r5,r12
                            TmpValue &= ~bitMask;
   259b4:	034c303a 	nor	r6,zero,r13
   259b8:	338c703a 	and	r6,r6,r14
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   259bc:	8380000b 	ldhu	r14,0(r16)
                            if (bCompleteAccess) 
   259c0:	a0000926 	beq	r20,zero,259e8 <OBJ_Write+0x5b0>
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
   259c4:	6b9a703a 	and	r13,r13,r14
   259c8:	3348b03a 	or	r4,r6,r13
                            pVarPtr[0] = SWAPWORD(TmpValue);
   259cc:	3900000d 	sth	r4,0(r7)
                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
   259d0:	8900008b 	ldhu	r4,2(r17)
   259d4:	2085883a 	add	r2,r4,r2
   259d8:	108003cc 	andi	r2,r2,15
   259dc:	103f7126 	beq	r2,zero,257a4 <OBJ_Write+0x36c>
                    bWritten = 1;
   259e0:	01800044 	movi	r6,1
   259e4:	003f6406 	br	25778 <OBJ_Write+0x340>
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
   259e8:	014a303a 	nor	r5,zero,r5
   259ec:	737fffcc 	andi	r13,r14,65535
   259f0:	2b4a703a 	and	r5,r5,r13
   259f4:	283f9d1e 	bne	r5,zero,2586c <OBJ_Write+0x434>
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
   259f8:	2388703a 	and	r4,r4,r14
   259fc:	213fffcc 	andi	r4,r4,65535
   25a00:	2308983a 	sll	r4,r4,r12
   25a04:	3108b03a 	or	r4,r6,r4
   25a08:	003ff006 	br	259cc <OBJ_Write+0x594>
                            if(index == 0x1C32 || index == 0x1C33)
   25a0c:	d8800117 	ldw	r2,4(sp)
   25a10:	10b8f384 	addi	r2,r2,-7218
   25a14:	10bfffcc 	andi	r2,r2,65535
   25a18:	108000b0 	cmpltui	r2,r2,2
   25a1c:	10000f26 	beq	r2,zero,25a5c <OBJ_Write+0x624>
                               if (i == 1) /* "Synchronisation type" written */
   25a20:	633fffcc 	andi	r12,r12,65535
   25a24:	60800058 	cmpnei	r2,r12,1
   25a28:	10000e1e 	bne	r2,zero,25a64 <OBJ_Write+0x62c>
                                  if (pVarPtr[0] != u16NewData)
   25a2c:	3880000b 	ldhu	r2,0(r7)
   25a30:	897fffcc 	andi	r5,r17,65535
   25a34:	11400726 	beq	r2,r5,25a54 <OBJ_Write+0x61c>
                                     result = CheckSyncTypeValue(index, u16NewData);
   25a38:	d900010b 	ldhu	r4,4(sp)
   25a3c:	d9c00615 	stw	r7,24(sp)
   25a40:	0024d1c0 	call	24d1c <CheckSyncTypeValue>
   25a44:	1039883a 	mov	fp,r2
                                     if (result != 0)
   25a48:	10803fcc 	andi	r2,r2,255
   25a4c:	d9c00617 	ldw	r7,24(sp)
   25a50:	103e961e 	bne	r2,zero,254ac <OBJ_Write+0x74>
                                  bSyncSetByUser = TRUE;
   25a54:	00800044 	movi	r2,1
   25a58:	d0a16d85 	stb	r2,-31306(gp)
                            pVarPtr[0] = u16NewData;
   25a5c:	3c40000d 	sth	r17,0(r7)
   25a60:	003f5006 	br	257a4 <OBJ_Write+0x36c>
                               if (i == 8) /* "Get Cycle Time" written*/
   25a64:	63000218 	cmpnei	r12,r12,8
   25a68:	603ffc1e 	bne	r12,zero,25a5c <OBJ_Write+0x624>
                                   sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   25a6c:	008000f4 	movhi	r2,3
   25a70:	10233715 	stw	zero,-29476(r2)
                                   sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25a74:	008000b4 	movhi	r2,2
   25a78:	10a1a804 	addi	r2,r2,-31072
   25a7c:	010000f4 	movhi	r4,3
   25a80:	20a33615 	stw	r2,-29480(r4)
                                   sSyncManOutPar.u32CycleTime = 0;
   25a84:	010000f4 	movhi	r4,3
   25a88:	20233315 	stw	zero,-29492(r4)
                                   sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   25a8c:	010000f4 	movhi	r4,3
   25a90:	20232615 	stw	zero,-29544(r4)
                                   sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25a94:	010000f4 	movhi	r4,3
   25a98:	20a32515 	stw	r2,-29548(r4)
                                   sSyncManInPar.u32CycleTime = 0;
   25a9c:	008000f4 	movhi	r2,3
   25aa0:	10232215 	stw	zero,-29560(r2)
                                  if ((u16NewData & 0x2) == 0x2)
   25aa4:	8880008c 	andi	r2,r17,2
   25aa8:	103fec26 	beq	r2,zero,25a5c <OBJ_Write+0x624>
                                     sSyncManOutPar.u16SmEventMissedCounter = 0;
   25aac:	008000f4 	movhi	r2,3
   25ab0:	10233c15 	stw	zero,-29456(r2)
                                     sSyncManOutPar.u8SyncError = 0;
   25ab4:	008000f4 	movhi	r2,3
   25ab8:	10234205 	stb	zero,-29432(r2)
                                     sSyncManInPar.u16SmEventMissedCounter = 0;
   25abc:	008000f4 	movhi	r2,3
   25ac0:	10232b15 	stw	zero,-29524(r2)
                                     sSyncManInPar.u8SyncError = 0;
   25ac4:	008000f4 	movhi	r2,3
   25ac8:	10233105 	stb	zero,-29500(r2)
   25acc:	003fe306 	br	25a5c <OBJ_Write+0x624>
                            if(bitOffset & 0xF)
   25ad0:	108003cc 	andi	r2,r2,15
   25ad4:	103e741e 	bne	r2,zero,254a8 <OBJ_Write+0x70>
                            if(bClearSubindex0Required && 
   25ad8:	99003fcc 	andi	r4,r19,255
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25adc:	8080000b 	ldhu	r2,0(r16)
                            if(bClearSubindex0Required && 
   25ae0:	20000626 	beq	r4,zero,25afc <OBJ_Write+0x6c4>
   25ae4:	3940000b 	ldhu	r5,0(r7)
   25ae8:	113fffcc 	andi	r4,r2,65535
   25aec:	29001d1e 	bne	r5,r4,25b64 <OBJ_Write+0x72c>
                                || (pVarPtr[1] != pData[1])))
   25af0:	3940008b 	ldhu	r5,2(r7)
   25af4:	8100008b 	ldhu	r4,2(r16)
   25af8:	29001a1e 	bne	r5,r4,25b64 <OBJ_Write+0x72c>
                            pVarPtr[0] = pData[0];
   25afc:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   25b00:	8080008b 	ldhu	r2,2(r16)
                            pData += 2;
   25b04:	84000104 	addi	r16,r16,4
                            pVarPtr[1] = pData[1];
   25b08:	3880008d 	sth	r2,2(r7)
                            break;
   25b0c:	003fb406 	br	259e0 <OBJ_Write+0x5a8>
                if(i == 0)
   25b10:	6800031e 	bne	r13,zero,25b20 <OBJ_Write+0x6e8>
                    pData++;
   25b14:	84000084 	addi	r16,r16,2
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25b18:	07000604 	movi	fp,24
   25b1c:	003f1606 	br	25778 <OBJ_Write+0x340>
                    if (((pEntry->BitLength & 0xF) > 0)
   25b20:	88c0008b 	ldhu	r3,2(r17)
   25b24:	190003cc 	andi	r4,r3,15
   25b28:	20000426 	beq	r4,zero,25b3c <OBJ_Write+0x704>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25b2c:	1885883a 	add	r2,r3,r2
   25b30:	108003cc 	andi	r2,r2,15
   25b34:	1000011e 	bne	r2,zero,25b3c <OBJ_Write+0x704>
                        pData++;
   25b38:	84000084 	addi	r16,r16,2
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
   25b3c:	1806d0fa 	srli	r3,r3,3
   25b40:	18c7ff8c 	andi	r3,r3,8190
   25b44:	80e1883a 	add	r16,r16,r3
   25b48:	003ff306 	br	25b18 <OBJ_Write+0x6e0>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25b4c:	07000444 	movi	fp,17
   25b50:	003e5606 	br	254ac <OBJ_Write+0x74>
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25b54:	07000684 	movi	fp,26
   25b58:	003e5406 	br	254ac <OBJ_Write+0x74>
                            return ABORTIDX_VALUE_TOO_GREAT;
   25b5c:	070004c4 	movi	fp,19
   25b60:	003e5206 	br	254ac <OBJ_Write+0x74>
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
   25b64:	07000704 	movi	fp,28
   25b68:	003e5006 	br	254ac <OBJ_Write+0x74>
        if ((subindex == 0) && (dataSize > 0))
   25b6c:	b0803fcc 	andi	r2,r22,255
   25b70:	103ead26 	beq	r2,zero,25628 <OBJ_Write+0x1f0>
   25b74:	003ea706 	br	25614 <OBJ_Write+0x1dc>

00025b78 <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
   25b78:	defffe04 	addi	sp,sp,-8
   25b7c:	dc000015 	stw	r16,0(sp)
   25b80:	dc000317 	ldw	r16,12(sp)
	/* for an upload segment response the toggle bit was overwritten */
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25b84:	29403fcc 	andi	r5,r5,255
{
   25b88:	dfc00115 	stw	ra,4(sp)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
	}
	if (abort == 0)
	{
		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25b8c:	8080018b 	ldhu	r2,6(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25b90:	28c01818 	cmpnei	r3,r5,96
{
   25b94:	da000217 	ldw	r8,8(sp)
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25b98:	1083ffcc 	andi	r2,r2,4095
   25b9c:	21003fcc 	andi	r4,r4,255
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25ba0:	18000d1e 	bne	r3,zero,25bd8 <SdoRes+0x60>
	if (abort == 0)
   25ba4:	20003f1e 	bne	r4,zero,25ca4 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25ba8:	108c0014 	ori	r2,r2,12288
   25bac:	8080018d 	sth	r2,6(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
	}

	// HBu 02.05.06: if the CoE-response could not be sent because the
	//               send mailbox is full it should be stored
	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
   25bb0:	01400084 	movi	r5,2
   25bb4:	8009883a 	mov	r4,r16
   25bb8:	00242640 	call	24264 <MBX_MailboxSendReq>
   25bbc:	10803fcc 	andi	r2,r2,255
   25bc0:	10000126 	beq	r2,zero,25bc8 <SdoRes+0x50>
	{
		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
   25bc4:	d4214a15 	stw	r16,-31448(gp)
	}
}
   25bc8:	dfc00117 	ldw	ra,4(sp)
   25bcc:	dc000017 	ldw	r16,0(sp)
   25bd0:	dec00204 	addi	sp,sp,8
   25bd4:	f800283a 	ret
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   25bd8:	80c0020b 	ldhu	r3,8(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25bdc:	2800081e 	bne	r5,zero,25c00 <SdoRes+0x88>
	if (abort == 0)
   25be0:	2000301e 	bne	r4,zero,25ca4 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25be4:	108c0014 	ori	r2,r2,12288
   25be8:	8080018d 	sth	r2,6(r16)
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   25bec:	00800284 	movi	r2,10
   25bf0:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   25bf4:	18c00814 	ori	r3,r3,32
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   25bf8:	80c0020d 	sth	r3,8(r16)
   25bfc:	003fec06 	br	25bb0 <SdoRes+0x38>
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
   25c00:	027fc004 	movi	r9,-256
   25c04:	1a46703a 	and	r3,r3,r9
   25c08:	80c0020d 	sth	r3,8(r16)
	if (abort == 0)
   25c0c:	2000251e 	bne	r4,zero,25ca4 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25c10:	108c0014 	ori	r2,r2,12288
   25c14:	8080018d 	sth	r2,6(r16)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25c18:	29401018 	cmpnei	r5,r5,64
   25c1c:	28001d1e 	bne	r5,zero,25c94 <SdoRes+0x11c>
			if ((objLength <= 4) && (objLength > 0))
   25c20:	40bfffc4 	addi	r2,r8,-1
   25c24:	10800128 	cmpgeui	r2,r2,4
   25c28:	10000c1e 	bne	r2,zero,25c5c <SdoRes+0xe4>
				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
   25c2c:	00800284 	movi	r2,10
   25c30:	8080000d 	sth	r2,0(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c34:	00800104 	movi	r2,4
   25c38:	1205c83a 	sub	r2,r2,r8
   25c3c:	100490ba 	slli	r2,r2,2
   25c40:	318000d4 	ori	r6,r6,3
   25c44:	31803fcc 	andi	r6,r6,255
   25c48:	1184b03a 	or	r2,r2,r6
   25c4c:	1884b03a 	or	r2,r3,r2
   25c50:	10801014 	ori	r2,r2,64
   25c54:	8080020d 	sth	r2,8(r16)
   25c58:	003fd506 	br	25bb0 <SdoRes+0x38>
				if (dataSize < objLength)
   25c5c:	38bfffcc 	andi	r2,r7,65535
   25c60:	12000a2e 	bgeu	r2,r8,25c8c <SdoRes+0x114>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25c64:	39c00284 	addi	r7,r7,10
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
   25c68:	8200030d 	sth	r8,12(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c6c:	31801054 	ori	r6,r6,65
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25c70:	4010d43a 	srli	r8,r8,16
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c74:	31803fcc 	andi	r6,r6,255
   25c78:	198cb03a 	or	r6,r3,r6
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25c7c:	81c0000d 	sth	r7,0(r16)
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25c80:	8200038d 	sth	r8,14(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c84:	8180020d 	sth	r6,8(r16)
   25c88:	003fc906 	br	25bb0 <SdoRes+0x38>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
   25c8c:	41c00284 	addi	r7,r8,10
   25c90:	003ff506 	br	25c68 <SdoRes+0xf0>
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   25c94:	00800284 	movi	r2,10
   25c98:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   25c9c:	18c01814 	ori	r3,r3,96
   25ca0:	003fd506 	br	25bf8 <SdoRes+0x80>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
   25ca4:	10880014 	ori	r2,r2,8192
   25ca8:	8080018d 	sth	r2,6(r16)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   25cac:	8080020b 	ldhu	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25cb0:	200890ba 	slli	r4,r4,2
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   25cb4:	00c00284 	movi	r3,10
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   25cb8:	10802014 	ori	r2,r2,128
   25cbc:	8080020d 	sth	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25cc0:	008000b4 	movhi	r2,2
   25cc4:	2085883a 	add	r2,r4,r2
   25cc8:	109fd617 	ldw	r2,32600(r2)
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   25ccc:	80c0000d 	sth	r3,0(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25cd0:	80800315 	stw	r2,12(r16)
   25cd4:	003fb606 	br	25bb0 <SdoRes+0x38>

00025cd8 <SDOS_SdoInd>:
			is received from the master and calls depending from
			the command the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
{
   25cd8:	defff004 	addi	sp,sp,-64
   25cdc:	dd000a15 	stw	r20,40(sp)
	/* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
	UINT8 bCompleteAccess = 0;
	UINT32 objLength = 0;
	UINT32 dataSize = 0;

	if (bSdoInWork)
   25ce0:	d52173c3 	ldbu	r20,-31281(gp)
{
   25ce4:	dd400b15 	stw	r21,44(sp)
	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK) >> SDOHEADER_COMMANDSHIFT;
   25ce8:	2540020b 	ldhu	r21,8(r4)
{
   25cec:	dc800815 	stw	r18,32(sp)
   25cf0:	dfc00f15 	stw	ra,60(sp)
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   25cf4:	04bff804 	movi	r18,-32
{
   25cf8:	df000e15 	stw	fp,56(sp)
   25cfc:	ddc00d15 	stw	r23,52(sp)
   25d00:	dd800c15 	stw	r22,48(sp)
   25d04:	dcc00915 	stw	r19,36(sp)
   25d08:	dc400715 	stw	r17,28(sp)
   25d0c:	dc000615 	stw	r16,24(sp)
	if (bSdoInWork)
   25d10:	a0803fcc 	andi	r2,r20,255
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   25d14:	9564703a 	and	r18,r18,r21
	if (bSdoInWork)
   25d18:	1002021e 	bne	r2,zero,26524 <SDOS_SdoInd+0x84c>
   25d1c:	a880040c 	andi	r2,r21,16
	{
		bCompleteAccess = 1;
	}
/* ECATCHANGE_END(V5.13) COE5*/

	switch (command)
   25d20:	94803fcc 	andi	r18,r18,255
	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
   25d24:	2440000b 	ldhu	r17,0(r4)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25d28:	2021883a 	mov	r16,r4
   25d2c:	d8800315 	stw	r2,12(sp)
	switch (command)
   25d30:	91001020 	cmpeqi	r4,r18,64
   25d34:	2000161e 	bne	r4,zero,25d90 <SDOS_SdoInd+0xb8>
   25d38:	91001068 	cmpgeui	r4,r18,65
   25d3c:	2000071e 	bne	r4,zero,25d5c <SDOS_SdoInd+0x84>
   25d40:	9000fe26 	beq	r18,zero,2613c <SDOS_SdoInd+0x464>
   25d44:	90800820 	cmpeqi	r2,r18,32
   25d48:	1000111e 	bne	r2,zero,25d90 <SDOS_SdoInd+0xb8>
		}
		break;

	case SDOSERVICE_DOWNLOADSEGMENTREQ:
	case SDOSERVICE_UPLOADSEGMENTREQ:
		if (command == nSdoSegService)
   25d4c:	0013883a 	mov	r9,zero
   25d50:	0039883a 	mov	fp,zero
   25d54:	044000c4 	movi	r17,3
   25d58:	00008206 	br	25f64 <SDOS_SdoInd+0x28c>
	switch (command)
   25d5c:	90801820 	cmpeqi	r2,r18,96
   25d60:	103ffa26 	beq	r2,zero,25d4c <SDOS_SdoInd+0x74>
		if (command == nSdoSegService)
   25d64:	d0a17383 	ldbu	r2,-31282(gp)
   25d68:	10801818 	cmpnei	r2,r2,96
   25d6c:	103ff71e 	bne	r2,zero,25d4c <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25d70:	80800203 	ldbu	r2,8(r16)
   25d74:	d1217003 	ldbu	r4,-31296(gp)
   25d78:	15c0040c 	andi	r23,r2,16
   25d7c:	25c1801e 	bne	r4,r23,26380 <SDOS_SdoInd+0x6a8>
	UINT32 dataSize = 0;
   25d80:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25d84:	0039883a 	mov	fp,zero
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   25d88:	04400044 	movi	r17,1
   25d8c:	00007506 	br	25f64 <SDOS_SdoInd+0x28c>
		index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
   25d90:	8580028b 	ldhu	r22,10(r16)
		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT) & SDOHEADER_INDEXLOMASK;
   25d94:	acffffcc 	andi	r19,r21,65535
   25d98:	9826d23a 	srli	r19,r19,8
   25d9c:	b004923a 	slli	r2,r22,8
   25da0:	98a7883a 	add	r19,r19,r2
		pObjEntry = OBJ_GetObjectHandle(index);
   25da4:	98bfffcc 	andi	r2,r19,65535
   25da8:	1009883a 	mov	r4,r2
   25dac:	d8800215 	stw	r2,8(sp)
   25db0:	002461c0 	call	2461c <OBJ_GetObjectHandle>
   25db4:	102f883a 	mov	r23,r2
		if (pObjEntry)
   25db8:	1001d226 	beq	r2,zero,26504 <SDOS_SdoInd+0x82c>
		subindex = (pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT) & SDOHEADER_SUBINDEXMASK;
   25dbc:	b0bfffcc 	andi	r2,r22,65535
   25dc0:	102cd23a 	srli	r22,r2,8
				if (subindex > maxSubindex)
   25dc4:	b9000303 	ldbu	r4,12(r23)
   25dc8:	2581d236 	bltu	r4,r22,26514 <SDOS_SdoInd+0x83c>
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25dcc:	a880040c 	andi	r2,r21,16
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25dd0:	b17fffcc 	andi	r5,r22,65535
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25dd4:	1004c03a 	cmpne	r2,r2,zero
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25dd8:	a9c0040c 	andi	r7,r21,16
   25ddc:	b80d883a 	mov	r6,r23
   25de0:	993fffcc 	andi	r4,r19,65535
   25de4:	d9400415 	stw	r5,16(sp)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25de8:	d8800215 	stw	r2,8(sp)
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25dec:	00246580 	call	24658 <OBJ_GetObjectLength>
   25df0:	1039883a 	mov	fp,r2
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25df4:	90801018 	cmpnei	r2,r18,64
   25df8:	d9400417 	ldw	r5,16(sp)
   25dfc:	8c7fffcc 	andi	r17,r17,65535
   25e00:	1000151e 	bne	r2,zero,25e58 <SDOS_SdoInd+0x180>
						if (mbxSize != EXPEDITED_FRAME_SIZE)
   25e04:	88800298 	cmpnei	r2,r17,10
   25e08:	1001c81e 	bne	r2,zero,2652c <SDOS_SdoInd+0x854>
						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
   25e0c:	e0bfffc4 	addi	r2,fp,-1
   25e10:	10800128 	cmpgeui	r2,r2,4
   25e14:	1000081e 	bne	r2,zero,25e38 <SDOS_SdoInd+0x160>
							pData[0] = 0;
   25e18:	8000030d 	sth	zero,12(r16)
							pData[1] = 0;
   25e1c:	8000038d 	sth	zero,14(r16)
			if ((abort == 0) && (bCompleteAccess == 1))
   25e20:	a880040c 	andi	r2,r21,16
   25e24:	1001e626 	beq	r2,zero,265c0 <SDOS_SdoInd+0x8e8>
				if (subindex > 1)
   25e28:	288000a8 	cmpgeui	r2,r5,2
   25e2c:	1001e426 	beq	r2,zero,265c0 <SDOS_SdoInd+0x8e8>
   25e30:	e013883a 	mov	r9,fp
   25e34:	0001e006 	br	265b8 <SDOS_SdoInd+0x8e0>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   25e38:	d2a16b8b 	ldhu	r10,-31314(gp)
   25e3c:	52bffc04 	addi	r10,r10,-16
							if (dataSize < objLength)
   25e40:	57007336 	bltu	r10,fp,26010 <SDOS_SdoInd+0x338>
			if ((abort == 0) && (bCompleteAccess == 1))
   25e44:	a880040c 	andi	r2,r21,16
								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
   25e48:	83000404 	addi	r12,r16,16
			if ((abort == 0) && (bCompleteAccess == 1))
   25e4c:	10004f26 	beq	r2,zero,25f8c <SDOS_SdoInd+0x2b4>
   25e50:	5013883a 	mov	r9,r10
   25e54:	00000b06 	br	25e84 <SDOS_SdoInd+0x1ac>
				if (bTransferType)
   25e58:	a880008c 	andi	r2,r21,2
   25e5c:	10001226 	beq	r2,zero,25ea8 <SDOS_SdoInd+0x1d0>
					if (mbxSize != EXPEDITED_FRAME_SIZE)
   25e60:	8c400298 	cmpnei	r17,r17,10
   25e64:	8801b11e 	bne	r17,zero,2652c <SDOS_SdoInd+0x854>
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25e68:	a804d0ba 	srli	r2,r21,2
   25e6c:	02400104 	movi	r9,4
					pData = (UINT16 MBXMEM *) &pSdoInd[1];
   25e70:	83000304 	addi	r12,r16,12
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25e74:	108000cc 	andi	r2,r2,3
   25e78:	4893c83a 	sub	r9,r9,r2
			if ((abort == 0) && (bCompleteAccess == 1))
   25e7c:	a880040c 	andi	r2,r21,16
   25e80:	1001ac26 	beq	r2,zero,26534 <SDOS_SdoInd+0x85c>
				if (subindex > 1)
   25e84:	288000a8 	cmpgeui	r2,r5,2
   25e88:	1001cb1e 	bne	r2,zero,265b8 <SDOS_SdoInd+0x8e0>
					if (objLength == 0)
   25e8c:	e000031e 	bne	fp,zero,25e9c <SDOS_SdoInd+0x1c4>
						nSdoSegIndex = index;
   25e90:	d4e1728d 	sth	r19,-31286(gp)
						nSdoSegSubindex = subindex;
   25e94:	d5a17205 	stb	r22,-31288(gp)
						pSdoSegObjEntry = pObjEntry;
   25e98:	d5e16e15 	stw	r23,-31304(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25e9c:	90801018 	cmpnei	r2,r18,64
   25ea0:	1001a81e 	bne	r2,zero,26544 <SDOS_SdoInd+0x86c>
   25ea4:	00003b06 	br	25f94 <SDOS_SdoInd+0x2bc>
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   25ea8:	8280038b 	ldhu	r10,14(r16)
   25eac:	8080030b 	ldhu	r2,12(r16)
   25eb0:	5014943a 	slli	r10,r10,16
   25eb4:	5094b03a 	or	r10,r10,r2
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   25eb8:	d0a16b0b 	ldhu	r2,-31316(gp)
   25ebc:	51000404 	addi	r4,r10,16
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   25ec0:	5013883a 	mov	r9,r10
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   25ec4:	11002f2e 	bgeu	r2,r4,25f84 <SDOS_SdoInd+0x2ac>
						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
   25ec8:	10bffe84 	addi	r2,r2,-6
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25ecc:	8881971e 	bne	r17,r2,2652c <SDOS_SdoInd+0x854>
					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
   25ed0:	88bffd84 	addi	r2,r17,-10
   25ed4:	1280522e 	bgeu	r2,r10,26020 <SDOS_SdoInd+0x348>
			if ((abort == 0) && (bCompleteAccess == 1))
   25ed8:	a880040c 	andi	r2,r21,16
   25edc:	10000226 	beq	r2,zero,25ee8 <SDOS_SdoInd+0x210>
				if (subindex > 1)
   25ee0:	288000a8 	cmpgeui	r2,r5,2
   25ee4:	1001b41e 	bne	r2,zero,265b8 <SDOS_SdoInd+0x8e0>
					bSdoSegFollows = TRUE;
   25ee8:	00800044 	movi	r2,1
   25eec:	d0a17345 	stb	r2,-31283(gp)
					bSdoSegLastToggle = 1;
   25ef0:	d0a17005 	stb	r2,-31296(gp)
					bSdoSegAccess = bCompleteAccess;
   25ef4:	d8800217 	ldw	r2,8(sp)
					if (pSdoSegData != NULL)
   25ef8:	d1217717 	ldw	r4,-31268(gp)
					nSdoSegIndex = index;
   25efc:	d4e1728d 	sth	r19,-31286(gp)
					bSdoSegAccess = bCompleteAccess;
   25f00:	d0a17305 	stb	r2,-31284(gp)
					nSdoSegSubindex = subindex;
   25f04:	d5a17205 	stb	r22,-31288(gp)
					pSdoSegObjEntry = pObjEntry;
   25f08:	d5e16e15 	stw	r23,-31304(gp)
						nSdoSegCompleteSize = objLength;
   25f0c:	d2616f15 	stw	r9,-31300(gp)
					if (pSdoSegData != NULL)
   25f10:	20000526 	beq	r4,zero,25f28 <SDOS_SdoInd+0x250>
   25f14:	da800515 	stw	r10,20(sp)
   25f18:	d9400415 	stw	r5,16(sp)
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25f1c:	002705c0 	call	2705c <free>
   25f20:	da800517 	ldw	r10,20(sp)
   25f24:	d9400417 	ldw	r5,16(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25f28:	d0a16f17 	ldw	r2,-31300(gp)
   25f2c:	013fff84 	movi	r4,-2
   25f30:	da800515 	stw	r10,20(sp)
   25f34:	10800044 	addi	r2,r2,1
   25f38:	1108703a 	and	r4,r2,r4
   25f3c:	d9400415 	stw	r5,16(sp)
   25f40:	002704c0 	call	2704c <malloc>
   25f44:	d0a17715 	stw	r2,-31268(gp)
					if (pSdoSegData == NULL)
   25f48:	d9400417 	ldw	r5,16(sp)
   25f4c:	da800517 	ldw	r10,20(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25f50:	1009883a 	mov	r4,r2
					if (pSdoSegData == NULL)
   25f54:	1000341e 	bne	r2,zero,26028 <SDOS_SdoInd+0x350>
						if (bCompleteAccess)
   25f58:	d8800217 	ldw	r2,8(sp)
   25f5c:	14400104 	addi	r17,r2,4
						nSdoSegBytesToHandle = dataSize;
   25f60:	5013883a 	mov	r9,r10
	}

	if (abort != ABORTIDX_WORKING)
	{
		/*  type cast was added because of warning */
		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
   25f64:	d9800317 	ldw	r6,12(sp)
   25f68:	dc000115 	stw	r16,4(sp)
   25f6c:	df000015 	stw	fp,0(sp)
   25f70:	49ffffcc 	andi	r7,r9,65535
   25f74:	900b883a 	mov	r5,r18
   25f78:	89003fcc 	andi	r4,r17,255
   25f7c:	0025b780 	call	25b78 <SdoRes>
   25f80:	00005506 	br	260d8 <SDOS_SdoInd+0x400>
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25f84:	50800284 	addi	r2,r10,10
   25f88:	003fd006 	br	25ecc <SDOS_SdoInd+0x1f4>
					if (objLength == 0)
   25f8c:	e0006726 	beq	fp,zero,2612c <SDOS_SdoInd+0x454>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25f90:	5013883a 	mov	r9,r10
						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
   25f94:	d8800217 	ldw	r2,8(sp)
   25f98:	db000015 	stw	r12,0(sp)
   25f9c:	b80f883a 	mov	r7,r23
   25fa0:	d8800115 	stw	r2,4(sp)
   25fa4:	e00d883a 	mov	r6,fp
   25fa8:	993fffcc 	andi	r4,r19,65535
   25fac:	da400515 	stw	r9,20(sp)
   25fb0:	db000415 	stw	r12,16(sp)
   25fb4:	0024e280 	call	24e28 <OBJ_Read>
   25fb8:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   25fbc:	10803fcc 	andi	r2,r2,255
   25fc0:	10803fd8 	cmpnei	r2,r2,255
   25fc4:	db000417 	ldw	r12,16(sp)
   25fc8:	da400517 	ldw	r9,20(sp)
   25fcc:	103fe51e 	bne	r2,zero,25f64 <SDOS_SdoInd+0x28c>
							u8PendingSdo = SDO_PENDING_READ;
   25fd0:	008000c4 	movi	r2,3
   25fd4:	d0a17c05 	stb	r2,-31248(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25fd8:	d8800217 	ldw	r2,8(sp)
							u8StoreSubindex = subindex;
   25fdc:	d5a17b85 	stb	r22,-31250(gp)
							u16StoreIndex = index;
   25fe0:	d4e17b0d 	sth	r19,-31252(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25fe4:	d0a17bc5 	stb	r2,-31249(gp)
							pSdoPendFunc = pObjEntry->Read;
   25fe8:	b8800717 	ldw	r2,28(r23)
							u32StoreDataSize = objLength;
   25fec:	d7217a15 	stw	fp,-31256(gp)
							pStoreData = pData;
   25ff0:	d3217915 	stw	r12,-31260(gp)
							pSdoPendFunc = pObjEntry->Read;
   25ff4:	d0a17815 	stw	r2,-31264(gp)
							bSdoInWork = TRUE;
   25ff8:	00800044 	movi	r2,1
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25ffc:	a8c03c0c 	andi	r3,r21,240
							bSdoInWork = TRUE;
   26000:	d0a173c5 	stb	r2,-31281(gp)
							pSdoResStored = pSdoInd;
   26004:	d4217415 	stw	r16,-31280(gp)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   26008:	80c00205 	stb	r3,8(r16)
							return 0;
   2600c:	00003206 	br	260d8 <SDOS_SdoInd+0x400>
			if ((abort == 0) && (bCompleteAccess == 1))
   26010:	a880040c 	andi	r2,r21,16
   26014:	1001651e 	bne	r2,zero,265ac <SDOS_SdoInd+0x8d4>
				if (subindex > 1)
   26018:	e013883a 	mov	r9,fp
   2601c:	003fb206 	br	25ee8 <SDOS_SdoInd+0x210>
					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
   26020:	83000404 	addi	r12,r16,16
   26024:	003f9506 	br	25e7c <SDOS_SdoInd+0x1a4>
						if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26028:	90801018 	cmpnei	r2,r18,64
   2602c:	1000371e 	bne	r2,zero,2610c <SDOS_SdoInd+0x434>
							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
   26030:	d8800217 	ldw	r2,8(sp)
   26034:	d9000015 	stw	r4,0(sp)
   26038:	b80f883a 	mov	r7,r23
   2603c:	d8800115 	stw	r2,4(sp)
   26040:	e00d883a 	mov	r6,fp
   26044:	993fffcc 	andi	r4,r19,65535
   26048:	da800415 	stw	r10,16(sp)
   2604c:	0024e280 	call	24e28 <OBJ_Read>
   26050:	1023883a 	mov	r17,r2
							if (abort == 0)
   26054:	10803fcc 	andi	r2,r2,255
   26058:	da800417 	ldw	r10,16(sp)
   2605c:	10000a1e 	bne	r2,zero,26088 <SDOS_SdoInd+0x3b0>
								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
   26060:	d1617717 	ldw	r5,-31268(gp)
   26064:	500d883a 	mov	r6,r10
   26068:	81000404 	addi	r4,r16,16
   2606c:	da800215 	stw	r10,8(sp)
   26070:	00273540 	call	27354 <memcpy>
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26074:	00801804 	movi	r2,96
   26078:	d0a17385 	stb	r2,-31282(gp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   2607c:	da800217 	ldw	r10,8(sp)
						nSdoSegBytesToHandle = dataSize;
   26080:	d2a17115 	stw	r10,-31292(gp)
   26084:	003fb606 	br	25f60 <SDOS_SdoInd+0x288>
							else if (abort == ABORTIDX_WORKING)
   26088:	10803fd8 	cmpnei	r2,r2,255
   2608c:	103ffc1e 	bne	r2,zero,26080 <SDOS_SdoInd+0x3a8>
								u8PendingSdo = SDO_PENDING_SEG_READ;
   26090:	00800104 	movi	r2,4
   26094:	d0a17c05 	stb	r2,-31248(gp)
								bStoreCompleteAccess = bCompleteAccess;
   26098:	d8800217 	ldw	r2,8(sp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   2609c:	a8c03c0c 	andi	r3,r21,240
								u8StoreSubindex = subindex;
   260a0:	d5a17b85 	stb	r22,-31250(gp)
								bStoreCompleteAccess = bCompleteAccess;
   260a4:	d0a17bc5 	stb	r2,-31249(gp)
								pStoreData = pSdoSegData;
   260a8:	d0a17717 	ldw	r2,-31268(gp)
								u16StoreIndex = index;
   260ac:	d4e17b0d 	sth	r19,-31252(gp)
								u32StoreDataSize = objLength;
   260b0:	d7217a15 	stw	fp,-31256(gp)
								pStoreData = pSdoSegData;
   260b4:	d0a17915 	stw	r2,-31260(gp)
								pSdoPendFunc = pObjEntry->Read;
   260b8:	b8800717 	ldw	r2,28(r23)
								pSdoResStored = pSdoInd;
   260bc:	d4217415 	stw	r16,-31280(gp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   260c0:	80c00205 	stb	r3,8(r16)
								pSdoPendFunc = pObjEntry->Read;
   260c4:	d0a17815 	stw	r2,-31264(gp)
								bSdoInWork = TRUE;
   260c8:	00800044 	movi	r2,1
   260cc:	d0a173c5 	stb	r2,-31281(gp)
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   260d0:	00801804 	movi	r2,96
   260d4:	d0a17385 	stb	r2,-31282(gp)
	}

	return 0;
}
   260d8:	a005883a 	mov	r2,r20
   260dc:	dfc00f17 	ldw	ra,60(sp)
   260e0:	df000e17 	ldw	fp,56(sp)
   260e4:	ddc00d17 	ldw	r23,52(sp)
   260e8:	dd800c17 	ldw	r22,48(sp)
   260ec:	dd400b17 	ldw	r21,44(sp)
   260f0:	dd000a17 	ldw	r20,40(sp)
   260f4:	dcc00917 	ldw	r19,36(sp)
   260f8:	dc800817 	ldw	r18,32(sp)
   260fc:	dc400717 	ldw	r17,28(sp)
   26100:	dc000617 	ldw	r16,24(sp)
   26104:	dec01004 	addi	sp,sp,64
   26108:	f800283a 	ret
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   2610c:	8abffd84 	addi	r10,r17,-10
   26110:	500d883a 	mov	r6,r10
   26114:	81400404 	addi	r5,r16,16
   26118:	da800215 	stw	r10,8(sp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   2611c:	a023883a 	mov	r17,r20
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   26120:	00273540 	call	27354 <memcpy>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   26124:	d0217385 	stb	zero,-31282(gp)
							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   26128:	003fd406 	br	2607c <SDOS_SdoInd+0x3a4>
						nSdoSegIndex = index;
   2612c:	d4e1728d 	sth	r19,-31286(gp)
						nSdoSegSubindex = subindex;
   26130:	d5a17205 	stb	r22,-31288(gp)
						pSdoSegObjEntry = pObjEntry;
   26134:	d5e16e15 	stw	r23,-31304(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26138:	003f9506 	br	25f90 <SDOS_SdoInd+0x2b8>
		if (command == nSdoSegService)
   2613c:	d1217383 	ldbu	r4,-31282(gp)
   26140:	203f021e 	bne	r4,zero,25d4c <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   26144:	d1617003 	ldbu	r5,-31296(gp)
		if (pSdoSegData)
   26148:	d1217717 	ldw	r4,-31268(gp)
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   2614c:	28808826 	beq	r5,r2,26370 <SDOS_SdoInd+0x698>
		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
   26150:	d0a17005 	stb	r2,-31296(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   26154:	d4e16b0b 	ldhu	r19,-31316(gp)
		if (pSdoSegData)
   26158:	20008726 	beq	r4,zero,26378 <SDOS_SdoInd+0x6a0>
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   2615c:	d0a17117 	ldw	r2,-31292(gp)
   26160:	d1616f17 	ldw	r5,-31300(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   26164:	9cfffdc4 	addi	r19,r19,-9
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   26168:	a980004c 	andi	r6,r21,1
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   2616c:	288bc83a 	sub	r5,r5,r2
				if (bytesToSave <= maxData)
   26170:	9cffffcc 	andi	r19,r19,65535
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   26174:	30003d26 	beq	r6,zero,2626c <SDOS_SdoInd+0x594>
				if (bytesToSave <= maxData)
   26178:	9940092e 	bgeu	r19,r5,261a0 <SDOS_SdoInd+0x4c8>
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
   2617c:	04400384 	movi	r17,14
		if (pSdoSegData)
   26180:	d1217717 	ldw	r4,-31268(gp)
		bSdoSegFollows = FALSE;
   26184:	d0217345 	stb	zero,-31283(gp)
		nSdoSegService = 0;
   26188:	d0217385 	stb	zero,-31282(gp)
		if (pSdoSegData)
   2618c:	20000226 	beq	r4,zero,26198 <SDOS_SdoInd+0x4c0>
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   26190:	002705c0 	call	2705c <free>
			pSdoSegData = NULL;
   26194:	d0217715 	stw	zero,-31268(gp)
		nSdoSegBytesToHandle = 0;
   26198:	d0217115 	stw	zero,-31292(gp)
   2619c:	00003006 	br	26260 <SDOS_SdoInd+0x588>
					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   261a0:	8c7fffcc 	andi	r17,r17,65535
   261a4:	8c7fff44 	addi	r17,r17,-3
   261a8:	897ff436 	bltu	r17,r5,2617c <SDOS_SdoInd+0x4a4>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   261ac:	a9bfffcc 	andi	r6,r21,65535
						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
   261b0:	300dd07a 	srai	r6,r6,1
   261b4:	018c303a 	nor	r6,zero,r6
   261b8:	318001cc 	andi	r6,r6,7
   261bc:	29800326 	beq	r5,r6,261cc <SDOS_SdoInd+0x4f4>
						|| ((bytesToSave > MIN_SEGMENTED_DATA)
   261c0:	29800230 	cmpltui	r6,r5,8
   261c4:	303fed1e 	bne	r6,zero,2617c <SDOS_SdoInd+0x4a4>
							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   261c8:	2c7fec1e 	bne	r5,r17,2617c <SDOS_SdoInd+0x4a4>
						bSdoSegFollows = FALSE;
   261cc:	d0217345 	stb	zero,-31283(gp)
   261d0:	2827883a 	mov	r19,r5
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   261d4:	11c0004c 	andi	r7,r2,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   261d8:	1004d07a 	srli	r2,r2,1
   261dc:	81400284 	addi	r5,r16,10
   261e0:	1004907a 	slli	r2,r2,1
   261e4:	208d883a 	add	r6,r4,r2
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   261e8:	38002426 	beq	r7,zero,2627c <SDOS_SdoInd+0x5a4>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   261ec:	30c00003 	ldbu	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   261f0:	10800084 	addi	r2,r2,2
   261f4:	2089883a 	add	r4,r4,r2
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   261f8:	30c0000d 	sth	r3,0(r6)
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
   261fc:	81c0020b 	ldhu	r7,8(r16)
   26200:	39ffc00c 	andi	r7,r7,65280
   26204:	19c6b03a 	or	r3,r3,r7
   26208:	30c0000d 	sth	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   2620c:	99bfffc4 	addi	r6,r19,-1
   26210:	00273540 	call	27354 <memcpy>
				if (bSdoSegFollows == FALSE)
   26214:	d0a17343 	ldbu	r2,-31283(gp)
   26218:	10002b26 	beq	r2,zero,262c8 <SDOS_SdoInd+0x5f0>
		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   2621c:	00800284 	movi	r2,10
   26220:	8080000d 	sth	r2,0(r16)
		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   26224:	8080018b 	ldhu	r2,6(r16)
   26228:	1083ffcc 	andi	r2,r2,4095
		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   2622c:	108c0014 	ori	r2,r2,12288
   26230:	8080018d 	sth	r2,6(r16)
		if (bSdoSegLastToggle)
   26234:	d0a17003 	ldbu	r2,-31296(gp)
   26238:	10004b1e 	bne	r2,zero,26368 <SDOS_SdoInd+0x690>
   2623c:	00800804 	movi	r2,32
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
   26240:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   26244:	d0a17343 	ldbu	r2,-31283(gp)
   26248:	10800058 	cmpnei	r2,r2,1
   2624c:	1000981e 	bne	r2,zero,264b0 <SDOS_SdoInd+0x7d8>
			nSdoSegBytesToHandle += bytesToSave;
   26250:	d0a17117 	ldw	r2,-31292(gp)
   26254:	14c5883a 	add	r2,r2,r19
   26258:	d0a17115 	stw	r2,-31292(gp)
	if (abort != ABORTIDX_WORKING)
   2625c:	a023883a 	mov	r17,r20
	UINT32 dataSize = 0;
   26260:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   26264:	0039883a 	mov	fp,zero
   26268:	003f3e06 	br	25f64 <SDOS_SdoInd+0x28c>
				bSdoSegFollows = TRUE;
   2626c:	01800044 	movi	r6,1
   26270:	d1a17345 	stb	r6,-31283(gp)
				if (bytesToSave <= maxData)
   26274:	997fc12e 	bgeu	r19,r5,2617c <SDOS_SdoInd+0x4a4>
   26278:	003fd606 	br	261d4 <SDOS_SdoInd+0x4fc>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   2627c:	8080028b 	ldhu	r2,10(r16)
   26280:	a8ffffcc 	andi	r3,r21,65535
   26284:	1806d23a 	srli	r3,r3,8
   26288:	1004923a 	slli	r2,r2,8
   2628c:	10c4b03a 	or	r2,r2,r3
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   26290:	98c00044 	addi	r3,r19,1
   26294:	1806d07a 	srli	r3,r3,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   26298:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   2629c:	39c00044 	addi	r7,r7,1
   262a0:	29400084 	addi	r5,r5,2
   262a4:	31800084 	addi	r6,r6,2
   262a8:	38ffda2e 	bgeu	r7,r3,26214 <SDOS_SdoInd+0x53c>
						pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
   262ac:	28bfff8b 	ldhu	r2,-2(r5)
   262b0:	2900000b 	ldhu	r4,0(r5)
   262b4:	1004d23a 	srli	r2,r2,8
   262b8:	2008923a 	slli	r4,r4,8
   262bc:	1104b03a 	or	r2,r2,r4
   262c0:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   262c4:	003ff506 	br	2629c <SDOS_SdoInd+0x5c4>
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   262c8:	d0a17303 	ldbu	r2,-31284(gp)
   262cc:	d1e16e17 	ldw	r7,-31304(gp)
   262d0:	d1a16f17 	ldw	r6,-31300(gp)
   262d4:	d8800115 	stw	r2,4(sp)
   262d8:	d0a17717 	ldw	r2,-31268(gp)
   262dc:	d1617203 	ldbu	r5,-31288(gp)
   262e0:	d121728b 	ldhu	r4,-31286(gp)
   262e4:	d8800015 	stw	r2,0(sp)
   262e8:	00254380 	call	25438 <OBJ_Write>
					if (abort == ABORTIDX_WORKING)
   262ec:	15803fcc 	andi	r22,r2,255
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   262f0:	1023883a 	mov	r17,r2
					if (abort == ABORTIDX_WORKING)
   262f4:	b0803fd8 	cmpnei	r2,r22,255
   262f8:	1000161e 	bne	r2,zero,26354 <SDOS_SdoInd+0x67c>
						u8PendingSdo = SDO_PENDING_SEG_WRITE;
   262fc:	00800084 	movi	r2,2
   26300:	d0a17c05 	stb	r2,-31248(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   26304:	d0a17303 	ldbu	r2,-31284(gp)
						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
   26308:	d4217415 	stw	r16,-31280(gp)
						bSdoSegFollows = FALSE;
   2630c:	d0217345 	stb	zero,-31283(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   26310:	d0a17bc5 	stb	r2,-31249(gp)
						u8StoreSubindex = nSdoSegSubindex;
   26314:	d0a17203 	ldbu	r2,-31288(gp)
						nSdoSegService = 0;
   26318:	d0217385 	stb	zero,-31282(gp)
						nSdoSegBytesToHandle = 0;
   2631c:	d0217115 	stw	zero,-31292(gp)
						u8StoreSubindex = nSdoSegSubindex;
   26320:	d0a17b85 	stb	r2,-31250(gp)
						u16StoreIndex = nSdoSegIndex;
   26324:	d0a1728b 	ldhu	r2,-31286(gp)
   26328:	d0a17b0d 	sth	r2,-31252(gp)
						u32StoreDataSize = nSdoSegCompleteSize;
   2632c:	d0a16f17 	ldw	r2,-31300(gp)
   26330:	d0a17a15 	stw	r2,-31256(gp)
						pStoreData = pSdoSegData;
   26334:	d0a17717 	ldw	r2,-31268(gp)
   26338:	d0a17915 	stw	r2,-31260(gp)
						pSdoPendFunc = pSdoSegObjEntry->Write;
   2633c:	d0a16e17 	ldw	r2,-31304(gp)
   26340:	10800817 	ldw	r2,32(r2)
   26344:	d0a17815 	stw	r2,-31264(gp)
						bSdoInWork = TRUE;
   26348:	00800044 	movi	r2,1
   2634c:	d0a173c5 	stb	r2,-31281(gp)
	if (abort != ABORTIDX_WORKING)
   26350:	003f6106 	br	260d8 <SDOS_SdoInd+0x400>
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   26354:	d1217717 	ldw	r4,-31268(gp)
   26358:	002705c0 	call	2705c <free>
						pSdoSegData = NULL;
   2635c:	d0217715 	stw	zero,-31268(gp)
	if (abort == 0)
   26360:	b03fae26 	beq	r22,zero,2621c <SDOS_SdoInd+0x544>
   26364:	003f8606 	br	26180 <SDOS_SdoInd+0x4a8>
   26368:	00800c04 	movi	r2,48
   2636c:	003fb406 	br	26240 <SDOS_SdoInd+0x568>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   26370:	04400044 	movi	r17,1
   26374:	003f8206 	br	26180 <SDOS_SdoInd+0x4a8>
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   26378:	044000c4 	movi	r17,3
   2637c:	003f8006 	br	26180 <SDOS_SdoInd+0x4a8>
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   26380:	d4616b8b 	ldhu	r17,-31314(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   26384:	d4e17117 	ldw	r19,-31292(gp)
   26388:	d0a16f17 	ldw	r2,-31300(gp)
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   2638c:	8c7ffdc4 	addi	r17,r17,-9
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   26390:	8c7fffcc 	andi	r17,r17,65535
		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
   26394:	d5e17005 	stb	r23,-31296(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   26398:	8cc9883a 	add	r4,r17,r19
   2639c:	1100242e 	bgeu	r2,r4,26430 <SDOS_SdoInd+0x758>
			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   263a0:	14e3c83a 	sub	r17,r2,r19
			bSdoSegFollows = FALSE;
   263a4:	a039883a 	mov	fp,r20
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263a8:	980cd07a 	srli	r6,r19,1
   263ac:	d5a17717 	ldw	r22,-31268(gp)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   263b0:	a8c03fcc 	andi	r3,r21,255
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263b4:	300a907a 	slli	r5,r6,1
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   263b8:	80c0020d 	sth	r3,8(r16)
			bSdoSegFollows = FALSE;
   263bc:	d7217345 	stb	fp,-31283(gp)
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263c0:	b145883a 	add	r2,r22,r5
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   263c4:	9900004c 	andi	r4,r19,1
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263c8:	1080000b 	ldhu	r2,0(r2)
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   263cc:	20001a26 	beq	r4,zero,26438 <SDOS_SdoInd+0x760>
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263d0:	10bfc00c 	andi	r2,r2,65280
   263d4:	1886b03a 	or	r3,r3,r2
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   263d8:	29400084 	addi	r5,r5,2
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263dc:	80c0020d 	sth	r3,8(r16)
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   263e0:	89bfffc4 	addi	r6,r17,-1
   263e4:	b14b883a 	add	r5,r22,r5
   263e8:	81000284 	addi	r4,r16,10
   263ec:	00273540 	call	27354 <memcpy>
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   263f0:	8080018b 	ldhu	r2,6(r16)
		if (bSdoSegFollows)
   263f4:	e7003fcc 	andi	fp,fp,255
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   263f8:	8807883a 	mov	r3,r17
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   263fc:	1083ffcc 	andi	r2,r2,4095
		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   26400:	108c0014 	ori	r2,r2,12288
   26404:	8080018d 	sth	r2,6(r16)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
   26408:	8080020b 	ldhu	r2,8(r16)
   2640c:	890001f0 	cmpltui	r4,r17,7
   26410:	10bfc00c 	andi	r2,r2,65280
		if (bSdoSegFollows)
   26414:	e0001d26 	beq	fp,zero,2648c <SDOS_SdoInd+0x7b4>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
   26418:	15c4b03a 	or	r2,r2,r23
   2641c:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   26420:	20002e1e 	bne	r4,zero,264dc <SDOS_SdoInd+0x804>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   26424:	18c000c4 	addi	r3,r3,3
   26428:	80c0000d 	sth	r3,0(r16)
		if (bSdoSegFollows == TRUE)
   2642c:	00003206 	br	264f8 <SDOS_SdoInd+0x820>
   26430:	07000044 	movi	fp,1
   26434:	003fdc06 	br	263a8 <SDOS_SdoInd+0x6d0>
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   26438:	1004923a 	slli	r2,r2,8
			for (i = 0; i < (size >> 1); i++)
   2643c:	880ed07a 	srli	r7,r17,1
   26440:	000b883a 	mov	r5,zero
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   26444:	1886b03a 	or	r3,r3,r2
   26448:	80c0020d 	sth	r3,8(r16)
			for (i = 0; i < (size >> 1); i++)
   2644c:	28bfffcc 	andi	r2,r5,65535
   26450:	11ffe72e 	bgeu	r2,r7,263f0 <SDOS_SdoInd+0x718>
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   26454:	1187883a 	add	r3,r2,r6
   26458:	1806907a 	slli	r3,r3,1
   2645c:	10800104 	addi	r2,r2,4
   26460:	1004907a 	slli	r2,r2,1
   26464:	b0c7883a 	add	r3,r22,r3
   26468:	1900008b 	ldhu	r4,2(r3)
   2646c:	18c0000b 	ldhu	r3,0(r3)
   26470:	8085883a 	add	r2,r16,r2
   26474:	2008923a 	slli	r4,r4,8
   26478:	1806d23a 	srli	r3,r3,8
			for (i = 0; i < (size >> 1); i++)
   2647c:	29400044 	addi	r5,r5,1
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   26480:	20c6b03a 	or	r3,r4,r3
   26484:	10c0008d 	sth	r3,2(r2)
			for (i = 0; i < (size >> 1); i++)
   26488:	003ff006 	br	2644c <SDOS_SdoInd+0x774>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
   2648c:	bdc00054 	ori	r23,r23,1
   26490:	15c4b03a 	or	r2,r2,r23
   26494:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   26498:	2000081e 	bne	r4,zero,264bc <SDOS_SdoInd+0x7e4>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   2649c:	18c000c4 	addi	r3,r3,3
   264a0:	80c0000d 	sth	r3,0(r16)
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   264a4:	b009883a 	mov	r4,r22
   264a8:	002705c0 	call	2705c <free>
			pSdoSegData = NULL;
   264ac:	d0217715 	stw	zero,-31268(gp)
			nSdoSegBytesToHandle = 0;
   264b0:	d0217115 	stw	zero,-31292(gp)
			nSdoSegService = 0;
   264b4:	d0217385 	stb	zero,-31282(gp)
	if (abort != ABORTIDX_WORKING)
   264b8:	003f6806 	br	2625c <SDOS_SdoInd+0x584>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   264bc:	01000284 	movi	r4,10
   264c0:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   264c4:	010001c4 	movi	r4,7
   264c8:	20c7c83a 	sub	r3,r4,r3
   264cc:	1806907a 	slli	r3,r3,1
   264d0:	1884b03a 	or	r2,r3,r2
   264d4:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   264d8:	003ff206 	br	264a4 <SDOS_SdoInd+0x7cc>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   264dc:	01000284 	movi	r4,10
   264e0:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   264e4:	010001c4 	movi	r4,7
   264e8:	20c7c83a 	sub	r3,r4,r3
   264ec:	1806907a 	slli	r3,r3,1
   264f0:	1884b03a 	or	r2,r3,r2
   264f4:	8080020d 	sth	r2,8(r16)
			nSdoSegBytesToHandle += size;
   264f8:	9c67883a 	add	r19,r19,r17
   264fc:	d4e17115 	stw	r19,-31292(gp)
	if (abort != ABORTIDX_WORKING)
   26500:	003f5606 	br	2625c <SDOS_SdoInd+0x584>
	UINT32 dataSize = 0;
   26504:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   26508:	0039883a 	mov	fp,zero
			abort = ABORTIDX_OBJECT_NOT_EXISTING;
   2650c:	04400204 	movi	r17,8
   26510:	003e9406 	br	25f64 <SDOS_SdoInd+0x28c>
   26514:	0013883a 	mov	r9,zero
   26518:	0039883a 	mov	fp,zero
   2651c:	04400444 	movi	r17,17
   26520:	003e9006 	br	25f64 <SDOS_SdoInd+0x28c>
		return MBXERR_SERVICEINWORK;
   26524:	05000244 	movi	r20,9
   26528:	003eeb06 	br	260d8 <SDOS_SdoInd+0x400>
							return MBXERR_INVALIDSIZE;
   2652c:	05000204 	movi	r20,8
   26530:	003ee906 	br	260d8 <SDOS_SdoInd+0x400>
					if (objLength == 0)
   26534:	e000031e 	bne	fp,zero,26544 <SDOS_SdoInd+0x86c>
						nSdoSegIndex = index;
   26538:	d4e1728d 	sth	r19,-31286(gp)
						nSdoSegSubindex = subindex;
   2653c:	d5a17205 	stb	r22,-31288(gp)
						pSdoSegObjEntry = pObjEntry;
   26540:	d5e16e15 	stw	r23,-31304(gp)
						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
   26544:	d8800217 	ldw	r2,8(sp)
   26548:	db000015 	stw	r12,0(sp)
   2654c:	480d883a 	mov	r6,r9
   26550:	d8800115 	stw	r2,4(sp)
   26554:	b80f883a 	mov	r7,r23
   26558:	993fffcc 	andi	r4,r19,65535
   2655c:	db000515 	stw	r12,20(sp)
   26560:	da400415 	stw	r9,16(sp)
   26564:	00254380 	call	25438 <OBJ_Write>
   26568:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   2656c:	10803fcc 	andi	r2,r2,255
   26570:	10803fd8 	cmpnei	r2,r2,255
   26574:	da400417 	ldw	r9,16(sp)
   26578:	db000517 	ldw	r12,20(sp)
   2657c:	103e791e 	bne	r2,zero,25f64 <SDOS_SdoInd+0x28c>
							bStoreCompleteAccess = bCompleteAccess;
   26580:	d8c00217 	ldw	r3,8(sp)
							pSdoPendFunc = pObjEntry->Write;
   26584:	b9000817 	ldw	r4,32(r23)
							u8PendingSdo = SDO_PENDING_WRITE;
   26588:	00800044 	movi	r2,1
   2658c:	d0a17c05 	stb	r2,-31248(gp)
							bStoreCompleteAccess = bCompleteAccess;
   26590:	d0e17bc5 	stb	r3,-31249(gp)
							u8StoreSubindex = subindex;
   26594:	d5a17b85 	stb	r22,-31250(gp)
							u16StoreIndex = index;
   26598:	d4e17b0d 	sth	r19,-31252(gp)
							u32StoreDataSize = dataSize;
   2659c:	d2617a15 	stw	r9,-31256(gp)
							pStoreData = pData;
   265a0:	d3217915 	stw	r12,-31260(gp)
							pSdoPendFunc = pObjEntry->Write;
   265a4:	d1217815 	stw	r4,-31264(gp)
   265a8:	003e9406 	br	25ffc <SDOS_SdoInd+0x324>
				if (subindex > 1)
   265ac:	288000a8 	cmpgeui	r2,r5,2
   265b0:	103e9926 	beq	r2,zero,26018 <SDOS_SdoInd+0x340>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   265b4:	5013883a 	mov	r9,r10
							abort = ABORTIDX_UNSUPPORTED_ACCESS;
   265b8:	04400144 	movi	r17,5
   265bc:	003e6906 	br	25f64 <SDOS_SdoInd+0x28c>
							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
   265c0:	83000304 	addi	r12,r16,12
   265c4:	e013883a 	mov	r9,fp
   265c8:	003e7206 	br	25f94 <SDOS_SdoInd+0x2bc>

000265cc <SDOS_SdoRes>:

void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
{
	UINT16 dataSize = 0;

	if (bSdoInWork)
   265cc:	d0a173c3 	ldbu	r2,-31281(gp)
   265d0:	10004126 	beq	r2,zero,266d8 <SDOS_SdoRes+0x10c>
{
   265d4:	defff604 	addi	sp,sp,-40
   265d8:	dcc00515 	stw	r19,20(sp)
	{
		/* SDO-Response is expected */
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   265dc:	d4e17417 	ldw	r19,-31280(gp)
{
   265e0:	dc800415 	stw	r18,16(sp)
   265e4:	dd400715 	stw	r21,28(sp)
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   265e8:	9c800203 	ldbu	r18,8(r19)
{
   265ec:	dd000615 	stw	r20,24(sp)
   265f0:	dc000215 	stw	r16,8(sp)
		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
   265f4:	9540040c 	andi	r21,r18,16

		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   265f8:	9480380c 	andi	r18,r18,224
{
   265fc:	dfc00915 	stw	ra,36(sp)
   26600:	dd800815 	stw	r22,32(sp)
   26604:	dc400315 	stw	r17,12(sp)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26608:	90801018 	cmpnei	r2,r18,64
   2660c:	2029883a 	mov	r20,r4
   26610:	2821883a 	mov	r16,r5
   26614:	10002e1e 	bne	r2,zero,266d0 <SDOS_SdoRes+0x104>
		{
			/* dataSize contains the available size in one mailbox */
			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   26618:	d4616b8b 	ldhu	r17,-31314(gp)
   2661c:	300b883a 	mov	r5,r6
   26620:	8c7ffc04 	addi	r17,r17,-16
   26624:	882d883a 	mov	r22,r17
			if (dataSize < objLength)
   26628:	8c7fffcc 	andi	r17,r17,65535
   2662c:	8c001e2e 	bgeu	r17,r16,266a8 <SDOS_SdoRes+0xdc>
			{
				/* Segmented Upload, the variables for the segmented transfer should be initialized */
				bSdoSegFollows = TRUE;
   26630:	00800044 	movi	r2,1
   26634:	d0a17345 	stb	r2,-31283(gp)
				bSdoSegLastToggle = 1;
   26638:	d0a17005 	stb	r2,-31296(gp)
				bSdoSegAccess = completeAccess;
				nSdoSegCompleteSize = objLength;
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
				pSdoSegData = (UINT16 VARMEM *) pData;
   2663c:	d1a17715 	stw	r6,-31268(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26640:	00801804 	movi	r2,96
				/* the first segment shall be copied */
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   26644:	880d883a 	mov	r6,r17
   26648:	99000404 	addi	r4,r19,16
				bSdoSegAccess = completeAccess;
   2664c:	d5617305 	stb	r21,-31284(gp)
				nSdoSegCompleteSize = objLength;
   26650:	d4216f15 	stw	r16,-31300(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26654:	d0a17385 	stb	r2,-31282(gp)
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   26658:	00273540 	call	27354 <memcpy>
				nSdoSegBytesToHandle = dataSize;
   2665c:	d4617115 	stw	r17,-31292(gp)
				}
		}

		/* SDO access is finished, send the response */
		bSdoInWork = FALSE;
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26660:	dcc00115 	stw	r19,4(sp)
   26664:	dc000015 	stw	r16,0(sp)
   26668:	b1ffffcc 	andi	r7,r22,65535
   2666c:	a80d883a 	mov	r6,r21
   26670:	900b883a 	mov	r5,r18
   26674:	a1003fcc 	andi	r4,r20,255
		bSdoInWork = FALSE;
   26678:	d02173c5 	stb	zero,-31281(gp)
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   2667c:	0025b780 	call	25b78 <SdoRes>
	}
}
   26680:	dfc00917 	ldw	ra,36(sp)
   26684:	dd800817 	ldw	r22,32(sp)
   26688:	dd400717 	ldw	r21,28(sp)
   2668c:	dd000617 	ldw	r20,24(sp)
   26690:	dcc00517 	ldw	r19,20(sp)
   26694:	dc800417 	ldw	r18,16(sp)
   26698:	dc400317 	ldw	r17,12(sp)
   2669c:	dc000217 	ldw	r16,8(sp)
   266a0:	dec00a04 	addi	sp,sp,40
   266a4:	f800283a 	ret
				if ((objLength <= 4) && (objLength > 0))
   266a8:	80bfffc4 	addi	r2,r16,-1
   266ac:	10800128 	cmpgeui	r2,r2,4
   266b0:	1000051e 	bne	r2,zero,266c8 <SDOS_SdoRes+0xfc>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
   266b4:	99000304 	addi	r4,r19,12
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   266b8:	217fe926 	beq	r4,r5,26660 <SDOS_SdoRes+0x94>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
   266bc:	800d883a 	mov	r6,r16
   266c0:	00273540 	call	27354 <memcpy>
   266c4:	003fe606 	br	26660 <SDOS_SdoRes+0x94>
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   266c8:	99000404 	addi	r4,r19,16
   266cc:	003ffa06 	br	266b8 <SDOS_SdoRes+0xec>
	UINT16 dataSize = 0;
   266d0:	002d883a 	mov	r22,zero
   266d4:	003fe206 	br	26660 <SDOS_SdoRes+0x94>
   266d8:	f800283a 	ret

000266dc <SDOS_ClearPendingResponse>:
		   This function shall be called before the other mailbox data pointer are set to NULL
*////////////////////////////////////////////////////////////////////////////////////////

void  SDOS_ClearPendingResponse(void)
{
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   266dc:	d0a173c3 	ldbu	r2,-31281(gp)
{
   266e0:	deffff04 	addi	sp,sp,-4
   266e4:	dfc00015 	stw	ra,0(sp)
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   266e8:	10800058 	cmpnei	r2,r2,1
   266ec:	1000081e 	bne	r2,zero,26710 <SDOS_ClearPendingResponse+0x34>
   266f0:	d1217417 	ldw	r4,-31280(gp)
   266f4:	20000626 	beq	r4,zero,26710 <SDOS_ClearPendingResponse+0x34>
   266f8:	d0a16617 	ldw	r2,-31336(gp)
   266fc:	20800426 	beq	r4,r2,26710 <SDOS_ClearPendingResponse+0x34>
   26700:	d0a16517 	ldw	r2,-31340(gp)
   26704:	20800226 	beq	r4,r2,26710 <SDOS_ClearPendingResponse+0x34>
	{
		APPL_FreeMailboxBuffer(pSdoResStored);
   26708:	002705c0 	call	2705c <free>
		pSdoResStored = NULL;
   2670c:	d0217415 	stw	zero,-31280(gp)
	u32StoreDataSize = 0;
	pStoreData = NULL;
	pSdoPendFunc = NULL;
	bSdoInWork = FALSE;

	if (pSdoSegData != NULL)
   26710:	d1217717 	ldw	r4,-31268(gp)
	u8PendingSdo = 0;
   26714:	d0217c05 	stb	zero,-31248(gp)
	bStoreCompleteAccess = FALSE;
   26718:	d0217bc5 	stb	zero,-31249(gp)
	u16StoreIndex = 0;
   2671c:	d0217b0d 	sth	zero,-31252(gp)
	u8StoreSubindex = 0;
   26720:	d0217b85 	stb	zero,-31250(gp)
	u32StoreDataSize = 0;
   26724:	d0217a15 	stw	zero,-31256(gp)
	pStoreData = NULL;
   26728:	d0217915 	stw	zero,-31260(gp)
	pSdoPendFunc = NULL;
   2672c:	d0217815 	stw	zero,-31264(gp)
	bSdoInWork = FALSE;
   26730:	d02173c5 	stb	zero,-31281(gp)
	if (pSdoSegData != NULL)
   26734:	20000226 	beq	r4,zero,26740 <SDOS_ClearPendingResponse+0x64>
	{
		FREEMEM((UINT16 VARMEM *) pSdoSegData);
   26738:	002705c0 	call	2705c <free>
		pSdoSegData = NULL;
   2673c:	d0217715 	stw	zero,-31268(gp)
	}

	nSdoSegBytesToHandle = 0;
   26740:	d0217115 	stw	zero,-31292(gp)
	nSdoSegService = 0;
   26744:	d0217385 	stb	zero,-31282(gp)

}
   26748:	dfc00017 	ldw	ra,0(sp)
   2674c:	dec00104 	addi	sp,sp,4
   26750:	f800283a 	ret

00026754 <SDOS_SdoInfoInd>:
			is received from the master and calls depending from
			the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
{
   26754:	defff804 	addi	sp,sp,-32
   26758:	dcc00515 	stw	r19,20(sp)
	UINT8 abort = 0;
	/* the variable opCode contains the requested SDO Information type */
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   2675c:	24c00203 	ldbu	r19,8(r4)
{
   26760:	dc800415 	stw	r18,16(sp)
   26764:	dc000215 	stw	r16,8(sp)
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26768:	9c801fcc 	andi	r18,r19,127
{
   2676c:	dfc00715 	stw	ra,28(sp)
   26770:	dd000615 	stw	r20,24(sp)
   26774:	dc400315 	stw	r17,12(sp)
	UINT8 abort = 0;
   26778:	d8000145 	stb	zero,5(sp)
	UINT16 index;
	UINT8 flags = COE_SERVICE;

	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
	   great enough for the service header of the requested SDO Information type */
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   2677c:	90c00158 	cmpnei	r3,r18,5
   26780:	2080000b 	ldhu	r2,0(r4)
{
   26784:	2021883a 	mov	r16,r4
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26788:	9027883a 	mov	r19,r18
   2678c:	1800041e 	bne	r3,zero,267a0 <SDOS_SdoInfoInd+0x4c>
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
   26790:	108002b0 	cmpltui	r2,r2,10
   26794:	10000926 	beq	r2,zero,267bc <SDOS_SdoInfoInd+0x68>
		{
			return MBXERR_SIZETOOSHORT;
   26798:	00800184 	movi	r2,6
   2679c:	00004b06 	br	268cc <SDOS_SdoInfoInd+0x178>
		}
	}
	else
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
   267a0:	10800230 	cmpltui	r2,r2,8
   267a4:	103ffc1e 	bne	r2,zero,26798 <SDOS_SdoInfoInd+0x44>
		{
			return MBXERR_SIZETOOSHORT;
		}
	}

	switch (opCode)
   267a8:	90800060 	cmpeqi	r2,r18,1
   267ac:	10000b1e 	bne	r2,zero,267dc <SDOS_SdoInfoInd+0x88>
   267b0:	9000dc26 	beq	r18,zero,26b24 <SDOS_SdoInfoInd+0x3d0>
   267b4:	908000e0 	cmpeqi	r2,r18,3
   267b8:	1000da26 	beq	r2,zero,26b24 <SDOS_SdoInfoInd+0x3d0>
		break;

	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
		/* get the requested index */
		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
   267bc:	8100030b 	ldhu	r4,12(r16)
   267c0:	d900018d 	sth	r4,6(sp)



		if (index < 0x1000)
   267c4:	213fffcc 	andi	r4,r4,65535
   267c8:	20840028 	cmpgeui	r2,r4,4096
   267cc:	1000741e 	bne	r2,zero,269a0 <SDOS_SdoInfoInd+0x24c>
		{
			/*SDO Info access is only allowed for objects >= 0x1000*/
			abort = ABORTIDX_UNSUPPORTED_ACCESS;
   267d0:	00800144 	movi	r2,5
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
			}
		}
		break;
	default:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   267d4:	d8800145 	stb	r2,5(sp)
   267d8:	00009506 	br	26a30 <SDOS_SdoInfoInd+0x2dc>
		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
   267dc:	2440030b 	ldhu	r17,12(r4)
   267e0:	8cbfffcc 	andi	r18,r17,65535
   267e4:	908001b0 	cmpltui	r2,r18,6
   267e8:	10009126 	beq	r2,zero,26a30 <SDOS_SdoInfoInd+0x2dc>
			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
   267ec:	200b883a 	mov	r5,r4
   267f0:	010000f4 	movhi	r4,3
   267f4:	01800384 	movi	r6,14
   267f8:	21234304 	addi	r4,r4,-29428
   267fc:	00273540 	call	27354 <memcpy>
			if (listType-- == 0)
   26800:	90003a1e 	bne	r18,zero,268ec <SDOS_SdoInfoInd+0x198>
				nSdoInfoFragmentsLeft = 0;
   26804:	d021768d 	sth	zero,-31270(gp)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26808:	84800384 	addi	r18,r16,14
				nSdoInfoFragmentsLeft = 0;
   2680c:	0023883a 	mov	r17,zero
					UINT16 n = OBJ_GetNoOfObjects(i);
   26810:	8809883a 	mov	r4,r17
   26814:	00249580 	call	24958 <OBJ_GetNoOfObjects>
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26818:	8c400044 	addi	r17,r17,1
					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
   2681c:	9080000d 	sth	r2,0(r18)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26820:	88800158 	cmpnei	r2,r17,5
   26824:	94800084 	addi	r18,r18,2
   26828:	103ff91e 	bne	r2,zero,26810 <SDOS_SdoInfoInd+0xbc>
				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
   2682c:	00800484 	movi	r2,18
			pSdoInfoInd->MbxHeader.Length = size;
   26830:	8080000d 	sth	r2,0(r16)
			if (abort == 0)
   26834:	d8800143 	ldbu	r2,5(sp)
   26838:	10007d1e 	bne	r2,zero,26a30 <SDOS_SdoInfoInd+0x2dc>
				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   2683c:	8080020b 	ldhu	r2,8(r16)
   26840:	00ffe004 	movi	r3,-128
   26844:	10c6703a 	and	r3,r2,r3
				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
   26848:	18c00094 	ori	r3,r3,2
   2684c:	80c0020d 	sth	r3,8(r16)
				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
   26850:	d0e1768b 	ldhu	r3,-31270(gp)
   26854:	80c0028d 	sth	r3,10(r16)
				if (nSdoInfoFragmentsLeft)
   26858:	18ffffcc 	andi	r3,r3,65535
   2685c:	18007426 	beq	r3,zero,26a30 <SDOS_SdoInfoInd+0x2dc>
					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
   26860:	00ffc004 	movi	r3,-256
   26864:	10c4703a 	and	r2,r2,r3
   26868:	10802094 	ori	r2,r2,130
   2686c:	8080020d 	sth	r2,8(r16)
					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
   26870:	017fe084 	movi	r5,-126
	}

	if (abort)
   26874:	d8c00143 	ldbu	r3,5(sp)
   26878:	18000d26 	beq	r3,zero,268b0 <SDOS_SdoInfoInd+0x15c>
	{
		/* send a SDO Information Error response */
		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
   2687c:	00800284 	movi	r2,10
   26880:	8080000d 	sth	r2,0(r16)

		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26884:	8080020b 	ldhu	r2,8(r16)
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);

		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   26888:	180690ba 	slli	r3,r3,2
		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   2688c:	8000028d 	sth	zero,10(r16)
		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26890:	10bfe00c 	andi	r2,r2,65408
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
   26894:	108001d4 	ori	r2,r2,7
   26898:	8080020d 	sth	r2,8(r16)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   2689c:	008000b4 	movhi	r2,2
   268a0:	1885883a 	add	r2,r3,r2
   268a4:	109fd617 	ldw	r2,32600(r2)

		nSdoInfoFragmentsLeft = 0;
   268a8:	d021768d 	sth	zero,-31270(gp)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   268ac:	80800315 	stw	r2,12(r16)
	}

	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
   268b0:	29403fcc 	andi	r5,r5,255
   268b4:	8009883a 	mov	r4,r16
   268b8:	00242640 	call	24264 <MBX_MailboxSendReq>
   268bc:	10803fcc 	andi	r2,r2,255
   268c0:	10000126 	beq	r2,zero,268c8 <SDOS_SdoInfoInd+0x174>
	{
		/* if the mailbox response could not be sent (or stored), the response will be
		   stored in the variable pCoeSendStored and will be sent automatically
			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
			the next time from the master */
		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
   268c4:	d4214a15 	stw	r16,-31448(gp)
	}

	return 0;
   268c8:	0005883a 	mov	r2,zero
}
   268cc:	dfc00717 	ldw	ra,28(sp)
   268d0:	dd000617 	ldw	r20,24(sp)
   268d4:	dcc00517 	ldw	r19,20(sp)
   268d8:	dc800417 	ldw	r18,16(sp)
   268dc:	dc400317 	ldw	r17,12(sp)
   268e0:	dc000217 	ldw	r16,8(sp)
   268e4:	dec00804 	addi	sp,sp,32
   268e8:	f800283a 	ret
				if (nSdoInfoFragmentsLeft)
   268ec:	d4a1768b 	ldhu	r18,-31270(gp)
			if (listType-- == 0)
   268f0:	8c7fffc4 	addi	r17,r17,-1
					n = OBJ_GetNoOfObjects(listType);
   268f4:	8c403fcc 	andi	r17,r17,255
				if (nSdoInfoFragmentsLeft)
   268f8:	90bfffcc 	andi	r2,r18,65535
   268fc:	10001426 	beq	r2,zero,26950 <SDOS_SdoInfoInd+0x1fc>
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   26900:	d4e16b8b 	ldhu	r19,-31314(gp)
					index = nSdoInfoIndex;
   26904:	d0a1760b 	ldhu	r2,-31272(gp)
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
   26908:	85000304 	addi	r20,r16,12
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   2690c:	9cfffd04 	addi	r19,r19,-12
					index = nSdoInfoIndex;
   26910:	d880018d 	sth	r2,6(sp)
					nSdoInfoFragmentsLeft--;
   26914:	94bfffc4 	addi	r18,r18,-1
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   26918:	d8800144 	addi	r2,sp,5
   2691c:	d8800015 	stw	r2,0(sp)
   26920:	a00f883a 	mov	r7,r20
   26924:	99bfffcc 	andi	r6,r19,65535
   26928:	d9400184 	addi	r5,sp,6
   2692c:	8809883a 	mov	r4,r17
					nSdoInfoFragmentsLeft--;
   26930:	d4a1768d 	sth	r18,-31270(gp)
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   26934:	0024a100 	call	24a10 <OBJ_GetObjectList>
				nSdoInfoIndex = index;
   26938:	d8c0018b 	ldhu	r3,6(sp)
   2693c:	d0e1760d 	sth	r3,-31272(gp)
					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
   26940:	d0e16b8b 	ldhu	r3,-31314(gp)
   26944:	18fffe84 	addi	r3,r3,-6
   26948:	1885c83a 	sub	r2,r3,r2
   2694c:	003fb806 	br	26830 <SDOS_SdoInfoInd+0xdc>
					n = OBJ_GetNoOfObjects(listType);
   26950:	8809883a 	mov	r4,r17
   26954:	00249580 	call	24958 <OBJ_GetNoOfObjects>
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26958:	d1616b8b 	ldhu	r5,-31314(gp)
					if ((n << 1) > size)
   2695c:	113fffcc 	andi	r4,r2,65535
					index = 0x1000;
   26960:	00c40004 	movi	r3,4096
					if ((n << 1) > size)
   26964:	2008907a 	slli	r4,r4,1
					index = 0x1000;
   26968:	d8c0018d 	sth	r3,6(sp)
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   2696c:	28fffc84 	addi	r3,r5,-14
					if ((n << 1) > size)
   26970:	18bfffcc 	andi	r2,r3,65535
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26974:	1827883a 	mov	r19,r3
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
   26978:	85000384 	addi	r20,r16,14
					if ((n << 1) > size)
   2697c:	113fe60e 	bge	r2,r4,26918 <SDOS_SdoInfoInd+0x1c4>
						UINT16 Fragsize = size + 2;
   26980:	297ffd04 	addi	r5,r5,-12
						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
   26984:	297fffcc 	andi	r5,r5,65535
   26988:	2089c83a 	sub	r4,r4,r2
   2698c:	28bfffc4 	addi	r2,r5,-1
   26990:	2089883a 	add	r4,r4,r2
   26994:	0026e700 	call	26e70 <__divsi3>
   26998:	1025883a 	mov	r18,r2
   2699c:	003fde06 	br	26918 <SDOS_SdoInfoInd+0x1c4>
			pObjEntry = OBJ_GetObjectHandle(index);
   269a0:	002461c0 	call	2461c <OBJ_GetObjectHandle>
   269a4:	1023883a 	mov	r17,r2
			if (pObjEntry)
   269a8:	10005c26 	beq	r2,zero,26b1c <SDOS_SdoInfoInd+0x3c8>
				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
   269ac:	9cc000d8 	cmpnei	r19,r19,3
   269b0:	9800211e 	bne	r19,zero,26a38 <SDOS_SdoInfoInd+0x2e4>
					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
   269b4:	1009883a 	mov	r4,r2
   269b8:	0024b580 	call	24b58 <OBJ_GetObjDesc>
   269bc:	01800104 	movi	r6,4
   269c0:	100b883a 	mov	r5,r2
   269c4:	81000384 	addi	r4,r16,14
   269c8:	00273540 	call	27354 <memcpy>
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   269cc:	d900018b 	ldhu	r4,6(sp)
   269d0:	000f883a 	mov	r7,zero
   269d4:	880d883a 	mov	r6,r17
   269d8:	000b883a 	mov	r5,zero
   269dc:	00247e40 	call	247e4 <OBJ_GetDesc>
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   269e0:	d0e16b8b 	ldhu	r3,-31314(gp)
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   269e4:	10800304 	addi	r2,r2,12
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   269e8:	10bfffcc 	andi	r2,r2,65535
   269ec:	18fffec4 	addi	r3,r3,-5
   269f0:	10c0460e 	bge	r2,r3,26b0c <SDOS_SdoInfoInd+0x3b8>
						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
   269f4:	d900018b 	ldhu	r4,6(sp)
   269f8:	81c00484 	addi	r7,r16,18
   269fc:	880d883a 	mov	r6,r17
   26a00:	000b883a 	mov	r5,zero
   26a04:	00247e40 	call	247e4 <OBJ_GetDesc>
   26a08:	10800304 	addi	r2,r2,12
				if (abort == 0)
   26a0c:	d8c00143 	ldbu	r3,5(sp)
   26a10:	1800071e 	bne	r3,zero,26a30 <SDOS_SdoInfoInd+0x2dc>
						pSdoInfoInd->MbxHeader.Length = size;
   26a14:	8080000d 	sth	r2,0(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26a18:	8080020b 	ldhu	r2,8(r16)
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26a1c:	94800044 	addi	r18,r18,1
						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26a20:	8000028d 	sth	zero,10(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26a24:	10bfe00c 	andi	r2,r2,65408
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26a28:	14a4b03a 	or	r18,r2,r18
   26a2c:	8480020d 	sth	r18,8(r16)
	UINT8 flags = COE_SERVICE;
   26a30:	01400084 	movi	r5,2
   26a34:	003f8f06 	br	26874 <SDOS_SdoInfoInd+0x120>
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26a38:	1009883a 	mov	r4,r2
					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
   26a3c:	84c00383 	ldbu	r19,14(r16)
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26a40:	0024b580 	call	24b58 <OBJ_GetObjDesc>
					if (subindex <= maxSubindex)
   26a44:	10800083 	ldbu	r2,2(r2)
   26a48:	9cc03fcc 	andi	r19,r19,255
   26a4c:	14c02b36 	bltu	r2,r19,26afc <SDOS_SdoInfoInd+0x3a8>
						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
   26a50:	980b883a 	mov	r5,r19
   26a54:	8809883a 	mov	r4,r17
   26a58:	002491c0 	call	2491c <OBJ_GetEntryDesc>
   26a5c:	01800184 	movi	r6,6
   26a60:	100b883a 	mov	r5,r2
   26a64:	81000404 	addi	r4,r16,16
   26a68:	00273540 	call	27354 <memcpy>
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26a6c:	80800383 	ldbu	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26a70:	8809883a 	mov	r4,r17
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26a74:	8080038d 	sth	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26a78:	0024b580 	call	24b58 <OBJ_GetObjDesc>
						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   26a7c:	1080008b 	ldhu	r2,2(r2)
   26a80:	1005d23a 	srai	r2,r2,8
   26a84:	108003cc 	andi	r2,r2,15
						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
   26a88:	10bffe04 	addi	r2,r2,-8
   26a8c:	10bfffcc 	andi	r2,r2,65535
   26a90:	108000a8 	cmpgeui	r2,r2,2
   26a94:	1000081e 	bne	r2,zero,26ab8 <SDOS_SdoInfoInd+0x364>
   26a98:	9800071e 	bne	r19,zero,26ab8 <SDOS_SdoInfoInd+0x364>
							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
   26a9c:	014000f4 	movhi	r5,3
   26aa0:	01800344 	movi	r6,13
   26aa4:	2960d504 	addi	r5,r5,-31916
   26aa8:	81000584 	addi	r4,r16,22
   26aac:	00273540 	call	27354 <memcpy>
							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
   26ab0:	00800704 	movi	r2,28
   26ab4:	003fd506 	br	26a0c <SDOS_SdoInfoInd+0x2b8>
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26ab8:	d900018b 	ldhu	r4,6(sp)
   26abc:	000f883a 	mov	r7,zero
   26ac0:	880d883a 	mov	r6,r17
   26ac4:	980b883a 	mov	r5,r19
   26ac8:	00247e40 	call	247e4 <OBJ_GetDesc>
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   26acc:	d0e16b8b 	ldhu	r3,-31314(gp)
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26ad0:	10800404 	addi	r2,r2,16
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   26ad4:	10bfffcc 	andi	r2,r2,65535
   26ad8:	18fffec4 	addi	r3,r3,-5
   26adc:	10c00d0e 	bge	r2,r3,26b14 <SDOS_SdoInfoInd+0x3c0>
								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26ae0:	d900018b 	ldhu	r4,6(sp)
   26ae4:	81c00584 	addi	r7,r16,22
   26ae8:	880d883a 	mov	r6,r17
   26aec:	980b883a 	mov	r5,r19
   26af0:	00247e40 	call	247e4 <OBJ_GetDesc>
   26af4:	10800404 	addi	r2,r2,16
   26af8:	003fc406 	br	26a0c <SDOS_SdoInfoInd+0x2b8>
						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
   26afc:	00800444 	movi	r2,17
   26b00:	d8800145 	stb	r2,5(sp)
				UINT16 size = 0;
   26b04:	0005883a 	mov	r2,zero
   26b08:	003fc006 	br	26a0c <SDOS_SdoInfoInd+0x2b8>
						size = SIZEOF_SDOINFOOBJSTRUCT;
   26b0c:	00800304 	movi	r2,12
   26b10:	003fbe06 	br	26a0c <SDOS_SdoInfoInd+0x2b8>
								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26b14:	00800404 	movi	r2,16
   26b18:	003fbc06 	br	26a0c <SDOS_SdoInfoInd+0x2b8>
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26b1c:	00800204 	movi	r2,8
   26b20:	003f2c06 	br	267d4 <SDOS_SdoInfoInd+0x80>
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   26b24:	008000c4 	movi	r2,3
   26b28:	003f2a06 	br	267d4 <SDOS_SdoInfoInd+0x80>

00026b2c <delay_ms>:
#include "system.h"
#include "stdint.h"

// Delay function
// No Parameters
void delay_ms(int milliseconds) {
   26b2c:	deffff04 	addi	sp,sp,-4
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b30:	0140fa04 	movi	r5,1000
void delay_ms(int milliseconds) {
   26b34:	dfc00015 	stw	ra,0(sp)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b38:	00270240 	call	27024 <__mulsi3>
   26b3c:	1009883a 	mov	r4,r2
}
   26b40:	dfc00017 	ldw	ra,0(sp)
   26b44:	dec00104 	addi	sp,sp,4
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b48:	00276fc1 	jmpi	276fc <usleep>

00026b4c <adc_init>:
// Parameter 2: Base address for SPI Chip Select Manual
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){

	int spi_check = -1;
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   26b4c:	008100f4 	movhi	r2,1027
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   26b50:	defff404 	addi	sp,sp,-48
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   26b54:	10804044 	addi	r2,r2,257
   26b58:	d8800415 	stw	r2,16(sp)
	alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   26b5c:	00954184 	movi	r2,21766
   26b60:	d8800515 	stw	r2,20(sp)
	alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
   26b64:	008201f4 	movhi	r2,2055
   26b68:	10818144 	addi	r2,r2,1541
   26b6c:	d8800615 	stw	r2,24(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26b70:	00954144 	movi	r2,21765
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   26b74:	dc400a15 	stw	r17,40(sp)
   26b78:	dc000915 	stw	r16,36(sp)
   26b7c:	dfc00b15 	stw	ra,44(sp)
   26b80:	2021883a 	mov	r16,r4
   26b84:	2823883a 	mov	r17,r5
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26b88:	d8000315 	stw	zero,12(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26b8c:	d8800715 	stw	r2,28(sp)
	uint8_t opcode_lock_receive[4] = {0x00, 0x00, 0x00, 0x00};
   26b90:	d8000815 	stw	zero,32(sp)

	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26b94:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b98:	0104e204 	movi	r4,5000
   26b9c:	00276fc0 	call	276fc <usleep>
	delay_ms(5);
	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   26ba0:	00800044 	movi	r2,1
   26ba4:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26ba8:	01138804 	movi	r4,20000
   26bac:	00276fc0 	call	276fc <usleep>
	delay_ms(20);

	spi_check = alt_avalon_spi_command(base,
   26bb0:	d9c00304 	addi	r7,sp,12
   26bb4:	01800104 	movi	r6,4
   26bb8:	000b883a 	mov	r5,zero
   26bbc:	8009883a 	mov	r4,r16
   26bc0:	d8000215 	stw	zero,8(sp)
   26bc4:	d8000115 	stw	zero,4(sp)
   26bc8:	d8000015 	stw	zero,0(sp)
   26bcc:	00277b00 	call	277b0 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26bd0:	0130d414 	movui	r4,50000
   26bd4:	00276fc0 	call	276fc <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26bd8:	04400104 	movi	r17,4
   26bdc:	d8800404 	addi	r2,sp,16
   26be0:	8009883a 	mov	r4,r16
   26be4:	d8000215 	stw	zero,8(sp)
   26be8:	d8800115 	stw	r2,4(sp)
   26bec:	dc400015 	stw	r17,0(sp)
   26bf0:	000f883a 	mov	r7,zero
   26bf4:	000d883a 	mov	r6,zero
   26bf8:	000b883a 	mov	r5,zero
   26bfc:	00277b00 	call	277b0 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_null_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26c00:	d9c00504 	addi	r7,sp,20
   26c04:	01800104 	movi	r6,4
   26c08:	000b883a 	mov	r5,zero
   26c0c:	8009883a 	mov	r4,r16
   26c10:	d8000215 	stw	zero,8(sp)
   26c14:	d8000115 	stw	zero,4(sp)
   26c18:	d8000015 	stw	zero,0(sp)
   26c1c:	00277b00 	call	277b0 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26c20:	0130d414 	movui	r4,50000
   26c24:	00276fc0 	call	276fc <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26c28:	d8800604 	addi	r2,sp,24
   26c2c:	8009883a 	mov	r4,r16
   26c30:	d8000215 	stw	zero,8(sp)
   26c34:	d8800115 	stw	r2,4(sp)
   26c38:	dc400015 	stw	r17,0(sp)
   26c3c:	000f883a 	mov	r7,zero
   26c40:	000d883a 	mov	r6,zero
   26c44:	000b883a 	mov	r5,zero
   26c48:	00277b00 	call	277b0 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26c4c:	d9c00704 	addi	r7,sp,28
   26c50:	01800104 	movi	r6,4
   26c54:	000b883a 	mov	r5,zero
   26c58:	8009883a 	mov	r4,r16
   26c5c:	d8000215 	stw	zero,8(sp)
   26c60:	d8000115 	stw	zero,4(sp)
   26c64:	d8000015 	stw	zero,0(sp)
   26c68:	00277b00 	call	277b0 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26c6c:	0130d414 	movui	r4,50000
   26c70:	00276fc0 	call	276fc <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26c74:	d8800804 	addi	r2,sp,32
   26c78:	000f883a 	mov	r7,zero
   26c7c:	000d883a 	mov	r6,zero
   26c80:	000b883a 	mov	r5,zero
   26c84:	8009883a 	mov	r4,r16
   26c88:	d8000215 	stw	zero,8(sp)
   26c8c:	d8800115 	stw	r2,4(sp)
   26c90:	dc400015 	stw	r17,0(sp)
   26c94:	00277b00 	call	277b0 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26c98:	0130d414 	movui	r4,50000
   26c9c:	00276fc0 	call	276fc <usleep>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);
	 delay_ms(50);
}
   26ca0:	dfc00b17 	ldw	ra,44(sp)
   26ca4:	dc400a17 	ldw	r17,40(sp)
   26ca8:	dc000917 	ldw	r16,36(sp)
   26cac:	dec00c04 	addi	sp,sp,48
   26cb0:	f800283a 	ret

00026cb4 <spi_transmit_receive>:
    alt_u8 *rx_ptr = rx_buf;
    const alt_u8 *tx_end = tx_buf ? (tx_buf + length) : NULL;
    alt_u8 dummy_tx = 0xFF;

    // 1. Select slave
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26cb4:	00c00044 	movi	r3,1
{
   26cb8:	d8800017 	ldw	r2,0(sp)
   26cbc:	da000117 	ldw	r8,4(sp)
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26cc0:	1946983a 	sll	r3,r3,r5
   26cc4:	20c00535 	stwio	r3,20(r4)

    // 2. Assert CS unless toggle flag is set
    if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   26cc8:	40c0008c 	andi	r3,r8,2
   26ccc:	1800021e 	bne	r3,zero,26cd8 <spi_transmit_receive+0x24>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   26cd0:	00c10004 	movi	r3,1024
   26cd4:	20c00335 	stwio	r3,12(r4)
    }

    // 3. Clear stale RX
    IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26cd8:	20c00037 	ldwio	r3,0(r4)
    alt_32 credits = 1;
   26cdc:	00c00044 	movi	r3,1
    alt_u8 *rx_ptr = rx_buf;
   26ce0:	3813883a 	mov	r9,r7

    while ((rx_ptr - rx_buf) < length)
   26ce4:	49cbc83a 	sub	r5,r9,r7
   26ce8:	22800204 	addi	r10,r4,8
   26cec:	28800736 	bltu	r5,r2,26d0c <spi_transmit_receive+0x58>
        }
    }

    // Wait until TX FIFO is empty (transmit complete)
    do {
        status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26cf0:	50c00037 	ldwio	r3,0(r10)
    } while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   26cf4:	18c0080c 	andi	r3,r3,32
   26cf8:	183ffd26 	beq	r3,zero,26cf0 <spi_transmit_receive+0x3c>

    // Release chip select unless merging
    if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0) {
   26cfc:	4200004c 	andi	r8,r8,1
   26d00:	4000011e 	bne	r8,zero,26d08 <spi_transmit_receive+0x54>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   26d04:	20000335 	stwio	zero,12(r4)
    }

    return length;
}
   26d08:	f800283a 	ret
            status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26d0c:	51400037 	ldwio	r5,0(r10)
        } while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   26d10:	2ac0100c 	andi	r11,r5,64
   26d14:	2940200c 	andi	r5,r5,128
   26d18:	58000126 	beq	r11,zero,26d20 <spi_transmit_receive+0x6c>
   26d1c:	1800031e 	bne	r3,zero,26d2c <spi_transmit_receive+0x78>
   26d20:	283ffa26 	beq	r5,zero,26d0c <spi_transmit_receive+0x58>
        if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) && credits > 0) {
   26d24:	58000726 	beq	r11,zero,26d44 <spi_transmit_receive+0x90>
   26d28:	18000626 	beq	r3,zero,26d44 <spi_transmit_receive+0x90>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   26d2c:	30000b26 	beq	r6,zero,26d5c <spi_transmit_receive+0xa8>
   26d30:	32800003 	ldbu	r10,0(r6)
   26d34:	31800044 	addi	r6,r6,1
            IOWR_ALTERA_AVALON_SPI_TXDATA(base, tx_data);
   26d38:	52803fcc 	andi	r10,r10,255
   26d3c:	22800135 	stwio	r10,4(r4)
            credits--;
   26d40:	18ffffc4 	addi	r3,r3,-1
        if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) {
   26d44:	283fe726 	beq	r5,zero,26ce4 <spi_transmit_receive+0x30>
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26d48:	21400037 	ldwio	r5,0(r4)
   26d4c:	49400005 	stb	r5,0(r9)
            credits++;
   26d50:	18c00044 	addi	r3,r3,1
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26d54:	4a400044 	addi	r9,r9,1
   26d58:	003fe206 	br	26ce4 <spi_transmit_receive+0x30>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   26d5c:	02bfffc4 	movi	r10,-1
   26d60:	003ff506 	br	26d38 <spi_transmit_receive+0x84>

00026d64 <adc_init_spi_transmit_receive>:

// ADC Initialization Using Full-Duplex SPI
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26d64:	defff304 	addi	sp,sp,-52
	int spi_check = -1;
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
		alt_u8 opcode_null_receive[4] = {0x01, 0x02, 0x03, 0x04};
		alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   26d68:	00954184 	movi	r2,21766
   26d6c:	d8800515 	stw	r2,20(sp)
		alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
		uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26d70:	00954144 	movi	r2,21765
   26d74:	d8800715 	stw	r2,28(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   26d78:	00824274 	movhi	r2,2313
   26d7c:	108201c4 	addi	r2,r2,2055
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26d80:	dc400a15 	stw	r17,40(sp)
   26d84:	dc000915 	stw	r16,36(sp)
   26d88:	dfc00c15 	stw	ra,48(sp)
   26d8c:	dc800b15 	stw	r18,44(sp)
   26d90:	2021883a 	mov	r16,r4
   26d94:	2823883a 	mov	r17,r5
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26d98:	d8000315 	stw	zero,12(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   26d9c:	d8800815 	stw	r2,32(sp)

		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26da0:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26da4:	0104e204 	movi	r4,5000
   26da8:	00276fc0 	call	276fc <usleep>
		delay_ms(5);
		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   26dac:	00800044 	movi	r2,1
   26db0:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26db4:	01138804 	movi	r4,20000
   26db8:	00276fc0 	call	276fc <usleep>
		delay_ms(20);

		spi_check = spi_transmit_receive(	base,
   26dbc:	04400104 	movi	r17,4
   26dc0:	d9c00404 	addi	r7,sp,16
   26dc4:	d9800304 	addi	r6,sp,12
   26dc8:	000b883a 	mov	r5,zero
   26dcc:	8009883a 	mov	r4,r16
   26dd0:	d8000115 	stw	zero,4(sp)
   26dd4:	dc400015 	stw	r17,0(sp)
   26dd8:	0026cb40 	call	26cb4 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26ddc:	0100fa04 	movi	r4,1000
   26de0:	00276fc0 	call	276fc <usleep>
											4,
											0							// Special control flags for the SPI command
											);

				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26de4:	d9c00604 	addi	r7,sp,24
   26de8:	d9800504 	addi	r6,sp,20
   26dec:	000b883a 	mov	r5,zero
   26df0:	8009883a 	mov	r4,r16
   26df4:	d8000115 	stw	zero,4(sp)
   26df8:	dc400015 	stw	r17,0(sp)
   26dfc:	0026cb40 	call	26cb4 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26e00:	0100fa04 	movi	r4,1000
   26e04:	00276fc0 	call	276fc <usleep>
											opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26e08:	dc800804 	addi	r18,sp,32
   26e0c:	900f883a 	mov	r7,r18
   26e10:	d9800704 	addi	r6,sp,28
   26e14:	000b883a 	mov	r5,zero
   26e18:	8009883a 	mov	r4,r16
   26e1c:	d8000115 	stw	zero,4(sp)
   26e20:	dc400015 	stw	r17,0(sp)
   26e24:	0026cb40 	call	26cb4 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26e28:	0100fa04 	movi	r4,1000
   26e2c:	00276fc0 	call	276fc <usleep>
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = alt_avalon_spi_command(base,
   26e30:	000f883a 	mov	r7,zero
   26e34:	000d883a 	mov	r6,zero
   26e38:	000b883a 	mov	r5,zero
   26e3c:	8009883a 	mov	r4,r16
   26e40:	d8000215 	stw	zero,8(sp)
   26e44:	dc800115 	stw	r18,4(sp)
   26e48:	dc400015 	stw	r17,0(sp)
   26e4c:	00277b00 	call	277b0 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26e50:	0100fa04 	movi	r4,1000
   26e54:	00276fc0 	call	276fc <usleep>
											4,							// The number of bytes to read from the SPI slave, '0' if only writing
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
}
   26e58:	dfc00c17 	ldw	ra,48(sp)
   26e5c:	dc800b17 	ldw	r18,44(sp)
   26e60:	dc400a17 	ldw	r17,40(sp)
   26e64:	dc000917 	ldw	r16,36(sp)
   26e68:	dec00d04 	addi	sp,sp,52
   26e6c:	f800283a 	ret

00026e70 <__divsi3>:
   26e70:	20001a16 	blt	r4,zero,26edc <__divsi3+0x6c>
   26e74:	000f883a 	mov	r7,zero
   26e78:	2800020e 	bge	r5,zero,26e84 <__divsi3+0x14>
   26e7c:	014bc83a 	sub	r5,zero,r5
   26e80:	39c0005c 	xori	r7,r7,1
   26e84:	200d883a 	mov	r6,r4
   26e88:	00c00044 	movi	r3,1
   26e8c:	2900092e 	bgeu	r5,r4,26eb4 <__divsi3+0x44>
   26e90:	00800804 	movi	r2,32
   26e94:	00c00044 	movi	r3,1
   26e98:	00000106 	br	26ea0 <__divsi3+0x30>
   26e9c:	10001226 	beq	r2,zero,26ee8 <__divsi3+0x78>
   26ea0:	294b883a 	add	r5,r5,r5
   26ea4:	10bfffc4 	addi	r2,r2,-1
   26ea8:	18c7883a 	add	r3,r3,r3
   26eac:	293ffb36 	bltu	r5,r4,26e9c <__divsi3+0x2c>
   26eb0:	18000d26 	beq	r3,zero,26ee8 <__divsi3+0x78>
   26eb4:	0005883a 	mov	r2,zero
   26eb8:	31400236 	bltu	r6,r5,26ec4 <__divsi3+0x54>
   26ebc:	314dc83a 	sub	r6,r6,r5
   26ec0:	10c4b03a 	or	r2,r2,r3
   26ec4:	1806d07a 	srli	r3,r3,1
   26ec8:	280ad07a 	srli	r5,r5,1
   26ecc:	183ffa1e 	bne	r3,zero,26eb8 <__divsi3+0x48>
   26ed0:	38000126 	beq	r7,zero,26ed8 <__divsi3+0x68>
   26ed4:	0085c83a 	sub	r2,zero,r2
   26ed8:	f800283a 	ret
   26edc:	0109c83a 	sub	r4,zero,r4
   26ee0:	01c00044 	movi	r7,1
   26ee4:	003fe406 	br	26e78 <__divsi3+0x8>
   26ee8:	0005883a 	mov	r2,zero
   26eec:	003ff806 	br	26ed0 <__divsi3+0x60>

00026ef0 <__modsi3>:
   26ef0:	20001716 	blt	r4,zero,26f50 <__modsi3+0x60>
   26ef4:	000f883a 	mov	r7,zero
   26ef8:	2005883a 	mov	r2,r4
   26efc:	2800010e 	bge	r5,zero,26f04 <__modsi3+0x14>
   26f00:	014bc83a 	sub	r5,zero,r5
   26f04:	00c00044 	movi	r3,1
   26f08:	2900092e 	bgeu	r5,r4,26f30 <__modsi3+0x40>
   26f0c:	01800804 	movi	r6,32
   26f10:	00c00044 	movi	r3,1
   26f14:	00000106 	br	26f1c <__modsi3+0x2c>
   26f18:	30001026 	beq	r6,zero,26f5c <__modsi3+0x6c>
   26f1c:	294b883a 	add	r5,r5,r5
   26f20:	31bfffc4 	addi	r6,r6,-1
   26f24:	18c7883a 	add	r3,r3,r3
   26f28:	293ffb36 	bltu	r5,r4,26f18 <__modsi3+0x28>
   26f2c:	18000b26 	beq	r3,zero,26f5c <__modsi3+0x6c>
   26f30:	1806d07a 	srli	r3,r3,1
   26f34:	11400136 	bltu	r2,r5,26f3c <__modsi3+0x4c>
   26f38:	1145c83a 	sub	r2,r2,r5
   26f3c:	280ad07a 	srli	r5,r5,1
   26f40:	183ffb1e 	bne	r3,zero,26f30 <__modsi3+0x40>
   26f44:	38000126 	beq	r7,zero,26f4c <__modsi3+0x5c>
   26f48:	0085c83a 	sub	r2,zero,r2
   26f4c:	f800283a 	ret
   26f50:	0109c83a 	sub	r4,zero,r4
   26f54:	01c00044 	movi	r7,1
   26f58:	003fe706 	br	26ef8 <__modsi3+0x8>
   26f5c:	2005883a 	mov	r2,r4
   26f60:	003ff806 	br	26f44 <__modsi3+0x54>

00026f64 <__udivsi3>:
   26f64:	200d883a 	mov	r6,r4
   26f68:	2900152e 	bgeu	r5,r4,26fc0 <__udivsi3+0x5c>
   26f6c:	28001416 	blt	r5,zero,26fc0 <__udivsi3+0x5c>
   26f70:	00800804 	movi	r2,32
   26f74:	00c00044 	movi	r3,1
   26f78:	00000206 	br	26f84 <__udivsi3+0x20>
   26f7c:	10000e26 	beq	r2,zero,26fb8 <__udivsi3+0x54>
   26f80:	28000416 	blt	r5,zero,26f94 <__udivsi3+0x30>
   26f84:	294b883a 	add	r5,r5,r5
   26f88:	10bfffc4 	addi	r2,r2,-1
   26f8c:	18c7883a 	add	r3,r3,r3
   26f90:	293ffa36 	bltu	r5,r4,26f7c <__udivsi3+0x18>
   26f94:	18000826 	beq	r3,zero,26fb8 <__udivsi3+0x54>
   26f98:	0005883a 	mov	r2,zero
   26f9c:	31400236 	bltu	r6,r5,26fa8 <__udivsi3+0x44>
   26fa0:	314dc83a 	sub	r6,r6,r5
   26fa4:	10c4b03a 	or	r2,r2,r3
   26fa8:	1806d07a 	srli	r3,r3,1
   26fac:	280ad07a 	srli	r5,r5,1
   26fb0:	183ffa1e 	bne	r3,zero,26f9c <__udivsi3+0x38>
   26fb4:	f800283a 	ret
   26fb8:	0005883a 	mov	r2,zero
   26fbc:	f800283a 	ret
   26fc0:	00c00044 	movi	r3,1
   26fc4:	003ff406 	br	26f98 <__udivsi3+0x34>

00026fc8 <__umodsi3>:
   26fc8:	2005883a 	mov	r2,r4
   26fcc:	2900132e 	bgeu	r5,r4,2701c <__umodsi3+0x54>
   26fd0:	28001216 	blt	r5,zero,2701c <__umodsi3+0x54>
   26fd4:	01800804 	movi	r6,32
   26fd8:	00c00044 	movi	r3,1
   26fdc:	00000206 	br	26fe8 <__umodsi3+0x20>
   26fe0:	30000c26 	beq	r6,zero,27014 <__umodsi3+0x4c>
   26fe4:	28000416 	blt	r5,zero,26ff8 <__umodsi3+0x30>
   26fe8:	294b883a 	add	r5,r5,r5
   26fec:	31bfffc4 	addi	r6,r6,-1
   26ff0:	18c7883a 	add	r3,r3,r3
   26ff4:	293ffa36 	bltu	r5,r4,26fe0 <__umodsi3+0x18>
   26ff8:	18000626 	beq	r3,zero,27014 <__umodsi3+0x4c>
   26ffc:	1806d07a 	srli	r3,r3,1
   27000:	11400136 	bltu	r2,r5,27008 <__umodsi3+0x40>
   27004:	1145c83a 	sub	r2,r2,r5
   27008:	280ad07a 	srli	r5,r5,1
   2700c:	183ffb1e 	bne	r3,zero,26ffc <__umodsi3+0x34>
   27010:	f800283a 	ret
   27014:	2005883a 	mov	r2,r4
   27018:	f800283a 	ret
   2701c:	00c00044 	movi	r3,1
   27020:	003ff606 	br	26ffc <__umodsi3+0x34>

00027024 <__mulsi3>:
   27024:	0005883a 	mov	r2,zero
   27028:	20000726 	beq	r4,zero,27048 <__mulsi3+0x24>
   2702c:	20c0004c 	andi	r3,r4,1
   27030:	2008d07a 	srli	r4,r4,1
   27034:	18000126 	beq	r3,zero,2703c <__mulsi3+0x18>
   27038:	1145883a 	add	r2,r2,r5
   2703c:	294b883a 	add	r5,r5,r5
   27040:	203ffa1e 	bne	r4,zero,2702c <__mulsi3+0x8>
   27044:	f800283a 	ret
   27048:	f800283a 	ret

0002704c <malloc>:
   2704c:	008000f4 	movhi	r2,3
   27050:	200b883a 	mov	r5,r4
   27054:	11210917 	ldw	r4,-31708(r2)
   27058:	00270f81 	jmpi	270f8 <_malloc_r>

0002705c <free>:
   2705c:	008000f4 	movhi	r2,3
   27060:	200b883a 	mov	r5,r4
   27064:	11210917 	ldw	r4,-31708(r2)
   27068:	00274001 	jmpi	27400 <_free_r>

0002706c <sbrk_aligned>:
   2706c:	008000f4 	movhi	r2,3
   27070:	10a26e17 	ldw	r2,-30280(r2)
   27074:	defffd04 	addi	sp,sp,-12
   27078:	dc400115 	stw	r17,4(sp)
   2707c:	dc000015 	stw	r16,0(sp)
   27080:	dfc00215 	stw	ra,8(sp)
   27084:	2023883a 	mov	r17,r4
   27088:	2821883a 	mov	r16,r5
   2708c:	1000041e 	bne	r2,zero,270a0 <sbrk_aligned+0x34>
   27090:	000b883a 	mov	r5,zero
   27094:	00273b80 	call	273b8 <_sbrk_r>
   27098:	00c000f4 	movhi	r3,3
   2709c:	18a26e15 	stw	r2,-30280(r3)
   270a0:	800b883a 	mov	r5,r16
   270a4:	8809883a 	mov	r4,r17
   270a8:	00273b80 	call	273b8 <_sbrk_r>
   270ac:	10ffffd8 	cmpnei	r3,r2,-1
   270b0:	1800071e 	bne	r3,zero,270d0 <sbrk_aligned+0x64>
   270b4:	043fffc4 	movi	r16,-1
   270b8:	8005883a 	mov	r2,r16
   270bc:	dfc00217 	ldw	ra,8(sp)
   270c0:	dc400117 	ldw	r17,4(sp)
   270c4:	dc000017 	ldw	r16,0(sp)
   270c8:	dec00304 	addi	sp,sp,12
   270cc:	f800283a 	ret
   270d0:	140000c4 	addi	r16,r2,3
   270d4:	00ffff04 	movi	r3,-4
   270d8:	80e0703a 	and	r16,r16,r3
   270dc:	143ff626 	beq	r2,r16,270b8 <sbrk_aligned+0x4c>
   270e0:	808bc83a 	sub	r5,r16,r2
   270e4:	8809883a 	mov	r4,r17
   270e8:	00273b80 	call	273b8 <_sbrk_r>
   270ec:	10bfffe0 	cmpeqi	r2,r2,-1
   270f0:	103ff126 	beq	r2,zero,270b8 <sbrk_aligned+0x4c>
   270f4:	003fef06 	br	270b4 <sbrk_aligned+0x48>

000270f8 <_malloc_r>:
   270f8:	defffb04 	addi	sp,sp,-20
   270fc:	00bfff04 	movi	r2,-4
   27100:	dc400115 	stw	r17,4(sp)
   27104:	2c4000c4 	addi	r17,r5,3
   27108:	88a2703a 	and	r17,r17,r2
   2710c:	8c400204 	addi	r17,r17,8
   27110:	dc800215 	stw	r18,8(sp)
   27114:	dfc00415 	stw	ra,16(sp)
   27118:	dcc00315 	stw	r19,12(sp)
   2711c:	dc000015 	stw	r16,0(sp)
   27120:	88800328 	cmpgeui	r2,r17,12
   27124:	2025883a 	mov	r18,r4
   27128:	10002a1e 	bne	r2,zero,271d4 <_malloc_r+0xdc>
   2712c:	04400304 	movi	r17,12
   27130:	89402936 	bltu	r17,r5,271d8 <_malloc_r+0xe0>
   27134:	9009883a 	mov	r4,r18
   27138:	00276a80 	call	276a8 <__malloc_lock>
   2713c:	008000f4 	movhi	r2,3
   27140:	10a26f17 	ldw	r2,-30276(r2)
   27144:	1021883a 	mov	r16,r2
   27148:	80002d1e 	bne	r16,zero,27200 <_malloc_r+0x108>
   2714c:	880b883a 	mov	r5,r17
   27150:	9009883a 	mov	r4,r18
   27154:	002706c0 	call	2706c <sbrk_aligned>
   27158:	1021883a 	mov	r16,r2
   2715c:	10bfffd8 	cmpnei	r2,r2,-1
   27160:	1000561e 	bne	r2,zero,272bc <_malloc_r+0x1c4>
   27164:	008000f4 	movhi	r2,3
   27168:	14226f17 	ldw	r16,-30276(r2)
   2716c:	8005883a 	mov	r2,r16
   27170:	1000481e 	bne	r2,zero,27294 <_malloc_r+0x19c>
   27174:	80004c26 	beq	r16,zero,272a8 <_malloc_r+0x1b0>
   27178:	84c00017 	ldw	r19,0(r16)
   2717c:	000b883a 	mov	r5,zero
   27180:	9009883a 	mov	r4,r18
   27184:	84e7883a 	add	r19,r16,r19
   27188:	00273b80 	call	273b8 <_sbrk_r>
   2718c:	9880461e 	bne	r19,r2,272a8 <_malloc_r+0x1b0>
   27190:	80800017 	ldw	r2,0(r16)
   27194:	9009883a 	mov	r4,r18
   27198:	88a3c83a 	sub	r17,r17,r2
   2719c:	880b883a 	mov	r5,r17
   271a0:	002706c0 	call	2706c <sbrk_aligned>
   271a4:	10bfffe0 	cmpeqi	r2,r2,-1
   271a8:	10003f1e 	bne	r2,zero,272a8 <_malloc_r+0x1b0>
   271ac:	80800017 	ldw	r2,0(r16)
   271b0:	1445883a 	add	r2,r2,r17
   271b4:	80800015 	stw	r2,0(r16)
   271b8:	008000f4 	movhi	r2,3
   271bc:	10a26f17 	ldw	r2,-30276(r2)
   271c0:	10000226 	beq	r2,zero,271cc <_malloc_r+0xd4>
   271c4:	10c00117 	ldw	r3,4(r2)
   271c8:	1c00351e 	bne	r3,r16,272a0 <_malloc_r+0x1a8>
   271cc:	10000115 	stw	zero,4(r2)
   271d0:	00001806 	br	27234 <_malloc_r+0x13c>
   271d4:	883fd60e 	bge	r17,zero,27130 <_malloc_r+0x38>
   271d8:	00800304 	movi	r2,12
   271dc:	90800015 	stw	r2,0(r18)
   271e0:	0005883a 	mov	r2,zero
   271e4:	dfc00417 	ldw	ra,16(sp)
   271e8:	dcc00317 	ldw	r19,12(sp)
   271ec:	dc800217 	ldw	r18,8(sp)
   271f0:	dc400117 	ldw	r17,4(sp)
   271f4:	dc000017 	ldw	r16,0(sp)
   271f8:	dec00504 	addi	sp,sp,20
   271fc:	f800283a 	ret
   27200:	81000017 	ldw	r4,0(r16)
   27204:	2449c83a 	sub	r4,r4,r17
   27208:	20001f16 	blt	r4,zero,27288 <_malloc_r+0x190>
   2720c:	20c00330 	cmpltui	r3,r4,12
   27210:	1800161e 	bne	r3,zero,2726c <_malloc_r+0x174>
   27214:	84400015 	stw	r17,0(r16)
   27218:	8447883a 	add	r3,r16,r17
   2721c:	1400111e 	bne	r2,r16,27264 <_malloc_r+0x16c>
   27220:	008000f4 	movhi	r2,3
   27224:	10e26f15 	stw	r3,-30276(r2)
   27228:	80800117 	ldw	r2,4(r16)
   2722c:	19000015 	stw	r4,0(r3)
   27230:	18800115 	stw	r2,4(r3)
   27234:	9009883a 	mov	r4,r18
   27238:	00276ac0 	call	276ac <__malloc_unlock>
   2723c:	013ffe04 	movi	r4,-8
   27240:	808002c4 	addi	r2,r16,11
   27244:	80c00104 	addi	r3,r16,4
   27248:	1104703a 	and	r2,r2,r4
   2724c:	10c9c83a 	sub	r4,r2,r3
   27250:	10ffe426 	beq	r2,r3,271e4 <_malloc_r+0xec>
   27254:	8121883a 	add	r16,r16,r4
   27258:	1887c83a 	sub	r3,r3,r2
   2725c:	80c00015 	stw	r3,0(r16)
   27260:	003fe006 	br	271e4 <_malloc_r+0xec>
   27264:	10c00115 	stw	r3,4(r2)
   27268:	003fef06 	br	27228 <_malloc_r+0x130>
   2726c:	80c00117 	ldw	r3,4(r16)
   27270:	1400031e 	bne	r2,r16,27280 <_malloc_r+0x188>
   27274:	008000f4 	movhi	r2,3
   27278:	10e26f15 	stw	r3,-30276(r2)
   2727c:	003fed06 	br	27234 <_malloc_r+0x13c>
   27280:	10c00115 	stw	r3,4(r2)
   27284:	003feb06 	br	27234 <_malloc_r+0x13c>
   27288:	8005883a 	mov	r2,r16
   2728c:	84000117 	ldw	r16,4(r16)
   27290:	003fad06 	br	27148 <_malloc_r+0x50>
   27294:	1021883a 	mov	r16,r2
   27298:	10800117 	ldw	r2,4(r2)
   2729c:	003fb406 	br	27170 <_malloc_r+0x78>
   272a0:	1805883a 	mov	r2,r3
   272a4:	003fc606 	br	271c0 <_malloc_r+0xc8>
   272a8:	00800304 	movi	r2,12
   272ac:	90800015 	stw	r2,0(r18)
   272b0:	9009883a 	mov	r4,r18
   272b4:	00276ac0 	call	276ac <__malloc_unlock>
   272b8:	003fc906 	br	271e0 <_malloc_r+0xe8>
   272bc:	84400015 	stw	r17,0(r16)
   272c0:	003fdc06 	br	27234 <_malloc_r+0x13c>

000272c4 <_puts_r>:
   272c4:	defffd04 	addi	sp,sp,-12
   272c8:	dc000015 	stw	r16,0(sp)
   272cc:	2021883a 	mov	r16,r4
   272d0:	2809883a 	mov	r4,r5
   272d4:	dfc00215 	stw	ra,8(sp)
   272d8:	dc400115 	stw	r17,4(sp)
   272dc:	2823883a 	mov	r17,r5
   272e0:	002739c0 	call	2739c <strlen>
   272e4:	81400217 	ldw	r5,8(r16)
   272e8:	00c000b4 	movhi	r3,2
   272ec:	18dd4004 	addi	r3,r3,29952
   272f0:	28c00115 	stw	r3,4(r5)
   272f4:	100f883a 	mov	r7,r2
   272f8:	880d883a 	mov	r6,r17
   272fc:	8009883a 	mov	r4,r16
   27300:	00275000 	call	27500 <__sfvwrite_small_dev>
   27304:	10ffffe0 	cmpeqi	r3,r2,-1
   27308:	1800091e 	bne	r3,zero,27330 <_puts_r+0x6c>
   2730c:	81400217 	ldw	r5,8(r16)
   27310:	018000b4 	movhi	r6,2
   27314:	01c00044 	movi	r7,1
   27318:	28800117 	ldw	r2,4(r5)
   2731c:	319ff404 	addi	r6,r6,32720
   27320:	8009883a 	mov	r4,r16
   27324:	103ee83a 	callr	r2
   27328:	10bfffe0 	cmpeqi	r2,r2,-1
   2732c:	0085c83a 	sub	r2,zero,r2
   27330:	dfc00217 	ldw	ra,8(sp)
   27334:	dc400117 	ldw	r17,4(sp)
   27338:	dc000017 	ldw	r16,0(sp)
   2733c:	dec00304 	addi	sp,sp,12
   27340:	f800283a 	ret

00027344 <puts>:
   27344:	008000f4 	movhi	r2,3
   27348:	200b883a 	mov	r5,r4
   2734c:	11210917 	ldw	r4,-31708(r2)
   27350:	00272c41 	jmpi	272c4 <_puts_r>

00027354 <memcpy>:
   27354:	2005883a 	mov	r2,r4
   27358:	0007883a 	mov	r3,zero
   2735c:	30c0011e 	bne	r6,r3,27364 <memcpy+0x10>
   27360:	f800283a 	ret
   27364:	28cf883a 	add	r7,r5,r3
   27368:	39c00003 	ldbu	r7,0(r7)
   2736c:	10c9883a 	add	r4,r2,r3
   27370:	18c00044 	addi	r3,r3,1
   27374:	21c00005 	stb	r7,0(r4)
   27378:	003ff806 	br	2735c <memcpy+0x8>

0002737c <memset>:
   2737c:	2005883a 	mov	r2,r4
   27380:	218d883a 	add	r6,r4,r6
   27384:	2007883a 	mov	r3,r4
   27388:	1980011e 	bne	r3,r6,27390 <memset+0x14>
   2738c:	f800283a 	ret
   27390:	18c00044 	addi	r3,r3,1
   27394:	197fffc5 	stb	r5,-1(r3)
   27398:	003ffb06 	br	27388 <memset+0xc>

0002739c <strlen>:
   2739c:	2005883a 	mov	r2,r4
   273a0:	10c00007 	ldb	r3,0(r2)
   273a4:	1800021e 	bne	r3,zero,273b0 <strlen+0x14>
   273a8:	1105c83a 	sub	r2,r2,r4
   273ac:	f800283a 	ret
   273b0:	10800044 	addi	r2,r2,1
   273b4:	003ffa06 	br	273a0 <strlen+0x4>

000273b8 <_sbrk_r>:
   273b8:	defffe04 	addi	sp,sp,-8
   273bc:	dc000015 	stw	r16,0(sp)
   273c0:	008000f4 	movhi	r2,3
   273c4:	2021883a 	mov	r16,r4
   273c8:	2809883a 	mov	r4,r5
   273cc:	dfc00115 	stw	ra,4(sp)
   273d0:	10227015 	stw	zero,-30272(r2)
   273d4:	00276b00 	call	276b0 <sbrk>
   273d8:	10ffffd8 	cmpnei	r3,r2,-1
   273dc:	1800041e 	bne	r3,zero,273f0 <_sbrk_r+0x38>
   273e0:	00c000f4 	movhi	r3,3
   273e4:	18e27017 	ldw	r3,-30272(r3)
   273e8:	18000126 	beq	r3,zero,273f0 <_sbrk_r+0x38>
   273ec:	80c00015 	stw	r3,0(r16)
   273f0:	dfc00117 	ldw	ra,4(sp)
   273f4:	dc000017 	ldw	r16,0(sp)
   273f8:	dec00204 	addi	sp,sp,8
   273fc:	f800283a 	ret

00027400 <_free_r>:
   27400:	28003e26 	beq	r5,zero,274fc <_free_r+0xfc>
   27404:	28bfff17 	ldw	r2,-4(r5)
   27408:	defffd04 	addi	sp,sp,-12
   2740c:	dc000115 	stw	r16,4(sp)
   27410:	dfc00215 	stw	ra,8(sp)
   27414:	2c3fff04 	addi	r16,r5,-4
   27418:	1000010e 	bge	r2,zero,27420 <_free_r+0x20>
   2741c:	80a1883a 	add	r16,r16,r2
   27420:	d9000015 	stw	r4,0(sp)
   27424:	00276a80 	call	276a8 <__malloc_lock>
   27428:	008000f4 	movhi	r2,3
   2742c:	10a26f17 	ldw	r2,-30276(r2)
   27430:	d9000017 	ldw	r4,0(sp)
   27434:	1000071e 	bne	r2,zero,27454 <_free_r+0x54>
   27438:	80000115 	stw	zero,4(r16)
   2743c:	008000f4 	movhi	r2,3
   27440:	14226f15 	stw	r16,-30276(r2)
   27444:	dfc00217 	ldw	ra,8(sp)
   27448:	dc000117 	ldw	r16,4(sp)
   2744c:	dec00304 	addi	sp,sp,12
   27450:	00276ac1 	jmpi	276ac <__malloc_unlock>
   27454:	8080092e 	bgeu	r16,r2,2747c <_free_r+0x7c>
   27458:	81400017 	ldw	r5,0(r16)
   2745c:	8147883a 	add	r3,r16,r5
   27460:	10c0041e 	bne	r2,r3,27474 <_free_r+0x74>
   27464:	10c00017 	ldw	r3,0(r2)
   27468:	10800117 	ldw	r2,4(r2)
   2746c:	1947883a 	add	r3,r3,r5
   27470:	80c00015 	stw	r3,0(r16)
   27474:	80800115 	stw	r2,4(r16)
   27478:	003ff006 	br	2743c <_free_r+0x3c>
   2747c:	1007883a 	mov	r3,r2
   27480:	10800117 	ldw	r2,4(r2)
   27484:	10000126 	beq	r2,zero,2748c <_free_r+0x8c>
   27488:	80bffc2e 	bgeu	r16,r2,2747c <_free_r+0x7c>
   2748c:	19400017 	ldw	r5,0(r3)
   27490:	194d883a 	add	r6,r3,r5
   27494:	34000b1e 	bne	r6,r16,274c4 <_free_r+0xc4>
   27498:	81800017 	ldw	r6,0(r16)
   2749c:	298b883a 	add	r5,r5,r6
   274a0:	19400015 	stw	r5,0(r3)
   274a4:	194d883a 	add	r6,r3,r5
   274a8:	11bfe61e 	bne	r2,r6,27444 <_free_r+0x44>
   274ac:	11800017 	ldw	r6,0(r2)
   274b0:	10800117 	ldw	r2,4(r2)
   274b4:	314b883a 	add	r5,r6,r5
   274b8:	19400015 	stw	r5,0(r3)
   274bc:	18800115 	stw	r2,4(r3)
   274c0:	003fe006 	br	27444 <_free_r+0x44>
   274c4:	8180032e 	bgeu	r16,r6,274d4 <_free_r+0xd4>
   274c8:	00800304 	movi	r2,12
   274cc:	20800015 	stw	r2,0(r4)
   274d0:	003fdc06 	br	27444 <_free_r+0x44>
   274d4:	81800017 	ldw	r6,0(r16)
   274d8:	818b883a 	add	r5,r16,r6
   274dc:	1140041e 	bne	r2,r5,274f0 <_free_r+0xf0>
   274e0:	11400017 	ldw	r5,0(r2)
   274e4:	10800117 	ldw	r2,4(r2)
   274e8:	298b883a 	add	r5,r5,r6
   274ec:	81400015 	stw	r5,0(r16)
   274f0:	80800115 	stw	r2,4(r16)
   274f4:	1c000115 	stw	r16,4(r3)
   274f8:	003fd206 	br	27444 <_free_r+0x44>
   274fc:	f800283a 	ret

00027500 <__sfvwrite_small_dev>:
   27500:	2880000b 	ldhu	r2,0(r5)
   27504:	1080020c 	andi	r2,r2,8
   27508:	10002526 	beq	r2,zero,275a0 <__sfvwrite_small_dev+0xa0>
   2750c:	2880008f 	ldh	r2,2(r5)
   27510:	defffb04 	addi	sp,sp,-20
   27514:	dcc00315 	stw	r19,12(sp)
   27518:	dc800215 	stw	r18,8(sp)
   2751c:	dc400115 	stw	r17,4(sp)
   27520:	dc000015 	stw	r16,0(sp)
   27524:	dfc00415 	stw	ra,16(sp)
   27528:	2027883a 	mov	r19,r4
   2752c:	2821883a 	mov	r16,r5
   27530:	3025883a 	mov	r18,r6
   27534:	3823883a 	mov	r17,r7
   27538:	1000100e 	bge	r2,zero,2757c <__sfvwrite_small_dev+0x7c>
   2753c:	8080000b 	ldhu	r2,0(r16)
   27540:	10801014 	ori	r2,r2,64
   27544:	8080000d 	sth	r2,0(r16)
   27548:	00bfffc4 	movi	r2,-1
   2754c:	00000d06 	br	27584 <__sfvwrite_small_dev+0x84>
   27550:	88810050 	cmplti	r2,r17,1025
   27554:	880f883a 	mov	r7,r17
   27558:	1000011e 	bne	r2,zero,27560 <__sfvwrite_small_dev+0x60>
   2755c:	01c10004 	movi	r7,1024
   27560:	8140008f 	ldh	r5,2(r16)
   27564:	900d883a 	mov	r6,r18
   27568:	9809883a 	mov	r4,r19
   2756c:	00275a80 	call	275a8 <_write_r>
   27570:	00bff20e 	bge	zero,r2,2753c <__sfvwrite_small_dev+0x3c>
   27574:	88a3c83a 	sub	r17,r17,r2
   27578:	90a5883a 	add	r18,r18,r2
   2757c:	047ff416 	blt	zero,r17,27550 <__sfvwrite_small_dev+0x50>
   27580:	0005883a 	mov	r2,zero
   27584:	dfc00417 	ldw	ra,16(sp)
   27588:	dcc00317 	ldw	r19,12(sp)
   2758c:	dc800217 	ldw	r18,8(sp)
   27590:	dc400117 	ldw	r17,4(sp)
   27594:	dc000017 	ldw	r16,0(sp)
   27598:	dec00504 	addi	sp,sp,20
   2759c:	f800283a 	ret
   275a0:	00bfffc4 	movi	r2,-1
   275a4:	f800283a 	ret

000275a8 <_write_r>:
   275a8:	defffe04 	addi	sp,sp,-8
   275ac:	dc000015 	stw	r16,0(sp)
   275b0:	008000f4 	movhi	r2,3
   275b4:	2021883a 	mov	r16,r4
   275b8:	2809883a 	mov	r4,r5
   275bc:	300b883a 	mov	r5,r6
   275c0:	380d883a 	mov	r6,r7
   275c4:	dfc00115 	stw	ra,4(sp)
   275c8:	10227015 	stw	zero,-30272(r2)
   275cc:	00277000 	call	27700 <write>
   275d0:	10ffffd8 	cmpnei	r3,r2,-1
   275d4:	1800041e 	bne	r3,zero,275e8 <_write_r+0x40>
   275d8:	00c000f4 	movhi	r3,3
   275dc:	18e27017 	ldw	r3,-30272(r3)
   275e0:	18000126 	beq	r3,zero,275e8 <_write_r+0x40>
   275e4:	80c00015 	stw	r3,0(r16)
   275e8:	dfc00117 	ldw	ra,4(sp)
   275ec:	dc000017 	ldw	r16,0(sp)
   275f0:	dec00204 	addi	sp,sp,8
   275f4:	f800283a 	ret

000275f8 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   275f8:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   275fc:	010000b4 	movhi	r4,2
   27600:	014000f4 	movhi	r5,3
   27604:	dfc00015 	stw	ra,0(sp)
   27608:	211ff504 	addi	r4,r4,32724
   2760c:	29610d04 	addi	r5,r5,-31692
   27610:	21400426 	beq	r4,r5,27624 <alt_load+0x2c>
  {
    while( to != end )
    {
      *to++ = *from++;
   27614:	018000f4 	movhi	r6,3
   27618:	31a10d04 	addi	r6,r6,-31692
   2761c:	310dc83a 	sub	r6,r6,r4
   27620:	00273540 	call	27354 <memcpy>
  if (to != from)
   27624:	010000b4 	movhi	r4,2
   27628:	014000b4 	movhi	r5,2
   2762c:	21000804 	addi	r4,r4,32
   27630:	29400804 	addi	r5,r5,32
   27634:	21400426 	beq	r4,r5,27648 <alt_load+0x50>
      *to++ = *from++;
   27638:	018000b4 	movhi	r6,2
   2763c:	31800804 	addi	r6,r6,32
   27640:	310dc83a 	sub	r6,r6,r4
   27644:	00273540 	call	27354 <memcpy>
  if (to != from)
   27648:	010000b4 	movhi	r4,2
   2764c:	014000b4 	movhi	r5,2
   27650:	211e4a04 	addi	r4,r4,31016
   27654:	295e4a04 	addi	r5,r5,31016
   27658:	21400426 	beq	r4,r5,2766c <alt_load+0x74>
      *to++ = *from++;
   2765c:	018000b4 	movhi	r6,2
   27660:	319ff504 	addi	r6,r6,32724
   27664:	310dc83a 	sub	r6,r6,r4
   27668:	00273540 	call	27354 <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   2766c:	00279180 	call	27918 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   27670:	dfc00017 	ldw	ra,0(sp)
   27674:	dec00104 	addi	sp,sp,4
  alt_icache_flush_all();
   27678:	002791c1 	jmpi	2791c <alt_icache_flush_all>

0002767c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   2767c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   27680:	0009883a 	mov	r4,zero
{
   27684:	dfc00015 	stw	ra,0(sp)
  alt_irq_init (NULL);
   27688:	002775c0 	call	2775c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   2768c:	002777c0 	call	2777c <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   27690:	d1a18017 	ldw	r6,-31232(gp)
   27694:	d1618117 	ldw	r5,-31228(gp)
   27698:	d1218217 	ldw	r4,-31224(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   2769c:	dfc00017 	ldw	ra,0(sp)
   276a0:	dec00104 	addi	sp,sp,4
  main (alt_argc, alt_argv, alt_envp);
   276a4:	002005c1 	jmpi	2005c <main>

000276a8 <__malloc_lock>:
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
}
   276a8:	f800283a 	ret

000276ac <__malloc_unlock>:

/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
   276ac:	f800283a 	ret

000276b0 <sbrk>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   276b0:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   276b4:	00bfff84 	movi	r2,-2
   276b8:	1884703a 	and	r2,r3,r2
   276bc:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   276c0:	d0a01917 	ldw	r2,-32668(gp)
   276c4:	017fff04 	movi	r5,-4
   276c8:	108000c4 	addi	r2,r2,3
   276cc:	1144703a 	and	r2,r2,r5
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   276d0:	014000f4 	movhi	r5,3
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   276d4:	d0a01915 	stw	r2,-32668(gp)
  if ((heap_end + incr) > __alt_heap_limit) {
   276d8:	1109883a 	add	r4,r2,r4
   276dc:	29500004 	addi	r5,r5,16384
   276e0:	2900032e 	bgeu	r5,r4,276f0 <sbrk+0x40>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   276e4:	1801703a 	wrctl	status,r3
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   276e8:	00bfffc4 	movi	r2,-1
   276ec:	f800283a 	ret
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
   276f0:	d1201915 	stw	r4,-32668(gp)
   276f4:	1801703a 	wrctl	status,r3
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
   276f8:	f800283a 	ret

000276fc <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   276fc:	00278881 	jmpi	27888 <alt_busy_sleep>

00027700 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   27700:	213fffc4 	addi	r4,r4,-1
   27704:	210000a8 	cmpgeui	r4,r4,2
   27708:	2000041e 	bne	r4,zero,2771c <write+0x1c>
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
   2770c:	010000f4 	movhi	r4,3
   27710:	000f883a 	mov	r7,zero
   27714:	21210b04 	addi	r4,r4,-31700
   27718:	00277801 	jmpi	27780 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   2771c:	d0a01b17 	ldw	r2,-32660(gp)
   27720:	10000926 	beq	r2,zero,27748 <write+0x48>
{
   27724:	deffff04 	addi	sp,sp,-4
   27728:	dfc00015 	stw	ra,0(sp)
   2772c:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   27730:	00c01444 	movi	r3,81
   27734:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   27738:	00bfffc4 	movi	r2,-1
   2773c:	dfc00017 	ldw	ra,0(sp)
   27740:	dec00104 	addi	sp,sp,4
   27744:	f800283a 	ret
   27748:	d0a17f04 	addi	r2,gp,-31236
        ALT_ERRNO = EBADFD;
   2774c:	00c01444 	movi	r3,81
   27750:	10c00015 	stw	r3,0(r2)
}
   27754:	00bfffc4 	movi	r2,-1
   27758:	f800283a 	ret

0002775c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   2775c:	deffff04 	addi	sp,sp,-4
   27760:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, NIOS);
   27764:	00279200 	call	27920 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   27768:	00800044 	movi	r2,1
   2776c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   27770:	dfc00017 	ldw	ra,0(sp)
   27774:	dec00104 	addi	sp,sp,4
   27778:	f800283a 	ret

0002777c <alt_sys_init>:
void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
    ALTERA_AVALON_SPI_INIT ( ESC_SPI, ESC_SPI);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, SYSID);
}
   2777c:	f800283a 	ret

00027780 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   27780:	20c00017 	ldw	r3,0(r4)
{
   27784:	3005883a 	mov	r2,r6

  const char * end = ptr + count;
   27788:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   2778c:	01bfffd4 	movui	r6,65535
  while (ptr < end)
   27790:	29000136 	bltu	r5,r4,27798 <altera_avalon_jtag_uart_write+0x18>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
   27794:	f800283a 	ret
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   27798:	19c00137 	ldwio	r7,4(r3)
   2779c:	31fffc2e 	bgeu	r6,r7,27790 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   277a0:	29c00007 	ldb	r7,0(r5)
   277a4:	29400044 	addi	r5,r5,1
   277a8:	19c00035 	stwio	r7,0(r3)
   277ac:	003ff806 	br	27790 <altera_avalon_jtag_uart_write+0x10>

000277b0 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   277b0:	d8800017 	ldw	r2,0(sp)
   277b4:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   277b8:	00c00044 	movi	r3,1
{
   277bc:	da400217 	ldw	r9,8(sp)
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   277c0:	1946983a 	sll	r3,r3,r5
  const alt_u8 * write_end = write_data + write_length;
   277c4:	399b883a 	add	r13,r7,r6
  alt_u8 * read_end = read_data + read_length;
   277c8:	4099883a 	add	r12,r8,r2
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   277cc:	20c00535 	stwio	r3,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   277d0:	48c0008c 	andi	r3,r9,2
   277d4:	1800021e 	bne	r3,zero,277e0 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   277d8:	00c10004 	movi	r3,1024
   277dc:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   277e0:	20c00037 	ldwio	r3,0(r4)
  alt_32 credits = 1;
   277e4:	00c00044 	movi	r3,1
  alt_u32 write_zeros = read_length;
   277e8:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   277ec:	22c00204 	addi	r11,r4,8
   277f0:	21400237 	ldwio	r5,8(r4)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   277f4:	2b80100c 	andi	r14,r5,64
   277f8:	2940200c 	andi	r5,r5,128
   277fc:	70000126 	beq	r14,zero,27804 <alt_avalon_spi_command+0x54>
   27800:	1800101e 	bne	r3,zero,27844 <alt_avalon_spi_command+0x94>
      }
      else
        credits = -1024;
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   27804:	283ff926 	beq	r5,zero,277ec <alt_avalon_spi_command+0x3c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   27808:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
        read_ignore--;
      else
        *read_data++ = (alt_u8)rxdata;
      credits++;
   2780c:	18c00044 	addi	r3,r3,1
      if (read_ignore > 0)
   27810:	30001a26 	beq	r6,zero,2787c <alt_avalon_spi_command+0xcc>
        read_ignore--;
   27814:	31bfffc4 	addi	r6,r6,-1

      if (read_ignore == 0 && read_data == read_end)
   27818:	303ff41e 	bne	r6,zero,277ec <alt_avalon_spi_command+0x3c>
   2781c:	6200071e 	bne	r12,r8,2783c <alt_avalon_spi_command+0x8c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27820:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   27824:	18c0080c 	andi	r3,r3,32
   27828:	183ffd26 	beq	r3,zero,27820 <alt_avalon_spi_command+0x70>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   2782c:	4a40004c 	andi	r9,r9,1
   27830:	4800011e 	bne	r9,zero,27838 <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   27834:	20000335 	stwio	zero,12(r4)

  return read_length;
}
   27838:	f800283a 	ret
   2783c:	000d883a 	mov	r6,zero
   27840:	003fea06 	br	277ec <alt_avalon_spi_command+0x3c>
    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   27844:	00ffef0e 	bge	zero,r3,27804 <alt_avalon_spi_command+0x54>
      credits--;
   27848:	18ffffc4 	addi	r3,r3,-1
      if (write_data < write_end)
   2784c:	3b40052e 	bgeu	r7,r13,27864 <alt_avalon_spi_command+0xb4>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   27850:	3b800044 	addi	r14,r7,1
   27854:	39c00003 	ldbu	r7,0(r7)
   27858:	21c00135 	stwio	r7,4(r4)
   2785c:	700f883a 	mov	r7,r14
   27860:	003fe806 	br	27804 <alt_avalon_spi_command+0x54>
      else if (write_zeros > 0)
   27864:	50000326 	beq	r10,zero,27874 <alt_avalon_spi_command+0xc4>
        write_zeros--;
   27868:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   2786c:	20000135 	stwio	zero,4(r4)
   27870:	003fe406 	br	27804 <alt_avalon_spi_command+0x54>
        credits = -1024;
   27874:	00ff0004 	movi	r3,-1024
   27878:	003fe206 	br	27804 <alt_avalon_spi_command+0x54>
        *read_data++ = (alt_u8)rxdata;
   2787c:	41400005 	stb	r5,0(r8)
   27880:	42000044 	addi	r8,r8,1
   27884:	003fe506 	br	2781c <alt_avalon_spi_command+0x6c>

00027888 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   27888:	defffe04 	addi	sp,sp,-8
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   2788c:	008666b4 	movhi	r2,6554
{
   27890:	dc000015 	stw	r16,0(sp)
   27894:	dfc00115 	stw	ra,4(sp)
  if (big_loops)
   27898:	10a66604 	addi	r2,r2,-26216
{
   2789c:	2021883a 	mov	r16,r4
  if (big_loops)
   278a0:	1100182e 	bgeu	r2,r4,27904 <alt_busy_sleep+0x7c>
  big_loops = us / (INT_MAX/
   278a4:	014666b4 	movhi	r5,6554
   278a8:	29666644 	addi	r5,r5,-26215
   278ac:	0026f640 	call	26f64 <__udivsi3>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   278b0:	00e00034 	movhi	r3,32768
  big_loops = us / (INT_MAX/
   278b4:	1009883a 	mov	r4,r2
      __asm__ volatile (
   278b8:	18ffffc4 	addi	r3,r3,-1
    for(i=0;i<big_loops;i++)
   278bc:	0005883a 	mov	r2,zero
      __asm__ volatile (
   278c0:	18ffffc4 	addi	r3,r3,-1
   278c4:	183ffe1e 	bne	r3,zero,278c0 <alt_busy_sleep+0x38>
    for(i=0;i<big_loops;i++)
   278c8:	10800044 	addi	r2,r2,1
   278cc:	113ffc16 	blt	r2,r4,278c0 <alt_busy_sleep+0x38>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   278d0:	017999b4 	movhi	r5,58982
   278d4:	295999c4 	addi	r5,r5,26215
   278d8:	00270240 	call	27024 <__mulsi3>
   278dc:	1405883a 	add	r2,r2,r16
   278e0:	100690ba 	slli	r3,r2,2
   278e4:	1885883a 	add	r2,r3,r2
    __asm__ volatile (
   278e8:	10bfffc4 	addi	r2,r2,-1
   278ec:	103ffe1e 	bne	r2,zero,278e8 <alt_busy_sleep+0x60>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   278f0:	0005883a 	mov	r2,zero
   278f4:	dfc00117 	ldw	ra,4(sp)
   278f8:	dc000017 	ldw	r16,0(sp)
   278fc:	dec00204 	addi	sp,sp,8
   27900:	f800283a 	ret
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   27904:	200490ba 	slli	r2,r4,2
   27908:	1105883a 	add	r2,r2,r4
    __asm__ volatile (
   2790c:	10bfffc4 	addi	r2,r2,-1
   27910:	00bffe16 	blt	zero,r2,2790c <alt_busy_sleep+0x84>
   27914:	003ff606 	br	278f0 <alt_busy_sleep+0x68>

00027918 <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   27918:	f800283a 	ret

0002791c <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   2791c:	f800283a 	ret

00027920 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   27920:	000170fa 	wrctl	ienable,zero
}
   27924:	f800283a 	ret
