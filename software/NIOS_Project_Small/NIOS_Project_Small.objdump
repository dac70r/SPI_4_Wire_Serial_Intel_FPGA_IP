
NIOS_Project_Small.elf:     file format elf32-littlenios2
NIOS_Project_Small.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00020020

Program Header:
    LOAD off    0x00001000 vaddr 0x00020000 paddr 0x00020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00020020 paddr 0x00020020 align 2**12
         filesz 0x00007fbc memsz 0x00007fbc flags r-x
    LOAD off    0x00008fdc vaddr 0x00027fdc paddr 0x0002843c align 2**12
         filesz 0x00000460 memsz 0x00000460 flags rw-
    LOAD off    0x0000089c vaddr 0x0002889c paddr 0x0002889c align 2**12
         filesz 0x00000000 memsz 0x0000048c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00020000  00020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00020020  00020020  0000943c  2**0
                  CONTENTS
  2 .text         00007910  00020020  00020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000006ac  00027930  00027930  00008930  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000460  00027fdc  0002843c  00008fdc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000048c  0002889c  0002889c  0000989c  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  00028d28  00028d28  0000943c  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  0000943c  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000568  00000000  00000000  00009470  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   0000e4b9  00000000  00000000  000099d8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 0000411f  00000000  00000000  00017e91  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   0000835b  00000000  00000000  0001bfb0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  0000156c  00000000  00000000  0002430c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    00002a7d  00000000  00000000  00025878  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000040  00000000  00000000  000282f8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000020  00000000  00000000  00028338  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 0000070f  00000000  00000000  00028358  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00000fb9  00000000  00000000  00028a67  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 00005b6f  00000000  00000000  00029a20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  0003308a  2**0
                  CONTENTS, READONLY
 20 .cpu          00000004  00000000  00000000  0003308d  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00033091  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00033092  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  00033093  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00033097  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0003309b  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000005  00000000  00000000  0003309f  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000005  00000000  00000000  000330a4  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000005  00000000  00000000  000330a9  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000015  00000000  00000000  000330ae  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000004c  00000000  00000000  000330c3  2**0
                  CONTENTS, READONLY
 31 .jdi          0000527d  00000000  00000000  0003310f  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     00049020  00000000  00000000  0003838c  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00020000 l    d  .entry	00000000 .entry
00020020 l    d  .exceptions	00000000 .exceptions
00020020 l    d  .text	00000000 .text
00027930 l    d  .rodata	00000000 .rodata
00027fdc l    d  .rwdata	00000000 .rwdata
0002889c l    d  .bss	00000000 .bss
00028d28 l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.o
00020058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
000283cc l     O .rwdata	00000001 invert_me.0
00000000 l    df *ABS*	00000000 ViCAT_LSC.c
0002889c l     O .bss	00000004 haha.0
00000000 l    df *ABS*	00000000 ax58100_hw.c
00020360 l     F .text	00000144 HW_SPI_Read
000204a4 l     F .text	00000118 HW_SPI_Write
00000000 l    df *ABS*	00000000 bootmode.c
00000000 l    df *ABS*	00000000 coeappl.c
00000000 l    df *ABS*	00000000 ecatappl.c
00000000 l    df *ABS*	00000000 ecatcoe.c
00000000 l    df *ABS*	00000000 ecatfoe.c
00000000 l    df *ABS*	00000000 ecatslv.c
00000000 l    df *ABS*	00000000 foeappl.c
00000000 l    df *ABS*	00000000 mailbox.c
00000000 l    df *ABS*	00000000 objdef.c
00000000 l    df *ABS*	00000000 sdoserv.c
00000000 l    df *ABS*	00000000 peripheral_linker.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00027074 l     F .text	0000008c sbrk_aligned
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 freer.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00028430 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
0002893c g     O .bss	00000001 b3BufferMode
00028934 g     O .bss	00000002 nEcatStateTrans
00028920 g     O .bss	00000002 u16IdValue
00027684 g     F .text	0000002c alt_main
000272cc g     F .text	00000080 _puts_r
00028422 g     O .rwdata	00000006 sEntryDesc0x1000
0002843c g       *ABS*	00000000 __flash_rwdata_start
00020660 g     F .text	0000000c HW_EscReadIsr
00028d28 g       *ABS*	00000000 __alt_heap_start
00027ff4 g     O .rwdata	000001e0 GenObjDic
00028416 g     O .rwdata	00000006 sEntryDesc0x1008
00020750 g     F .text	00000004 BL_Start
00027ca4 g     O .rodata	00000047 aName0x1018
00024b60 g     F .text	00000008 OBJ_GetObjDesc
00023c74 g     F .text	00000010 FOE_Error
00028937 g     O .bss	00000001 bApplEsmPending
00020748 g     F .text	00000004 HW_SYNC1_IRQHandler
000227c4 g     F .text	0000005c StartOutputHandler
000202c4 g     F .text	0000004c APPL_OutputMapping
000276b4 g     F .text	00000004 __malloc_unlock
000288f8 g     O .bss	00000004 pCoeSendStored
00026cbc g     F .text	000000b0 spi_transmit_receive
0002434c g     F .text	000000e0 MBX_MailboxWriteInd
000289a8 g     O .bss	00000002 nSdoInfoIndex
0002372c g     F .text	000001e4 ECAT_StateChange
000289b4 g     O .bss	00000004 pStoreData
000288dc g     O .bss	00000004 pAPPL_CoeReadInd
00028975 g     O .bss	00000001 u8MbxReadCounter
00021bf8 g     F .text	00000034 FOE_ContinueInd
000217e4 g     F .text	00000068 COE_ContinueInd
0002892b g     O .bss	00000001 nAlStatus
00028930 g     O .bss	00000002 nPdOutputSize
00020740 g     F .text	00000004 HW_ALEVENT_IRQHandler
0002890c g     O .bss	00000004 u32FileOffset
00027928 g     F .text	00000008 altera_nios2_gen2_irq_init
000289dc g     O .bss	0000000c spiRxBuf
00020000 g     F .entry	0000000c __reset
000288bc g     O .bss	00000001 bInitFinished
00020020 g       *ABS*	00000000 __flash_exceptions_start
0002893a g     O .bss	00000002 u16LocalErrorCode
00028994 g     O .bss	00000004 nSdoSegBytesToHandle
0002032c g     F .text	00000034 main_initial
00021c2c g     F .text	0000004c ResetALEventMask
000289cc g     O .bss	00000004 errno
000288a0 g     O .bss	00000002 bootSwitchID
00028938 g     O .bss	00000001 u8LocalErrorState
000281e8 g     O .rwdata	0000000a acDevicename
00027e44 g     O .rodata	0000000c asEntryDesc0x7000
00028c5c g     O .bss	00000034 sMbxSendQueue
0002892a g     O .bss	00000001 bExplicitDevIdRequested
0002836c g     O .rwdata	0000000c sErrorSettings
000289d4 g     O .bss	00000004 alt_argv
00020084 g     F .text	00000004 APPL_AckErrorInd
000303cc g       *ABS*	00000000 _gp
00027704 g     F .text	00000004 usleep
00020754 g     F .text	00000004 BL_Stop
000283fc g     O .rwdata	00000006 sEntryDesc0x100A
0002185c g     F .text	0000039c FOE_ServiceInd
0002282c g     F .text	000000a0 StopInputHandler
00028c28 g     O .bss	00000034 sMbxReceiveQueue
00028960 g     O .bss	00000001 bNoMbxMemoryAvailable
00024144 g     F .text	000000c0 MBX_MailboxReadInd
000281d4 g     O .rwdata	00000014 sIdentity
00028904 g     O .bss	00000002 u16FileAccessState
0002894a g     O .bss	00000002 Sync0WdCounter
0002735c g     F .text	00000028 memcpy
00028910 g     O .bss	00000004 u32PacketNo
00024d24 g     F .text	0000010c CheckSyncTypeValue
000283dc g     O .rwdata	00000004 sRxPDOassign
000288c4 g     O .bss	00000001 bMinCycleTimeMeasurementStarted
0002734c g     F .text	00000010 puts
00020730 g     F .text	0000000c HW_EscWriteIsr
00028982 g     O .bss	00000001 bSendMbxIsFull
000288d0 g     O .bss	00000004 u32CycleTimeStartValue
00027c3c g     O .rodata	00000013 aName0x10F8
00028940 g     O .bss	00000002 LatchInputSync0Counter
00027054 g     F .text	00000010 malloc
0002894c g     O .bss	00000002 i16WaitForPllRunningCnt
00026f6c g     F .text	00000064 .hidden __udivsi3
00028926 g     O .bss	00000002 nEscAddrOutputData
00028981 g     O .bss	00000001 bMbxRunning
00025ce0 g     F .text	000008f4 SDOS_SdoInd
000283d0 g     O .rwdata	00000004 OUT_GENERIC0x7000
000200b0 g     F .text	00000008 APPL_StopOutputHandler
00021de8 g     F .text	00000270 CheckSmSettings
00023b9c g     F .text	0000003c FOE_Read
00027a4c g     O .rodata	00000108 aName0x1C32
00028948 g     O .bss	00000002 Sync0WdValue
000273c0 g     F .text	00000048 _sbrk_r
00024924 g     F .text	0000003c OBJ_GetEntryDesc
00027fe8 g     O .rwdata	0000000c MLParameterSetting0x8000
00027d68 g     O .rodata	0000000c aName0x1000
00023c68 g     F .text	0000000c FOE_Busy
00020d04 g     F .text	00000068 GetSystemTimeDelay
000200a0 g     F .text	00000008 APPL_StopInputHandler
0002894e g     O .bss	00000002 i16WaitForPllRunningTimeout
0002899c g     O .bss	00000001 bSdoSegAccess
00028944 g     O .bss	00000002 Sync1WdValue
00022058 g     F .text	0000076c StartInputHandler
0002074c g     F .text	00000004 HW_TIMETASK_IRQHandler
00027ea0 g     O .rodata	0000001b aName0x1C12
000283d8 g     O .rwdata	00000004 sTxPDOassign
00023dc8 g     F .text	000000dc MBX_StartMailboxHandler
00028d28 g       *ABS*	00000000 __bss_end
00028914 g     O .bss	00000001 EepromLoaded
00027e50 g     O .rodata	00000019 aName0x6000
00027f34 g     O .rodata	0000000c asEntryDesc0x1600
0002899d g     O .bss	00000001 bSdoSegFollows
0002898c g     O .bss	00000004 nSdoSegCompleteSize
0002891f g     O .bss	00000001 u8dummy
00028922 g     O .bss	00000002 u16ALEventMask
00027f60 g     O .rodata	00000078 cAbortCode
000289b0 g     O .bss	00000004 pSdoPendFunc
00028956 g     O .bss	00000001 bDcRunning
00024e30 g     F .text	00000610 OBJ_Read
000288f4 g     O .bss	00000001 bRunApplication
00027e28 g     O .rodata	0000001b aName0x7000
0002897a g     O .bss	00000002 u16EscAddrReceiveMbx
00028964 g     O .bss	00000004 psStoreMbx
00024560 g     F .text	000000c4 MBX_Main
00028916 g     O .bss	00000008 SyncManInfo
000283f0 g     O .rwdata	00000006 sSyncmanagertype
0002893e g     O .bss	00000001 b32BitDc
00021d8c g     F .text	0000005c EnableSyncManChannel
00027920 g     F .text	00000004 alt_dcache_flush_all
00027f04 g     O .rodata	00000030 aName0x1600
0002843c g       *ABS*	00000000 __ram_rwdata_end
00020870 g     F .text	0000005c COE_UpdateSyncErrorStatus
000283e8 g     O .rwdata	00000008 OUT_GENERICProcessDataMapping0x1600
00027708 g     F .text	0000005c write
000288c8 g     O .bss	00000004 u32SystemTimeReadFailure
00023ea4 g     F .text	0000010c MBX_StopMailboxHandler
00027c50 g     O .rodata	0000003f aName0x10F1
000289c0 g     O .bss	00000001 u8PendingSdo
00027fdc g       *ABS*	00000000 __ram_rodata_end
00028434 g     O .rwdata	00000004 DEBUG
0002075c g     F .text	00000008 BL_Data
000281f4 g     O .rwdata	00000168 ApplicationObjDic
00020e1c g     F .text	0000006c HandleCycleTimeMeasurement
00028942 g     O .bss	00000002 LatchInputSync0Value
00026fd0 g     F .text	0000005c .hidden __umodsi3
000283e0 g     O .rwdata	00000008 IN_GENERICProcessDataMapping0x1A00
00027cec g     O .rodata	0000001e asEntryDesc0x1018
00028d28 g       *ABS*	00000000 end
00020098 g     F .text	00000008 APPL_StartInputHandler
00023bf0 g     F .text	0000005c FOE_Data
0002897e g     O .bss	00000002 u16SendMbxSize
00028936 g     O .bss	00000001 bEcatWaitForAlControlRes
000266e4 g     F .text	00000078 SDOS_ClearPendingResponse
0002896c g     O .bss	00000004 psReadMbx
00022820 g     F .text	0000000c StopOutputHandler
00027d2c g     O .rodata	0000001e aName0x1009
000288f7 g     O .bss	00000001 bEcatWaitForInputUpdate
00021234 g     F .text	000001c0 PDI_Isr
00028c90 g     O .bss	00000044 sSyncManInPar
00034000 g       *ABS*	00000000 __alt_stack_pointer
00028410 g     O .rwdata	00000006 acHardwareversion
0002675c g     F .text	000003d8 SDOS_SdoInfoInd
00027788 g     F .text	00000030 altera_avalon_jtag_uart_write
000288c0 g     O .bss	00000004 u32MinCycleTimeValue
00028932 g     O .bss	00000002 nPdInputSize
00027408 g     F .text	00000100 _free_r
00027d58 g     O .rodata	0000000f aName0x1001
000283d4 g     O .rwdata	00000004 IN_GENERIC0x6000
0002066c g     F .text	00000038 HW_EscWrite
00020090 g     F .text	00000008 APPL_StopMailboxHandler
0002835c g     O .rwdata	0000000d aSubindexDesc
00023d18 g     F .text	000000b0 MBX_Init
00020020 g     F .text	0000003c _start
00026d6c g     F .text	0000010c adc_init_spi_transmit_receive
0002899f g     O .bss	00000001 bSdoInWork
00020744 g     F .text	00000004 HW_SYNC0_IRQHandler
00028952 g     O .bss	00000002 u16SmSync0Value
000289bf g     O .bss	00000001 bStoreCompleteAccess
000277b8 g     F .text	000000d8 alt_avalon_spi_command
0002476c g     F .text	00000080 OBJ_CopyNumberToString
00020868 g     F .text	00000008 COE_GetObjectDictionary
00027784 g     F .text	00000004 alt_sys_init
00024960 g     F .text	000000b8 OBJ_GetNoOfObjects
00028c18 g     O .bss	00000010 aPdOutputData
00028990 g     O .bss	00000001 bSdoSegLastToggle
00023ff8 g     F .text	0000014c MBX_CopyToSendMailbox
00022978 g     F .text	00000914 AL_ControlInd
0002702c g     F .text	00000028 .hidden __mulsi3
00027fdc g       *ABS*	00000000 __ram_rwdata_start
00027930 g       *ABS*	00000000 __ram_rodata_start
0002899e g     O .bss	00000001 nSdoSegService
000283f6 g     O .rwdata	00000006 sEntryDesc0x10F8
00020c74 g     F .text	00000090 ECAT_CheckTimer
000239f4 g     F .text	000001a8 ECAT_Main
00028983 g     O .bss	00000001 bReceiveMbxIsLocked
000288e8 g     O .bss	00000004 pAPPL_FoeError
00028978 g     O .bss	00000002 u16EscAddrSendMbx
0002892c g     O .bss	00000002 nMaxEscAddress
0002895c g     O .bss	00000001 bEcatFirstOutputsReceived
00027890 g     F .text	00000090 alt_busy_sleep
00028970 g     O .bss	00000004 psWriteMbx
000288b4 g     O .bss	00000008 u64Timestamp
00027c2e g     O .rodata	0000000c asEntryDesc0x1C00
00020088 g     F .text	00000008 APPL_StartMailboxHandler
00028976 g     O .bss	00000001 u8MbxWriteCounter
000206a4 g     F .text	0000008c HW_Init
00028d28 g       *ABS*	00000000 __alt_stack_base
00027f40 g     O .rodata	00000020 cBitMask
0002891e g     O .bss	00000001 SMActivate
000288b0 g     O .bss	00000004 u32LastDc32Value
00023fb0 g     F .text	00000048 MailboxServiceInd
00023c84 g     F .text	00000050 PutInMbxQueue
000247ec g     F .text	00000138 OBJ_GetDesc
000288ac g     O .bss	00000004 u32CheckForDcOverrunCnt
00024204 g     F .text	00000068 MBX_MailboxRepeatReq
00028974 g     O .bss	00000001 u8MailboxSendReqStored
00021790 g     F .text	0000000c COE_Init
00020958 g     F .text	00000054 COE_RemoveDicEntry
00020d6c g     F .text	000000b0 PDO_InputMapping
00028404 g     O .rwdata	00000006 acSoftwareversion
000288a8 g     O .bss	00000002 u16ErrorRegister
000276b0 g     F .text	00000004 __malloc_lock
000276b8 g     F .text	0000004c sbrk
000288d8 g     O .bss	00000004 pAPPL_CoeWriteInd
000265d4 g     F .text	00000110 SDOS_SdoRes
000289a4 g     O .bss	00000004 pSdoInfoObjEntry
000214c8 g     F .text	00000218 ESC_EepromAccess
00027508 g     F .text	000000a8 __sfvwrite_small_dev
00028950 g     O .bss	00000001 bSmSyncSequenceValid
000289aa g     O .bss	00000002 nSdoInfoFragmentsLeft
0002328c g     F .text	00000308 AL_ControlRes
0002889c g       *ABS*	00000000 __bss_start
00027384 g     F .text	00000020 memset
00025440 g     F .text	00000740 OBJ_Write
0002005c g     F .text	00000028 main
00020000 g       *ABS*	00000000 __alt_mem_RAM
00026b34 g     F .text	00000020 delay_ms
00027ebc g     O .rodata	0000000c asEntryDesc0x1C12
000289d0 g     O .bss	00000004 alt_envp
0002841c g     O .rwdata	00000006 sEntryDesc0x1001
000200b8 g     F .text	000001c0 APPL_GenerateMapping
000205c0 g     F .text	00000028 HW_GetALEventRegister_Isr
00028958 g     O .bss	00000002 EsmTimeoutCounter
00020ba8 g     F .text	000000cc COE_Main
0002184c g     F .text	00000010 FOE_Init
00034000 g       *ABS*	00000000 __alt_heap_limit
000288ec g     O .bss	00000004 pAPPL_FoeReadData
000216e0 g     F .text	000000b0 ESC_EepromWriteCRC
00027100 g     F .text	000001cc _malloc_r
000207d0 g     F .text	00000098 Read0x10F8
000288a2 g     O .bss	00000002 EscALEvent
0002897c g     O .bss	00000002 u16ReceiveMbxSize
000288a4 g     O .bss	00000004 ObjDicList
00028438 g     O .rwdata	00000004 alt_errno
0002840a g     O .rwdata	00000006 sEntryDesc0x1009
000289a0 g     O .bss	00000004 pSdoResStored
0002895f g     O .bss	00000001 bBootMode
000289b8 g     O .bss	00000004 u32StoreDataSize
00026e78 g     F .text	00000080 .hidden __divsi3
00023594 g     F .text	000000c0 DC_CheckWatchdog
000289ac g     O .bss	00000004 pSdoSegData
00027930 g       *ABS*	00000000 __flash_rodata_start
00021d2c g     F .text	00000060 DisableSyncManChannel
0002895a g     O .bss	00000001 bDcSyncActive
0002895e g     O .bss	00000001 bEcatOutputUpdateRunning
00027764 g     F .text	00000020 alt_irq_init
000213f4 g     F .text	000000d4 MainLoop
0002426c g     F .text	000000e0 MBX_MailboxSendReq
000288d4 g     O .bss	00000004 pAPPL_MainLoop
00020f9c g     F .text	000000fc MainInit
000208cc g     F .text	0000008c COE_AddObjectToDic
000275b0 g     F .text	00000050 _write_r
00028cd4 g     O .bss	00000044 sSyncManOutPar
00028946 g     O .bss	00000002 Sync1WdCounter
0002842c g     O .rwdata	00000004 _impure_ptr
000289d8 g     O .bss	00000004 alt_argc
00026b54 g     F .text	00000168 adc_init
00021cfc g     F .text	00000030 GetSyncMan
0002179c g     F .text	00000048 COE_ServiceInd
00027c90 g     O .rodata	00000012 asEntryDesc0x10F1
00027e78 g     O .rodata	0000001b aName0x1C13
00027e94 g     O .rodata	0000000c asEntryDesc0x1C13
000228d4 g     F .text	000000a4 SetALStatus
000210d4 g     F .text	00000160 Sync0_Isr
00028928 g     O .bss	00000002 EcatWdValue
000288f5 g     O .bss	00000001 bEtherCATErrorLed
00020764 g     F .text	0000006c COE_SyncTimeStamp
00020020 g       *ABS*	00000000 __ram_exceptions_start
00023bd8 g     F .text	00000018 FOE_Write
00020620 g     F .text	00000040 HW_GetALEventRegister
000288cc g     O .bss	00000004 u32MinCycleTimeStartValue
00027c1c g     O .rodata	00000012 aName0x1C00
00027e16 g     O .rodata	00000012 asEntryDesc0x8000
0002843c g       *ABS*	00000000 _edata
00021c78 g     F .text	0000004c SetALEventMask
00028986 g     O .bss	00000001 bSyncSetByUser
00028d28 g       *ABS*	00000000 _end
00028980 g     O .bss	00000001 bMbxRepeatToggle
00027d0c g     O .rodata	0000001e aName0x100A
0002895d g     O .bss	00000001 bEcatInputUpdateRunning
00021cc4 g     F .text	00000038 UpdateEEPROMLoadedState
00020f48 g     F .text	00000054 Sync1_Isr
00020020 g       *ABS*	00000000 __ram_exceptions_end
0002893d g     O .bss	00000001 bEscIntEnabled
00028968 g     O .bss	00000004 psRepeatMbx
00020324 g     F .text	00000008 APPL_GetDeviceID
00027b54 g     O .rodata	000000c6 asEntryDesc0x1C3x
00024624 g     F .text	0000003c OBJ_GetObjectHandle
00027dcc g     O .rodata	00000018 asEntryDesc0x8008
00027fdc g     O .rwdata	0000000c ADCParameterSetting0x8008
0002899a g     O .bss	00000002 nSdoSegIndex
00028d18 g     O .bss	00000010 aSdoInfoHeader
00027ec8 g     O .rodata	0000002f aName0x1A00
000200a8 g     F .text	00000008 APPL_StartOutputHandler
00028988 g     O .bss	00000004 pSdoSegObjEntry
00027ef8 g     O .rodata	0000000c asEntryDesc0x1A00
00024b68 g     F .text	000001bc OBJ_GetEntryOffset
00020a38 g     F .text	00000040 COE_ObjDictionaryInit
00027de4 g     O .rodata	00000031 aName0x8000
0002442c g     F .text	00000134 MBX_CheckAndCopyMailbox
00020a78 g     F .text	00000130 COE_ObjInit
000289f4 g     O .bss	00000224 aPdInputData
000209ac g     F .text	0000003c COE_ClearObjDictionary
0002895b g     O .bss	00000001 bWdTrigger
00026ef8 g     F .text	00000074 .hidden __modsi3
00020e88 g     F .text	000000c0 PDO_OutputMapping
00028998 g     O .bss	00000001 nSdoSegSubindex
00028378 g     O .rwdata	00000054 _impure_data
00034000 g       *ABS*	00000000 __alt_data_end
00025b80 g     F .text	00000160 SdoRes
000205e8 g     F .text	00000038 HW_EscRead
00020758 g     F .text	00000004 BL_StartDownload
000289bc g     O .bss	00000002 u16StoreIndex
000288f6 g     O .bss	00000001 bEtherCATRunLed
00023654 g     F .text	000000d8 CheckIfEcatError
00024a18 g     F .text	00000148 OBJ_GetObjectList
000288e0 g     O .bss	00000004 pAPPL_FoeWriteData
00027e6a g     O .rodata	0000000c asEntryDesc0x6000
0002000c g       .entry	00000000 _exit
00028954 g     O .bss	00000002 u16SmSync0Counter
00028900 g     O .bss	00000004 pFoeSendStored
0002892e g     O .bss	00000001 nMaxSyncMan
0002073c g     F .text	00000004 HW_RestartTarget
000273a4 g     F .text	0000001c strlen
00020278 g     F .text	0000004c APPL_InputMapping
00020310 g     F .text	00000014 APPL_Application
00028428 g     O .rwdata	00000004 u32Devicetype
000289c4 g     O .bss	00000004 __malloc_sbrk_start
000289be g     O .bss	00000001 u8StoreSubindex
00027944 g     O .rodata	00000107 aName0x1C33
000228cc g     F .text	00000008 BackToInitTransition
00028908 g     O .bss	00000004 u32LastFileOffset
00024660 g     F .text	0000010c OBJ_GetObjectLength
00023cd4 g     F .text	00000044 GetOutOfMbxQueue
00027924 g     F .text	00000004 alt_icache_flush_all
000289c8 g     O .bss	00000004 __malloc_free_list
000288f0 g     O .bss	00000004 pAPPL_FoeRead
000209e8 g     F .text	00000050 AddObjectsToObjDictionary
000289e8 g     O .bss	0000000c spiTxBuf
00028984 g     O .bss	00000002 sCycleDiag
00021098 g     F .text	0000003c ECAT_Application
00027d4c g     O .rodata	0000000c aName0x1008
000288e4 g     O .bss	00000004 pAPPL_FoeWrite
00027d74 g     O .rodata	00000057 aName0x8008
000288fc g     O .bss	00000002 u16FoeMaxSendBlockSize
00023910 g     F .text	000000e4 ECAT_Init
00027600 g     F .text	00000084 alt_load
00023c4c g     F .text	0000001c FOE_Ack
00028924 g     O .bss	00000002 nEscAddrInputData
00027064 g     F .text	00000010 free
000205bc g     F .text	00000004 HW_Release



Disassembly of section .entry:

00020000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   20000:	004000b4 	movhi	at,2
    ori r1, r1, %lo(_start)
   20004:	08400814 	ori	at,at,32
    jmp r1
   20008:	0800683a 	jmp	at

0002000c <_exit>:
	...

Disassembly of section .text:

00020020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   20020:	06c000f4 	movhi	sp,3
    ori sp, sp, %lo(__alt_stack_pointer)
   20024:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
   20028:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
   2002c:	d680f314 	ori	gp,gp,972
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   20030:	008000b4 	movhi	r2,2
    ori r2, r2, %lo(__bss_start)
   20034:	10a22714 	ori	r2,r2,34972

    movhi r3, %hi(__bss_end)
   20038:	00c000b4 	movhi	r3,2
    ori r3, r3, %lo(__bss_end)
   2003c:	18e34a14 	ori	r3,r3,36136

    beq r2, r3, 1f
   20040:	10c00326 	beq	r2,r3,20050 <_start+0x30>

0:
    stw zero, (r2)
   20044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   20048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   2004c:	10fffd36 	bltu	r2,r3,20044 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   20050:	00276000 	call	27600 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   20054:	00276840 	call	27684 <alt_main>

00020058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   20058:	003fff06 	br	20058 <alt_after_alt_main>

0002005c <main>:
#include "altera_avalon_pio_regs.h"
#include "peripheral/peripheral_linker.h"

int main()
{
  printf("Hello from Nios II!\n");
   2005c:	010000b4 	movhi	r4,2
{
   20060:	deffff04 	addi	sp,sp,-4
  printf("Hello from Nios II!\n");
   20064:	211e4c04 	addi	r4,r4,31024
{
   20068:	dfc00015 	stw	ra,0(sp)
  printf("Hello from Nios II!\n");
   2006c:	002734c0 	call	2734c <puts>
  	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, invert_me);
  	  delay_ms(1000);
  	  invert_me = ~invert_me;
  }*/

  main_initial();
   20070:	002032c0 	call	2032c <main_initial>

  return 0;
}
   20074:	0005883a 	mov	r2,zero
   20078:	dfc00017 	ldw	ra,0(sp)
   2007c:	dec00104 	addi	sp,sp,4
   20080:	f800283a 	ret

00020084 <APPL_AckErrorInd>:
*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{

}
   20084:	f800283a 	ret

00020088 <APPL_StartMailboxHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}
   20088:	0005883a 	mov	r2,zero
   2008c:	f800283a 	ret

00020090 <APPL_StopMailboxHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
   20090:	0005883a 	mov	r2,zero
   20094:	f800283a 	ret

00020098 <APPL_StartInputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
    return ALSTATUSCODE_NOERROR;
}
   20098:	0005883a 	mov	r2,zero
   2009c:	f800283a 	ret

000200a0 <APPL_StopInputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
   200a0:	0005883a 	mov	r2,zero
   200a4:	f800283a 	ret

000200a8 <APPL_StartOutputHandler>:
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
   200a8:	0005883a 	mov	r2,zero
   200ac:	f800283a 	ret

000200b0 <APPL_StopOutputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
   200b0:	0005883a 	mov	r2,zero
   200b4:	f800283a 	ret

000200b8 <APPL_GenerateMapping>:

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
{
   200b8:	defff404 	addi	sp,sp,-48
   200bc:	dd800815 	stw	r22,32(sp)
   200c0:	dd400715 	stw	r21,28(sp)
   200c4:	dd000615 	stw	r20,24(sp)
   200c8:	dcc00515 	stw	r19,20(sp)
   200cc:	dc000215 	stw	r16,8(sp)
   200d0:	dfc00b15 	stw	ra,44(sp)
   200d4:	df000a15 	stw	fp,40(sp)
   200d8:	ddc00915 	stw	r23,36(sp)
   200dc:	dc800415 	stw	r18,16(sp)
   200e0:	dc400315 	stw	r17,12(sp)
   200e4:	2029883a 	mov	r20,r4
   200e8:	2827883a 	mov	r19,r5
    UINT32 *pPDOEntry = NULL;
    UINT16 PDOEntryCnt = 0;
   
#if MAX_PD_OUTPUT_SIZE > 0
    /*Scan object 0x1C12 RXPDO assign*/
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   200ec:	002d883a 	mov	r22,zero
    UINT16 OutputSize = 0;
   200f0:	0021883a 	mov	r16,zero
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   200f4:	d5600404 	addi	r21,gp,-32752
   200f8:	d0e0040b 	ldhu	r3,-32752(gp)
   200fc:	b0bfffcc 	andi	r2,r22,65535
   20100:	10c01a36 	bltu	r2,r3,2016c <APPL_GenerateMapping+0xb4>
    UINT16 result = ALSTATUSCODE_NOERROR;
   20104:	0023883a 	mov	r17,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
            break;
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
   20108:	84bfffcc 	andi	r18,r16,65535
   2010c:	948001c4 	addi	r18,r18,7
#endif

#if MAX_PD_INPUT_SIZE > 0
    if(result == 0)
   20110:	88bfffcc 	andi	r2,r17,65535
    OutputSize = (OutputSize + 7) >> 3;
   20114:	9025d0fa 	srai	r18,r18,3
    if(result == 0)
   20118:	10005026 	beq	r2,zero,2025c <APPL_GenerateMapping+0x1a4>
    UINT16 InputSize = 0;
   2011c:	0021883a 	mov	r16,zero
   20120:	04400944 	movi	r17,37
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
                break;
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
   20124:	843fffcc 	andi	r16,r16,65535
   20128:	840001c4 	addi	r16,r16,7
   2012c:	8021d0fa 	srai	r16,r16,3
#endif

    *pInputSize = InputSize;
    *pOutputSize = OutputSize;
    return result;
}
   20130:	8805883a 	mov	r2,r17
    InputSize = (InputSize + 7) >> 3;
   20134:	a400000d 	sth	r16,0(r20)
    *pOutputSize = OutputSize;
   20138:	9c80000d 	sth	r18,0(r19)
}
   2013c:	dfc00b17 	ldw	ra,44(sp)
   20140:	df000a17 	ldw	fp,40(sp)
   20144:	ddc00917 	ldw	r23,36(sp)
   20148:	dd800817 	ldw	r22,32(sp)
   2014c:	dd400717 	ldw	r21,28(sp)
   20150:	dd000617 	ldw	r20,24(sp)
   20154:	dcc00517 	ldw	r19,20(sp)
   20158:	dc800417 	ldw	r18,16(sp)
   2015c:	dc400317 	ldw	r17,12(sp)
   20160:	dc000217 	ldw	r16,8(sp)
   20164:	dec00c04 	addi	sp,sp,48
   20168:	f800283a 	ret
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
   2016c:	1004907a 	slli	r2,r2,1
   20170:	a885883a 	add	r2,r21,r2
   20174:	1100008b 	ldhu	r4,2(r2)
   20178:	00246240 	call	24624 <OBJ_GetObjectHandle>
   2017c:	1025883a 	mov	r18,r2
        if(pPDO != NULL)
   20180:	10001326 	beq	r2,zero,201d0 <APPL_GenerateMapping+0x118>
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   20184:	10800617 	ldw	r2,24(r2)
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20188:	0007883a 	mov	r3,zero
   2018c:	1700000b 	ldhu	fp,0(r2)
   20190:	18bfffcc 	andi	r2,r3,65535
   20194:	1700021e 	bne	r2,fp,201a0 <APPL_GenerateMapping+0xe8>
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20198:	b5800044 	addi	r22,r22,1
   2019c:	003fd606 	br	200f8 <APPL_GenerateMapping+0x40>
                pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   201a0:	1c400044 	addi	r17,r3,1
   201a4:	900b883a 	mov	r5,r18
   201a8:	89003fcc 	andi	r4,r17,255
   201ac:	95c00617 	ldw	r23,24(r18)
   201b0:	0024b680 	call	24b68 <OBJ_GetEntryOffset>
   201b4:	1004d0fa 	srli	r2,r2,3
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   201b8:	8807883a 	mov	r3,r17
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   201bc:	1087ff8c 	andi	r2,r2,8190
   201c0:	b8af883a 	add	r23,r23,r2
   201c4:	b8800003 	ldbu	r2,0(r23)
   201c8:	1421883a 	add	r16,r2,r16
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   201cc:	003ff006 	br	20190 <APPL_GenerateMapping+0xd8>
            OutputSize = 0;
   201d0:	0021883a 	mov	r16,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
   201d4:	04400944 	movi	r17,37
   201d8:	003fcb06 	br	20108 <APPL_GenerateMapping+0x50>
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
   201dc:	1004907a 	slli	r2,r2,1
   201e0:	b885883a 	add	r2,r23,r2
   201e4:	1100008b 	ldhu	r4,2(r2)
   201e8:	00246240 	call	24624 <OBJ_GetObjectHandle>
   201ec:	102d883a 	mov	r22,r2
            if(pPDO != NULL)
   201f0:	10001e26 	beq	r2,zero,2026c <APPL_GenerateMapping+0x1b4>
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   201f4:	10800617 	ldw	r2,24(r2)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   201f8:	8807883a 	mov	r3,r17
   201fc:	11c0000b 	ldhu	r7,0(r2)
   20200:	18bfffcc 	andi	r2,r3,65535
   20204:	11c0051e 	bne	r2,r7,2021c <APPL_GenerateMapping+0x164>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20208:	e7000044 	addi	fp,fp,1
   2020c:	d0e0030b 	ldhu	r3,-32756(gp)
   20210:	e0bfffcc 	andi	r2,fp,65535
   20214:	10fff136 	bltu	r2,r3,201dc <APPL_GenerateMapping+0x124>
   20218:	003fc206 	br	20124 <APPL_GenerateMapping+0x6c>
                    pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   2021c:	b1800617 	ldw	r6,24(r22)
   20220:	1d400044 	addi	r21,r3,1
   20224:	b00b883a 	mov	r5,r22
   20228:	a9003fcc 	andi	r4,r21,255
   2022c:	d9c00115 	stw	r7,4(sp)
   20230:	d9800015 	stw	r6,0(sp)
   20234:	0024b680 	call	24b68 <OBJ_GetEntryOffset>
   20238:	1004d0fa 	srli	r2,r2,3
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   2023c:	d9800017 	ldw	r6,0(sp)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20240:	d9c00117 	ldw	r7,4(sp)
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   20244:	1087ff8c 	andi	r2,r2,8190
   20248:	308d883a 	add	r6,r6,r2
   2024c:	30800003 	ldbu	r2,0(r6)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20250:	a807883a 	mov	r3,r21
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   20254:	1421883a 	add	r16,r2,r16
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20258:	003fe906 	br	20200 <APPL_GenerateMapping+0x148>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   2025c:	8839883a 	mov	fp,r17
    UINT16 InputSize = 0;
   20260:	8821883a 	mov	r16,r17
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20264:	d5e00304 	addi	r23,gp,-32756
   20268:	003fe806 	br	2020c <APPL_GenerateMapping+0x154>
                InputSize = 0;
   2026c:	8821883a 	mov	r16,r17
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
   20270:	04400904 	movi	r17,36
   20274:	003fab06 	br	20124 <APPL_GenerateMapping+0x6c>

00020278 <APPL_InputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   20278:	0007883a 	mov	r3,zero
   2027c:	d1a00304 	addi	r6,gp,-32756
   20280:	d160030b 	ldhu	r5,-32756(gp)
   20284:	18803fcc 	andi	r2,r3,255
   20288:	11400136 	bltu	r2,r5,20290 <APPL_InputMapping+0x18>
					   sizeof(IN_GENERIC0x6000.IN_GEN_INT1));
				pTmpData += sizeof(IN_GENERIC0x6000.IN_GEN_INT1);
				break;
		}
	}
}
   2028c:	f800283a 	ret
		switch (sTxPDOassign.aEntries[j]) {
   20290:	18803fcc 	andi	r2,r3,255
   20294:	1004907a 	slli	r2,r2,1
   20298:	3085883a 	add	r2,r6,r2
   2029c:	1080008b 	ldhu	r2,2(r2)
   202a0:	10868018 	cmpnei	r2,r2,6656
   202a4:	1000051e 	bne	r2,zero,202bc <APPL_InputMapping+0x44>
				memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   202a8:	d0a00283 	ldbu	r2,-32758(gp)
				pTmpData += sizeof(IN_GENERIC0x6000.IN_GEN_INT1);
   202ac:	21000084 	addi	r4,r4,2
				memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   202b0:	20bfff85 	stb	r2,-2(r4)
   202b4:	d0a002c3 	ldbu	r2,-32757(gp)
   202b8:	20bfffc5 	stb	r2,-1(r4)
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   202bc:	18c00044 	addi	r3,r3,1
   202c0:	003fef06 	br	20280 <APPL_InputMapping+0x8>

000202c4 <APPL_OutputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	    for (UINT8 k = 0; k < sRxPDOassign.u16SubIndex0; k++) {
   202c4:	0007883a 	mov	r3,zero
   202c8:	d1a00404 	addi	r6,gp,-32752
   202cc:	d160040b 	ldhu	r5,-32752(gp)
   202d0:	18803fcc 	andi	r2,r3,255
   202d4:	11400136 	bltu	r2,r5,202dc <APPL_OutputMapping+0x18>
	                       sizeof(OUT_GENERIC0x7000.OUT_GEN_INT1));
	                pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_INT1);
	                break;
	        }
	    }
}
   202d8:	f800283a 	ret
	        switch (sRxPDOassign.aEntries[k]) {
   202dc:	18803fcc 	andi	r2,r3,255
   202e0:	1004907a 	slli	r2,r2,1
   202e4:	3085883a 	add	r2,r6,r2
   202e8:	1080008b 	ldhu	r2,2(r2)
   202ec:	10858018 	cmpnei	r2,r2,5632
   202f0:	1000051e 	bne	r2,zero,20308 <APPL_OutputMapping+0x44>
	                memcpy(pTmpData, &OUT_GENERIC0x7000.OUT_GEN_INT1,
   202f4:	d0a00183 	ldbu	r2,-32762(gp)
	                pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_INT1);
   202f8:	21000084 	addi	r4,r4,2
	                memcpy(pTmpData, &OUT_GENERIC0x7000.OUT_GEN_INT1,
   202fc:	20bfff85 	stb	r2,-2(r4)
   20300:	d0a001c3 	ldbu	r2,-32761(gp)
   20304:	20bfffc5 	stb	r2,-1(r4)
	    for (UINT8 k = 0; k < sRxPDOassign.u16SubIndex0; k++) {
   20308:	18c00044 	addi	r3,r3,1
   2030c:	003fef06 	br	202cc <APPL_OutputMapping+0x8>

00020310 <APPL_Application>:
            or from the mainloop if no synchronisation is supported
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
	static int haha = 0;
	IN_GENERIC0x6000.IN_GEN_INT1 = haha++;
   20310:	d0a13417 	ldw	r2,-31536(gp)
   20314:	10c00044 	addi	r3,r2,1
   20318:	d0e13415 	stw	r3,-31536(gp)
   2031c:	d0a0028d 	sth	r2,-32758(gp)
}
   20320:	f800283a 	ret

00020324 <APPL_GetDeviceID>:
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GetDeviceID()
{
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    return 0x5;
}
   20324:	00800144 	movi	r2,5
   20328:	f800283a 	ret

0002032c <main_initial>:
/**

 \brief    This is the main function

*////////////////////////////////////////////////////////////////////////////////////////
void main_initial(void) {
   2032c:	deffff04 	addi	sp,sp,-4
   20330:	dfc00015 	stw	ra,0(sp)
    /* initialize the Hardware and the EtherCAT Slave Controller */
    HW_Init();
   20334:	00206a40 	call	206a4 <HW_Init>
    MainInit();
   20338:	0020f9c0 	call	20f9c <MainInit>

    bRunApplication = TRUE;
   2033c:	00800044 	movi	r2,1
   20340:	d0a14a05 	stb	r2,-31448(gp)
    do {
        MainLoop();
   20344:	00213f40 	call	213f4 <MainLoop>
    } while (bRunApplication == TRUE);
   20348:	d0a14a03 	ldbu	r2,-31448(gp)
   2034c:	10800060 	cmpeqi	r2,r2,1
   20350:	103ffc1e 	bne	r2,zero,20344 <main_initial+0x18>

    HW_Release();
}
   20354:	dfc00017 	ldw	ra,0(sp)
   20358:	dec00104 	addi	sp,sp,4
    HW_Release();
   2035c:	00205bc1 	jmpi	205bc <HW_Release>

00020360 <HW_SPI_Read>:
 * @param pBuf
 * @param Addr
 * @param ByteLen
 */

static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   20360:	defff504 	addi	sp,sp,-44
   20364:	ddc00915 	stw	r23,36(sp)
   20368:	dd000615 	stw	r20,24(sp)

        /* Set dummy byte */
        spiTxBuf[DataOffset] = 0xff;

        /* Set read terminal byte */
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2036c:	05c000f4 	movhi	r23,3
        spiTxBuf[0] = ptr[1];
   20370:	050000f4 	movhi	r20,3
static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   20374:	dd400715 	stw	r21,28(sp)
   20378:	dc800415 	stw	r18,16(sp)
   2037c:	dc400315 	stw	r17,12(sp)
   20380:	dc000215 	stw	r16,8(sp)
   20384:	dfc00a15 	stw	ra,40(sp)
   20388:	dd800815 	stw	r22,32(sp)
   2038c:	dcc00515 	stw	r19,20(sp)
   20390:	2023883a 	mov	r17,r4
   20394:	2825883a 	mov	r18,r5
   20398:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   2039c:	a5227a04 	addi	r20,r20,-30232
        spiTxBuf[DataOffset] = 0xff;
   203a0:	057fffc4 	movi	r21,-1
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   203a4:	bde27ac4 	addi	r23,r23,-30229
    while (ByteLen) {
   203a8:	80bfffcc 	andi	r2,r16,65535
   203ac:	10000b1e 	bne	r2,zero,203dc <HW_SPI_Read+0x7c>
        /* Next section */
        Addr += XferLen;
        pBuf += XferLen;
        ByteLen -= XferLen;
    }
}
   203b0:	dfc00a17 	ldw	ra,40(sp)
   203b4:	ddc00917 	ldw	r23,36(sp)
   203b8:	dd800817 	ldw	r22,32(sp)
   203bc:	dd400717 	ldw	r21,28(sp)
   203c0:	dd000617 	ldw	r20,24(sp)
   203c4:	dcc00517 	ldw	r19,20(sp)
   203c8:	dc800417 	ldw	r18,16(sp)
   203cc:	dc400317 	ldw	r17,12(sp)
   203d0:	dc000217 	ldw	r16,8(sp)
   203d4:	dec00b04 	addi	sp,sp,44
   203d8:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   203dc:	10800270 	cmpltui	r2,r2,9
   203e0:	802d883a 	mov	r22,r16
   203e4:	1000011e 	bne	r2,zero,203ec <HW_SPI_Read+0x8c>
   203e8:	05800204 	movi	r22,8
        AddrTmp = AddrTmp << 3;
   203ec:	900490fa 	slli	r2,r18,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   203f0:	b4ffffcc 	andi	r19,r22,65535
        spiTxBuf[0] = ptr[1];
   203f4:	010000f4 	movhi	r4,3
   203f8:	10ffffcc 	andi	r3,r2,65535
   203fc:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   20400:	108000d4 	ori	r2,r2,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20404:	980d883a 	mov	r6,r19
        spiTxBuf[0] = ptr[1];
   20408:	20e27a05 	stb	r3,-30232(r4)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2040c:	000b883a 	mov	r5,zero
   20410:	b809883a 	mov	r4,r23
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   20414:	a0800045 	stb	r2,1(r20)
        spiTxBuf[DataOffset] = 0xff;
   20418:	a5400085 	stb	r21,2(r20)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2041c:	00273840 	call	27384 <memset>
        spiTxBuf[DataOffset + XferLen] = 0xff;
   20420:	008000f4 	movhi	r2,3
   20424:	9885883a 	add	r2,r19,r2
   20428:	15627a85 	stb	r21,-30230(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   2042c:	00800134 	movhi	r2,4
   20430:	10041035 	stwio	zero,4160(r2)
													DataOffset + XferLen, 0);
   20434:	988000c4 	addi	r2,r19,3
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20438:	01c000f4 	movhi	r7,3
   2043c:	018000f4 	movhi	r6,3
   20440:	01000134 	movhi	r4,4
   20444:	d8000115 	stw	zero,4(sp)
   20448:	d8800015 	stw	r2,0(sp)
   2044c:	39e27704 	addi	r7,r7,-30244
   20450:	31a27a04 	addi	r6,r6,-30232
   20454:	000b883a 	mov	r5,zero
   20458:	21040004 	addi	r4,r4,4096
   2045c:	0026cbc0 	call	26cbc <spi_transmit_receive>
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20460:	00c00044 	movi	r3,1
   20464:	00800134 	movhi	r2,4
   20468:	10c41035 	stwio	r3,4160(r2)
        for (i = 0; i < XferLen; i++) {
   2046c:	008000f4 	movhi	r2,3
   20470:	10a27704 	addi	r2,r2,-30244
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20474:	0007883a 	mov	r3,zero
            pBuf[i] = spiRxBuf[DataOffset + i];
   20478:	114000c3 	ldbu	r5,3(r2)
   2047c:	88c9883a 	add	r4,r17,r3
        for (i = 0; i < XferLen; i++) {
   20480:	18c00044 	addi	r3,r3,1
            pBuf[i] = spiRxBuf[DataOffset + i];
   20484:	21400005 	stb	r5,0(r4)
        for (i = 0; i < XferLen; i++) {
   20488:	193fffcc 	andi	r4,r3,65535
   2048c:	10800044 	addi	r2,r2,1
   20490:	24fff936 	bltu	r4,r19,20478 <HW_SPI_Read+0x118>
        Addr += XferLen;
   20494:	b4a5883a 	add	r18,r22,r18
        pBuf += XferLen;
   20498:	8ce3883a 	add	r17,r17,r19
        ByteLen -= XferLen;
   2049c:	85a1c83a 	sub	r16,r16,r22
   204a0:	003fc106 	br	203a8 <HW_SPI_Read+0x48>

000204a4 <HW_SPI_Write>:
 *
 * @param pData
 * @param Addr
 * @param ByteLen
 */
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   204a4:	defff604 	addi	sp,sp,-40
   204a8:	dd400715 	stw	r21,28(sp)
   204ac:	dd000615 	stw	r20,24(sp)
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
        DataOffset = 2;
#endif

        /* Set transmit data bytes */
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   204b0:	054000f4 	movhi	r21,3
        spiTxBuf[0] = ptr[1];
   204b4:	050000f4 	movhi	r20,3
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   204b8:	dcc00515 	stw	r19,20(sp)
   204bc:	dc800415 	stw	r18,16(sp)
   204c0:	dc000215 	stw	r16,8(sp)
   204c4:	dfc00915 	stw	ra,36(sp)
   204c8:	dd800815 	stw	r22,32(sp)
   204cc:	dc400315 	stw	r17,12(sp)
   204d0:	2025883a 	mov	r18,r4
   204d4:	2827883a 	mov	r19,r5
   204d8:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   204dc:	a5227a04 	addi	r20,r20,-30232
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   204e0:	ad627a84 	addi	r21,r21,-30230
    while (ByteLen) {
   204e4:	80bfffcc 	andi	r2,r16,65535
   204e8:	10000a1e 	bne	r2,zero,20514 <HW_SPI_Write+0x70>

        Addr += XferLen;
        pData += XferLen;
        ByteLen -= XferLen;
    }
}
   204ec:	dfc00917 	ldw	ra,36(sp)
   204f0:	dd800817 	ldw	r22,32(sp)
   204f4:	dd400717 	ldw	r21,28(sp)
   204f8:	dd000617 	ldw	r20,24(sp)
   204fc:	dcc00517 	ldw	r19,20(sp)
   20500:	dc800417 	ldw	r18,16(sp)
   20504:	dc400317 	ldw	r17,12(sp)
   20508:	dc000217 	ldw	r16,8(sp)
   2050c:	dec00a04 	addi	sp,sp,40
   20510:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   20514:	10c00268 	cmpgeui	r3,r2,9
   20518:	1800241e 	bne	r3,zero,205ac <HW_SPI_Write+0x108>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   2051c:	108000e0 	cmpeqi	r2,r2,3
   20520:	1000241e 	bne	r2,zero,205b4 <HW_SPI_Write+0x110>
   20524:	8023883a 	mov	r17,r16
        AddrTmp = AddrTmp << 3;
   20528:	980490fa 	slli	r2,r19,3
        spiTxBuf[0] = ptr[1];
   2052c:	010000f4 	movhi	r4,3
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20530:	8dbfffcc 	andi	r22,r17,65535
        spiTxBuf[0] = ptr[1];
   20534:	10ffffcc 	andi	r3,r2,65535
   20538:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   2053c:	10800114 	ori	r2,r2,4
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20540:	b00d883a 	mov	r6,r22
        spiTxBuf[0] = ptr[1];
   20544:	20e27a05 	stb	r3,-30232(r4)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20548:	900b883a 	mov	r5,r18
   2054c:	a809883a 	mov	r4,r21
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   20550:	a0800045 	stb	r2,1(r20)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20554:	002735c0 	call	2735c <memcpy>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   20558:	00800134 	movhi	r2,4
   2055c:	10041035 	stwio	zero,4160(r2)
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20560:	88800084 	addi	r2,r17,2
   20564:	10bfffcc 	andi	r2,r2,65535
   20568:	01c000f4 	movhi	r7,3
   2056c:	018000f4 	movhi	r6,3
   20570:	01000134 	movhi	r4,4
   20574:	d8000115 	stw	zero,4(sp)
   20578:	d8800015 	stw	r2,0(sp)
   2057c:	39e27704 	addi	r7,r7,-30244
   20580:	31a27a04 	addi	r6,r6,-30232
   20584:	000b883a 	mov	r5,zero
   20588:	21040004 	addi	r4,r4,4096
   2058c:	0026cbc0 	call	26cbc <spi_transmit_receive>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20590:	00c00044 	movi	r3,1
   20594:	00800134 	movhi	r2,4
   20598:	10c41035 	stwio	r3,4160(r2)
        Addr += XferLen;
   2059c:	9c67883a 	add	r19,r19,r17
        pData += XferLen;
   205a0:	95a5883a 	add	r18,r18,r22
        ByteLen -= XferLen;
   205a4:	8461c83a 	sub	r16,r16,r17
   205a8:	003fce06 	br	204e4 <HW_SPI_Write+0x40>
            XferLen = HW_SPI_MAX_DATA_FRAGMENT_SIZE;
   205ac:	04400204 	movi	r17,8
   205b0:	003fdd06 	br	20528 <HW_SPI_Write+0x84>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   205b4:	04400084 	movi	r17,2
   205b8:	003fdb06 	br	20528 <HW_SPI_Write+0x84>

000205bc <HW_Release>:
 * @brief  This function shall be implemented if hardware resources need to be
 * release when the sample application stops.
 * @param  None
 * @retval None
 */
void HW_Release(void) {}
   205bc:	f800283a 	ret

000205c0 <HW_GetALEventRegister_Isr>:
 * interrupts service routines. The behaviour is equal to
 * "HW_GetALEventRegister()"
 * @param  None
 * @retval First two Bytes of ALEvent register (0x220)
 */
uint16_t HW_GetALEventRegister_Isr(void) {
   205c0:	deffff04 	addi	sp,sp,-4
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscReadIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   205c4:	01800084 	movi	r6,2
   205c8:	01408804 	movi	r5,544
   205cc:	d1213584 	addi	r4,gp,-31530
uint16_t HW_GetALEventRegister_Isr(void) {
   205d0:	dfc00015 	stw	ra,0(sp)
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   205d4:	00203600 	call	20360 <HW_SPI_Read>
}
   205d8:	d0a1358b 	ldhu	r2,-31530(gp)
   205dc:	dfc00017 	ldw	ra,0(sp)
   205e0:	dec00104 	addi	sp,sp,4
   205e4:	f800283a 	ret

000205e8 <HW_EscRead>:
void HW_EscRead(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   205e8:	deffff04 	addi	sp,sp,-4
   205ec:	dfc00015 	stw	ra,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   205f0:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   205f4:	00ffff84 	movi	r3,-2
   205f8:	10c4703a 	and	r2,r2,r3
   205fc:	1001703a 	wrctl	status,r2
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20600:	31bfffcc 	andi	r6,r6,65535
   20604:	297fffcc 	andi	r5,r5,65535
   20608:	00203600 	call	20360 <HW_SPI_Read>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   2060c:	00800044 	movi	r2,1
   20610:	1001703a 	wrctl	status,r2
}
   20614:	dfc00017 	ldw	ra,0(sp)
   20618:	dec00104 	addi	sp,sp,4
   2061c:	f800283a 	ret

00020620 <HW_GetALEventRegister>:
uint16_t HW_GetALEventRegister(void) {
   20620:	deffff04 	addi	sp,sp,-4
   20624:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   20628:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2062c:	00ffff84 	movi	r3,-2
   20630:	10c4703a 	and	r2,r2,r3
   20634:	1001703a 	wrctl	status,r2
    HW_EscRead((MEM_ADDR*)EscALEvent.Byte, ESC_AL_EVENT_OFFSET, 2);
   20638:	01800084 	movi	r6,2
   2063c:	01408804 	movi	r5,544
   20640:	d1213584 	addi	r4,gp,-31530
   20644:	00205e80 	call	205e8 <HW_EscRead>
  NIOS2_WRITE_STATUS (context);
   20648:	00800044 	movi	r2,1
   2064c:	1001703a 	wrctl	status,r2
}
   20650:	d0a1358b 	ldhu	r2,-31530(gp)
   20654:	dfc00017 	ldw	ra,0(sp)
   20658:	dec00104 	addi	sp,sp,4
   2065c:	f800283a 	ret

00020660 <HW_EscReadIsr>:
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20660:	31bfffcc 	andi	r6,r6,65535
   20664:	297fffcc 	andi	r5,r5,65535
   20668:	00203601 	jmpi	20360 <HW_SPI_Read>

0002066c <HW_EscWrite>:
 * @param  Address     EtherCAT ASIC address ( upper limit is 0x1FFF ) for
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWrite(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   2066c:	deffff04 	addi	sp,sp,-4
   20670:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   20674:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20678:	00ffff84 	movi	r3,-2
   2067c:	10c4703a 	and	r2,r2,r3
   20680:	1001703a 	wrctl	status,r2

#if AL_EVENT_ENABLED
    DISABLE_AL_EVENT_INT;
#endif
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   20684:	31bfffcc 	andi	r6,r6,65535
   20688:	297fffcc 	andi	r5,r5,65535
   2068c:	00204a40 	call	204a4 <HW_SPI_Write>
  NIOS2_WRITE_STATUS (context);
   20690:	00800044 	movi	r2,1
   20694:	1001703a 	wrctl	status,r2
#if AL_EVENT_ENABLED
    ENABLE_AL_EVENT_INT;
#endif
}
   20698:	dfc00017 	ldw	ra,0(sp)
   2069c:	dec00104 	addi	sp,sp,4
   206a0:	f800283a 	ret

000206a4 <HW_Init>:
uint8_t HW_Init(void) {
   206a4:	defffd04 	addi	sp,sp,-12
   206a8:	dc000115 	stw	r16,4(sp)
   206ac:	dfc00215 	stw	ra,8(sp)
        intMask = 0x93;
   206b0:	040024c4 	movi	r16,147
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206b4:	01800104 	movi	r6,4
   206b8:	01408104 	movi	r5,516
   206bc:	d809883a 	mov	r4,sp
        intMask = 0x93;
   206c0:	dc000015 	stw	r16,0(sp)
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206c4:	002066c0 	call	2066c <HW_EscWrite>
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206c8:	01800104 	movi	r6,4
   206cc:	01408104 	movi	r5,516
   206d0:	d809883a 	mov	r4,sp
        intMask = 0;
   206d4:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206d8:	00205e80 	call	205e8 <HW_EscRead>
    } while (intMask != 0x93);
   206dc:	d8800017 	ldw	r2,0(sp)
   206e0:	108024d8 	cmpnei	r2,r2,147
   206e4:	103ff31e 	bne	r2,zero,206b4 <HW_Init+0x10>
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206e8:	01800104 	movi	r6,4
   206ec:	01408104 	movi	r5,516
   206f0:	d809883a 	mov	r4,sp
    intMask = 0x00;
   206f4:	d8000015 	stw	zero,0(sp)
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   206f8:	002066c0 	call	2066c <HW_EscWrite>
   206fc:	00800044 	movi	r2,1
   20700:	1001703a 	wrctl	status,r2
    if (bootSwitchID) {
   20704:	d0a1350b 	ldhu	r2,-31532(gp)
   20708:	10000426 	beq	r2,zero,2071c <HW_Init+0x78>
        HW_EscWriteWord(bootSwitchID, ESC_ALIAS_ADDRESS_OFFSET);
   2070c:	01800084 	movi	r6,2
   20710:	01400484 	movi	r5,18
   20714:	d1213504 	addi	r4,gp,-31532
   20718:	002066c0 	call	2066c <HW_EscWrite>
}
   2071c:	0005883a 	mov	r2,zero
   20720:	dfc00217 	ldw	ra,8(sp)
   20724:	dc000117 	ldw	r16,4(sp)
   20728:	dec00304 	addi	sp,sp,12
   2072c:	f800283a 	ret

00020730 <HW_EscWriteIsr>:
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWriteIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   20730:	31bfffcc 	andi	r6,r6,65535
   20734:	297fffcc 	andi	r5,r5,65535
   20738:	00204a41 	jmpi	204a4 <HW_SPI_Write>

0002073c <HW_RestartTarget>:
/**
 * @brief  This function resets the hardware
 * @param  None
 * @retval None
 */
void HW_RestartTarget(void) {}
   2073c:	f800283a 	ret

00020740 <HW_ALEVENT_IRQHandler>:
 * @retval None
 */
void HW_ALEVENT_IRQHandler(void) {
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SPI_ESC_INT_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SPI_ESC_INT_PIN);
        PDI_Isr();
   20740:	00212341 	jmpi	21234 <PDI_Isr>

00020744 <HW_SYNC0_IRQHandler>:
 */
void HW_SYNC0_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC0_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC0_PIN);
        Sync0_Isr();
   20744:	00210d41 	jmpi	210d4 <Sync0_Isr>

00020748 <HW_SYNC1_IRQHandler>:

void HW_SYNC1_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC1_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC1_PIN);
        Sync1_Isr();
   20748:	0020f481 	jmpi	20f48 <Sync1_Isr>

0002074c <HW_TIMETASK_IRQHandler>:
	if ((__HAL_TIM_GET_IT_SOURCE(&HW_TIMETASK_INSTANCE_H, TIM_IT_UPDATE) ==
		 SET) &&
		(__HAL_TIM_GET_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE) != 0)) {
		__HAL_TIM_CLEAR_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE);
		*/
		ECAT_CheckTimer();
   2074c:	0020c741 	jmpi	20c74 <ECAT_CheckTimer>

00020750 <BL_Start>:

 \brief Called from INIT to BOOT
*////////////////////////////////////////////////////////////////////////////////////////
void BL_Start( UINT8 State)
{
}
   20750:	f800283a 	ret

00020754 <BL_Stop>:

\brief Called in the state transition from BOOT to Init
*////////////////////////////////////////////////////////////////////////////////////////
void BL_Stop(void)
{
}
   20754:	f800283a 	ret

00020758 <BL_StartDownload>:

 \brief Dummy BL_StartDownload function
*////////////////////////////////////////////////////////////////////////////////////////
void BL_StartDownload(UINT32 password)
{
}
   20758:	f800283a 	ret

0002075c <BL_Data>:
 \brief Dummy BL_Data function
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 BL_Data(UINT16 *pData,UINT16 Size)
{
    return 0;
}
   2075c:	0005883a 	mov	r2,zero
   20760:	f800283a 	ret

00020764 <COE_SyncTimeStamp>:
          Called from the Timer handler 
*////////////////////////////////////////////////////////////////////////////////////////
void COE_SyncTimeStamp(void)
{

    if (b32BitDc)
   20764:	d0a15c83 	ldbu	r2,-31374(gp)
{
   20768:	defffe04 	addi	sp,sp,-8
   2076c:	dfc00115 	stw	ra,4(sp)
    if (b32BitDc)
   20770:	10001226 	beq	r2,zero,207bc <COE_SyncTimeStamp+0x58>
    {
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   20774:	d0a13a17 	ldw	r2,-31512(gp)


        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   20778:	d809883a 	mov	r4,sp
   2077c:	01800104 	movi	r6,4
   20780:	01424404 	movi	r5,2320
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   20784:	d8800015 	stw	r2,0(sp)
        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   20788:	00205e80 	call	205e8 <HW_EscRead>

        /*update the lower 32Bit*/
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   2078c:	d8800017 	ldw	r2,0(sp)

        if (DcTime < u32LastDc32Value)
   20790:	d1213917 	ldw	r4,-31516(gp)
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   20794:	d0e13b17 	ldw	r3,-31508(gp)
   20798:	d0a13a15 	stw	r2,-31512(gp)
        if (DcTime < u32LastDc32Value)
   2079c:	1100022e 	bgeu	r2,r4,207a8 <COE_SyncTimeStamp+0x44>
        {
            /*32Bit overrun*/
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
   207a0:	18c00044 	addi	r3,r3,1
   207a4:	d0e13b15 	stw	r3,-31508(gp)
        }
        
        u32LastDc32Value = DcTime;
   207a8:	d0a13915 	stw	r2,-31516(gp)
        /*The DC unit supports 64Bit => update the complete object*/
        
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
    }

    u32CheckForDcOverrunCnt = 0;
   207ac:	d0213815 	stw	zero,-31520(gp)

}
   207b0:	dfc00117 	ldw	ra,4(sp)
   207b4:	dec00204 	addi	sp,sp,8
   207b8:	f800283a 	ret
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
   207bc:	01800204 	movi	r6,8
   207c0:	01424404 	movi	r5,2320
   207c4:	d1213a04 	addi	r4,gp,-31512
   207c8:	00205e80 	call	205e8 <HW_EscRead>
   207cc:	003ff706 	br	207ac <COE_SyncTimeStamp+0x48>

000207d0 <Read0x10F8>:
{
   207d0:	defffc04 	addi	sp,sp,-16
    if (index != 0x10F8)
   207d4:	20bfffcc 	andi	r2,r4,65535
{
   207d8:	dfc00315 	stw	ra,12(sp)
   207dc:	dc800215 	stw	r18,8(sp)
   207e0:	dc400115 	stw	r17,4(sp)
   207e4:	dc000015 	stw	r16,0(sp)
    if (index != 0x10F8)
   207e8:	10843e18 	cmpnei	r2,r2,4344
{
   207ec:	d8c00403 	ldbu	r3,16(sp)
    if (index != 0x10F8)
   207f0:	1000151e 	bne	r2,zero,20848 <Read0x10F8+0x78>
    if (bCompleteAccess)
   207f4:	18c03fcc 	andi	r3,r3,255
   207f8:	1800151e 	bne	r3,zero,20850 <Read0x10F8+0x80>
   207fc:	2821883a 	mov	r16,r5
    if (subindex > 0)
   20800:	29403fcc 	andi	r5,r5,255
   20804:	2800141e 	bne	r5,zero,20858 <Read0x10F8+0x88>
    if (dataSize > 8)
   20808:	30800268 	cmpgeui	r2,r6,9
   2080c:	3023883a 	mov	r17,r6
   20810:	1000131e 	bne	r2,zero,20860 <Read0x10F8+0x90>
   20814:	3825883a 	mov	r18,r7
    COE_SyncTimeStamp();
   20818:	00207640 	call	20764 <COE_SyncTimeStamp>
    MEMCPY(pData, &u64Timestamp, dataSize);
   2081c:	880d883a 	mov	r6,r17
   20820:	d1613a04 	addi	r5,gp,-31512
   20824:	9009883a 	mov	r4,r18
   20828:	002735c0 	call	2735c <memcpy>
}
   2082c:	8005883a 	mov	r2,r16
   20830:	dfc00317 	ldw	ra,12(sp)
   20834:	dc800217 	ldw	r18,8(sp)
   20838:	dc400117 	ldw	r17,4(sp)
   2083c:	dc000017 	ldw	r16,0(sp)
   20840:	dec00404 	addi	sp,sp,16
   20844:	f800283a 	ret
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
   20848:	040002c4 	movi	r16,11
   2084c:	003ff706 	br	2082c <Read0x10F8+0x5c>
        return ABORTIDX_UNSUPPORTED_ACCESS;
   20850:	04000144 	movi	r16,5
   20854:	003ff506 	br	2082c <Read0x10F8+0x5c>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   20858:	04000444 	movi	r16,17
   2085c:	003ff306 	br	2082c <Read0x10F8+0x5c>
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
   20860:	040003c4 	movi	r16,15
   20864:	003ff106 	br	2082c <Read0x10F8+0x5c>

00020868 <COE_GetObjectDictionary>:
 \brief    returns the pointer to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
OBJCONST TOBJECT OBJMEM * COE_GetObjectDictionary(void)
{
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
}
   20868:	d0a13617 	ldw	r2,-31528(gp)
   2086c:	f800283a 	ret

00020870 <COE_UpdateSyncErrorStatus>:
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   20870:	00c000f4 	movhi	r3,3
   20874:	18e33504 	addi	r3,r3,-29484
   20878:	18800a8b 	ldhu	r2,42(r3)
   2087c:	10000f1e 	bne	r2,zero,208bc <COE_UpdateSyncErrorStatus+0x4c>
   20880:	008000f4 	movhi	r2,3
   20884:	19000a0b 	ldhu	r4,40(r3)
   20888:	10a0dd0b 	ldhu	r2,-31884(r2)
   2088c:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManOutPar.u8SyncError = 1;
   20890:	18801005 	stb	r2,64(r3)
    {
        sSyncManOutPar.u8SyncError = 0;
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   20894:	00c000f4 	movhi	r3,3
   20898:	18e32404 	addi	r3,r3,-29552
   2089c:	18800a8b 	ldhu	r2,42(r3)
   208a0:	1000081e 	bne	r2,zero,208c4 <COE_UpdateSyncErrorStatus+0x54>
   208a4:	008000f4 	movhi	r2,3
   208a8:	19000a0b 	ldhu	r4,40(r3)
   208ac:	10a0dd0b 	ldhu	r2,-31884(r2)
   208b0:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManInPar.u8SyncError = 1;
   208b4:	18801005 	stb	r2,64(r3)
    else
    {
        sSyncManInPar.u8SyncError = 0;
    }

}
   208b8:	f800283a 	ret
   208bc:	00800044 	movi	r2,1
   208c0:	003ff306 	br	20890 <COE_UpdateSyncErrorStatus+0x20>
   208c4:	00800044 	movi	r2,1
   208c8:	003ffa06 	br	208b4 <COE_UpdateSyncErrorStatus+0x44>

000208cc <COE_AddObjectToDic>:

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
    if(pNewObjEntry != NULL)
   208cc:	20002026 	beq	r4,zero,20950 <COE_AddObjectToDic+0x84>
    {
        if(ObjDicList == NULL)
   208d0:	d0a13617 	ldw	r2,-31528(gp)
   208d4:	1000051e 	bne	r2,zero,208ec <COE_AddObjectToDic+0x20>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
   208d8:	d1213615 	stw	r4,-31528(gp)
            ObjDicList->pNext = NULL;
   208dc:	20000115 	stw	zero,4(r4)
            ObjDicList->pPrev = NULL;
   208e0:	20000015 	stw	zero,0(r4)
            return 0;
   208e4:	0005883a 	mov	r2,zero
   208e8:	f800283a 	ret
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
   208ec:	1140020b 	ldhu	r5,8(r2)
   208f0:	20c0020b 	ldhu	r3,8(r4)
   208f4:	1940142e 	bgeu	r3,r5,20948 <COE_AddObjectToDic+0x7c>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
   208f8:	20000015 	stw	zero,0(r4)
            pNewObjEntry->pNext = ObjDicList;
   208fc:	20800115 	stw	r2,4(r4)
            ObjDicList->pPrev = pNewObjEntry;
   20900:	11000015 	stw	r4,0(r2)
            ObjDicList = pNewObjEntry;
   20904:	d1213615 	stw	r4,-31528(gp)
            return 0;
   20908:	003ff606 	br	208e4 <COE_AddObjectToDic+0x18>
                if(pDicEntry->Index == pNewObjEntry->Index)
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
   2090c:	1940072e 	bgeu	r3,r5,2092c <COE_AddObjectToDic+0x60>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20910:	10c00017 	ldw	r3,0(r2)
                    pNewObjEntry->pNext = pDicEntry;
   20914:	20800115 	stw	r2,4(r4)
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20918:	20c00015 	stw	r3,0(r4)

                    if(pDicEntry->pPrev != NULL)
   2091c:	18000126 	beq	r3,zero,20924 <COE_AddObjectToDic+0x58>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
   20920:	19000115 	stw	r4,4(r3)

                    pDicEntry->pPrev = pNewObjEntry;
   20924:	11000015 	stw	r4,0(r2)

                    return 0;
   20928:	003fee06 	br	208e4 <COE_AddObjectToDic+0x18>
                }
                else if(pDicEntry->pNext == NULL)
   2092c:	11400117 	ldw	r5,4(r2)
   20930:	2800041e 	bne	r5,zero,20944 <COE_AddObjectToDic+0x78>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
   20934:	11000115 	stw	r4,4(r2)
                    pNewObjEntry->pPrev = pDicEntry;
   20938:	20800015 	stw	r2,0(r4)
                    pNewObjEntry->pNext = NULL;
   2093c:	20000115 	stw	zero,4(r4)
                    return 0;
   20940:	003fe806 	br	208e4 <COE_AddObjectToDic+0x18>
   20944:	2805883a 	mov	r2,r5
                if(pDicEntry->Index == pNewObjEntry->Index)
   20948:	1140020b 	ldhu	r5,8(r2)
   2094c:	197fef1e 	bne	r3,r5,2090c <COE_AddObjectToDic+0x40>
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
   20950:	00800044 	movi	r2,1
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
}
   20954:	f800283a 	ret

00020958 <COE_RemoveDicEntry>:

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20958:	d1613617 	ldw	r5,-31528(gp)

    while(pDicEntry != NULL)
    {
        if(pDicEntry->Index == index)
   2095c:	213fffcc 	andi	r4,r4,65535
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20960:	2805883a 	mov	r2,r5
    while(pDicEntry != NULL)
   20964:	1000011e 	bne	r2,zero,2096c <COE_RemoveDicEntry+0x14>
            return;
        }

        pDicEntry = pDicEntry->pNext;
    }
}
   20968:	f800283a 	ret
        if(pDicEntry->Index == index)
   2096c:	1180020b 	ldhu	r6,8(r2)
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20970:	10c00117 	ldw	r3,4(r2)
        if(pDicEntry->Index == index)
   20974:	31000b1e 	bne	r6,r4,209a4 <COE_RemoveDicEntry+0x4c>
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
   20978:	11000017 	ldw	r4,0(r2)
            if(pPrevEntry != NULL)
   2097c:	20000126 	beq	r4,zero,20984 <COE_RemoveDicEntry+0x2c>
                pPrevEntry->pNext = pNextEntry;
   20980:	20c00115 	stw	r3,4(r4)
            if(pNextEntry != NULL)
   20984:	18000126 	beq	r3,zero,2098c <COE_RemoveDicEntry+0x34>
                pNextEntry->pPrev = pPrevEntry;
   20988:	19000015 	stw	r4,0(r3)
            pDicEntry->pPrev = NULL;
   2098c:	10000015 	stw	zero,0(r2)
            pDicEntry->pNext = NULL;
   20990:	10000115 	stw	zero,4(r2)
            if(pDicEntry->Index == ObjDicList->Index)
   20994:	2880020b 	ldhu	r2,8(r5)
   20998:	30bff31e 	bne	r6,r2,20968 <COE_RemoveDicEntry+0x10>
                ObjDicList = pNextEntry;
   2099c:	d0e13615 	stw	r3,-31528(gp)
   209a0:	f800283a 	ret
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   209a4:	1805883a 	mov	r2,r3
   209a8:	003fee06 	br	20964 <COE_RemoveDicEntry+0xc>

000209ac <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
   209ac:	defffe04 	addi	sp,sp,-8
   209b0:	dc000015 	stw	r16,0(sp)
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
   209b4:	d4213617 	ldw	r16,-31528(gp)
{
   209b8:	dfc00115 	stw	ra,4(sp)
    UINT16 Index = 0;

    while(pObjEntry != NULL)
   209bc:	8000051e 	bne	r16,zero,209d4 <COE_ClearObjDictionary+0x28>
        Index = pObjEntry->Index;
        pObjEntry = pObjEntry->pNext;

        COE_RemoveDicEntry(Index);
    }
    ObjDicList = NULL;
   209c0:	d0213615 	stw	zero,-31528(gp)
}
   209c4:	dfc00117 	ldw	ra,4(sp)
   209c8:	dc000017 	ldw	r16,0(sp)
   209cc:	dec00204 	addi	sp,sp,8
   209d0:	f800283a 	ret
        Index = pObjEntry->Index;
   209d4:	8100020b 	ldhu	r4,8(r16)
        pObjEntry = pObjEntry->pNext;
   209d8:	84000117 	ldw	r16,4(r16)
        COE_RemoveDicEntry(Index);
   209dc:	213fffcc 	andi	r4,r4,65535
   209e0:	00209580 	call	20958 <COE_RemoveDicEntry>
   209e4:	003ff506 	br	209bc <COE_ClearObjDictionary+0x10>

000209e8 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
   209e8:	defffd04 	addi	sp,sp,-12
   209ec:	dc400115 	stw	r17,4(sp)
   209f0:	dc000015 	stw	r16,0(sp)
   209f4:	dfc00215 	stw	ra,8(sp)
   209f8:	2021883a 	mov	r16,r4
    UINT16 result = 0;
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;

    while(pEntry->Index != 0xFFFF)
   209fc:	047fffd4 	movui	r17,65535
   20a00:	8080020b 	ldhu	r2,8(r16)
   20a04:	1440061e 	bne	r2,r17,20a20 <AddObjectsToObjDictionary+0x38>
        }

        pEntry++;
    }

    return result;
   20a08:	0005883a 	mov	r2,zero

}
   20a0c:	dfc00217 	ldw	ra,8(sp)
   20a10:	dc400117 	ldw	r17,4(sp)
   20a14:	dc000017 	ldw	r16,0(sp)
   20a18:	dec00304 	addi	sp,sp,12
   20a1c:	f800283a 	ret
        result = COE_AddObjectToDic(pEntry);
   20a20:	8009883a 	mov	r4,r16
   20a24:	00208cc0 	call	208cc <COE_AddObjectToDic>
        if(result != 0)
   20a28:	10ffffcc 	andi	r3,r2,65535
   20a2c:	183ff71e 	bne	r3,zero,20a0c <AddObjectsToObjDictionary+0x24>
        pEntry++;
   20a30:	84000a04 	addi	r16,r16,40
   20a34:	003ff206 	br	20a00 <AddObjectsToObjDictionary+0x18>

00020a38 <COE_ObjDictionaryInit>:
    UINT16 result = 0;

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20a38:	010000b4 	movhi	r4,2
{
   20a3c:	deffff04 	addi	sp,sp,-4
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20a40:	211ffd04 	addi	r4,r4,32756
{
   20a44:	dfc00015 	stw	ra,0(sp)
    ObjDicList = NULL;
   20a48:	d0213615 	stw	zero,-31528(gp)
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20a4c:	00209e80 	call	209e8 <AddObjectsToObjDictionary>

    if(result != 0)
   20a50:	10ffffcc 	andi	r3,r2,65535
   20a54:	1800051e 	bne	r3,zero,20a6c <COE_ObjDictionaryInit+0x34>
        return result;
    }
    
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20a58:	010000f4 	movhi	r4,3
   20a5c:	21207d04 	addi	r4,r4,-32268
    }



    return result;
}
   20a60:	dfc00017 	ldw	ra,0(sp)
   20a64:	dec00104 	addi	sp,sp,4
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20a68:	00209e81 	jmpi	209e8 <AddObjectsToObjDictionary>
}
   20a6c:	dfc00017 	ldw	ra,0(sp)
   20a70:	dec00104 	addi	sp,sp,4
   20a74:	f800283a 	ret

00020a78 <COE_ObjInit>:
    sSyncManOutPar.subindex0         = 32;
   20a78:	01400804 	movi	r5,32
   20a7c:	00c000f4 	movhi	r3,3
   20a80:	19633515 	stw	r5,-29484(r3)
    sSyncManOutPar.u32CycleTime     = 0;
   20a84:	00c000f4 	movhi	r3,3
{
   20a88:	defffe04 	addi	sp,sp,-8
    sSyncManOutPar.u32CycleTime     = 0;
   20a8c:	18233615 	stw	zero,-29480(r3)
    sSyncManOutPar.subindex0         = 32;
   20a90:	008000f4 	movhi	r2,3
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20a94:	00c000b4 	movhi	r3,2
{
   20a98:	dfc00115 	stw	ra,4(sp)
    sSyncManOutPar.subindex0         = 32;
   20a9c:	10a33504 	addi	r2,r2,-29484
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20aa0:	011007c4 	movi	r4,16415
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20aa4:	18e1a804 	addi	r3,r3,-31072
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20aa8:	1100030d 	sth	r4,12(r2)
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20aac:	10c00415 	stw	r3,16(r2)
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   20ab0:	008000f4 	movhi	r2,3
   20ab4:	10233a15 	stw	zero,-29464(r2)
    sSyncManOutPar.u16GetCycleTime = 0;
   20ab8:	008000f4 	movhi	r2,3
   20abc:	10233c0d 	sth	zero,-29456(r2)
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
   20ac0:	008000f4 	movhi	r2,3
   20ac4:	10233d15 	stw	zero,-29452(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   20ac8:	008000f4 	movhi	r2,3
   20acc:	10233f15 	stw	zero,-29444(r2)
    sSyncManOutPar.u8SyncError = 0;
   20ad0:	008000f4 	movhi	r2,3
   20ad4:	10234505 	stb	zero,-29420(r2)
    sSyncManInPar.subindex0         = 32;
   20ad8:	008000f4 	movhi	r2,3
   20adc:	10a32404 	addi	r2,r2,-29552
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
   20ae0:	1100030d 	sth	r4,12(r2)
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20ae4:	10c00415 	stw	r3,16(r2)
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   20ae8:	008000f4 	movhi	r2,3
   20aec:	10232915 	stw	zero,-29532(r2)
    sSyncManInPar.u16GetCycleTime = 0;
   20af0:	008000f4 	movhi	r2,3
   20af4:	10232b0d 	sth	zero,-29524(r2)
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20af8:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20afc:	018000f4 	movhi	r6,3
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20b00:	10232c15 	stw	zero,-29520(r2)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20b04:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20b08:	31632415 	stw	r5,-29552(r6)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20b0c:	10232e15 	stw	zero,-29512(r2)
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20b10:	014000f4 	movhi	r5,3
    sSyncManInPar.u8SyncError = 0;
   20b14:	008000f4 	movhi	r2,3
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20b18:	28232515 	stw	zero,-29548(r5)
    sSyncManInPar.u8SyncError = 0;
   20b1c:	10233405 	stb	zero,-29488(r2)
    bSyncSetByUser = FALSE;
   20b20:	d0216e85 	stb	zero,-31302(gp)
    UINT16 result = COE_ObjDictionaryInit();
   20b24:	0020a380 	call	20a38 <COE_ObjDictionaryInit>
    if(result != 0)
   20b28:	10bfffcc 	andi	r2,r2,65535
   20b2c:	10000126 	beq	r2,zero,20b34 <COE_ObjInit+0xbc>
        COE_ClearObjDictionary();
   20b30:	00209ac0 	call	209ac <COE_ClearObjDictionary>
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20b34:	01800104 	movi	r6,4
   20b38:	01400204 	movi	r5,8
   20b3c:	d809883a 	mov	r4,sp
    u8PendingSdo = 0;
   20b40:	d0217d05 	stb	zero,-31244(gp)
    bStoreCompleteAccess = FALSE;
   20b44:	d0217cc5 	stb	zero,-31245(gp)
    u16StoreIndex   =   0;
   20b48:	d0217c0d 	sth	zero,-31248(gp)
    u8StoreSubindex = 0;
   20b4c:	d0217c85 	stb	zero,-31246(gp)
    u32StoreDataSize = 0;
   20b50:	d0217b15 	stw	zero,-31252(gp)
    pStoreData = NULL;
   20b54:	d0217a15 	stw	zero,-31256(gp)
    pSdoPendFunc    = NULL;
   20b58:	d0217915 	stw	zero,-31260(gp)
    pSdoSegData = NULL;
   20b5c:	d0217815 	stw	zero,-31264(gp)
        UINT32 EscFeature = 0;
   20b60:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20b64:	00205e80 	call	205e8 <HW_EscRead>
        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
   20b68:	d8800017 	ldw	r2,0(sp)
   20b6c:	1080020c 	andi	r2,r2,8
   20b70:	10000626 	beq	r2,zero,20b8c <COE_ObjInit+0x114>
            b32BitDc = FALSE;
   20b74:	d0215c85 	stb	zero,-31374(gp)
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20b78:	0083e804 	movi	r2,4000
   20b7c:	d0a13815 	stw	r2,-31520(gp)
}
   20b80:	dfc00117 	ldw	ra,4(sp)
   20b84:	dec00204 	addi	sp,sp,8
   20b88:	f800283a 	ret
            b32BitDc = TRUE;
   20b8c:	00800044 	movi	r2,1
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20b90:	01800104 	movi	r6,4
   20b94:	01424404 	movi	r5,2320
   20b98:	d1213904 	addi	r4,gp,-31516
            b32BitDc = TRUE;
   20b9c:	d0a15c85 	stb	r2,-31374(gp)
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20ba0:	00205e80 	call	205e8 <HW_EscRead>
   20ba4:	003ff406 	br	20b78 <COE_ObjInit+0x100>

00020ba8 <COE_Main>:

void COE_Main(void)
{
     UINT8 abort = 0;
     
    if(pSdoPendFunc != NULL)
   20ba8:	d0a17917 	ldw	r2,-31260(gp)
   20bac:	10003026 	beq	r2,zero,20c70 <COE_Main+0xc8>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20bb0:	d0e17cc3 	ldbu	r3,-31245(gp)
   20bb4:	d1e17a17 	ldw	r7,-31256(gp)
   20bb8:	d1a17b17 	ldw	r6,-31252(gp)
   20bbc:	d1617c83 	ldbu	r5,-31246(gp)
   20bc0:	d1217c0b 	ldhu	r4,-31248(gp)
{
   20bc4:	defffd04 	addi	sp,sp,-12
   20bc8:	dc000115 	stw	r16,4(sp)
   20bcc:	dfc00215 	stw	ra,8(sp)
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20bd0:	d8c00015 	stw	r3,0(sp)
   20bd4:	103ee83a 	callr	r2

        if(abort != ABORTIDX_WORKING)
   20bd8:	14003fcc 	andi	r16,r2,255
   20bdc:	80803fe0 	cmpeqi	r2,r16,255
   20be0:	10000f1e 	bne	r2,zero,20c20 <COE_Main+0x78>
        {
            switch(u8PendingSdo)
   20be4:	d0e17d03 	ldbu	r3,-31244(gp)
   20be8:	18803fcc 	andi	r2,r3,255
   20bec:	110000a0 	cmpeqi	r4,r2,2
   20bf0:	2000161e 	bne	r4,zero,20c4c <COE_Main+0xa4>
   20bf4:	110000e8 	cmpgeui	r4,r2,3
   20bf8:	20000d1e 	bne	r4,zero,20c30 <COE_Main+0x88>
   20bfc:	10800060 	cmpeqi	r2,r2,1
   20c00:	1000161e 	bne	r2,zero,20c5c <COE_Main+0xb4>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
                    break;

            }

            u8PendingSdo = 0;
   20c04:	d0217d05 	stb	zero,-31244(gp)
            u16StoreIndex = 0;
   20c08:	d0217c0d 	sth	zero,-31248(gp)
            u8StoreSubindex = 0;
   20c0c:	d0217c85 	stb	zero,-31246(gp)
            u32StoreDataSize = 0;
   20c10:	d0217b15 	stw	zero,-31252(gp)
            pStoreData = NULL;
   20c14:	d0217a15 	stw	zero,-31256(gp)
            bStoreCompleteAccess = 0;
   20c18:	d0217cc5 	stb	zero,-31245(gp)
            pSdoPendFunc = NULL;
   20c1c:	d0217915 	stw	zero,-31260(gp)
        }
    }
}
   20c20:	dfc00217 	ldw	ra,8(sp)
   20c24:	dc000117 	ldw	r16,4(sp)
   20c28:	dec00304 	addi	sp,sp,12
   20c2c:	f800283a 	ret
            switch(u8PendingSdo)
   20c30:	18ffff44 	addi	r3,r3,-3
   20c34:	18c03fcc 	andi	r3,r3,255
   20c38:	18c000a8 	cmpgeui	r3,r3,2
   20c3c:	183ff11e 	bne	r3,zero,20c04 <COE_Main+0x5c>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20c40:	d1a17a17 	ldw	r6,-31256(gp)
   20c44:	d1617b17 	ldw	r5,-31252(gp)
   20c48:	00000606 	br	20c64 <COE_Main+0xbc>
                    if(pSdoSegData)
   20c4c:	d1217817 	ldw	r4,-31264(gp)
   20c50:	20000226 	beq	r4,zero,20c5c <COE_Main+0xb4>
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
   20c54:	00270640 	call	27064 <free>
                        pSdoSegData = NULL;
   20c58:	d0217815 	stw	zero,-31264(gp)
                    SDOS_SdoRes(abort, 0, NULL);
   20c5c:	000d883a 	mov	r6,zero
   20c60:	000b883a 	mov	r5,zero
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20c64:	8009883a 	mov	r4,r16
   20c68:	00265d40 	call	265d4 <SDOS_SdoRes>
                    break;
   20c6c:	003fe506 	br	20c04 <COE_Main+0x5c>
   20c70:	f800283a 	ret

00020c74 <ECAT_CheckTimer>:

void ECAT_CheckTimer(void)
{

    /*decrement the state transition timeout counter*/
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20c74:	d0a15a83 	ldbu	r2,-31382(gp)
{
   20c78:	deffff04 	addi	sp,sp,-4
   20c7c:	dfc00015 	stw	ra,0(sp)
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20c80:	10000726 	beq	r2,zero,20ca0 <ECAT_CheckTimer+0x2c>
   20c84:	d0a1630b 	ldhu	r2,-31348(gp)
   20c88:	10ffffcc 	andi	r3,r2,65535
   20c8c:	18e0001c 	xori	r3,r3,32768
   20c90:	18e00004 	addi	r3,r3,-32768
   20c94:	00c0020e 	bge	zero,r3,20ca0 <ECAT_CheckTimer+0x2c>
    {
        EsmTimeoutCounter--;
   20c98:	10bfffc4 	addi	r2,r2,-1
   20c9c:	d0a1630d 	sth	r2,-31348(gp)
    }



    DC_CheckWatchdog();
   20ca0:	00235940 	call	23594 <DC_CheckWatchdog>



/*ECATCHANGE_START(V5.13) */
    /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
   20ca4:	d0a15c83 	ldbu	r2,-31374(gp)
   20ca8:	10000426 	beq	r2,zero,20cbc <ECAT_CheckTimer+0x48>
   20cac:	d0e13a17 	ldw	r3,-31512(gp)
   20cb0:	00bff8b4 	movhi	r2,65506
   20cb4:	10bed004 	addi	r2,r2,-1216
   20cb8:	10c00f36 	bltu	r2,r3,20cf8 <ECAT_CheckTimer+0x84>
/*ECATCHANGE_END(V5.13) */
    {

        /* the timestamp is stored in ns */
        u64Timestamp = u64Timestamp + 1000000;
   20cbc:	d0a13a17 	ldw	r2,-31512(gp)
   20cc0:	00c003f4 	movhi	r3,15
   20cc4:	d1213b17 	ldw	r4,-31508(gp)
   20cc8:	18d09004 	addi	r3,r3,16960
   20ccc:	10c7883a 	add	r3,r2,r3
   20cd0:	1885803a 	cmpltu	r2,r3,r2
   20cd4:	1105883a 	add	r2,r2,r4
   20cd8:	d0e13a15 	stw	r3,-31512(gp)
   20cdc:	d0a13b15 	stw	r2,-31508(gp)
    {
        /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
    }

    u32CheckForDcOverrunCnt++;
   20ce0:	d0a13817 	ldw	r2,-31520(gp)
   20ce4:	10800044 	addi	r2,r2,1
   20ce8:	d0a13815 	stw	r2,-31520(gp)


}
   20cec:	dfc00017 	ldw	ra,0(sp)
   20cf0:	dec00104 	addi	sp,sp,4
   20cf4:	f800283a 	ret
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20cf8:	0083e804 	movi	r2,4000
   20cfc:	d0a13815 	stw	r2,-31520(gp)
   20d00:	003ff706 	br	20ce0 <ECAT_CheckTimer+0x6c>

00020d04 <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
   20d04:	defffd04 	addi	sp,sp,-12
   20d08:	dc000115 	stw	r16,4(sp)
   UINT32 u32CurValue = 0;
   UINT32 u32Delta = 0;

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20d0c:	01800104 	movi	r6,4
{
   20d10:	2021883a 	mov	r16,r4
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20d14:	01424404 	movi	r5,2320
   20d18:	d809883a 	mov	r4,sp
{
   20d1c:	dfc00215 	stw	ra,8(sp)
   UINT32 u32CurValue = 0;
   20d20:	d8000015 	stw	zero,0(sp)
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20d24:	00206600 	call	20660 <HW_EscReadIsr>

   if (u32CurValue > 0)
   20d28:	d8800017 	ldw	r2,0(sp)
   20d2c:	10000626 	beq	r2,zero,20d48 <GetSystemTimeDelay+0x44>
   {
      if (u32StartTime <= u32CurValue)
   20d30:	14000936 	bltu	r2,r16,20d58 <GetSystemTimeDelay+0x54>
      {
         u32Delta = u32CurValue - u32StartTime;
   20d34:	1405c83a 	sub	r2,r2,r16
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
      }
   }// current value successfully read out

   if (u32StartTime > 0)
   20d38:	80000326 	beq	r16,zero,20d48 <GetSystemTimeDelay+0x44>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
   20d3c:	d0e13f17 	ldw	r3,-31492(gp)
   20d40:	1880082e 	bgeu	r3,r2,20d64 <GetSystemTimeDelay+0x60>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
   20d44:	10c5c83a 	sub	r2,r2,r3
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
       }
   }
   return u32Delta;
}
   20d48:	dfc00217 	ldw	ra,8(sp)
   20d4c:	dc000117 	ldw	r16,4(sp)
   20d50:	dec00304 	addi	sp,sp,12
   20d54:	f800283a 	ret
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
   20d58:	10bfffc4 	addi	r2,r2,-1
   20d5c:	1405c83a 	sub	r2,r2,r16
   if (u32StartTime > 0)
   20d60:	003ff606 	br	20d3c <GetSystemTimeDelay+0x38>
   UINT32 u32Delta = 0;
   20d64:	0005883a 	mov	r2,zero
   return u32Delta;
   20d68:	003ff706 	br	20d48 <GetSystemTimeDelay+0x44>

00020d6c <PDO_InputMapping>:
{
   20d6c:	defffc04 	addi	sp,sp,-16
   20d70:	dc800215 	stw	r18,8(sp)
   20d74:	dc000015 	stw	r16,0(sp)
    if (MEASUREMENT_ACTIVE)
   20d78:	048000f4 	movhi	r18,3
   20d7c:	040000f4 	movhi	r16,3
{
   20d80:	dfc00315 	stw	ra,12(sp)
   20d84:	dc400115 	stw	r17,4(sp)
    if (MEASUREMENT_ACTIVE)
   20d88:	94a33504 	addi	r18,r18,-29484
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
   20d8c:	00205c00 	call	205c0 <HW_GetALEventRegister_Isr>
    if (MEASUREMENT_ACTIVE)
   20d90:	84232404 	addi	r16,r16,-29552
   20d94:	9080070b 	ldhu	r2,28(r18)
   20d98:	80c0070b 	ldhu	r3,28(r16)
   20d9c:	10c4b03a 	or	r2,r2,r3
   20da0:	1080004c 	andi	r2,r2,1
   20da4:	10001b26 	beq	r2,zero,20e14 <PDO_InputMapping+0xa8>
        u32TimeValue = GetSystemTimeDelay(0);
   20da8:	0009883a 	mov	r4,zero
   20dac:	0020d040 	call	20d04 <GetSystemTimeDelay>
   20db0:	1023883a 	mov	r17,r2
    APPL_InputMapping((UINT16*)aPdInputData);
   20db4:	010000f4 	movhi	r4,3
   20db8:	21227d04 	addi	r4,r4,-30220
   20dbc:	00202780 	call	20278 <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
   20dc0:	d1a1598b 	ldhu	r6,-31386(gp)
   20dc4:	d161560b 	ldhu	r5,-31400(gp)
   20dc8:	010000f4 	movhi	r4,3
   20dcc:	21227d04 	addi	r4,r4,-30220
   20dd0:	00207300 	call	20730 <HW_EscWriteIsr>
    if (MEASUREMENT_ACTIVE)
   20dd4:	90c0070b 	ldhu	r3,28(r18)
   20dd8:	8080070b 	ldhu	r2,28(r16)
   20ddc:	1886b03a 	or	r3,r3,r2
   20de0:	18c0004c 	andi	r3,r3,1
   20de4:	18000526 	beq	r3,zero,20dfc <PDO_InputMapping+0x90>
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20de8:	8809883a 	mov	r4,r17
   20dec:	0020d040 	call	20d04 <GetSystemTimeDelay>
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
   20df0:	80c00517 	ldw	r3,20(r16)
   20df4:	1880012e 	bgeu	r3,r2,20dfc <PDO_InputMapping+0x90>
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
   20df8:	80800515 	stw	r2,20(r16)
}
   20dfc:	dfc00317 	ldw	ra,12(sp)
   20e00:	dc800217 	ldw	r18,8(sp)
   20e04:	dc400117 	ldw	r17,4(sp)
   20e08:	dc000017 	ldw	r16,0(sp)
   20e0c:	dec00404 	addi	sp,sp,16
   20e10:	f800283a 	ret
    UINT32 u32TimeValue = 0;
   20e14:	0023883a 	mov	r17,zero
   20e18:	003fe606 	br	20db4 <PDO_InputMapping+0x48>

00020e1c <HandleCycleTimeMeasurement>:
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
   20e1c:	d0a16383 	ldbu	r2,-31346(gp)
   20e20:	1000181e 	bne	r2,zero,20e84 <HandleCycleTimeMeasurement+0x68>
        if (u32CycleTimeStartValue > 0)
   20e24:	d1214117 	ldw	r4,-31484(gp)
{
   20e28:	deffff04 	addi	sp,sp,-4
   20e2c:	dfc00015 	stw	ra,0(sp)
        if (u32CycleTimeStartValue > 0)
   20e30:	20000e26 	beq	r4,zero,20e6c <HandleCycleTimeMeasurement+0x50>
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20e34:	0020d040 	call	20d04 <GetSystemTimeDelay>
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20e38:	00c000f4 	movhi	r3,3
   20e3c:	18e33504 	addi	r3,r3,-29484
   20e40:	19000117 	ldw	r4,4(r3)
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20e44:	d0a14115 	stw	r2,-31484(gp)
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20e48:	20000126 	beq	r4,zero,20e50 <HandleCycleTimeMeasurement+0x34>
   20e4c:	1100012e 	bgeu	r2,r4,20e54 <HandleCycleTimeMeasurement+0x38>
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
   20e50:	18800115 	stw	r2,4(r3)
            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
   20e54:	00c000f4 	movhi	r3,3
   20e58:	18e32404 	addi	r3,r3,-29552
   20e5c:	19000117 	ldw	r4,4(r3)
   20e60:	20000126 	beq	r4,zero,20e68 <HandleCycleTimeMeasurement+0x4c>
   20e64:	1100012e 	bgeu	r2,r4,20e6c <HandleCycleTimeMeasurement+0x50>
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
   20e68:	18800115 	stw	r2,4(r3)
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
   20e6c:	0009883a 	mov	r4,zero
   20e70:	0020d040 	call	20d04 <GetSystemTimeDelay>
   20e74:	d0a14115 	stw	r2,-31484(gp)
}
   20e78:	dfc00017 	ldw	ra,0(sp)
   20e7c:	dec00104 	addi	sp,sp,4
   20e80:	f800283a 	ret
   20e84:	f800283a 	ret

00020e88 <PDO_OutputMapping>:
{
   20e88:	defffc04 	addi	sp,sp,-16
   20e8c:	dc800215 	stw	r18,8(sp)
   20e90:	dc000015 	stw	r16,0(sp)
   if (MEASUREMENT_ACTIVE)
   20e94:	048000f4 	movhi	r18,3
   20e98:	040000f4 	movhi	r16,3
   20e9c:	84233504 	addi	r16,r16,-29484
   20ea0:	94a32404 	addi	r18,r18,-29552
   20ea4:	8080070b 	ldhu	r2,28(r16)
   20ea8:	90c0070b 	ldhu	r3,28(r18)
{
   20eac:	dfc00315 	stw	ra,12(sp)
   20eb0:	dc400115 	stw	r17,4(sp)
   if (MEASUREMENT_ACTIVE)
   20eb4:	10c4b03a 	or	r2,r2,r3
   20eb8:	1080004c 	andi	r2,r2,1
   20ebc:	10002026 	beq	r2,zero,20f40 <PDO_OutputMapping+0xb8>
      u32TimeValue = GetSystemTimeDelay(0);
   20ec0:	0009883a 	mov	r4,zero
   20ec4:	0020d040 	call	20d04 <GetSystemTimeDelay>
   20ec8:	1023883a 	mov	r17,r2
      u32MinCycleTimeStartValue = u32TimeValue;
   20ecc:	d0a14015 	stw	r2,-31488(gp)
      bMinCycleTimeMeasurementStarted = TRUE;
   20ed0:	00800044 	movi	r2,1
   20ed4:	d0a13e05 	stb	r2,-31496(gp)
      u32MinCycleTimeValue = 0;
   20ed8:	d0213d15 	stw	zero,-31500(gp)
      HandleCycleTimeMeasurement();
   20edc:	0020e1c0 	call	20e1c <HandleCycleTimeMeasurement>
    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
   20ee0:	d1a1590b 	ldhu	r6,-31388(gp)
   20ee4:	d161568b 	ldhu	r5,-31398(gp)
   20ee8:	010000f4 	movhi	r4,3
   20eec:	21230604 	addi	r4,r4,-29672
   20ef0:	00206600 	call	20660 <HW_EscReadIsr>
    APPL_OutputMapping((UINT16*) aPdOutputData);
   20ef4:	010000f4 	movhi	r4,3
   20ef8:	21230604 	addi	r4,r4,-29672
   20efc:	00202c40 	call	202c4 <APPL_OutputMapping>
    if (MEASUREMENT_ACTIVE)
   20f00:	8080070b 	ldhu	r2,28(r16)
   20f04:	90c0070b 	ldhu	r3,28(r18)
   20f08:	10c4b03a 	or	r2,r2,r3
   20f0c:	1080004c 	andi	r2,r2,1
   20f10:	10000526 	beq	r2,zero,20f28 <PDO_OutputMapping+0xa0>
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20f14:	8809883a 	mov	r4,r17
   20f18:	0020d040 	call	20d04 <GetSystemTimeDelay>
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
   20f1c:	80c00517 	ldw	r3,20(r16)
   20f20:	1880012e 	bgeu	r3,r2,20f28 <PDO_OutputMapping+0xa0>
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
   20f24:	80800515 	stw	r2,20(r16)
}
   20f28:	dfc00317 	ldw	ra,12(sp)
   20f2c:	dc800217 	ldw	r18,8(sp)
   20f30:	dc400117 	ldw	r17,4(sp)
   20f34:	dc000017 	ldw	r16,0(sp)
   20f38:	dec00404 	addi	sp,sp,16
   20f3c:	f800283a 	ret
   UINT32 u32TimeValue = 0;
   20f40:	0023883a 	mov	r17,zero
   20f44:	003fe606 	br	20ee0 <PDO_OutputMapping+0x58>

00020f48 <Sync1_Isr>:
void Sync1_Isr(void)
{
    Sync1WdCounter = 0;

    /*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   20f48:	d0a16443 	ldbu	r2,-31343(gp)
    Sync1WdCounter = 0;
   20f4c:	d0215e8d 	sth	zero,-31366(gp)
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   20f50:	10800058 	cmpnei	r2,r2,1
   20f54:	10000f1e 	bne	r2,zero,20f94 <Sync1_Isr+0x4c>
   20f58:	d0a1598b 	ldhu	r2,-31386(gp)
   20f5c:	10000d26 	beq	r2,zero,20f94 <Sync1_Isr+0x4c>
/*ECATCHANGE_END(V5.13) ECAT 5*/
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
   20f60:	008000f4 	movhi	r2,3
   20f64:	10a3248b 	ldhu	r2,-29550(r2)
   20f68:	108000d8 	cmpnei	r2,r2,3
   20f6c:	1000091e 	bne	r2,zero,20f94 <Sync1_Isr+0x4c>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
   20f70:	d0a15d8b 	ldhu	r2,-31370(gp)
   20f74:	1000071e 	bne	r2,zero,20f94 <Sync1_Isr+0x4c>
{
   20f78:	deffff04 	addi	sp,sp,-4
   20f7c:	dfc00015 	stw	ra,0(sp)
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
   20f80:	0020d6c0 	call	20d6c <PDO_InputMapping>
        }

        /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
        LatchInputSync0Counter = 0;
   20f84:	d0215d0d 	sth	zero,-31372(gp)
}
   20f88:	dfc00017 	ldw	ra,0(sp)
   20f8c:	dec00104 	addi	sp,sp,4
   20f90:	f800283a 	ret
        LatchInputSync0Counter = 0;
   20f94:	d0215d0d 	sth	zero,-31372(gp)
   20f98:	f800283a 	ret

00020f9c <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
   20f9c:	defffc04 	addi	sp,sp,-16
   20fa0:	dfc00315 	stw	ra,12(sp)
   20fa4:	dc000215 	stw	r16,8(sp)

/* Reset application function pointer*/



    pAPPL_FoeRead = NULL;
   20fa8:	d0214915 	stw	zero,-31452(gp)
    pAPPL_FoeReadData = NULL;
   20fac:	d0214815 	stw	zero,-31456(gp)
    pAPPL_FoeError = NULL;
   20fb0:	d0214715 	stw	zero,-31460(gp)
    pAPPL_FoeWrite = NULL;
   20fb4:	d0214615 	stw	zero,-31464(gp)
    pAPPL_FoeWriteData = NULL;
   20fb8:	d0214515 	stw	zero,-31468(gp)

    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
   20fbc:	d0214415 	stw	zero,-31472(gp)
    pAPPL_CoeWriteInd = NULL;
   20fc0:	d0214315 	stw	zero,-31476(gp)
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
   20fc4:	d0214215 	stw	zero,-31480(gp)

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
   20fc8:	00239100 	call	23910 <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
   20fcc:	0020a780 	call	20a78 <COE_ObjInit>

    /*Reset PDI Access*/
    {
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values

    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20fd0:	01800084 	movi	r6,2
   20fd4:	01414004 	movi	r5,1280
   20fd8:	d9000104 	addi	r4,sp,4
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values
   20fdc:	d800010d 	sth	zero,4(sp)
    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20fe0:	00205e80 	call	205e8 <HW_EscRead>
    eepromConfigControl = SWAPWORD(eepromConfigControl);
   20fe4:	d880010b 	ldhu	r2,4(sp)

    if((eepromConfigControl & ESC_EEPROM_ASSIGN_TO_PDI_MASK) > 0)
   20fe8:	10c0004c 	andi	r3,r2,1
   20fec:	18000626 	beq	r3,zero,21008 <MainInit+0x6c>
    {
        /*Clear access register(0x0501.1)*/
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   20ff0:	10bfbfcc 	andi	r2,r2,65279

        eepromConfigControl = SWAPWORD(eepromConfigControl);
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   20ff4:	01800084 	movi	r6,2
   20ff8:	01414004 	movi	r5,1280
   20ffc:	d9000104 	addi	r4,sp,4
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21000:	d880010d 	sth	r2,4(sp)
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21004:	002066c0 	call	2066c <HW_EscWrite>
    }
    }
    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
   21008:	00800044 	movi	r2,1
   2100c:	d0a13c05 	stb	r2,-31504(gp)


    bMinCycleTimeMeasurementStarted = FALSE;
   21010:	d0213e05 	stb	zero,-31496(gp)
    u32CycleTimeStartValue = 0;
   21014:	d0214115 	stw	zero,-31484(gp)
    u32MinCycleTimeStartValue = 0;
   21018:	d0214015 	stw	zero,-31488(gp)

    u32SystemTimeReadFailure = 0;
   2101c:	d0213f15 	stw	zero,-31492(gp)

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
   21020:	d8000015 	stw	zero,0(sp)
       UINT32 u32Cnt = 0;
       UINT32 u32Delta = 0;
   21024:	d8000115 	stw	zero,4(sp)
   21028:	0400fa04 	movi	r16,1000

       while (u32Cnt < 1000)
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
   2102c:	01800104 	movi	r6,4
   21030:	01424404 	movi	r5,2320
   21034:	d809883a 	mov	r4,sp
   21038:	00206600 	call	20660 <HW_EscReadIsr>
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
   2103c:	01800104 	movi	r6,4
   21040:	01424404 	movi	r5,2320
   21044:	d9000104 	addi	r4,sp,4
   21048:	00206600 	call	20660 <HW_EscReadIsr>

            if (u32TimeValue <= u32Delta)
   2104c:	d8800017 	ldw	r2,0(sp)
   21050:	d8c00117 	ldw	r3,4(sp)
   21054:	18800636 	bltu	r3,r2,21070 <MainInit+0xd4>
                    u32Delta = u32Delta - u32TimeValue;
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   21058:	1885c83a 	sub	r2,r3,r2
            }


            if (u32SystemTimeReadFailure == 0)
   2105c:	d0e13f17 	ldw	r3,-31492(gp)
                    u32Delta = u32Delta - u32TimeValue;
   21060:	d8800115 	stw	r2,4(sp)
            if (u32SystemTimeReadFailure == 0)
   21064:	1800041e 	bne	r3,zero,21078 <MainInit+0xdc>
            {
                u32SystemTimeReadFailure = u32Delta;
            }
            else if (u32SystemTimeReadFailure > u32Delta)
            {
                u32SystemTimeReadFailure = u32Delta;
   21068:	d0a13f15 	stw	r2,-31492(gp)
   2106c:	00000306 	br	2107c <MainInit+0xe0>
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   21070:	18ffffc4 	addi	r3,r3,-1
   21074:	003ff806 	br	21058 <MainInit+0xbc>
            else if (u32SystemTimeReadFailure > u32Delta)
   21078:	10fffb36 	bltu	r2,r3,21068 <MainInit+0xcc>
       while (u32Cnt < 1000)
   2107c:	843fffc4 	addi	r16,r16,-1
   21080:	803fea1e 	bne	r16,zero,2102c <MainInit+0x90>



/*Application Init need to be called from the application layer*/
     return Error;
}
   21084:	0005883a 	mov	r2,zero
   21088:	dfc00317 	ldw	ra,12(sp)
   2108c:	dc000217 	ldw	r16,8(sp)
   21090:	dec00404 	addi	sp,sp,16
   21094:	f800283a 	ret

00021098 <ECAT_Application>:
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
   21098:	008000f4 	movhi	r2,3
   2109c:	00c000f4 	movhi	r3,3
   210a0:	10a33c0b 	ldhu	r2,-29456(r2)
   210a4:	18e32b0b 	ldhu	r3,-29524(r3)
   210a8:	10c4b03a 	or	r2,r2,r3
   210ac:	1080004c 	andi	r2,r2,1
   210b0:	10000726 	beq	r2,zero,210d0 <ECAT_Application+0x38>
    {
        if (nPdOutputSize == 0)
   210b4:	d0a1590b 	ldhu	r2,-31388(gp)
   210b8:	1000051e 	bne	r2,zero,210d0 <ECAT_Application+0x38>
{
   210bc:	deffff04 	addi	sp,sp,-4
   210c0:	dfc00015 	stw	ra,0(sp)
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
   210c4:	0020e1c0 	call	20e1c <HandleCycleTimeMeasurement>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
   210c8:	dfc00017 	ldw	ra,0(sp)
   210cc:	dec00104 	addi	sp,sp,4
    APPL_Application();
   210d0:	00203101 	jmpi	20310 <APPL_Application>

000210d4 <Sync0_Isr>:
    if(bDcSyncActive)
   210d4:	d0a16383 	ldbu	r2,-31346(gp)
     Sync0WdCounter = 0;
   210d8:	d0215f8d 	sth	zero,-31362(gp)
    if(bDcSyncActive)
   210dc:	10000d26 	beq	r2,zero,21114 <Sync0_Isr+0x40>
{
   210e0:	defffe04 	addi	sp,sp,-8
   210e4:	dc000015 	stw	r16,0(sp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   210e8:	d4216443 	ldbu	r16,-31343(gp)
{
   210ec:	dfc00115 	stw	ra,4(sp)
   210f0:	d0a1618b 	ldhu	r2,-31354(gp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   210f4:	80c03fcc 	andi	r3,r16,255
   210f8:	18c00060 	cmpeqi	r3,r3,1
   210fc:	1800061e 	bne	r3,zero,21118 <Sync0_Isr+0x44>
        if(u16SmSync0Value > 0)
   21100:	1000181e 	bne	r2,zero,21164 <Sync0_Isr+0x90>
        ECAT_Application();
   21104:	00210980 	call	21098 <ECAT_Application>
}
   21108:	dfc00117 	ldw	ra,4(sp)
   2110c:	dc000017 	ldw	r16,0(sp)
   21110:	dec00204 	addi	sp,sp,8
    COE_UpdateSyncErrorStatus();
   21114:	00208701 	jmpi	20870 <COE_UpdateSyncErrorStatus>
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   21118:	d1215d8b 	ldhu	r4,-31370(gp)
   2111c:	203ff826 	beq	r4,zero,21100 <Sync0_Isr+0x2c>
   21120:	d0e1598b 	ldhu	r3,-31386(gp)
   21124:	183ff626 	beq	r3,zero,21100 <Sync0_Isr+0x2c>
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
   21128:	d0e15d0b 	ldhu	r3,-31372(gp)
   2112c:	197fffcc 	andi	r5,r3,65535
   21130:	2900022e 	bgeu	r5,r4,2113c <Sync0_Isr+0x68>
                LatchInputSync0Counter++;
   21134:	18c00044 	addi	r3,r3,1
   21138:	d0e15d0d 	sth	r3,-31372(gp)
            if (LatchInputSync0Value == LatchInputSync0Counter)
   2113c:	d0e15d0b 	ldhu	r3,-31372(gp)
   21140:	20ffef1e 	bne	r4,r3,21100 <Sync0_Isr+0x2c>
        if(u16SmSync0Value > 0)
   21144:	1000081e 	bne	r2,zero,21168 <Sync0_Isr+0x94>
        ECAT_Application();
   21148:	00210980 	call	21098 <ECAT_Application>
            PDO_InputMapping();
   2114c:	0020d6c0 	call	20d6c <PDO_InputMapping>
            if(LatchInputSync0Value == 1)
   21150:	d0a15d8b 	ldhu	r2,-31370(gp)
   21154:	10800058 	cmpnei	r2,r2,1
   21158:	103feb1e 	bne	r2,zero,21108 <Sync0_Isr+0x34>
                LatchInputSync0Counter = 0;
   2115c:	d0215d0d 	sth	zero,-31372(gp)
   21160:	003fe906 	br	21108 <Sync0_Isr+0x34>
        BOOL bCallInputMapping = FALSE;
   21164:	0021883a 	mov	r16,zero
           if (u16SmSync0Counter > u16SmSync0Value)
   21168:	d0e1620b 	ldhu	r3,-31352(gp)
   2116c:	d121590b 	ldhu	r4,-31388(gp)
   21170:	197fffcc 	andi	r5,r3,65535
   21174:	11400a36 	bltu	r2,r5,211a0 <Sync0_Isr+0xcc>
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   21178:	20002b1e 	bne	r4,zero,21228 <Sync0_Isr+0x154>
   2117c:	d0a1598b 	ldhu	r2,-31386(gp)
   21180:	10002926 	beq	r2,zero,21228 <Sync0_Isr+0x154>
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
   21184:	00205c00 	call	205c0 <HW_GetALEventRegister_Isr>
              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
   21188:	1082000c 	andi	r2,r2,2048
   2118c:	10001f26 	beq	r2,zero,2120c <Sync0_Isr+0x138>
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   21190:	008000f4 	movhi	r2,3
                 u16SmSync0Counter = 0;
   21194:	d021620d 	sth	zero,-31352(gp)
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   21198:	10232e0d 	sth	zero,-29512(r2)
   2119c:	00001606 	br	211f8 <Sync0_Isr+0x124>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   211a0:	20000c1e 	bne	r4,zero,211d4 <Sync0_Isr+0x100>
               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   211a4:	d0a1598b 	ldhu	r2,-31386(gp)
   211a8:	10001326 	beq	r2,zero,211f8 <Sync0_Isr+0x124>
   211ac:	008000f4 	movhi	r2,3
   211b0:	10a32404 	addi	r2,r2,-29552
   211b4:	10c00a0b 	ldhu	r3,40(r2)
   211b8:	014000f4 	movhi	r5,3
   211bc:	2960dd0b 	ldhu	r5,-31884(r5)
   211c0:	193fffcc 	andi	r4,r3,65535
   211c4:	293fef36 	bltu	r5,r4,21184 <Sync0_Isr+0xb0>
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
   211c8:	18c000c4 	addi	r3,r3,3
   211cc:	10c00a0d 	sth	r3,40(r2)
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   211d0:	003fec06 	br	21184 <Sync0_Isr+0xb0>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   211d4:	008000f4 	movhi	r2,3
   211d8:	10a33504 	addi	r2,r2,-29484
   211dc:	010000f4 	movhi	r4,3
   211e0:	10c00a0b 	ldhu	r3,40(r2)
   211e4:	2160dd0b 	ldhu	r5,-31884(r4)
   211e8:	193fffcc 	andi	r4,r3,65535
   211ec:	29000236 	bltu	r5,r4,211f8 <Sync0_Isr+0x124>
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
   211f0:	18c000c4 	addi	r3,r3,3
   211f4:	10c00a0d 	sth	r3,40(r2)
        if (bCallInputMapping == TRUE)
   211f8:	84003fcc 	andi	r16,r16,255
   211fc:	84000058 	cmpnei	r16,r16,1
        ECAT_Application();
   21200:	00210980 	call	21098 <ECAT_Application>
        if (bCallInputMapping == TRUE)
   21204:	803fd126 	beq	r16,zero,2114c <Sync0_Isr+0x78>
   21208:	003fbf06 	br	21108 <Sync0_Isr+0x34>
                if (u16SmSync0Counter <= u16SmSync0Value)
   2120c:	d0a1620b 	ldhu	r2,-31352(gp)
   21210:	d121618b 	ldhu	r4,-31354(gp)
   21214:	10ffffcc 	andi	r3,r2,65535
   21218:	20fff736 	bltu	r4,r3,211f8 <Sync0_Isr+0x124>
                    u16SmSync0Counter++;
   2121c:	10800044 	addi	r2,r2,1
   21220:	d0a1620d 	sth	r2,-31352(gp)
   21224:	003ff406 	br	211f8 <Sync0_Isr+0x124>
               u16SmSync0Counter++;
   21228:	18c00044 	addi	r3,r3,1
   2122c:	d0e1620d 	sth	r3,-31352(gp)
   21230:	003ff106 	br	211f8 <Sync0_Isr+0x124>

00021234 <PDI_Isr>:
{
   21234:	defffb04 	addi	sp,sp,-20
   21238:	dc000115 	stw	r16,4(sp)
   2123c:	dfc00415 	stw	ra,16(sp)
   21240:	dc800315 	stw	r18,12(sp)
   21244:	dc400215 	stw	r17,8(sp)
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
   21248:	00205c00 	call	205c0 <HW_GetALEventRegister_Isr>
   2124c:	1021883a 	mov	r16,r2
    if (ALEvent & SYNC1_EVENT)
   21250:	8080020c 	andi	r2,r16,8
   21254:	10000b1e 	bne	r2,zero,21284 <PDI_Isr+0x50>
    if(bEscIntEnabled)
   21258:	d0a15c43 	ldbu	r2,-31375(gp)
   2125c:	10000f1e 	bne	r2,zero,2129c <PDI_Isr+0x68>
    if (ALEvent & SYNC0_EVENT)
   21260:	8400010c 	andi	r16,r16,4
   21264:	80004d26 	beq	r16,zero,2139c <PDI_Isr+0x168>
        Sync0_Isr();
   21268:	00210d40 	call	210d4 <Sync0_Isr>
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   2126c:	01800104 	movi	r6,4
   21270:	01426304 	movi	r5,2444
   21274:	d809883a 	mov	r4,sp
        volatile UINT32 SyncState = 0;
   21278:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   2127c:	00205e80 	call	205e8 <HW_EscRead>
   21280:	00004606 	br	2139c <PDI_Isr+0x168>
        Sync1_Isr();
   21284:	0020f480 	call	20f48 <Sync1_Isr>
    if(bEscIntEnabled)
   21288:	d0a15c43 	ldbu	r2,-31375(gp)
   2128c:	10004a1e 	bne	r2,zero,213b8 <PDI_Isr+0x184>
    if (ALEvent & SYNC0_EVENT)
   21290:	8400010c 	andi	r16,r16,4
   21294:	803ff526 	beq	r16,zero,2126c <PDI_Isr+0x38>
   21298:	003ff306 	br	21268 <PDI_Isr+0x34>
    BOOL SyncAcknowledgePending = FALSE;
   2129c:	0025883a 	mov	r18,zero
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
   212a0:	044000f4 	movhi	r17,3
   212a4:	8401000c 	andi	r16,r16,1024
   212a8:	8c633504 	addi	r17,r17,-29484
   212ac:	80001226 	beq	r16,zero,212f8 <PDI_Isr+0xc4>
            if(bDcRunning && bDcSyncActive)
   212b0:	d0a16283 	ldbu	r2,-31350(gp)
   212b4:	10000326 	beq	r2,zero,212c4 <PDI_Isr+0x90>
   212b8:	d0a16383 	ldbu	r2,-31346(gp)
   212bc:	10000126 	beq	r2,zero,212c4 <PDI_Isr+0x90>
                u16SmSync0Counter = 0;
   212c0:	d021620d 	sth	zero,-31352(gp)
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
   212c4:	88800a0b 	ldhu	r2,40(r17)
   212c8:	10ffffcc 	andi	r3,r2,65535
   212cc:	18000226 	beq	r3,zero,212d8 <PDI_Isr+0xa4>
                sSyncManOutPar.u16SmEventMissedCounter--;
   212d0:	10bfffc4 	addi	r2,r2,-1
   212d4:	88800a0d 	sth	r2,40(r17)
            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
   212d8:	88c00a0b 	ldhu	r3,40(r17)
   212dc:	008000f4 	movhi	r2,3
   212e0:	10e32e0d 	sth	r3,-29512(r2)
        bEcatFirstOutputsReceived = TRUE;
   212e4:	00800044 	movi	r2,1
   212e8:	d0a16405 	stb	r2,-31344(gp)
        if ( bEcatOutputUpdateRunning )
   212ec:	d0a16483 	ldbu	r2,-31342(gp)
   212f0:	10003326 	beq	r2,zero,213c0 <PDI_Isr+0x18c>
            PDO_OutputMapping();
   212f4:	0020e880 	call	20e88 <PDO_OutputMapping>
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
   212f8:	8880008b 	ldhu	r2,2(r17)
   212fc:	10800058 	cmpnei	r2,r2,1
   21300:	1000011e 	bne	r2,zero,21308 <PDI_Isr+0xd4>
            ECAT_Application();
   21304:	00210980 	call	21098 <ECAT_Application>
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21308:	d0a16443 	ldbu	r2,-31343(gp)
   2130c:	10800058 	cmpnei	r2,r2,1
   21310:	1000091e 	bne	r2,zero,21338 <PDI_Isr+0x104>
   21314:	d0a1598b 	ldhu	r2,-31386(gp)
   21318:	10000726 	beq	r2,zero,21338 <PDI_Isr+0x104>
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
   2131c:	008000f4 	movhi	r2,3
   21320:	10a3248b 	ldhu	r2,-29550(r2)
   21324:	10c00060 	cmpeqi	r3,r2,1
   21328:	1800021e 	bne	r3,zero,21334 <PDI_Isr+0x100>
   2132c:	10800898 	cmpnei	r2,r2,34
   21330:	1000011e 	bne	r2,zero,21338 <PDI_Isr+0x104>
        PDO_InputMapping();
   21334:	0020d6c0 	call	20d6c <PDO_InputMapping>
    ALEvent = HW_GetALEventRegister_Isr();
   21338:	00205c00 	call	205c0 <HW_GetALEventRegister_Isr>
   2133c:	1021883a 	mov	r16,r2
    if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21340:	8081000c 	andi	r2,r16,1024
   21344:	10001126 	beq	r2,zero,2138c <PDI_Isr+0x158>
        sSyncManOutPar.u16CycleExceededCounter++;
   21348:	88800a8b 	ldhu	r2,42(r17)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   2134c:	d161568b 	ldhu	r5,-31398(gp)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21350:	00c000f4 	movhi	r3,3
        sSyncManOutPar.u16CycleExceededCounter++;
   21354:	10800044 	addi	r2,r2,1
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21358:	01800044 	movi	r6,1
   2135c:	d12154c4 	addi	r4,gp,-31405
        sSyncManOutPar.u16CycleExceededCounter++;
   21360:	88800a8d 	sth	r2,42(r17)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21364:	18a32e8d 	sth	r2,-29510(r3)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21368:	00206600 	call	20660 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   2136c:	d161568b 	ldhu	r5,-31398(gp)
   21370:	d0a1590b 	ldhu	r2,-31388(gp)
   21374:	01800044 	movi	r6,1
   21378:	d12154c4 	addi	r4,gp,-31405
   2137c:	288b883a 	add	r5,r5,r2
   21380:	297fffc4 	addi	r5,r5,-1
   21384:	297fffcc 	andi	r5,r5,65535
   21388:	00206600 	call	20660 <HW_EscReadIsr>
    if (ALEvent & SYNC0_EVENT)
   2138c:	8400010c 	andi	r16,r16,4
   21390:	803fb51e 	bne	r16,zero,21268 <PDI_Isr+0x34>
    if (SyncAcknowledgePending)
   21394:	94803fcc 	andi	r18,r18,255
   21398:	903fb41e 	bne	r18,zero,2126c <PDI_Isr+0x38>
    COE_UpdateSyncErrorStatus();
   2139c:	00208700 	call	20870 <COE_UpdateSyncErrorStatus>
}
   213a0:	dfc00417 	ldw	ra,16(sp)
   213a4:	dc800317 	ldw	r18,12(sp)
   213a8:	dc400217 	ldw	r17,8(sp)
   213ac:	dc000117 	ldw	r16,4(sp)
   213b0:	dec00504 	addi	sp,sp,20
   213b4:	f800283a 	ret
        SyncAcknowledgePending = TRUE;
   213b8:	04800044 	movi	r18,1
   213bc:	003fb806 	br	212a0 <PDI_Isr+0x6c>
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   213c0:	d161568b 	ldhu	r5,-31398(gp)
   213c4:	01800044 	movi	r6,1
   213c8:	d12154c4 	addi	r4,gp,-31405
   213cc:	00206600 	call	20660 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   213d0:	d0a1590b 	ldhu	r2,-31388(gp)
   213d4:	d161568b 	ldhu	r5,-31398(gp)
   213d8:	01800044 	movi	r6,1
   213dc:	d12154c4 	addi	r4,gp,-31405
   213e0:	288b883a 	add	r5,r5,r2
   213e4:	297fffc4 	addi	r5,r5,-1
   213e8:	297fffcc 	andi	r5,r5,65535
   213ec:	00206600 	call	20660 <HW_EscReadIsr>
   213f0:	003fc106 	br	212f8 <PDI_Isr+0xc4>

000213f4 <MainLoop>:
    if(bInitFinished == FALSE)
   213f4:	d0a13c03 	ldbu	r2,-31504(gp)
   213f8:	10003226 	beq	r2,zero,214c4 <MainLoop+0xd0>
        if (
   213fc:	d0a15c43 	ldbu	r2,-31375(gp)
{
   21400:	deffff04 	addi	sp,sp,-4
   21404:	dfc00015 	stw	ra,0(sp)
          && !bDcSyncActive                                               /* DC-Synchronous */
   21408:	d0e16383 	ldbu	r3,-31346(gp)
        if (
   2140c:	10000e1e 	bne	r2,zero,21448 <MainLoop+0x54>
          && !bDcSyncActive                                               /* DC-Synchronous */
   21410:	18c03fcc 	andi	r3,r3,255
   21414:	18001826 	beq	r3,zero,21478 <MainLoop+0x84>
        if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
   21418:	d0a13817 	ldw	r2,-31520(gp)
   2141c:	1083e830 	cmpltui	r2,r2,4000
   21420:	1000011e 	bne	r2,zero,21428 <MainLoop+0x34>
            COE_SyncTimeStamp();
   21424:	00207640 	call	20764 <COE_SyncTimeStamp>
        ECAT_Main();
   21428:	00239f40 	call	239f4 <ECAT_Main>
       COE_Main();
   2142c:	0020ba80 	call	20ba8 <COE_Main>
       CheckIfEcatError();
   21430:	00236540 	call	23654 <CheckIfEcatError>
    if (pAPPL_MainLoop != NULL)
   21434:	d0a14217 	ldw	r2,-31480(gp)
   21438:	10001f26 	beq	r2,zero,214b8 <MainLoop+0xc4>
}
   2143c:	dfc00017 	ldw	ra,0(sp)
   21440:	dec00104 	addi	sp,sp,4
        pAPPL_MainLoop();
   21444:	1000683a 	jmp	r2
          && !bDcSyncActive                                               /* DC-Synchronous */
   21448:	d0a16403 	ldbu	r2,-31344(gp)
   2144c:	10c4b03a 	or	r2,r2,r3
   21450:	10803fcc 	andi	r2,r2,255
   21454:	103ff01e 	bne	r2,zero,21418 <MainLoop+0x24>
             ECAT_Application();
   21458:	00210980 	call	21098 <ECAT_Application>
             if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
   2145c:	d0a16443 	ldbu	r2,-31343(gp)
   21460:	10800058 	cmpnei	r2,r2,1
   21464:	103fec1e 	bne	r2,zero,21418 <MainLoop+0x24>
   21468:	d0a1598b 	ldhu	r2,-31386(gp)
   2146c:	103fea26 	beq	r2,zero,21418 <MainLoop+0x24>
                PDO_InputMapping();
   21470:	0020d6c0 	call	20d6c <PDO_InputMapping>
   21474:	003fe806 	br	21418 <MainLoop+0x24>
                UINT16 ALEvent = HW_GetALEventRegister();
   21478:	00206200 	call	20620 <HW_GetALEventRegister>
                if ( ALEvent & PROCESS_OUTPUT_EVENT )
   2147c:	10c1000c 	andi	r3,r2,1024
   21480:	18000626 	beq	r3,zero,2149c <MainLoop+0xa8>
                    bEcatFirstOutputsReceived = TRUE;
   21484:	00800044 	movi	r2,1
   21488:	d0a16405 	stb	r2,-31344(gp)
                    if ( bEcatOutputUpdateRunning )
   2148c:	d0a16483 	ldbu	r2,-31342(gp)
   21490:	103ff126 	beq	r2,zero,21458 <MainLoop+0x64>
                        PDO_OutputMapping();
   21494:	0020e880 	call	20e88 <PDO_OutputMapping>
   21498:	003fef06 	br	21458 <MainLoop+0x64>
                else if ( nPdOutputSize == 0 )
   2149c:	d0e1590b 	ldhu	r3,-31388(gp)
   214a0:	183fed1e 	bne	r3,zero,21458 <MainLoop+0x64>
                    if ( ALEvent & PROCESS_INPUT_EVENT )
   214a4:	1082000c 	andi	r2,r2,2048
   214a8:	103feb26 	beq	r2,zero,21458 <MainLoop+0x64>
                        bEcatFirstOutputsReceived = TRUE;
   214ac:	00800044 	movi	r2,1
   214b0:	d0a16405 	stb	r2,-31344(gp)
   214b4:	003fe806 	br	21458 <MainLoop+0x64>
}
   214b8:	dfc00017 	ldw	ra,0(sp)
   214bc:	dec00104 	addi	sp,sp,4
   214c0:	f800283a 	ret
   214c4:	f800283a 	ret

000214c8 <ESC_EepromAccess>:
 \brief        Controller (switch BIG_ENDIAN_FORMAT set) the data has to be swapped outside
 \brief        of this function)
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access)
{
   214c8:	defff404 	addi	sp,sp,-48
   214cc:	dd000615 	stw	r20,24(sp)
   214d0:	dcc00515 	stw	r19,20(sp)
   214d4:	d9000015 	stw	r4,0(sp)
   214d8:	3029883a 	mov	r20,r6
    UINT8 RetryCnt = MAX_CMD_RETIRES; //Maximum number of retries (evaluated in case of an Acknowledge Error)

    UINT16 nConfig;
    VARVOLATILE UINT16 nControl;

    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   214dc:	d9000104 	addi	r4,sp,4
   214e0:	01800084 	movi	r6,2
{
   214e4:	2827883a 	mov	r19,r5
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   214e8:	01414004 	movi	r5,1280
{
   214ec:	dfc00b15 	stw	ra,44(sp)
   214f0:	dd800815 	stw	r22,32(sp)
   214f4:	dc000215 	stw	r16,8(sp)
   214f8:	382d883a 	mov	r22,r7
   214fc:	3821883a 	mov	r16,r7
   21500:	df000a15 	stw	fp,40(sp)
   21504:	ddc00915 	stw	r23,36(sp)
   21508:	dd400715 	stw	r21,28(sp)
   2150c:	dc800415 	stw	r18,16(sp)
   21510:	dc400315 	stw	r17,12(sp)
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21514:	00205e80 	call	205e8 <HW_EscRead>
    HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21518:	01800084 	movi	r6,2
   2151c:	01414084 	movi	r5,1282
   21520:	d9000184 	addi	r4,sp,6
   21524:	00205e80 	call	205e8 <HW_EscRead>



    if ( nConfig & ESC_EEPROM_ASSIGN_TO_PDI_MASK )
   21528:	d880010b 	ldhu	r2,4(sp)
   2152c:	1080004c 	andi	r2,r2,1
   21530:	10006926 	beq	r2,zero,216d8 <ESC_EepromAccess+0x210>
    {
        /* register 0x500.0 is set (should be written by the master before sending
        the state transition request to PREOP),we have access to the EEPROM */
        UINT16 step = 1; /* we write always only 1 word with one write access */

        if ( access == ESC_RD )
   21534:	84003fcc 	andi	r16,r16,255
   21538:	84000098 	cmpnei	r16,r16,2
   2153c:	1023883a 	mov	r17,r2
   21540:	8000041e 	bne	r16,zero,21554 <ESC_EepromAccess+0x8c>
        {
            /* read access requested, we have to check if we read 2 (register 0x502.6=0)
            or 4 words (register 0x502.6=1) with one access */
            if ( nControl & ESC_EEPROM_SUPPORTED_READBYTES_MASK )
   21544:	d880018b 	ldhu	r2,6(sp)
   21548:	1080100c 	andi	r2,r2,64
   2154c:	10002126 	beq	r2,zero,215d4 <ESC_EepromAccess+0x10c>
            {
                step = 4; /* we get 4 words with one read access */
   21550:	04400104 	movi	r17,4
            }
            else
            {
                if ( access == ESC_RD )
                {
                    UINT16 u16BytesToCopy = (step << 1);
   21554:	882e907a 	slli	r23,r17,1
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21558:	00804004 	movi	r2,256
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   2155c:	01800084 	movi	r6,2
   21560:	01414004 	movi	r5,1280
   21564:	d9000104 	addi	r4,sp,4
            if ( access == ESC_RD )
   21568:	b5803fcc 	andi	r22,r22,255
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   2156c:	d880010d 	sth	r2,4(sp)
        for (i = 0; i < wordsize;)
   21570:	0025883a 	mov	r18,zero
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21574:	002066c0 	call	2066c <HW_EscWrite>
        for (i = 0; i < wordsize;)
   21578:	9d7fffcc 	andi	r21,r19,65535
                if ( access == ESC_RD )
   2157c:	b7000098 	cmpnei	fp,r22,2
        for (i = 0; i < wordsize;)
   21580:	943fffcc 	andi	r16,r18,65535
   21584:	85401536 	bltu	r16,r21,215dc <ESC_EepromAccess+0x114>
    UINT16 u16RetErr = 0;
   21588:	0021883a 	mov	r16,zero
    }

    /* clear EEPROM control register 0x500 */
    nConfig = 0;

    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   2158c:	01800084 	movi	r6,2
   21590:	01414004 	movi	r5,1280
   21594:	d9000104 	addi	r4,sp,4
    nConfig = 0;
   21598:	d800010d 	sth	zero,4(sp)
    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   2159c:	002066c0 	call	2066c <HW_EscWrite>
    return u16RetErr;
}
   215a0:	8005883a 	mov	r2,r16
   215a4:	dfc00b17 	ldw	ra,44(sp)
   215a8:	df000a17 	ldw	fp,40(sp)
   215ac:	ddc00917 	ldw	r23,36(sp)
   215b0:	dd800817 	ldw	r22,32(sp)
   215b4:	dd400717 	ldw	r21,28(sp)
   215b8:	dd000617 	ldw	r20,24(sp)
   215bc:	dcc00517 	ldw	r19,20(sp)
   215c0:	dc800417 	ldw	r18,16(sp)
   215c4:	dc400317 	ldw	r17,12(sp)
   215c8:	dc000217 	ldw	r16,8(sp)
   215cc:	dec00c04 	addi	sp,sp,48
   215d0:	f800283a 	ret
                step = 2; /* we get 2 words with one read access */
   215d4:	04400084 	movi	r17,2
   215d8:	003fde06 	br	21554 <ESC_EepromAccess+0x8c>
            HW_EscWrite((MEM_ADDR *) &wordaddress, ESC_EEPROM_ADDRESS_OFFSET, 4);
   215dc:	01800104 	movi	r6,4
   215e0:	01414104 	movi	r5,1284
   215e4:	d809883a 	mov	r4,sp
   215e8:	002066c0 	call	2066c <HW_EscWrite>
            if ( access == ESC_RD )
   215ec:	b0800098 	cmpnei	r2,r22,2
   215f0:	10001b1e 	bne	r2,zero,21660 <ESC_EepromAccess+0x198>
                nControl = ESC_EEPROM_CMD_READ_MASK;
   215f4:	00804004 	movi	r2,256
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   215f8:	01800084 	movi	r6,2
   215fc:	01414084 	movi	r5,1282
   21600:	d9000184 	addi	r4,sp,6
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   21604:	d880018d 	sth	r2,6(sp)
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21608:	002066c0 	call	2066c <HW_EscWrite>
                HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   2160c:	01800084 	movi	r6,2
   21610:	01414084 	movi	r5,1282
   21614:	d9000184 	addi	r4,sp,6
   21618:	00205e80 	call	205e8 <HW_EscRead>
            while ( nControl & (ESC_EEPROM_BUSY_MASK));
   2161c:	d880018b 	ldhu	r2,6(sp)
   21620:	10bfffcc 	andi	r2,r2,65535
   21624:	10a0001c 	xori	r2,r2,32768
   21628:	10a00004 	addi	r2,r2,-32768
   2162c:	103ff716 	blt	r2,zero,2160c <ESC_EepromAccess+0x144>
            HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21630:	01800084 	movi	r6,2
   21634:	01414084 	movi	r5,1282
   21638:	d9000184 	addi	r4,sp,6
   2163c:	00205e80 	call	205e8 <HW_EscRead>
            if ( nControl & ESC_EEPROM_ERROR_MASK )
   21640:	d880018b 	ldhu	r2,6(sp)
   21644:	109e000c 	andi	r2,r2,30720
   21648:	10000c26 	beq	r2,zero,2167c <ESC_EepromAccess+0x1b4>
                if(!(nControl & ESC_EEPROM_ERROR_CMD_ACK) && (RetryCnt != 0))
   2164c:	d880018b 	ldhu	r2,6(sp)
   21650:	1088000c 	andi	r2,r2,8192
   21654:	1000141e 	bne	r2,zero,216a8 <ESC_EepromAccess+0x1e0>
                    u16RetErr =  ALSTATUSCODE_EE_ERROR;
   21658:	04001444 	movi	r16,81
   2165c:	003fcb06 	br	2158c <ESC_EepromAccess+0xc4>
                HW_EscWriteWord(pData[i],ESC_EEPROM_DATA_OFFSET);
   21660:	8008907a 	slli	r4,r16,1
   21664:	01800084 	movi	r6,2
   21668:	01414204 	movi	r5,1288
   2166c:	a109883a 	add	r4,r20,r4
   21670:	002066c0 	call	2066c <HW_EscWrite>
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   21674:	00808004 	movi	r2,512
   21678:	003fdf06 	br	215f8 <ESC_EepromAccess+0x130>
                if ( access == ESC_RD )
   2167c:	e0000a1e 	bne	fp,zero,216a8 <ESC_EepromAccess+0x1e0>
                    if((u16WordOffset + step) > wordsize)
   21680:	88bfffcc 	andi	r2,r17,65535
   21684:	8085883a 	add	r2,r16,r2
   21688:	a880100e 	bge	r21,r2,216cc <ESC_EepromAccess+0x204>
                        u16BytesToCopy = (wordsize - u16WordOffset) << 1;
   2168c:	9c8dc83a 	sub	r6,r19,r18
   21690:	300c907a 	slli	r6,r6,1
                    HW_EscRead((MEM_ADDR *) &pData[i], ESC_EEPROM_DATA_OFFSET, u16BytesToCopy);
   21694:	8008907a 	slli	r4,r16,1
   21698:	31bfffcc 	andi	r6,r6,65535
   2169c:	01414204 	movi	r5,1288
   216a0:	a109883a 	add	r4,r20,r4
   216a4:	00205e80 	call	205e8 <HW_EscRead>
            if(!(nControl & ESC_EEPROM_ERROR_MASK))
   216a8:	d880018b 	ldhu	r2,6(sp)
   216ac:	109e000c 	andi	r2,r2,30720
   216b0:	1000081e 	bne	r2,zero,216d4 <ESC_EepromAccess+0x20c>
                wordaddress += step;
   216b4:	d8800017 	ldw	r2,0(sp)
   216b8:	88ffffcc 	andi	r3,r17,65535
                u16WordOffset +=step;
   216bc:	9465883a 	add	r18,r18,r17
                wordaddress += step;
   216c0:	10c5883a 	add	r2,r2,r3
   216c4:	d8800015 	stw	r2,0(sp)
                i += step;
   216c8:	003fad06 	br	21580 <ESC_EepromAccess+0xb8>
                    UINT16 u16BytesToCopy = (step << 1);
   216cc:	b80d883a 	mov	r6,r23
   216d0:	003ff006 	br	21694 <ESC_EepromAccess+0x1cc>
                    while(i32TimeoutTicks > 0)
   216d4:	003fff06 	br	216d4 <ESC_EepromAccess+0x20c>
        u16RetErr = ALSTATUSCODE_EE_NOACCESS;
   216d8:	04001404 	movi	r16,80
   216dc:	003fab06 	br	2158c <ESC_EepromAccess+0xc4>

000216e0 <ESC_EepromWriteCRC>:

 \brief        This function recalculates the EEPROM CRC and writes the updated value to EEPROM.
            After writing the ESC Config Area a device restart is required!
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 ESC_EepromWriteCRC(void)
{
   216e0:	defffa04 	addi	sp,sp,-24
    UINT16 u16Return = ALSTATUSCODE_UNSPECIFIEDERROR;
    UINT16 EscCfgData[8];
    UINT16 u16Crc = 0x00FF;
   216e4:	00803fc4 	movi	r2,255
    UINT16 i,j;

    
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   216e8:	01c00084 	movi	r7,2
   216ec:	d9800104 	addi	r6,sp,4
   216f0:	014001c4 	movi	r5,7
   216f4:	0009883a 	mov	r4,zero
{
   216f8:	dfc00515 	stw	ra,20(sp)
    UINT16 u16Crc = 0x00FF;
   216fc:	d880008d 	sth	r2,2(sp)
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   21700:	00214c80 	call	214c8 <ESC_EepromAccess>
    if(u16Return == 0)
   21704:	10ffffcc 	andi	r3,r2,65535
   21708:	18001c1e 	bne	r3,zero,2177c <ESC_EepromWriteCRC+0x9c>
   2170c:	d880008b 	ldhu	r2,2(sp)
    {
        UINT8 *pData = (UINT8 *)EscCfgData;

        for(i = 0; i < 14; i++ )
        {
            u16Crc ^= pData[i];
   21710:	d9000104 	addi	r4,sp,4
   21714:	20c9883a 	add	r4,r4,r3
   21718:	21000003 	ldbu	r4,0(r4)
   2171c:	01400204 	movi	r5,8
   21720:	2084f03a 	xor	r2,r4,r2

            for(j=0; j<8; j++ )
            {
                if( u16Crc & 0x80 )
   21724:	1100200c 	andi	r4,r2,128
   21728:	20001726 	beq	r4,zero,21788 <ESC_EepromWriteCRC+0xa8>
   2172c:	10bfffcc 	andi	r2,r2,65535
                {
                    u16Crc = (u16Crc<<1) ^ 0x07;
   21730:	1004907a 	slli	r2,r2,1
   21734:	108001dc 	xori	r2,r2,7
            for(j=0; j<8; j++ )
   21738:	293fffc4 	addi	r4,r5,-1
   2173c:	200b883a 	mov	r5,r4
   21740:	213fffcc 	andi	r4,r4,65535
   21744:	203ff71e 	bne	r4,zero,21724 <ESC_EepromWriteCRC+0x44>
        for(i = 0; i < 14; i++ )
   21748:	18c00044 	addi	r3,r3,1
   2174c:	19000398 	cmpnei	r4,r3,14
   21750:	203fef1e 	bne	r4,zero,21710 <ESC_EepromWriteCRC+0x30>
                }
            }
        }

        /*only low Byte shall be written*/
        u16Crc &= 0x00FF;
   21754:	10803fcc 	andi	r2,r2,255

        /*write new calculated Crc to Esc Config area*/
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   21758:	01c00104 	movi	r7,4
   2175c:	d9800084 	addi	r6,sp,2
   21760:	01400044 	movi	r5,1
   21764:	010001c4 	movi	r4,7
        u16Crc &= 0x00FF;
   21768:	d880008d 	sth	r2,2(sp)
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   2176c:	00214c80 	call	214c8 <ESC_EepromAccess>
        if(u16Return == 0)
   21770:	10ffffcc 	andi	r3,r2,65535
   21774:	1800011e 	bne	r3,zero,2177c <ESC_EepromWriteCRC+0x9c>
        {
            u16Return =  ALSTATUSCODE_WAITFORCOLDSTART;
   21778:	00800804 	movi	r2,32
        }
    }

    return u16Return;
}
   2177c:	dfc00517 	ldw	ra,20(sp)
   21780:	dec00604 	addi	sp,sp,24
   21784:	f800283a 	ret
                    u16Crc <<= 1;
   21788:	1004907a 	slli	r2,r2,1
   2178c:	003fea06 	br	21738 <ESC_EepromWriteCRC+0x58>

00021790 <COE_Init>:
 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
    pCoeSendStored = 0;
   21790:	d0214b15 	stw	zero,-31444(gp)
    nSdoInfoFragmentsLeft = 0;
   21794:	d021778d 	sth	zero,-31266(gp)
}
   21798:	f800283a 	ret

0002179c <COE_ServiceInd>:

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
    UINT8 result = 0;

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
   2179c:	2080018b 	ldhu	r2,6(r4)
   217a0:	1004d33a 	srli	r2,r2,12
   217a4:	10c00228 	cmpgeui	r3,r2,8
   217a8:	1800081e 	bne	r3,zero,217cc <COE_ServiceInd+0x30>
   217ac:	10c000e8 	cmpgeui	r3,r2,3
   217b0:	18000a1e 	bne	r3,zero,217dc <COE_ServiceInd+0x40>
   217b4:	10c00060 	cmpeqi	r3,r2,1
   217b8:	1800081e 	bne	r3,zero,217dc <COE_ServiceInd+0x40>
   217bc:	108000a0 	cmpeqi	r2,r2,2
   217c0:	1000051e 	bne	r2,zero,217d8 <COE_ServiceInd+0x3c>
   217c4:	00800144 	movi	r2,5
   217c8:	f800283a 	ret
   217cc:	10800220 	cmpeqi	r2,r2,8
   217d0:	103ffc26 	beq	r2,zero,217c4 <COE_ServiceInd+0x28>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
        break;

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
   217d4:	002675c1 	jmpi	2675c <SDOS_SdoInfoInd>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
   217d8:	0025ce01 	jmpi	25ce0 <SDOS_SdoInd>
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
   217dc:	00800104 	movi	r2,4
    default:
        result = MBXERR_INVALIDHEADER;
        break;
    }
    return result;
}
   217e0:	f800283a 	ret

000217e4 <COE_ContinueInd>:
 \brief  be put in the send mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if (pCoeSendStored)
   217e4:	d1214b17 	ldw	r4,-31444(gp)
{
   217e8:	deffff04 	addi	sp,sp,-4
   217ec:	dfc00015 	stw	ra,0(sp)
    if (pCoeSendStored)
   217f0:	20000926 	beq	r4,zero,21818 <COE_ContinueInd+0x34>
    {
        /* send the stored CoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) COE8*/
        if (MBX_MailboxSendReq(pCoeSendStored, COE_SERVICE) == 0)
   217f4:	01400084 	movi	r5,2
   217f8:	002426c0 	call	2426c <MBX_MailboxSendReq>
   217fc:	10803fcc 	andi	r2,r2,255
   21800:	1000011e 	bne	r2,zero,21808 <COE_ContinueInd+0x24>
        {
            pCoeSendStored = 0;
   21804:	d0214b15 	stw	zero,-31444(gp)
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
        }
    }

    return 0;
   21808:	0005883a 	mov	r2,zero
}
   2180c:	dfc00017 	ldw	ra,0(sp)
   21810:	dec00104 	addi	sp,sp,4
   21814:	f800283a 	ret
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
   21818:	01002004 	movi	r4,128
   2181c:	00270540 	call	27054 <malloc>
   21820:	1009883a 	mov	r4,r2
        if (pMbx == NULL)
   21824:	10000726 	beq	r2,zero,21844 <COE_ContinueInd+0x60>
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
   21828:	014000f4 	movhi	r5,3
   2182c:	01800384 	movi	r6,14
   21830:	29634604 	addi	r5,r5,-29416
   21834:	002735c0 	call	2735c <memcpy>
   21838:	1009883a 	mov	r4,r2
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
   2183c:	002675c0 	call	2675c <SDOS_SdoInfoInd>
   21840:	003ff106 	br	21808 <COE_ContinueInd+0x24>
            return MBXERR_NOMOREMEMORY;
   21844:	008001c4 	movi	r2,7
   21848:	003ff006 	br	2180c <COE_ContinueInd+0x28>

0002184c <FOE_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void FOE_Init(void)
{
    /* no file transmission sequence is running */
    u16FileAccessState    = FOE_READY;
   2184c:	d0214e0d 	sth	zero,-31432(gp)
    /* initialize the expected packet number */
    u32PacketNo = 0;
   21850:	d0215115 	stw	zero,-31420(gp)
    pFoeSendStored = NULL;
   21854:	d0214d15 	stw	zero,-31436(gp)
}
   21858:	f800283a 	ret

0002185c <FOE_ServiceInd>:
UINT8 FOE_ServiceInd(TFOEMBX MBXMEM * pFoeInd)
{
    /* initialize the result of the service checking */
    UINT16 nextState = ECAT_FOE_ERRCODE_ILLEGAL;
    /* dataSize contains the size of the file data */
    UINT16 dataSize = SWAPWORD(pFoeInd->MbxHeader.Length) - FOE_HEADER_SIZE;
   2185c:	2080000b 	ldhu	r2,0(r4)
   21860:	117ffe84 	addi	r5,r2,-6


    /* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
       great enough for the service header of the FoE service */
    if ( SWAPWORD(pFoeInd->MbxHeader.Length) < FOE_HEADER_SIZE )
   21864:	10bfffcc 	andi	r2,r2,65535
   21868:	108001b0 	cmpltui	r2,r2,6
   2186c:	1000e01e 	bne	r2,zero,21bf0 <FOE_ServiceInd+0x394>
    {
        return MBXERR_SIZETOOSHORT;
    }

    switch ( SWAPWORD(pFoeInd->FoeHeader.OpCode) )
   21870:	2080018b 	ldhu	r2,6(r4)
{
   21874:	defffe04 	addi	sp,sp,-8
   21878:	dc000015 	stw	r16,0(sp)
    switch ( SWAPWORD(pFoeInd->FoeHeader.OpCode) )
   2187c:	10bfffc4 	addi	r2,r2,-1
   21880:	10bfffcc 	andi	r2,r2,65535
{
   21884:	dfc00115 	stw	ra,4(sp)
    switch ( SWAPWORD(pFoeInd->FoeHeader.OpCode) )
   21888:	10c001a8 	cmpgeui	r3,r2,6
   2188c:	2021883a 	mov	r16,r4
   21890:	1800c71e 	bne	r3,zero,21bb0 <FOE_ServiceInd+0x354>
   21894:	100490ba 	slli	r2,r2,2
   21898:	00c000b4 	movhi	r3,2
   2189c:	10c7883a 	add	r3,r2,r3
   218a0:	18862a17 	ldw	r2,6312(r3)
   218a4:	1000683a 	jmp	r2
   218a8:	000218c0 	call	218c <__reset-0x1de74>
   218ac:	000219bc 	xorhi	zero,zero,2150
   218b0:	00021a2c 	andhi	zero,zero,2152
   218b4:	00021a68 	cmpgeui	zero,zero,2153
   218b8:	00021ad4 	movui	zero,2155
   218bc:	00021af4 	movhi	zero,2155
    {
    case ECAT_FOE_OPCODE_RRQ:
        /* file read is requested */
        if ( u16FileAccessState == FOE_READY )
   218c0:	d0a14e0b 	ldhu	r2,-31432(gp)
   218c4:	1000ba1e 	bne	r2,zero,21bb0 <FOE_ServiceInd+0x354>
        {
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   218c8:	2080028b 	ldhu	r2,10(r4)
   218cc:	21c0020b 	ldhu	r7,8(r4)
            /* last FoE sequence was finished, call application function */
            nextState = FOE_Read((UINT16 MBXMEM *)pFoeInd->Data, dataSize, (UINT16*)pFoeInd->Data, u32Password);
   218d0:	21800304 	addi	r6,r4,12
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   218d4:	1004943a 	slli	r2,r2,16
            nextState = FOE_Read((UINT16 MBXMEM *)pFoeInd->Data, dataSize, (UINT16*)pFoeInd->Data, u32Password);
   218d8:	3009883a 	mov	r4,r6
   218dc:	297fffcc 	andi	r5,r5,65535
   218e0:	11ceb03a 	or	r7,r2,r7
   218e4:	0023b9c0 	call	23b9c <FOE_Read>

            /* u32LastFileOffset contains the offset of the file which is sent now */
            u32LastFileOffset = 0;

            if (nextState <= FOE_MAXDATA)
   218e8:	10ffffcc 	andi	r3,r2,65535
            u32LastFileOffset = 0;
   218ec:	d0214f15 	stw	zero,-31428(gp)
            if (nextState <= FOE_MAXDATA)
   218f0:	191fe5a8 	cmpgeui	r4,r3,32662
   218f4:	2000241e 	bne	r4,zero,21988 <FOE_ServiceInd+0x12c>
            {
                /* the first data packet shall be sent */
                u32PacketNo    = 1;
   218f8:	01000044 	movi	r4,1
   218fc:	d1215115 	stw	r4,-31420(gp)
                /* u32FileOffset contains the offset of the file which shall be sent when the next FoE ACK is received */
                u32FileOffset = nextState;
   21900:	d0e15015 	stw	r3,-31424(gp)
    }

    if ( nextState <= FOE_MAXDATA )
    {
        /* we send DATA and wait for ACK */
        UINT32 d = SWAPDWORD(u32PacketNo);
   21904:	d0e15117 	ldw	r3,-31420(gp)

        /* store the OpCode in the mailbox buffer */
        pFoeInd->FoeHeader.OpCode           = SWAPWORD(ECAT_FOE_OPCODE_DATA);
   21908:	010000c4 	movi	r4,3
   2190c:	8100018d 	sth	r4,6(r16)
        /* store the packet number in the mailbox buffer */
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_LOWWORD] = ((d & 0x0000FFFF));
   21910:	80c0020d 	sth	r3,8(r16)
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   21914:	1806d43a 	srli	r3,r3,16
   21918:	80c0028d 	sth	r3,10(r16)
     
        /* store the size of the mailbox data in the mailbox buffer */
        pFoeInd->MbxHeader.Length           = FOE_HEADER_SIZE + nextState;
   2191c:	10c00184 	addi	r3,r2,6
   21920:	80c0000d 	sth	r3,0(r16)

        if ( nextState == u16SendMbxSize - FOE_HEADER_SIZE - MBX_HEADER_SIZE )
   21924:	d0e16c8b 	ldhu	r3,-31310(gp)
   21928:	10bfffcc 	andi	r2,r2,65535
   2192c:	18fffd04 	addi	r3,r3,-12
   21930:	10c09b1e 	bne	r2,r3,21ba0 <FOE_ServiceInd+0x344>
        {
            /* packets still following, we wait for an ACK */
            u16FileAccessState = FOE_WAIT_FOR_ACK;
   21934:	00800044 	movi	r2,1
        }
        else
        {
            /* it was the last Packet, we wait for the last ACK */
            u16FileAccessState = FOE_WAIT_FOR_LAST_ACK;
   21938:	d0a14e0d 	sth	r2,-31432(gp)

        /* the file transmission sequence is finished */
        u16FileAccessState = FOE_READY;
    }

    if ( bBootMode )
   2193c:	d0a164c3 	ldbu	r2,-31341(gp)
   21940:	1000a426 	beq	r2,zero,21bd4 <FOE_ServiceInd+0x378>
    {
        /* in BOOT mode the mailbox buffer is not sent via the mailbox functions
           because only FoE is allowed in BOOT mode, so we have to include the
            mailbox data link layer counter */
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
        if ( (u8MbxReadCounter & 0x07) == 0 )
   21944:	d0e16a43 	ldbu	r3,-31319(gp)
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   21948:	8080010b 	ldhu	r2,4(r16)
        if ( (u8MbxReadCounter & 0x07) == 0 )
   2194c:	18c001cc 	andi	r3,r3,7
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   21950:	1083ffcc 	andi	r2,r2,4095
        if ( (u8MbxReadCounter & 0x07) == 0 )
   21954:	1800021e 	bne	r3,zero,21960 <FOE_ServiceInd+0x104>
        {
            /* counter 0 is not allowed if mailbox data link layer is supported */
            u8MbxReadCounter = 1;
   21958:	00c00044 	movi	r3,1
   2195c:	d0e16a45 	stb	r3,-31319(gp)
        }
        /* store the counter in the mailbox header */
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   21960:	d0e16a43 	ldbu	r3,-31319(gp)
   21964:	19003fcc 	andi	r4,r3,255
   21968:	2008933a 	slli	r4,r4,12
        /* increment the counter for the next service */
          u8MbxReadCounter++;
   2196c:	18c00044 	addi	r3,r3,1
   21970:	d0e16a45 	stb	r3,-31319(gp)
        pFoeInd->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   21974:	1104b03a 	or	r2,r2,r4
   21978:	8080010d 	sth	r2,4(r16)
        /* call the function to send the mailbox service directly,
           in BOOT mode we can be sure that the send mailbox is empty
           because no parallel services are allowed */
        MBX_CopyToSendMailbox((TMBX MBXMEM *) pFoeInd);
   2197c:	8009883a 	mov	r4,r16
   21980:	0023ff80 	call	23ff8 <MBX_CopyToSendMailbox>
   21984:	00004e06 	br	21ac0 <FOE_ServiceInd+0x264>
            else if (nextState <= FOE_MAXBUSY)
   21988:	18dffee8 	cmpgeui	r3,r3,32763
   2198c:	1800681e 	bne	r3,zero,21b30 <FOE_ServiceInd+0x2d4>
                u16FileAccessState = FOE_WAIT_FOR_ACK;
   21990:	00c00044 	movi	r3,1
                u32PacketNo    = 0;
   21994:	d0215115 	stw	zero,-31420(gp)
                u32FileOffset = 0;
   21998:	d0215015 	stw	zero,-31424(gp)
                u16FileAccessState = FOE_WAIT_FOR_ACK;
   2199c:	d0e14e0d 	sth	r3,-31432(gp)
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_BUSY);
   219a0:	00c00184 	movi	r3,6
        pFoeInd->FoeHeader.Cmd.Busy.Done            = SWAPWORD(nextState-FOE_MAXBUSY_ZERO);
   219a4:	10a01a84 	addi	r2,r2,-32662
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_BUSY);
   219a8:	80c0018d 	sth	r3,6(r16)
        pFoeInd->FoeHeader.Cmd.Busy.Done            = SWAPWORD(nextState-FOE_MAXBUSY_ZERO);
   219ac:	8080020d 	sth	r2,8(r16)
        pFoeInd->FoeHeader.Cmd.Busy.Entire          = 0;
   219b0:	8000028d 	sth	zero,10(r16)
        pFoeInd->MbxHeader.Length                   = FOE_HEADER_SIZE;
   219b4:	80c0000d 	sth	r3,0(r16)
   219b8:	003fe006 	br	2193c <FOE_ServiceInd+0xe0>
        if ( u16FileAccessState == FOE_READY )
   219bc:	d0a14e0b 	ldhu	r2,-31432(gp)
   219c0:	10007b1e 	bne	r2,zero,21bb0 <FOE_ServiceInd+0x354>
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   219c4:	2080028b 	ldhu	r2,10(r4)
   219c8:	2180020b 	ldhu	r6,8(r4)
            nextState = FOE_Write((UINT16 MBXMEM *)pFoeInd->Data, dataSize, u32Password);
   219cc:	297fffcc 	andi	r5,r5,65535
            UINT32 u32Password = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.Password[FOE_COMMAND_HIGHWORD]) << 16));
   219d0:	1004943a 	slli	r2,r2,16
            nextState = FOE_Write((UINT16 MBXMEM *)pFoeInd->Data, dataSize, u32Password);
   219d4:	21000304 	addi	r4,r4,12
   219d8:	118cb03a 	or	r6,r2,r6
   219dc:	0023bd80 	call	23bd8 <FOE_Write>
            if ( nextState == 0 )
   219e0:	10ffffcc 	andi	r3,r2,65535
            u32PacketNo    = 0;
   219e4:	d0215115 	stw	zero,-31420(gp)
            if ( nextState == 0 )
   219e8:	18004b1e 	bne	r3,zero,21b18 <FOE_ServiceInd+0x2bc>
                    nextState = FOE_ACK;
   219ec:	009fff44 	movi	r2,32765
        UINT32 d = SWAPDWORD(u32PacketNo);
   219f0:	d0e15117 	ldw	r3,-31420(gp)
        if ( nextState == FOE_ACK )
   219f4:	10bfffcc 	andi	r2,r2,65535
   219f8:	109fff58 	cmpnei	r2,r2,32765
        u32PacketNo++;
   219fc:	19000044 	addi	r4,r3,1
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_LOWWORD] = ((d & 0x0000FFFF));
   21a00:	80c0020d 	sth	r3,8(r16)
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   21a04:	1806d43a 	srli	r3,r3,16
        u32PacketNo++;
   21a08:	d1215115 	stw	r4,-31420(gp)
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_ACK);
   21a0c:	01000104 	movi	r4,4
        pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   21a10:	80c0028d 	sth	r3,10(r16)
        pFoeInd->MbxHeader.Length                   = SIZEOF(TFOEHEADER);
   21a14:	00c00184 	movi	r3,6
        pFoeInd->FoeHeader.OpCode                   = SWAPWORD(ECAT_FOE_OPCODE_ACK);
   21a18:	8100018d 	sth	r4,6(r16)
        pFoeInd->MbxHeader.Length                   = SIZEOF(TFOEHEADER);
   21a1c:	80c0000d 	sth	r3,0(r16)
        if ( nextState == FOE_ACK )
   21a20:	10006a1e 	bne	r2,zero,21bcc <FOE_ServiceInd+0x370>
            u16FileAccessState = FOE_WAIT_FOR_DATA;
   21a24:	00800084 	movi	r2,2
   21a28:	003fc306 	br	21938 <FOE_ServiceInd+0xdc>
        if ( u16FileAccessState == FOE_WAIT_FOR_DATA
   21a2c:	d0a14e0b 	ldhu	r2,-31432(gp)
   21a30:	10bffecc 	andi	r2,r2,65531
   21a34:	10800098 	cmpnei	r2,r2,2
   21a38:	10005d1e 	bne	r2,zero,21bb0 <FOE_ServiceInd+0x354>
            UINT32 u32CmdPacketNo = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.PacketNo[FOE_COMMAND_HIGHWORD]) << 16));
   21a3c:	2080028b 	ldhu	r2,10(r4)
   21a40:	20c0020b 	ldhu	r3,8(r4)
   21a44:	1004943a 	slli	r2,r2,16
   21a48:	10c4b03a 	or	r2,r2,r3
            if ( u32CmdPacketNo == u32PacketNo )
   21a4c:	d0e15117 	ldw	r3,-31420(gp)
   21a50:	1880551e 	bne	r3,r2,21ba8 <FOE_ServiceInd+0x34c>
                nextState = FOE_Data((UINT16 MBXMEM *)pFoeInd->Data, dataSize);
   21a54:	297fffcc 	andi	r5,r5,65535
   21a58:	21000304 	addi	r4,r4,12
   21a5c:	0023bf00 	call	23bf0 <FOE_Data>
                if ( nextState == 0 )
   21a60:	10ffffcc 	andi	r3,r2,65535
   21a64:	003fe006 	br	219e8 <FOE_ServiceInd+0x18c>
        if ( u16FileAccessState == FOE_WAIT_FOR_ACK )
   21a68:	d0a14e0b 	ldhu	r2,-31432(gp)
   21a6c:	10c00058 	cmpnei	r3,r2,1
   21a70:	18000e1e 	bne	r3,zero,21aac <FOE_ServiceInd+0x250>
            nextState = FOE_Ack( u32FileOffset, (UINT16 MBXMEM *)pFoeInd->Data );
   21a74:	21400304 	addi	r5,r4,12
   21a78:	d1215017 	ldw	r4,-31424(gp)
   21a7c:	0023c4c0 	call	23c4c <FOE_Ack>
            u32LastFileOffset = u32FileOffset;
   21a80:	d1215017 	ldw	r4,-31424(gp)
            if (nextState <= FOE_MAXDATA) 
   21a84:	10ffffcc 	andi	r3,r2,65535
   21a88:	195fe5a8 	cmpgeui	r5,r3,32662
            u32LastFileOffset = u32FileOffset;
   21a8c:	d1214f15 	stw	r4,-31428(gp)
            if (nextState <= FOE_MAXDATA) 
   21a90:	2800241e 	bne	r5,zero,21b24 <FOE_ServiceInd+0x2c8>
                u32FileOffset += nextState;
   21a94:	1907883a 	add	r3,r3,r4
   21a98:	d0e15015 	stw	r3,-31424(gp)
                u32PacketNo++;
   21a9c:	d0e15117 	ldw	r3,-31420(gp)
   21aa0:	18c00044 	addi	r3,r3,1
   21aa4:	d0e15115 	stw	r3,-31420(gp)
    if ( nextState <= FOE_MAXDATA )
   21aa8:	003f9606 	br	21904 <FOE_ServiceInd+0xa8>
        else if ( u16FileAccessState == FOE_WAIT_FOR_LAST_ACK )
   21aac:	10800118 	cmpnei	r2,r2,4
   21ab0:	10003f1e 	bne	r2,zero,21bb0 <FOE_ServiceInd+0x354>
        APPL_FreeMailboxBuffer(pFoeInd);
   21ab4:	8009883a 	mov	r4,r16
        u16FileAccessState = FOE_READY;
   21ab8:	d0214e0d 	sth	zero,-31432(gp)
        APPL_FreeMailboxBuffer(pFoeInd);
   21abc:	00270640 	call	27064 <free>
        return 0;
   21ac0:	0005883a 	mov	r2,zero
            pFoeSendStored = (TMBX MBXMEM *) pFoeInd;
        }
    }

    return 0;
}
   21ac4:	dfc00117 	ldw	ra,4(sp)
   21ac8:	dc000017 	ldw	r16,0(sp)
   21acc:	dec00204 	addi	sp,sp,8
   21ad0:	f800283a 	ret
        if ( u16FileAccessState != FOE_READY )
   21ad4:	d0a14e0b 	ldhu	r2,-31432(gp)
   21ad8:	10003526 	beq	r2,zero,21bb0 <FOE_ServiceInd+0x354>
            UINT32 u32CmdErrorCode = SWAPDWORD((((UINT32)pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_LOWWORD]) | ((UINT32)pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_HIGHWORD]) << 16));
   21adc:	8080028b 	ldhu	r2,10(r16)
   21ae0:	2100020b 	ldhu	r4,8(r4)
   21ae4:	1004943a 	slli	r2,r2,16
            FOE_Error( u32CmdErrorCode );
   21ae8:	1108b03a 	or	r4,r2,r4
   21aec:	0023c740 	call	23c74 <FOE_Error>
    else if ( nextState < FOE_ERROR )
   21af0:	003ff006 	br	21ab4 <FOE_ServiceInd+0x258>
        if ( u16FileAccessState == FOE_WAIT_FOR_ACK
   21af4:	d0a14e0b 	ldhu	r2,-31432(gp)
   21af8:	10c00060 	cmpeqi	r3,r2,1
   21afc:	1800021e 	bne	r3,zero,21b08 <FOE_ServiceInd+0x2ac>
          || u16FileAccessState == FOE_WAIT_FOR_LAST_ACK )
   21b00:	10800118 	cmpnei	r2,r2,4
   21b04:	10002a1e 	bne	r2,zero,21bb0 <FOE_ServiceInd+0x354>
            nextState = FOE_Busy( SWAPWORD(pFoeInd->FoeHeader.Cmd.Busy.Done), u32LastFileOffset, (UINT16 MBXMEM *)pFoeInd->Data );
   21b08:	d1614f17 	ldw	r5,-31428(gp)
   21b0c:	8100020b 	ldhu	r4,8(r16)
   21b10:	81800304 	addi	r6,r16,12
   21b14:	0023c680 	call	23c68 <FOE_Busy>
    if ( nextState <= FOE_MAXDATA )
   21b18:	10ffffcc 	andi	r3,r2,65535
   21b1c:	18dfe5a8 	cmpgeui	r3,r3,32662
   21b20:	183f7826 	beq	r3,zero,21904 <FOE_ServiceInd+0xa8>
    else if ( nextState <= FOE_MAXBUSY )
   21b24:	10ffffcc 	andi	r3,r2,65535
   21b28:	18dffee8 	cmpgeui	r3,r3,32763
   21b2c:	183f9c26 	beq	r3,zero,219a0 <FOE_ServiceInd+0x144>
    else if ( nextState == FOE_ACK || nextState == FOE_ACKFINISHED )
   21b30:	10e00104 	addi	r3,r2,-32764
   21b34:	18ffffcc 	andi	r3,r3,65535
   21b38:	18c000a8 	cmpgeui	r3,r3,2
   21b3c:	183fac26 	beq	r3,zero,219f0 <FOE_ServiceInd+0x194>
    else if ( nextState < FOE_ERROR )
   21b40:	10ffffcc 	andi	r3,r2,65535
   21b44:	18e0001c 	xori	r3,r3,32768
   21b48:	18e00004 	addi	r3,r3,-32768
   21b4c:	183fd90e 	bge	r3,zero,21ab4 <FOE_ServiceInd+0x258>
        pFoeInd->FoeHeader.OpCode                    = SWAPWORD(ECAT_FOE_OPCODE_ERR);
   21b50:	00c00144 	movi	r3,5
        pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_LOWWORD] = ((d & 0x0000FFFF));
   21b54:	8080020d 	sth	r2,8(r16)
        pFoeInd->MbxHeader.Length                   = SIZEOF(TFOEHEADER);
   21b58:	00800184 	movi	r2,6
   21b5c:	8080000d 	sth	r2,0(r16)
        pFoeInd->FoeHeader.OpCode                    = SWAPWORD(ECAT_FOE_OPCODE_ERR);
   21b60:	80c0018d 	sth	r3,6(r16)
        pFoeInd->FoeHeader.Cmd.ErrorCode[FOE_COMMAND_HIGHWORD] = ((d & 0xFFFF0000) >> 16);
   21b64:	8000028d 	sth	zero,10(r16)
        UINT8 b = 0;
   21b68:	0005883a 	mov	r2,zero
            UINT16 data = ((UINT16 MBXMEM *) pFoeInd->Data)[(b >> 1)];
   21b6c:	10c03f8c 	andi	r3,r2,254
   21b70:	80c7883a 	add	r3,r16,r3
   21b74:	18c0030b 	ldhu	r3,12(r3)
            if ((data & 0x00FF) == 0)
   21b78:	19003fcc 	andi	r4,r3,255
   21b7c:	20000426 	beq	r4,zero,21b90 <FOE_ServiceInd+0x334>
            if ((data & 0xFF00) == 0)
   21b80:	18ffffcc 	andi	r3,r3,65535
   21b84:	18c04028 	cmpgeui	r3,r3,256
   21b88:	18000b1e 	bne	r3,zero,21bb8 <FOE_ServiceInd+0x35c>
            b++;
   21b8c:	10800044 	addi	r2,r2,1
            pFoeInd->MbxHeader.Length    += b+1;
   21b90:	108001c4 	addi	r2,r2,7
   21b94:	10803fcc 	andi	r2,r2,255
   21b98:	8080000d 	sth	r2,0(r16)
   21b9c:	00000b06 	br	21bcc <FOE_ServiceInd+0x370>
            u16FileAccessState = FOE_WAIT_FOR_LAST_ACK;
   21ba0:	00800104 	movi	r2,4
   21ba4:	003f6406 	br	21938 <FOE_ServiceInd+0xdc>
   21ba8:	00a00144 	movi	r2,-32763
   21bac:	003fe806 	br	21b50 <FOE_ServiceInd+0x2f4>
   21bb0:	00a00104 	movi	r2,-32764
   21bb4:	003fe606 	br	21b50 <FOE_ServiceInd+0x2f4>
            b++;
   21bb8:	10c00084 	addi	r3,r2,2
   21bbc:	1805883a 	mov	r2,r3
        while (b < 32)
   21bc0:	18c03fcc 	andi	r3,r3,255
   21bc4:	18c00818 	cmpnei	r3,r3,32
   21bc8:	183fe81e 	bne	r3,zero,21b6c <FOE_ServiceInd+0x310>
            u16FileAccessState = FOE_READY;
   21bcc:	d0214e0d 	sth	zero,-31432(gp)
   21bd0:	003f5a06 	br	2193c <FOE_ServiceInd+0xe0>
        if ( MBX_MailboxSendReq((TMBX MBXMEM *) pFoeInd, FOE_SERVICE) != 0 )
   21bd4:	01401004 	movi	r5,64
   21bd8:	8009883a 	mov	r4,r16
   21bdc:	002426c0 	call	2426c <MBX_MailboxSendReq>
   21be0:	10803fcc 	andi	r2,r2,255
   21be4:	103fb626 	beq	r2,zero,21ac0 <FOE_ServiceInd+0x264>
            pFoeSendStored = (TMBX MBXMEM *) pFoeInd;
   21be8:	d4214d15 	stw	r16,-31436(gp)
   21bec:	003fb406 	br	21ac0 <FOE_ServiceInd+0x264>
        return MBXERR_SIZETOOSHORT;
   21bf0:	00800184 	movi	r2,6
}
   21bf4:	f800283a 	ret

00021bf8 <FOE_ContinueInd>:
 \brief    This function is called when the next mailbox fragment can be sent.
*////////////////////////////////////////////////////////////////////////////////////////

void FOE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if ( pFoeSendStored )
   21bf8:	d1214d17 	ldw	r4,-31436(gp)
   21bfc:	20000a26 	beq	r4,zero,21c28 <FOE_ContinueInd+0x30>
{
   21c00:	deffff04 	addi	sp,sp,-4
    {
        /* send the stored FoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) FOE1*/
        if (MBX_MailboxSendReq(pFoeSendStored, FOE_SERVICE) == 0)
   21c04:	01401004 	movi	r5,64
{
   21c08:	dfc00015 	stw	ra,0(sp)
        if (MBX_MailboxSendReq(pFoeSendStored, FOE_SERVICE) == 0)
   21c0c:	002426c0 	call	2426c <MBX_MailboxSendReq>
   21c10:	10803fcc 	andi	r2,r2,255
   21c14:	1000011e 	bne	r2,zero,21c1c <FOE_ContinueInd+0x24>
        {
            pFoeSendStored = 0;
   21c18:	d0214d15 	stw	zero,-31436(gp)
        }
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   21c1c:	dfc00017 	ldw	ra,0(sp)
   21c20:	dec00104 	addi	sp,sp,4
   21c24:	f800283a 	ret
   21c28:	f800283a 	ret

00021c2c <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
   21c2c:	defffd04 	addi	sp,sp,-12
   21c30:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c34:	01800084 	movi	r6,2
{
   21c38:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c3c:	01408104 	movi	r5,516
   21c40:	d9000084 	addi	r4,sp,2
{
   21c44:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c48:	00205e80 	call	205e8 <HW_EscRead>
    
    mask &= intMask;
   21c4c:	d880008b 	ldhu	r2,2(sp)


    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c50:	01800084 	movi	r6,2
   21c54:	01408104 	movi	r5,516
    mask &= intMask;
   21c58:	80a0703a 	and	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c5c:	d9000084 	addi	r4,sp,2
    mask &= intMask;
   21c60:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c64:	002066c0 	call	2066c <HW_EscWrite>
    ENABLE_ESC_INT();
}
   21c68:	dfc00217 	ldw	ra,8(sp)
   21c6c:	dc000117 	ldw	r16,4(sp)
   21c70:	dec00304 	addi	sp,sp,12
   21c74:	f800283a 	ret

00021c78 <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
   21c78:	defffd04 	addi	sp,sp,-12
   21c7c:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c80:	01800084 	movi	r6,2
{
   21c84:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c88:	01408104 	movi	r5,516
   21c8c:	d9000084 	addi	r4,sp,2
{
   21c90:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c94:	00205e80 	call	205e8 <HW_EscRead>
    

    mask |= intMask;
   21c98:	d880008b 	ldhu	r2,2(sp)

    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21c9c:	01800084 	movi	r6,2
   21ca0:	01408104 	movi	r5,516
    mask |= intMask;
   21ca4:	80a0b03a 	or	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21ca8:	d9000084 	addi	r4,sp,2
    mask |= intMask;
   21cac:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21cb0:	002066c0 	call	2066c <HW_EscWrite>
    ENABLE_ESC_INT();
}
   21cb4:	dfc00217 	ldw	ra,8(sp)
   21cb8:	dc000117 	ldw	r16,4(sp)
   21cbc:	dec00304 	addi	sp,sp,12
   21cc0:	f800283a 	ret

00021cc4 <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
   21cc4:	defffe04 	addi	sp,sp,-8
    UINT16 TmpVar = 0;
    //read EEPROM loaded information
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21cc8:	01800084 	movi	r6,2
   21ccc:	01414084 	movi	r5,1282
   21cd0:	d9000084 	addi	r4,sp,2
{
   21cd4:	dfc00115 	stw	ra,4(sp)
    UINT16 TmpVar = 0;
   21cd8:	d800008d 	sth	zero,2(sp)
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21cdc:	00205e80 	call	205e8 <HW_EscRead>
    TmpVar = SWAPWORD(TmpVar);


    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
   21ce0:	d880008b 	ldhu	r2,2(sp)
   21ce4:	1086000c 	andi	r2,r2,6144
   21ce8:	1005003a 	cmpeq	r2,r2,zero
   21cec:	d0a15205 	stb	r2,-31416(gp)
    }
    else
    {
        EepromLoaded = TRUE;
    }
}
   21cf0:	dfc00117 	ldw	ra,4(sp)
   21cf4:	dec00204 	addi	sp,sp,8
   21cf8:	f800283a 	ret

00021cfc <GetSyncMan>:
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21cfc:	21403fcc 	andi	r5,r4,255
   21d00:	29404004 	addi	r5,r5,256
   21d04:	280a90fa 	slli	r5,r5,3
{
   21d08:	deffff04 	addi	sp,sp,-4
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21d0c:	01800204 	movi	r6,8
   21d10:	d1215284 	addi	r4,gp,-31414
{
   21d14:	dfc00015 	stw	ra,0(sp)
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21d18:	00205e80 	call	205e8 <HW_EscRead>



    return &SyncManInfo;
}
   21d1c:	d0a15284 	addi	r2,gp,-31414
   21d20:	dfc00017 	ldw	ra,0(sp)
   21d24:	dec00104 	addi	sp,sp,4
   21d28:	f800283a 	ret

00021d2c <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
   21d2c:	defffd04 	addi	sp,sp,-12
   21d30:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d34:	24003fcc 	andi	r16,r4,255
   21d38:	802090fa 	slli	r16,r16,3
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21d3c:	00800044 	movi	r2,1

    HW_EscWriteByte(smStatus,Offset);
   21d40:	01800044 	movi	r6,1
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d44:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21d48:	843fffcc 	andi	r16,r16,65535
   21d4c:	800b883a 	mov	r5,r16
   21d50:	d90000c4 	addi	r4,sp,3
{
   21d54:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21d58:	d88000c5 	stb	r2,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21d5c:	002066c0 	call	2066c <HW_EscWrite>
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadByte(smStatus, Offset);
   21d60:	01800044 	movi	r6,1
   21d64:	800b883a 	mov	r5,r16
   21d68:	d90000c4 	addi	r4,sp,3
   21d6c:	00205e80 	call	205e8 <HW_EscRead>
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
   21d70:	d88000c3 	ldbu	r2,3(sp)
   21d74:	1080004c 	andi	r2,r2,1
   21d78:	103ff926 	beq	r2,zero,21d60 <DisableSyncManChannel+0x34>
}
   21d7c:	dfc00217 	ldw	ra,8(sp)
   21d80:	dc000117 	ldw	r16,4(sp)
   21d84:	dec00304 	addi	sp,sp,12
   21d88:	f800283a 	ret

00021d8c <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
   21d8c:	defffd04 	addi	sp,sp,-12
   21d90:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = 0x00;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21d94:	24003fcc 	andi	r16,r4,255
   21d98:	802090fa 	slli	r16,r16,3

    HW_EscWriteByte(smStatus,Offset);
   21d9c:	01800044 	movi	r6,1
   21da0:	d90000c4 	addi	r4,sp,3
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21da4:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21da8:	843fffcc 	andi	r16,r16,65535
   21dac:	800b883a 	mov	r5,r16
{
   21db0:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = 0x00;
   21db4:	d80000c5 	stb	zero,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21db8:	002066c0 	call	2066c <HW_EscWrite>
    
    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadByte(smStatus,Offset);
   21dbc:	01800044 	movi	r6,1
   21dc0:	800b883a 	mov	r5,r16
   21dc4:	d90000c4 	addi	r4,sp,3
   21dc8:	00205e80 	call	205e8 <HW_EscRead>
    }while((smStatus & SM_SETTING_PDI_DISABLE));
   21dcc:	d88000c3 	ldbu	r2,3(sp)
   21dd0:	1080004c 	andi	r2,r2,1
   21dd4:	103ff91e 	bne	r2,zero,21dbc <EnableSyncManChannel+0x30>
}
   21dd8:	dfc00217 	ldw	ra,8(sp)
   21ddc:	dc000117 	ldw	r16,4(sp)
   21de0:	dec00304 	addi	sp,sp,12
   21de4:	f800283a 	ret

00021de8 <CheckSmSettings>:
    UINT16 SMLength = 0;
    UINT16 SMAddress = 0;


        //Check if max address defines are within the available ESC address range
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21de8:	d0a1580b 	ldhu	r2,-31392(gp)
{
   21dec:	defffc04 	addi	sp,sp,-16
   21df0:	dfc00315 	stw	ra,12(sp)
   21df4:	dc800215 	stw	r18,8(sp)
   21df8:	dc400115 	stw	r17,4(sp)
   21dfc:	dc000015 	stw	r16,0(sp)
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21e00:	108bfff0 	cmpltui	r2,r2,12287
   21e04:	1000921e 	bne	r2,zero,22050 <CheckSmSettings+0x268>
   21e08:	2025883a 	mov	r18,r4
   21e0c:	2023883a 	mov	r17,r4

                return ALSTATUSCODE_NOVALIDFIRMWARE;
        }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
   21e10:	0009883a 	mov	r4,zero
   21e14:	0021cfc0 	call	21cfc <GetSyncMan>
    SMLength = pSyncMan->Length;
    SMAddress = pSyncMan->PhysicalStartAddress;



    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e18:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21e1c:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21e20:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e24:	2940004c 	andi	r5,r5,1
   21e28:	2800081e 	bne	r5,zero,21e4c <CheckSmSettings+0x64>
            result = SYNCMANCHSIZE + 1;
        }

        if ( result != 0 )
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21e2c:	04000584 	movi	r16,22
            pSyncMan = GetSyncMan(i);
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
        }
    }
    return result;
}
   21e30:	8005883a 	mov	r2,r16
   21e34:	dfc00317 	ldw	ra,12(sp)
   21e38:	dc800217 	ldw	r18,8(sp)
   21e3c:	dc400117 	ldw	r17,4(sp)
   21e40:	dc000017 	ldw	r16,0(sp)
   21e44:	dec00404 	addi	sp,sp,16
   21e48:	f800283a 	ret
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
   21e4c:	10800103 	ldbu	r2,4(r2)
   21e50:	1140030c 	andi	r5,r2,12
   21e54:	29400118 	cmpnei	r5,r5,4
   21e58:	283ff41e 	bne	r5,zero,21e2c <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e5c:	1080008c 	andi	r2,r2,2
   21e60:	103ff226 	beq	r2,zero,21e2c <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21e64:	20bff704 	addi	r2,r4,-36
   21e68:	10bfffcc 	andi	r2,r2,65535
   21e6c:	10801768 	cmpgeui	r2,r2,93
   21e70:	103fee1e 	bne	r2,zero,21e2c <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
   21e74:	18bc0004 	addi	r2,r3,-4096
   21e78:	10bfffcc 	andi	r2,r2,65535
   21e7c:	10880028 	cmpgeui	r2,r2,8192
   21e80:	103fea1e 	bne	r2,zero,21e2c <CheckSmSettings+0x44>
        pSyncMan = GetSyncMan(MAILBOX_READ);
   21e84:	01000044 	movi	r4,1
   21e88:	0021cfc0 	call	21cfc <GetSyncMan>
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e8c:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21e90:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21e94:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21e98:	2940004c 	andi	r5,r5,1
   21e9c:	283fe326 	beq	r5,zero,21e2c <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
   21ea0:	10800103 	ldbu	r2,4(r2)
   21ea4:	1140030c 	andi	r5,r2,12
   21ea8:	2821883a 	mov	r16,r5
   21eac:	283fdf1e 	bne	r5,zero,21e2c <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21eb0:	1080008c 	andi	r2,r2,2
   21eb4:	103fdd26 	beq	r2,zero,21e2c <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21eb8:	20bff704 	addi	r2,r4,-36
   21ebc:	10bfffcc 	andi	r2,r2,65535
   21ec0:	10801768 	cmpgeui	r2,r2,93
   21ec4:	103fd91e 	bne	r2,zero,21e2c <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_READ_ADDRESS)
   21ec8:	18bc0004 	addi	r2,r3,-4096
   21ecc:	10bfffcc 	andi	r2,r2,65535
   21ed0:	10880028 	cmpgeui	r2,r2,8192
   21ed4:	103fd51e 	bne	r2,zero,21e2c <CheckSmSettings+0x44>
    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
   21ed8:	94803fcc 	andi	r18,r18,255
   21edc:	90800130 	cmpltui	r2,r18,4
   21ee0:	1000421e 	bne	r2,zero,21fec <CheckSmSettings+0x204>
        b3BufferMode = TRUE;
   21ee4:	00800044 	movi	r2,1
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21ee8:	010000c4 	movi	r4,3
        b3BufferMode = TRUE;
   21eec:	d0a15c05 	stb	r2,-31376(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21ef0:	0021cfc0 	call	21cfc <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21ef4:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21ef8:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21efc:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21f00:	2940004c 	andi	r5,r5,1
   21f04:	28003426 	beq	r5,zero,21fd8 <CheckSmSettings+0x1f0>
   21f08:	217fffc4 	addi	r5,r4,-1
   21f0c:	297fffcc 	andi	r5,r5,65535
   21f10:	29408928 	cmpgeui	r5,r5,548
   21f14:	28000d1e 	bne	r5,zero,21f4c <CheckSmSettings+0x164>
                if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
   21f18:	d161598b 	ldhu	r5,-31386(gp)
   21f1c:	213fffcc 	andi	r4,r4,65535
   21f20:	21400a1e 	bne	r4,r5,21f4c <CheckSmSettings+0x164>
                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
   21f24:	10800103 	ldbu	r2,4(r2)
   21f28:	1100030c 	andi	r4,r2,12
   21f2c:	2000071e 	bne	r4,zero,21f4c <CheckSmSettings+0x164>
                        if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
   21f30:	d12157c3 	ldbu	r4,-31393(gp)
   21f34:	21000098 	cmpnei	r4,r4,2
   21f38:	2000061e 	bne	r4,zero,21f54 <CheckSmSettings+0x16c>
   21f3c:	18fc0004 	addi	r3,r3,-4096
   21f40:	18ffffcc 	andi	r3,r3,65535
   21f44:	18c80030 	cmpltui	r3,r3,8192
   21f48:	1800051e 	bne	r3,zero,21f60 <CheckSmSettings+0x178>
            result = ALSTATUSCODE_INVALIDSMINCFG;
   21f4c:	04000784 	movi	r16,30
   21f50:	003fb706 	br	21e30 <CheckSmSettings+0x48>
                            || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
   21f54:	d121560b 	ldhu	r4,-31400(gp)
   21f58:	18ffffcc 	andi	r3,r3,65535
   21f5c:	193ffb1e 	bne	r3,r4,21f4c <CheckSmSettings+0x164>
                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21f60:	1080008c 	andi	r2,r2,2
   21f64:	10000126 	beq	r2,zero,21f6c <CheckSmSettings+0x184>
                                    b3BufferMode = FALSE;
   21f68:	d0215c05 	stb	zero,-31376(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21f6c:	01000084 	movi	r4,2
   21f70:	0021cfc0 	call	21cfc <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21f74:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21f78:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21f7c:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21f80:	2940004c 	andi	r5,r5,1
   21f84:	28002d26 	beq	r5,zero,2203c <CheckSmSettings+0x254>
   21f88:	217fffc4 	addi	r5,r4,-1
   21f8c:	297fffcc 	andi	r5,r5,65535
   21f90:	29400428 	cmpgeui	r5,r5,16
   21f94:	28000e1e 	bne	r5,zero,21fd0 <CheckSmSettings+0x1e8>
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
   21f98:	d161590b 	ldhu	r5,-31388(gp)
   21f9c:	213fffcc 	andi	r4,r4,65535
   21fa0:	21400b1e 	bne	r4,r5,21fd0 <CheckSmSettings+0x1e8>
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
   21fa4:	10800103 	ldbu	r2,4(r2)
   21fa8:	1100030c 	andi	r4,r2,12
   21fac:	21000118 	cmpnei	r4,r4,4
   21fb0:	2000071e 	bne	r4,zero,21fd0 <CheckSmSettings+0x1e8>
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
   21fb4:	d12157c3 	ldbu	r4,-31393(gp)
   21fb8:	21000098 	cmpnei	r4,r4,2
   21fbc:	2000151e 	bne	r4,zero,22014 <CheckSmSettings+0x22c>
   21fc0:	18fc0004 	addi	r3,r3,-4096
   21fc4:	18ffffcc 	andi	r3,r3,65535
   21fc8:	18c80030 	cmpltui	r3,r3,8192
   21fcc:	1800141e 	bne	r3,zero,22020 <CheckSmSettings+0x238>
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21fd0:	04000744 	movi	r16,29
   21fd4:	003f9606 	br	21e30 <CheckSmSettings+0x48>
        else if (SMLength != 0 || nPdInputSize != 0)
   21fd8:	d0a1598b 	ldhu	r2,-31386(gp)
   21fdc:	1104b03a 	or	r2,r2,r4
   21fe0:	10bfffcc 	andi	r2,r2,65535
   21fe4:	103fe126 	beq	r2,zero,21f6c <CheckSmSettings+0x184>
   21fe8:	003fd806 	br	21f4c <CheckSmSettings+0x164>
    if (result == 0 && maxChannel > PROCESS_DATA_OUT)
   21fec:	948000e0 	cmpeqi	r18,r18,3
   21ff0:	903fde1e 	bne	r18,zero,21f6c <CheckSmSettings+0x184>
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21ff4:	d0a15883 	ldbu	r2,-31390(gp)
   21ff8:	89003fcc 	andi	r4,r17,255
   21ffc:	20bf8c2e 	bgeu	r4,r2,21e30 <CheckSmSettings+0x48>
            pSyncMan = GetSyncMan(i);
   22000:	0021cfc0 	call	21cfc <GetSyncMan>
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   22004:	10800183 	ldbu	r2,6(r2)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   22008:	8c400044 	addi	r17,r17,1
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   2200c:	d0a15485 	stb	r2,-31406(gp)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   22010:	003ff806 	br	21ff4 <CheckSmSettings+0x20c>
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
   22014:	d121568b 	ldhu	r4,-31398(gp)
   22018:	18ffffcc 	andi	r3,r3,65535
   2201c:	193fec1e 	bne	r3,r4,21fd0 <CheckSmSettings+0x1e8>
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   22020:	1006d1ba 	srli	r3,r2,6
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   22024:	1080008c 	andi	r2,r2,2
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   22028:	18c0004c 	andi	r3,r3,1
                                bWdTrigger = TRUE;
   2202c:	d0e163c5 	stb	r3,-31345(gp)
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   22030:	103ff026 	beq	r2,zero,21ff4 <CheckSmSettings+0x20c>
                                b3BufferMode = FALSE;
   22034:	d0215c05 	stb	zero,-31376(gp)
   22038:	003fee06 	br	21ff4 <CheckSmSettings+0x20c>
        else if (SMLength != 0 || nPdOutputSize != 0)
   2203c:	d0a1590b 	ldhu	r2,-31388(gp)
   22040:	1104b03a 	or	r2,r2,r4
   22044:	10bfffcc 	andi	r2,r2,65535
   22048:	103fea26 	beq	r2,zero,21ff4 <CheckSmSettings+0x20c>
   2204c:	003fe006 	br	21fd0 <CheckSmSettings+0x1e8>
                return ALSTATUSCODE_NOVALIDFIRMWARE;
   22050:	04000504 	movi	r16,20
   22054:	003f7606 	br	21e30 <CheckSmSettings+0x48>

00022058 <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
   22058:	defff104 	addi	sp,sp,-60
   2205c:	dc800715 	stw	r18,28(sp)
   22060:	dc000515 	stw	r16,20(sp)
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   22064:	048000f4 	movhi	r18,3
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   22068:	040000f4 	movhi	r16,3
   2206c:	84233504 	addi	r16,r16,-29484
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   22070:	94a32404 	addi	r18,r18,-29552
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   22074:	01000084 	movi	r4,2
{
   22078:	dd000915 	stw	r20,36(sp)
   2207c:	dcc00815 	stw	r19,32(sp)
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   22080:	9500030b 	ldhu	r20,12(r18)
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   22084:	84c0030b 	ldhu	r19,12(r16)
{
   22088:	dfc00e15 	stw	ra,56(sp)
   2208c:	df000d15 	stw	fp,52(sp)
   22090:	ddc00c15 	stw	r23,48(sp)
   22094:	dd800b15 	stw	r22,44(sp)
   22098:	dd400a15 	stw	r21,40(sp)
   2209c:	dc400615 	stw	r17,24(sp)
    UINT16     wdiv = 0;
   220a0:	d800020d 	sth	zero,8(sp)
    UINT16     wd = 0;
   220a4:	d800028d 	sth	zero,10(sp)
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
   220a8:	d8000315 	stw	zero,12(sp)
    UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
   220ac:	d8000415 	stw	zero,16(sp)
    u16ALEventMask = 0;
   220b0:	d021558d 	sth	zero,-31402(gp)
    bEcatFirstOutputsReceived = FALSE;
   220b4:	d0216405 	stb	zero,-31344(gp)
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   220b8:	0021cfc0 	call	21cfc <GetSyncMan>
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   220bc:	10c0000b 	ldhu	r3,0(r2)
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220c0:	10800103 	ldbu	r2,4(r2)
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   220c4:	d0e1568d 	sth	r3,-31398(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220c8:	1080008c 	andi	r2,r2,2
   220cc:	1000491e 	bne	r2,zero,221f4 <StartInputHandler+0x19c>
    UINT16    nPdOutputBuffer = 3;
   220d0:	070000c4 	movi	fp,3
       nPdOutputBuffer = 1;
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   220d4:	010000c4 	movi	r4,3
   220d8:	0021cfc0 	call	21cfc <GetSyncMan>
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   220dc:	1440000b 	ldhu	r17,0(r2)


    /* get the number of input buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220e0:	10800103 	ldbu	r2,4(r2)
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   220e4:	d461560d 	sth	r17,-31400(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   220e8:	1080008c 	andi	r2,r2,2
   220ec:	1000431e 	bne	r2,zero,221fc <StartInputHandler+0x1a4>
    UINT16    nPdInputBuffer = 3;
   220f0:	010000c4 	movi	r4,3
        nPdInputBuffer = 1;
    }
    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   220f4:	d5a1598b 	ldhu	r22,-31386(gp)
   220f8:	210000cc 	andi	r4,r4,3
   220fc:	8c7fffcc 	andi	r17,r17,65535
   22100:	b00b883a 	mov	r5,r22
   22104:	002702c0 	call	2702c <__mulsi3>
   22108:	d0e16b0b 	ldhu	r3,-31316(gp)
   2210c:	1445883a 	add	r2,r2,r17
   22110:	1880030e 	bge	r3,r2,22120 <StartInputHandler+0xc8>
   22114:	d1216c8b 	ldhu	r4,-31310(gp)
   22118:	20c9883a 	add	r4,r4,r3
   2211c:	8901a316 	blt	r17,r4,227ac <StartInputHandler+0x754>
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   22120:	d5e16b8b 	ldhu	r23,-31314(gp)
   22124:	b880030e 	bge	r23,r2,22134 <StartInputHandler+0xdc>
   22128:	d0a16c0b 	ldhu	r2,-31312(gp)
   2212c:	15c5883a 	add	r2,r2,r23
   22130:	88819e16 	blt	r17,r2,227ac <StartInputHandler+0x754>
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   22134:	d121590b 	ldhu	r4,-31388(gp)
   22138:	e14000cc 	andi	r5,fp,3
   2213c:	d8c00015 	stw	r3,0(sp)
   22140:	d561568b 	ldhu	r21,-31398(gp)
   22144:	002702c0 	call	2702c <__mulsi3>
    if (
   22148:	d8c00017 	ldw	r3,0(sp)
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   2214c:	1545883a 	add	r2,r2,r21
    if (
   22150:	1880030e 	bge	r3,r2,22160 <StartInputHandler+0x108>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   22154:	d1216c8b 	ldhu	r4,-31310(gp)
   22158:	20c7883a 	add	r3,r4,r3
   2215c:	a8c19516 	blt	r21,r3,227b4 <StartInputHandler+0x75c>
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   22160:	b880030e 	bge	r23,r2,22170 <StartInputHandler+0x118>
   22164:	d0e16c0b 	ldhu	r3,-31312(gp)
   22168:	1dc7883a 	add	r3,r3,r23
   2216c:	a8c19116 	blt	r21,r3,227b4 <StartInputHandler+0x75c>
        ||
   22170:	8880020e 	bge	r17,r2,2217c <StartInputHandler+0x124>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
   22174:	8da3883a 	add	r17,r17,r22
   22178:	ac418e16 	blt	r21,r17,227b4 <StartInputHandler+0x75c>
        --- Check configured synchronization ---
    */

    /* Get the DC Control/Activation register value*/
    /*Read register 0x981 (corresponding masks are adapted)*/
    HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
   2217c:	01800044 	movi	r6,1
   22180:	01426044 	movi	r5,2433
   22184:	d9000184 	addi	r4,sp,6
   22188:	00205e80 	call	205e8 <HW_EscRead>

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
   2218c:	01800104 	movi	r6,4
   22190:	01426804 	movi	r5,2464
   22194:	d9000304 	addi	r4,sp,12
   22198:	00205e80 	call	205e8 <HW_EscRead>
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);

    // Cycle time for Sync1
        HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
   2219c:	01800104 	movi	r6,4
   221a0:	01426904 	movi	r5,2468
   221a4:	d9000404 	addi	r4,sp,16
   221a8:	00205e80 	call	205e8 <HW_EscRead>
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   221ac:	d9400183 	ldbu	r5,6(sp)
        shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
   221b0:	dd400417 	ldw	r21,16(sp)
    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
   221b4:	80c0008b 	ldhu	r3,2(r16)
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
   221b8:	2980024c 	andi	r6,r5,9
   221bc:	9080008b 	ldhu	r2,2(r18)
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   221c0:	3000101e 	bne	r6,zero,22204 <StartInputHandler+0x1ac>


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
   221c4:	d1216e83 	ldbu	r4,-31302(gp)
   221c8:	21403fcc 	andi	r5,r4,255
   221cc:	28003f1e 	bne	r5,zero,222cc <StartInputHandler+0x274>
            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
                
                if (nPdInputSize > 0)
   221d0:	d0a1598b 	ldhu	r2,-31386(gp)
            if (nPdOutputSize > 0)
   221d4:	d161590b 	ldhu	r5,-31388(gp)
   221d8:	10ffffcc 	andi	r3,r2,65535
   221dc:	28005826 	beq	r5,zero,22340 <StartInputHandler+0x2e8>
                if (nPdInputSize > 0)
   221e0:	1800c21e 	bne	r3,zero,224ec <StartInputHandler+0x494>
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
   221e4:	d0e15c03 	ldbu	r3,-31376(gp)
   221e8:	1800a426 	beq	r3,zero,2247c <StartInputHandler+0x424>
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
   221ec:	00c00044 	movi	r3,1
   221f0:	00007d06 	br	223e8 <StartInputHandler+0x390>
       nPdOutputBuffer = 1;
   221f4:	07000044 	movi	fp,1
   221f8:	003fb606 	br	220d4 <StartInputHandler+0x7c>
        nPdInputBuffer = 1;
   221fc:	01000044 	movi	r4,1
   22200:	003fbc06 	br	220f4 <StartInputHandler+0x9c>
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
   22204:	2900008c 	andi	r4,r5,2
   22208:	20004926 	beq	r4,zero,22330 <StartInputHandler+0x2d8>
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   2220c:	9d08703a 	and	r4,r19,r20
        if(u16MinSuppSyncType != 0)
   22210:	21bfffcc 	andi	r6,r4,65535
   22214:	30000626 	beq	r6,zero,22230 <StartInputHandler+0x1d8>
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
   22218:	2180010c 	andi	r6,r4,4
   2221c:	30004426 	beq	r6,zero,22330 <StartInputHandler+0x2d8>
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
   22220:	2180020c 	andi	r6,r4,8
   22224:	3000021e 	bne	r6,zero,22230 <StartInputHandler+0x1d8>
   22228:	2980010c 	andi	r6,r5,4
   2222c:	3000401e 	bne	r6,zero,22330 <StartInputHandler+0x2d8>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   22230:	d9c00317 	ldw	r7,12(sp)
            curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
   22234:	82000417 	ldw	r8,16(r16)
   22238:	2980018c 	andi	r6,r5,6
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   2223c:	3800131e 	bne	r7,zero,2228c <StartInputHandler+0x234>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   22240:	31800198 	cmpnei	r6,r6,6
   22244:	3000011e 	bne	r6,zero,2224c <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   22248:	a800171e 	bne	r21,zero,222a8 <StartInputHandler+0x250>
    if(bSyncSetByUser)
   2224c:	d1216e83 	ldbu	r4,-31302(gp)
   22250:	2000391e 	bne	r4,zero,22338 <StartInputHandler+0x2e0>
            if (nPdOutputSize > 0)
   22254:	d0a1590b 	ldhu	r2,-31388(gp)
   22258:	1000701e 	bne	r2,zero,2241c <StartInputHandler+0x3c4>
   2225c:	0009883a 	mov	r4,zero
            if (nPdInputSize > 0)
   22260:	d0e1598b 	ldhu	r3,-31386(gp)
   22264:	d0a15c03 	ldbu	r2,-31376(gp)
   22268:	18003726 	beq	r3,zero,22348 <StartInputHandler+0x2f0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   2226c:	2940010c 	andi	r5,r5,4
   22270:	2800911e 	bne	r5,zero,224b8 <StartInputHandler+0x460>
    if ( !b3BufferMode )
   22274:	10008126 	beq	r2,zero,2247c <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   22278:	00800084 	movi	r2,2

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
   2227c:	00c00044 	movi	r3,1
   22280:	d0e15c45 	stb	r3,-31375(gp)
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
   22284:	0007883a 	mov	r3,zero
   22288:	00005906 	br	223f0 <StartInputHandler+0x398>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   2228c:	3a014b36 	bltu	r7,r8,227bc <StartInputHandler+0x764>
   22290:	0230d434 	movhi	r8,50000
   22294:	41c14936 	bltu	r8,r7,227bc <StartInputHandler+0x764>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   22298:	318001a0 	cmpeqi	r6,r6,6
   2229c:	303feb26 	beq	r6,zero,2224c <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   222a0:	a83fea26 	beq	r21,zero,2224c <StartInputHandler+0x1f4>
   222a4:	a9ffe936 	bltu	r21,r7,2224c <StartInputHandler+0x1f4>
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
   222a8:	2100040c 	andi	r4,r4,16
   222ac:	20002026 	beq	r4,zero,22330 <StartInputHandler+0x2d8>
    if(bSyncSetByUser)
   222b0:	d1216e83 	ldbu	r4,-31302(gp)
   222b4:	2000151e 	bne	r4,zero,2230c <StartInputHandler+0x2b4>
            if (nPdOutputSize > 0)
   222b8:	d0e1590b 	ldhu	r3,-31388(gp)
                if (nPdInputSize > 0)
   222bc:	d0a1598b 	ldhu	r2,-31386(gp)
            if (nPdOutputSize > 0)
   222c0:	18003c1e 	bne	r3,zero,223b4 <StartInputHandler+0x35c>
                bSubordinatedCycles = TRUE;
   222c4:	01000044 	movi	r4,1
   222c8:	003fe506 	br	22260 <StartInputHandler+0x208>
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   222cc:	193fff84 	addi	r4,r3,-2
   222d0:	213fffcc 	andi	r4,r4,65535
   222d4:	210000b0 	cmpltui	r4,r4,2
   222d8:	2000151e 	bne	r4,zero,22330 <StartInputHandler+0x2d8>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
   222dc:	113fff84 	addi	r4,r2,-2
   222e0:	213fffcc 	andi	r4,r4,65535
   222e4:	210000b0 	cmpltui	r4,r4,2
   222e8:	2000111e 	bne	r4,zero,22330 <StartInputHandler+0x2d8>
   222ec:	3009883a 	mov	r4,r6
    if ( !b3BufferMode )
   222f0:	d1a15c03 	ldbu	r6,-31376(gp)
   222f4:	197fffcc 	andi	r5,r3,65535
   222f8:	3000761e 	bne	r6,zero,224d4 <StartInputHandler+0x47c>
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
   222fc:	28005f26 	beq	r5,zero,2247c <StartInputHandler+0x424>
   22300:	117fffcc 	andi	r5,r2,65535
   22304:	2800381e 	bne	r5,zero,223e8 <StartInputHandler+0x390>
   22308:	00005c06 	br	2247c <StartInputHandler+0x424>
                bSubordinatedCycles = TRUE;
   2230c:	01000044 	movi	r4,1
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
   22310:	2940010c 	andi	r5,r5,4
   22314:	19bfffcc 	andi	r6,r3,65535
   22318:	2800491e 	bne	r5,zero,22440 <StartInputHandler+0x3e8>
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
   2231c:	314000e0 	cmpeqi	r5,r6,3
   22320:	2800031e 	bne	r5,zero,22330 <StartInputHandler+0x2d8>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
   22324:	117fffcc 	andi	r5,r2,65535
   22328:	294000e0 	cmpeqi	r5,r5,3
   2232c:	28004626 	beq	r5,zero,22448 <StartInputHandler+0x3f0>
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
   22330:	00800c04 	movi	r2,48
   22334:	00005206 	br	22480 <StartInputHandler+0x428>
    BOOL bSubordinatedCycles = FALSE;
   22338:	0009883a 	mov	r4,zero
   2233c:	003ff406 	br	22310 <StartInputHandler+0x2b8>
            else if (nPdInputSize > 0)
   22340:	d0a15c03 	ldbu	r2,-31376(gp)
   22344:	18004c1e 	bne	r3,zero,22478 <StartInputHandler+0x420>
    if ( !b3BufferMode )
   22348:	10004c26 	beq	r2,zero,2247c <StartInputHandler+0x424>
        if(bEscIntEnabled)
   2234c:	d0a15c43 	ldbu	r2,-31375(gp)
   22350:	1000681e 	bne	r2,zero,224f4 <StartInputHandler+0x49c>
   22354:	0007883a 	mov	r3,zero
            }
        }



    sSyncManOutPar.u16SyncType = SyncType0x1C32;
   22358:	80c0008d 	sth	r3,2(r16)
    LatchInputSync0Counter = 0;
    u16SmSync0Value = 0;
    u16SmSync0Counter = 0;


    if(bSubordinatedCycles == TRUE)
   2235c:	24003fcc 	andi	r16,r4,255
    sSyncManInPar.u16SyncType = SyncType0x1C33;
   22360:	9080008d 	sth	r2,2(r18)
    LatchInputSync0Value = 0;
   22364:	d0215d8d 	sth	zero,-31370(gp)
    LatchInputSync0Counter = 0;
   22368:	d0215d0d 	sth	zero,-31372(gp)
    u16SmSync0Value = 0;
   2236c:	d021618d 	sth	zero,-31354(gp)
    u16SmSync0Counter = 0;
   22370:	d021620d 	sth	zero,-31352(gp)
    if(bSubordinatedCycles == TRUE)
   22374:	81000058 	cmpnei	r4,r16,1
   22378:	2000d31e 	bne	r4,zero,226c8 <StartInputHandler+0x670>
    {
        
        UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
   2237c:	dc800317 	ldw	r18,12(sp)
   22380:	aca7883a 	add	r19,r21,r18

        /* get the number of Sync0 event within on SM cycle */
        if(shiftTimeSync1 >= cycleTimeSync0)
        {

            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   22384:	900b883a 	mov	r5,r18
   22388:	9809883a 	mov	r4,r19
   2238c:	0026f6c0 	call	26f6c <__udivsi3>
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22390:	900b883a 	mov	r5,r18
   22394:	9809883a 	mov	r4,r19
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   22398:	1023883a 	mov	r17,r2
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   2239c:	0026fd00 	call	26fd0 <__umodsi3>
        if(shiftTimeSync1 >= cycleTimeSync0)
   223a0:	ac80c636 	bltu	r21,r18,226bc <StartInputHandler+0x664>
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   223a4:	10006c26 	beq	r2,zero,22558 <StartInputHandler+0x500>
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   223a8:	d461618d 	sth	r17,-31354(gp)
        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);

        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
        {
            LatchInputSync0Value++;
   223ac:	8c400044 	addi	r17,r17,1
   223b0:	00006b06 	br	22560 <StartInputHandler+0x508>
            if (nPdInputSize > 0)
   223b4:	10ffffcc 	andi	r3,r2,65535
   223b8:	18000326 	beq	r3,zero,223c8 <StartInputHandler+0x370>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   223bc:	2940010c 	andi	r5,r5,4
   223c0:	28002b26 	beq	r5,zero,22470 <StartInputHandler+0x418>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   223c4:	008000c4 	movi	r2,3
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   223c8:	01000044 	movi	r4,1
    if ( !b3BufferMode )
   223cc:	d0e15c03 	ldbu	r3,-31376(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   223d0:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   223d4:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   223d8:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   223dc:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   223e0:	18003826 	beq	r3,zero,224c4 <StartInputHandler+0x46c>
   223e4:	00c000c4 	movi	r3,3
        bEscIntEnabled = TRUE;
   223e8:	01400044 	movi	r5,1
   223ec:	d1615c45 	stb	r5,-31375(gp)
            if(nPdOutputSize > 0)
   223f0:	d1a1590b 	ldhu	r6,-31388(gp)
   223f4:	197fff84 	addi	r5,r3,-2
   223f8:	30004026 	beq	r6,zero,224fc <StartInputHandler+0x4a4>
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   223fc:	01810004 	movi	r6,1024
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22400:	297fffcc 	andi	r5,r5,65535
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   22404:	d1a1558d 	sth	r6,-31402(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22408:	294000a8 	cmpgeui	r5,r5,2
   2240c:	2800461e 	bne	r5,zero,22528 <StartInputHandler+0x4d0>
            bDcSyncActive = TRUE;
   22410:	01400044 	movi	r5,1
   22414:	d1616385 	stb	r5,-31346(gp)
            if (nPdOutputSize == 0)
   22418:	003fcf06 	br	22358 <StartInputHandler+0x300>
            if (nPdInputSize > 0)
   2241c:	d0a1598b 	ldhu	r2,-31386(gp)
   22420:	10ffffcc 	andi	r3,r2,65535
   22424:	18000426 	beq	r3,zero,22438 <StartInputHandler+0x3e0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22428:	2940010c 	andi	r5,r5,4
   2242c:	2809883a 	mov	r4,r5
   22430:	28001f26 	beq	r5,zero,224b0 <StartInputHandler+0x458>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   22434:	008000c4 	movi	r2,3
            if (nPdInputSize > 0)
   22438:	0009883a 	mov	r4,zero
   2243c:	00000406 	br	22450 <StartInputHandler+0x3f8>
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22440:	314000d8 	cmpnei	r5,r6,3
   22444:	283fe126 	beq	r5,zero,223cc <StartInputHandler+0x374>
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   22448:	31800098 	cmpnei	r6,r6,2
   2244c:	303fa81e 	bne	r6,zero,222f0 <StartInputHandler+0x298>
    if ( !b3BufferMode )
   22450:	d0e15c03 	ldbu	r3,-31376(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22454:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22458:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   2245c:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22460:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   22464:	18001926 	beq	r3,zero,224cc <StartInputHandler+0x474>
   22468:	00c00084 	movi	r3,2
   2246c:	003fde06 	br	223e8 <StartInputHandler+0x390>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   22470:	00800084 	movi	r2,2
   22474:	003fd406 	br	223c8 <StartInputHandler+0x370>
    if ( !b3BufferMode )
   22478:	10001a1e 	bne	r2,zero,224e4 <StartInputHandler+0x48c>
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
   2247c:	00800a44 	movi	r2,41

    /*write initial input data*/
    PDO_InputMapping();

    return ALSTATUSCODE_NOERROR;
}
   22480:	dfc00e17 	ldw	ra,56(sp)
   22484:	df000d17 	ldw	fp,52(sp)
   22488:	ddc00c17 	ldw	r23,48(sp)
   2248c:	dd800b17 	ldw	r22,44(sp)
   22490:	dd400a17 	ldw	r21,40(sp)
   22494:	dd000917 	ldw	r20,36(sp)
   22498:	dcc00817 	ldw	r19,32(sp)
   2249c:	dc800717 	ldw	r18,28(sp)
   224a0:	dc400617 	ldw	r17,24(sp)
   224a4:	dc000517 	ldw	r16,20(sp)
   224a8:	dec00f04 	addi	sp,sp,60
   224ac:	f800283a 	ret
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   224b0:	00800084 	movi	r2,2
   224b4:	003fe606 	br	22450 <StartInputHandler+0x3f8>
    if ( !b3BufferMode )
   224b8:	103ff026 	beq	r2,zero,2247c <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   224bc:	008000c4 	movi	r2,3
   224c0:	003f6e06 	br	2227c <StartInputHandler+0x224>
    if ( !b3BufferMode )
   224c4:	00c000c4 	movi	r3,3
   224c8:	003f8d06 	br	22300 <StartInputHandler+0x2a8>
   224cc:	00c00084 	movi	r3,2
   224d0:	003f8b06 	br	22300 <StartInputHandler+0x2a8>
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
   224d4:	283fc41e 	bne	r5,zero,223e8 <StartInputHandler+0x390>
   224d8:	10ffffcc 	andi	r3,r2,65535
   224dc:	183f9b26 	beq	r3,zero,2234c <StartInputHandler+0x2f4>
   224e0:	003f6606 	br	2227c <StartInputHandler+0x224>
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
   224e4:	00800044 	movi	r2,1
   224e8:	003f6406 	br	2227c <StartInputHandler+0x224>
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
   224ec:	00800884 	movi	r2,34
   224f0:	003f3e06 	br	221ec <StartInputHandler+0x194>
        if(bEscIntEnabled)
   224f4:	0005883a 	mov	r2,zero
   224f8:	003f6206 	br	22284 <StartInputHandler+0x22c>
            else if(nPdInputSize > 0)
   224fc:	d1a1598b 	ldhu	r6,-31386(gp)
   22500:	30000226 	beq	r6,zero,2250c <StartInputHandler+0x4b4>
                u16ALEventMask = PROCESS_INPUT_EVENT;
   22504:	01820004 	movi	r6,2048
   22508:	d1a1558d 	sth	r6,-31402(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   2250c:	297fffcc 	andi	r5,r5,65535
   22510:	294000b0 	cmpltui	r5,r5,2
   22514:	28000a26 	beq	r5,zero,22540 <StartInputHandler+0x4e8>
            bDcSyncActive = TRUE;
   22518:	01400044 	movi	r5,1
   2251c:	d1616385 	stb	r5,-31346(gp)
               u16ALEventMask = 0;
   22520:	d021558d 	sth	zero,-31402(gp)
   22524:	003f8c06 	br	22358 <StartInputHandler+0x300>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
   22528:	117fffcc 	andi	r5,r2,65535
   2252c:	29800098 	cmpnei	r6,r5,2
   22530:	303fb726 	beq	r6,zero,22410 <StartInputHandler+0x3b8>
   22534:	294000d8 	cmpnei	r5,r5,3
   22538:	283fb526 	beq	r5,zero,22410 <StartInputHandler+0x3b8>
   2253c:	003f8606 	br	22358 <StartInputHandler+0x300>
   22540:	117fffcc 	andi	r5,r2,65535
   22544:	298000a0 	cmpeqi	r6,r5,2
   22548:	303ff31e 	bne	r6,zero,22518 <StartInputHandler+0x4c0>
   2254c:	294000d8 	cmpnei	r5,r5,3
   22550:	283ff126 	beq	r5,zero,22518 <StartInputHandler+0x4c0>
   22554:	003f8006 	br	22358 <StartInputHandler+0x300>
                u16SmSync0Value ++;
   22558:	88800044 	addi	r2,r17,1
   2255c:	d0a1618d 	sth	r2,-31354(gp)
            LatchInputSync0Value++;
   22560:	d4615d8d 	sth	r17,-31370(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   22564:	01800084 	movi	r6,2
   22568:	01410804 	movi	r5,1056
   2256c:	d9000284 	addi	r4,sp,10
    sCycleDiag.syncFailedCounter = 0;
   22570:	d0216e0d 	sth	zero,-31304(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   22574:	00205e80 	call	205e8 <HW_EscRead>
    if (nPdOutputSize > 0 &&  wd != 0 )
   22578:	d0e1590b 	ldhu	r3,-31388(gp)
    wd = SWAPWORD(wd);
   2257c:	d880028b 	ldhu	r2,10(sp)
    if (nPdOutputSize > 0 &&  wd != 0 )
   22580:	18005f26 	beq	r3,zero,22700 <StartInputHandler+0x6a8>
   22584:	10bfffcc 	andi	r2,r2,65535
   22588:	10005d26 	beq	r2,zero,22700 <StartInputHandler+0x6a8>
    HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
   2258c:	01410004 	movi	r5,1024
   22590:	01800084 	movi	r6,2
   22594:	d9000204 	addi	r4,sp,8
   22598:	00205e80 	call	205e8 <HW_EscRead>
        if ( wdiv != 0 )
   2259c:	d940020b 	ldhu	r5,8(sp)
   225a0:	28005426 	beq	r5,zero,226f4 <StartInputHandler+0x69c>
            d *= wd;
   225a4:	d900028b 	ldhu	r4,10(sp)
   225a8:	29400084 	addi	r5,r5,2
   225ac:	002702c0 	call	2702c <__mulsi3>
            d /= 25000;
   225b0:	01586a04 	movi	r5,25000
   225b4:	111869c4 	addi	r4,r2,24999
   225b8:	0026f6c0 	call	26f6c <__udivsi3>
            EcatWdValue = (UINT16) d;
   225bc:	d0a1570d 	sth	r2,-31396(gp)
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   225c0:	10bfffcc 	andi	r2,r2,65535
   225c4:	d0e163c3 	ldbu	r3,-31345(gp)
   225c8:	10004f1e 	bne	r2,zero,22708 <StartInputHandler+0x6b0>
   225cc:	d0a163c3 	ldbu	r2,-31345(gp)
   225d0:	10004f1e 	bne	r2,zero,22710 <StartInputHandler+0x6b8>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   225d4:	d0a15c43 	ldbu	r2,-31375(gp)
   225d8:	10004f1e 	bne	r2,zero,22718 <StartInputHandler+0x6c0>
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   225dc:	01800044 	movi	r6,1
   225e0:	01405444 	movi	r5,337
   225e4:	d90001c4 	addi	r4,sp,7
    Sync0WdValue = 0;
   225e8:	d0215f0d 	sth	zero,-31364(gp)
    Sync0WdCounter = 0;
   225ec:	d0215f8d 	sth	zero,-31362(gp)
    Sync1WdCounter = 0;
   225f0:	d0215e8d 	sth	zero,-31366(gp)
    Sync1WdValue = 0;
   225f4:	d0215e0d 	sth	zero,-31368(gp)
    bDcRunning = FALSE;
   225f8:	d0216285 	stb	zero,-31350(gp)
    bSmSyncSequenceValid = FALSE;
   225fc:	d0216105 	stb	zero,-31356(gp)
    i16WaitForPllRunningTimeout = 0;
   22600:	d021608d 	sth	zero,-31358(gp)
        UINT8 u8TmpVar = 0;
   22604:	d80001c5 	stb	zero,7(sp)
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   22608:	00205e80 	call	205e8 <HW_EscRead>
        if ((u8TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
   2260c:	d88001c3 	ldbu	r2,7(sp)
   22610:	10c0020c 	andi	r3,r2,8
   22614:	18000326 	beq	r3,zero,22624 <StartInputHandler+0x5cc>
            u16ALEventMask |= SYNC0_EVENT;
   22618:	d0e1558b 	ldhu	r3,-31402(gp)
   2261c:	18c00114 	ori	r3,r3,4
   22620:	d0e1558d 	sth	r3,-31402(gp)
        if ((u8TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
   22624:	10803fcc 	andi	r2,r2,255
   22628:	1080201c 	xori	r2,r2,128
   2262c:	10bfe004 	addi	r2,r2,-128
   22630:	1000030e 	bge	r2,zero,22640 <StartInputHandler+0x5e8>
            u16ALEventMask |= SYNC1_EVENT;
   22634:	d0a1558b 	ldhu	r2,-31402(gp)
   22638:	10800214 	ori	r2,r2,8
   2263c:	d0a1558d 	sth	r2,-31402(gp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22640:	008000f4 	movhi	r2,3
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   22644:	dc400183 	ldbu	r17,6(sp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22648:	10232e15 	stw	zero,-29512(r2)
    sSyncManInPar.u8SyncError = 0;
   2264c:	008000f4 	movhi	r2,3
   22650:	10233405 	stb	zero,-29488(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   22654:	008000f4 	movhi	r2,3
   22658:	10233f15 	stw	zero,-29444(r2)
    sSyncManOutPar.u8SyncError = 0;
   2265c:	008000f4 	movhi	r2,3
   22660:	10234505 	stb	zero,-29420(r2)
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   22664:	8880008c 	andi	r2,r17,2
   22668:	10004126 	beq	r2,zero,22770 <StartInputHandler+0x718>
        if(cycleTimeSync0 == 0)
   2266c:	dc000317 	ldw	r16,12(sp)
   22670:	8c40010c 	andi	r17,r17,4
   22674:	80002e1e 	bne	r16,zero,22730 <StartInputHandler+0x6d8>
            Sync0WdValue = 0;
   22678:	d0215f0d 	sth	zero,-31364(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   2267c:	88003c26 	beq	r17,zero,22770 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   22680:	d8c00417 	ldw	r3,16(sp)
                if(Sync1Cycle < 5)
   22684:	00800234 	movhi	r2,8
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   22688:	80c9883a 	add	r4,r16,r3
                if(Sync1Cycle < 5)
   2268c:	10a847c4 	addi	r2,r2,-24289
   22690:	1100442e 	bgeu	r2,r4,227a4 <StartInputHandler+0x74c>
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   22694:	014000b4 	movhi	r5,2
   22698:	2961a804 	addi	r5,r5,-31072
   2269c:	0026f6c0 	call	26f6c <__udivsi3>
                    Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
   226a0:	1008907a 	slli	r4,r2,1
   226a4:	01400284 	movi	r5,10
   226a8:	0026f6c0 	call	26f6c <__udivsi3>
                Sync1WdValue += Sync0WdValue/2;
   226ac:	d0e15f0b 	ldhu	r3,-31364(gp)
   226b0:	1806d07a 	srli	r3,r3,1
   226b4:	1885883a 	add	r2,r3,r2
   226b8:	00002c06 	br	2276c <StartInputHandler+0x714>
            u16SmSync0Value = 1;
   226bc:	d421618d 	sth	r16,-31354(gp)
        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
   226c0:	103f3a1e 	bne	r2,zero,223ac <StartInputHandler+0x354>
   226c4:	003fa606 	br	22560 <StartInputHandler+0x508>
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   226c8:	18ffffcc 	andi	r3,r3,65535
   226cc:	18c00098 	cmpnei	r3,r3,2
   226d0:	1800021e 	bne	r3,zero,226dc <StartInputHandler+0x684>
            u16SmSync0Value = 1;
   226d4:	00c00044 	movi	r3,1
   226d8:	d0e1618d 	sth	r3,-31354(gp)
        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
   226dc:	10bfffcc 	andi	r2,r2,65535
   226e0:	108000e0 	cmpeqi	r2,r2,3
   226e4:	103f9f1e 	bne	r2,zero,22564 <StartInputHandler+0x50c>
            LatchInputSync0Value = 1;
   226e8:	00800044 	movi	r2,1
   226ec:	d0a15d8d 	sth	r2,-31370(gp)
   226f0:	003f9c06 	br	22564 <StartInputHandler+0x50c>
            wd = 0;
   226f4:	d800028d 	sth	zero,10(sp)
        EcatWdValue = 0;
   226f8:	d021570d 	sth	zero,-31396(gp)
   226fc:	003fb306 	br	225cc <StartInputHandler+0x574>
        wdiv = 0;
   22700:	d800020d 	sth	zero,8(sp)
   22704:	003ffc06 	br	226f8 <StartInputHandler+0x6a0>
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   22708:	18803fcc 	andi	r2,r3,255
   2270c:	103fb11e 	bne	r2,zero,225d4 <StartInputHandler+0x57c>
        return ALSTATUSCODE_INVALIDWDCFG;
   22710:	008007c4 	movi	r2,31
   22714:	003f5a06 	br	22480 <StartInputHandler+0x428>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   22718:	d0a1590b 	ldhu	r2,-31388(gp)
   2271c:	103faf26 	beq	r2,zero,225dc <StartInputHandler+0x584>
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
   22720:	d0a1558b 	ldhu	r2,-31402(gp)
   22724:	10810014 	ori	r2,r2,1024
   22728:	d0a1558d 	sth	r2,-31402(gp)
   2272c:	003fab06 	br	225dc <StartInputHandler+0x584>
            if(Sync0Cycle < 5)
   22730:	00800234 	movhi	r2,8
   22734:	10a847c4 	addi	r2,r2,-24289
   22738:	1400182e 	bgeu	r2,r16,2279c <StartInputHandler+0x744>
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
   2273c:	014000b4 	movhi	r5,2
   22740:	2961a804 	addi	r5,r5,-31072
   22744:	8009883a 	mov	r4,r16
   22748:	0026f6c0 	call	26f6c <__udivsi3>
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
   2274c:	1008907a 	slli	r4,r2,1
   22750:	01400284 	movi	r5,10
   22754:	213fff8c 	andi	r4,r4,65534
   22758:	0026f6c0 	call	26f6c <__udivsi3>
   2275c:	d0a15f0d 	sth	r2,-31364(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   22760:	88000326 	beq	r17,zero,22770 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   22764:	d8c00417 	ldw	r3,16(sp)
   22768:	1c3fc62e 	bgeu	r3,r16,22684 <StartInputHandler+0x62c>
                Sync1WdValue += Sync0WdValue/2;
   2276c:	d0a15e0d 	sth	r2,-31368(gp)
    if(nPdOutputSize > 0)
   22770:	d0a1590b 	ldhu	r2,-31388(gp)
   22774:	10000226 	beq	r2,zero,22780 <StartInputHandler+0x728>
        EnableSyncManChannel(PROCESS_DATA_OUT);
   22778:	01000084 	movi	r4,2
   2277c:	0021d8c0 	call	21d8c <EnableSyncManChannel>
    if(nPdInputSize > 0)
   22780:	d0a1598b 	ldhu	r2,-31386(gp)
   22784:	10000226 	beq	r2,zero,22790 <StartInputHandler+0x738>
        EnableSyncManChannel(PROCESS_DATA_IN);
   22788:	010000c4 	movi	r4,3
   2278c:	0021d8c0 	call	21d8c <EnableSyncManChannel>
    PDO_InputMapping();
   22790:	0020d6c0 	call	20d6c <PDO_InputMapping>
    return ALSTATUSCODE_NOERROR;
   22794:	0005883a 	mov	r2,zero
   22798:	003f3906 	br	22480 <StartInputHandler+0x428>
   2279c:	00800044 	movi	r2,1
   227a0:	003fee06 	br	2275c <StartInputHandler+0x704>
   227a4:	00800044 	movi	r2,1
   227a8:	003fc006 	br	226ac <StartInputHandler+0x654>
        return ALSTATUSCODE_INVALIDSMINCFG;
   227ac:	00800784 	movi	r2,30
   227b0:	003f3306 	br	22480 <StartInputHandler+0x428>
        return ALSTATUSCODE_INVALIDSMOUTCFG;
   227b4:	00800744 	movi	r2,29
   227b8:	003f3106 	br	22480 <StartInputHandler+0x428>
                    return ALSTATUSCODE_DCSYNC0CYCLETIME;
   227bc:	00800d84 	movi	r2,54
   227c0:	003f2f06 	br	22480 <StartInputHandler+0x428>

000227c4 <StartOutputHandler>:
    /* by default the SO transition should be completed in AlControlRes().
       required to support also masters which starts to send process data after the SO transition was triggered
       (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
    UINT16 result = NOERROR_INWORK;
    /*ECATCHANGE_START(V5.13) ESM1*/
    if(STATE_VALID(u8LocalErrorState))
   227c4:	d0e15b03 	ldbu	r3,-31380(gp)
   227c8:	00804584 	movi	r2,278
   227cc:	18c003cc 	andi	r3,r3,15
   227d0:	10c4d83a 	srl	r2,r2,r3
   227d4:	1080004c 	andi	r2,r2,1
   227d8:	10000226 	beq	r2,zero,227e4 <StartOutputHandler+0x20>
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
        return u16LocalErrorCode;
   227dc:	d0a15b8b 	ldhu	r2,-31378(gp)
   227e0:	f800283a 	ret
    }
/*The application ESM function is separated from this function to handle pending transitions*/


    /*DC synchronisation is active wait until pll is valid*/
    if(bDcSyncActive)
   227e4:	d0a16383 	ldbu	r2,-31346(gp)
   227e8:	10000326 	beq	r2,zero,227f8 <StartOutputHandler+0x34>
    {
        i16WaitForPllRunningTimeout = 200;
   227ec:	00803204 	movi	r2,200
   227f0:	d0a1608d 	sth	r2,-31358(gp)

        i16WaitForPllRunningCnt = 0;
   227f4:	d021600d 	sth	zero,-31360(gp)
    }



    sSyncManOutPar.u16SmEventMissedCounter = 0;
   227f8:	008000f4 	movhi	r2,3
   227fc:	10233f0d 	sth	zero,-29444(r2)
    sSyncManOutPar.u8SyncError = 0;
   22800:	008000f4 	movhi	r2,3
   22804:	10234505 	stb	zero,-29420(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   22808:	008000f4 	movhi	r2,3
   2280c:	10232e0d 	sth	zero,-29512(r2)
    sSyncManInPar.u8SyncError = 0;
   22810:	008000f4 	movhi	r2,3
   22814:	10233405 	stb	zero,-29488(r2)
   22818:	00803fc4 	movi	r2,255


    return result;
}
   2281c:	f800283a 	ret

00022820 <StopOutputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

void StopOutputHandler(void)
{
    /* reset the flags that outputs were received and that the slave is in OP */
    bEcatFirstOutputsReceived = FALSE;
   22820:	d0216405 	stb	zero,-31344(gp)
    bEcatOutputUpdateRunning = FALSE;
   22824:	d0216485 	stb	zero,-31342(gp)
}
   22828:	f800283a 	ret

0002282c <StopInputHandler>:

*////////////////////////////////////////////////////////////////////////////////////////

void StopInputHandler(void)
{
    if(nPdOutputSize > 0)
   2282c:	d0a1590b 	ldhu	r2,-31388(gp)
{
   22830:	deffff04 	addi	sp,sp,-4
   22834:	dfc00015 	stw	ra,0(sp)
    if(nPdOutputSize > 0)
   22838:	10000226 	beq	r2,zero,22844 <StopInputHandler+0x18>
    {
        /* disable the Sync Manager Channel 2 (outputs) */
        DisableSyncManChannel(PROCESS_DATA_OUT);
   2283c:	01000084 	movi	r4,2
   22840:	0021d2c0 	call	21d2c <DisableSyncManChannel>
    }

    if(nPdInputSize > 0)
   22844:	d0a1598b 	ldhu	r2,-31386(gp)
   22848:	10000226 	beq	r2,zero,22854 <StopInputHandler+0x28>
    {
        /*disable Sync Manager 3 (inputs) if no outputs available*/
        DisableSyncManChannel(PROCESS_DATA_IN);
   2284c:	010000c4 	movi	r4,3
   22850:	0021d2c0 	call	21d2c <DisableSyncManChannel>
    {
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
        ResetMask |= PROCESS_OUTPUT_EVENT;
        ResetMask |= PROCESS_INPUT_EVENT;

    ResetALEventMask( ~(ResetMask) );
   22854:	013cfcd4 	movui	r4,62451
   22858:	0021c2c0 	call	21c2c <ResetALEventMask>
    Sync1WdValue = 0;
    LatchInputSync0Value = 0;
    LatchInputSync0Counter = 0;


    sSyncManOutPar.u16SmEventMissedCounter = 0;
   2285c:	008000f4 	movhi	r2,3
   22860:	10233f15 	stw	zero,-29444(r2)
    sSyncManOutPar.u16CycleExceededCounter = 0;
    sSyncManOutPar.u8SyncError = 0;
   22864:	008000f4 	movhi	r2,3
   22868:	10234505 	stb	zero,-29420(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   2286c:	008000f4 	movhi	r2,3
   22870:	10232e15 	stw	zero,-29512(r2)
    sSyncManInPar.u16CycleExceededCounter = 0;
    sSyncManInPar.u8SyncError = 0;
   22874:	008000f4 	movhi	r2,3
    bEcatFirstOutputsReceived = FALSE;
   22878:	d0216405 	stb	zero,-31344(gp)
    bEscIntEnabled = FALSE;
   2287c:	d0215c45 	stb	zero,-31375(gp)
    bDcSyncActive = FALSE;
   22880:	d0216385 	stb	zero,-31346(gp)
    bDcRunning = FALSE;
   22884:	d0216285 	stb	zero,-31350(gp)
    bSmSyncSequenceValid = FALSE;
   22888:	d0216105 	stb	zero,-31356(gp)
    u16SmSync0Value = 0;
   2288c:	d021618d 	sth	zero,-31354(gp)
    u16SmSync0Counter = 0;
   22890:	d021620d 	sth	zero,-31352(gp)
    Sync0WdValue = 0;
   22894:	d0215f0d 	sth	zero,-31364(gp)
    Sync0WdCounter = 0;
   22898:	d0215f8d 	sth	zero,-31362(gp)
    Sync1WdCounter = 0;
   2289c:	d0215e8d 	sth	zero,-31366(gp)
    Sync1WdValue = 0;
   228a0:	d0215e0d 	sth	zero,-31368(gp)
    LatchInputSync0Value = 0;
   228a4:	d0215d8d 	sth	zero,-31370(gp)
    LatchInputSync0Counter = 0;
   228a8:	d0215d0d 	sth	zero,-31372(gp)
    sSyncManInPar.u8SyncError = 0;
   228ac:	10233405 	stb	zero,-29488(r2)

    i16WaitForPllRunningTimeout = 0;
   228b0:	d021608d 	sth	zero,-31358(gp)

    bWdTrigger = FALSE;
   228b4:	d02163c5 	stb	zero,-31345(gp)
    bEcatInputUpdateRunning = FALSE;
   228b8:	d0216445 	stb	zero,-31343(gp)

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
   228bc:	d0216e85 	stb	zero,-31302(gp)
}
   228c0:	dfc00017 	ldw	ra,0(sp)
   228c4:	dec00104 	addi	sp,sp,4
   228c8:	f800283a 	ret

000228cc <BackToInitTransition>:
*////////////////////////////////////////////////////////////////////////////////////////

void BackToInitTransition(void)
{
    /* Reset indication that the user has written a sync mode*/
    bSyncSetByUser = FALSE;
   228cc:	d0216e85 	stb	zero,-31302(gp)
}
   228d0:	f800283a 	ret

000228d4 <SetALStatus>:
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
    UINT16 Value = alStatusCode;

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
   228d4:	d0e157c3 	ldbu	r3,-31393(gp)
{
   228d8:	defffe04 	addi	sp,sp,-8
   228dc:	dfc00115 	stw	ra,4(sp)
    UINT16 Value = alStatusCode;
   228e0:	d940008d 	sth	r5,2(sp)
    if(nAlStatus != alStatus)
   228e4:	20803fcc 	andi	r2,r4,255
   228e8:	18800126 	beq	r3,r2,228f0 <SetALStatus+0x1c>
    {
        nAlStatus = alStatus;
   228ec:	d12157c5 	stb	r4,-31393(gp)
    }

    /*Handle Explicit Device ID is requested*/
    if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
   228f0:	d0e15783 	ldbu	r3,-31394(gp)
   228f4:	d0a157c3 	ldbu	r2,-31393(gp)
   228f8:	297fffcc 	andi	r5,r5,65535
   228fc:	18001126 	beq	r3,zero,22944 <SetALStatus+0x70>
   22900:	10c0040c 	andi	r3,r2,16
   22904:	18000f1e 	bne	r3,zero,22944 <SetALStatus+0x70>
   22908:	28000e1e 	bne	r5,zero,22944 <SetALStatus+0x70>
   2290c:	10c003cc 	andi	r3,r2,15
   22910:	18c000e0 	cmpeqi	r3,r3,3
   22914:	1800091e 	bne	r3,zero,2293c <SetALStatus+0x68>
    {
/*ECATCHANGE_START(V5.13) ECAT2*/
        Value = u16IdValue;
   22918:	d0e1550b 	ldhu	r3,-31404(gp)
/*ECATCHANGE_END(V5.13) ECAT2*/
        nAlStatus |= STATE_DEVID;
   2291c:	10800814 	ori	r2,r2,32
        Value = u16IdValue;
   22920:	d8c0008d 	sth	r3,2(sp)
    }
    else
    {
        nAlStatus &= ~STATE_DEVID;
   22924:	d0a157c5 	stb	r2,-31393(gp)

    if (alStatusCode != 0xFFFF)
    {
        Value = SWAPWORD(Value);

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
   22928:	01800084 	movi	r6,2
   2292c:	01404d04 	movi	r5,308
   22930:	d9000084 	addi	r4,sp,2
   22934:	002066c0 	call	2066c <HW_EscWrite>
   22938:	00000606 	br	22954 <SetALStatus+0x80>
        nAlStatus &= ~STATE_DEVID;
   2293c:	108037cc 	andi	r2,r2,223
   22940:	003ff806 	br	22924 <SetALStatus+0x50>
   22944:	108037cc 	andi	r2,r2,223
   22948:	d0a157c5 	stb	r2,-31393(gp)
    if (alStatusCode != 0xFFFF)
   2294c:	00bfffd4 	movui	r2,65535
   22950:	28bff51e 	bne	r5,r2,22928 <SetALStatus+0x54>
    }

    Value = nAlStatus;
   22954:	d0a157c3 	ldbu	r2,-31393(gp)
    Value = SWAPWORD(Value);
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   22958:	01800084 	movi	r6,2
   2295c:	01404c04 	movi	r5,304
   22960:	d9000084 	addi	r4,sp,2
    Value = nAlStatus;
   22964:	d880008d 	sth	r2,2(sp)
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   22968:	002066c0 	call	2066c <HW_EscWrite>

}
   2296c:	dfc00117 	ldw	ra,4(sp)
   22970:	dec00204 	addi	sp,sp,8
   22974:	f800283a 	ret

00022978 <AL_ControlInd>:
{
    UINT16        result = 0;
    UINT8            bErrAck = 0;
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
   22978:	00bfffc4 	movi	r2,-1
{
   2297c:	defff704 	addi	sp,sp,-36
    EsmTimeoutCounter = -1;
   22980:	d0a1630d 	sth	r2,-31348(gp)
    bApplEsmPending = TRUE;
   22984:	00800044 	movi	r2,1
{
   22988:	dd800615 	stw	r22,24(sp)
   2298c:	dd400515 	stw	r21,20(sp)
   22990:	dd000415 	stw	r20,16(sp)
   22994:	dcc00315 	stw	r19,12(sp)
   22998:	dc400115 	stw	r17,4(sp)
    bApplEsmPending = TRUE;
   2299c:	d0a15ac5 	stb	r2,-31381(gp)
   229a0:	24c003cc 	andi	r19,r4,15
{
   229a4:	dfc00815 	stw	ra,32(sp)
   229a8:	ddc00715 	stw	r23,28(sp)
   229ac:	dc800215 	stw	r18,8(sp)
   229b0:	dc000015 	stw	r16,0(sp)
   229b4:	2080040c 	andi	r2,r4,16

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
    {
        bErrAck = 1;
        nAlStatus &= ~STATE_CHANGE;
   229b8:	d46157c3 	ldbu	r17,-31393(gp)
{
   229bc:	2829883a 	mov	r20,r5
   229c0:	282d883a 	mov	r22,r5
   229c4:	982b883a 	mov	r21,r19
    if ( alControl & STATE_CHANGE )
   229c8:	10005126 	beq	r2,zero,22b10 <AL_ControlInd+0x198>
        nAlStatus &= ~STATE_CHANGE;
   229cc:	00bffbc4 	movi	r2,-17
   229d0:	1462703a 	and	r17,r2,r17
        bErrAck = 1;
   229d4:	05c00044 	movi	r23,1
        nAlStatus &= ~STATE_CHANGE;
   229d8:	d46157c5 	stb	r17,-31393(gp)

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
    stateTrans = nAlStatus;
    stateTrans <<= 4;
   229dc:	8822913a 	slli	r17,r17,4
    stateTrans += alControl;
   229e0:	9c63883a 	add	r17,r19,r17

    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
   229e4:	8c803fcc 	andi	r18,r17,255
   229e8:	908010a0 	cmpeqi	r2,r18,66
   229ec:	1000951e 	bne	r2,zero,22c44 <AL_ControlInd+0x2cc>
   229f0:	908010e8 	cmpgeui	r2,r18,67
   229f4:	1000551e 	bne	r2,zero,22b4c <AL_ControlInd+0x1d4>
   229f8:	90800920 	cmpeqi	r2,r18,36
   229fc:	1000b01e 	bne	r2,zero,22cc0 <AL_ControlInd+0x348>
   22a00:	90800970 	cmpltui	r2,r18,37
   22a04:	1000491e 	bne	r2,zero,22b2c <AL_ControlInd+0x1b4>
    }

    if ( result == 0 )
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
   22a08:	d0215a0d 	sth	zero,-31384(gp)
        switch ( stateTrans )
   22a0c:	8c7ffbc4 	addi	r17,r17,-17
   22a10:	8c403fcc 	andi	r17,r17,255
   22a14:	88800e28 	cmpgeui	r2,r17,56
   22a18:	10005b1e 	bne	r2,zero,22b88 <AL_ControlInd+0x210>
   22a1c:	882290ba 	slli	r17,r17,2
   22a20:	008000b4 	movhi	r2,2
   22a24:	8885883a 	add	r2,r17,r2
   22a28:	108a8c17 	ldw	r2,10800(r2)
   22a2c:	1000683a 	jmp	r2
   22a30:	00023104 	movi	zero,2244
   22a34:	00022f0c 	andi	zero,zero,2236
   22a38:	00022cfc 	xorhi	zero,zero,2227
   22a3c:	00023238 	rdprs	zero,zero,2248
   22a40:	00022b88 	cmpgei	zero,zero,2222
   22a44:	00022b88 	cmpgei	zero,zero,2222
   22a48:	00022b88 	cmpgei	zero,zero,2222
   22a4c:	00023238 	rdprs	zero,zero,2248
   22a50:	00022b88 	cmpgei	zero,zero,2222
   22a54:	00022b88 	cmpgei	zero,zero,2222
   22a58:	00022b88 	cmpgei	zero,zero,2222
   22a5c:	00022b88 	cmpgei	zero,zero,2222
   22a60:	00022b88 	cmpgei	zero,zero,2222
   22a64:	00022b88 	cmpgei	zero,zero,2222
   22a68:	00022b88 	cmpgei	zero,zero,2222
   22a6c:	00022b88 	cmpgei	zero,zero,2222
   22a70:	000230d8 	cmpnei	zero,zero,2243
   22a74:	00023108 	cmpgei	zero,zero,2244
   22a78:	00023238 	rdprs	zero,zero,2248
   22a7c:	00022f7c 	xorhi	zero,zero,2237
   22a80:	00022b88 	cmpgei	zero,zero,2222
   22a84:	00022b88 	cmpgei	zero,zero,2222
   22a88:	00022b88 	cmpgei	zero,zero,2222
   22a8c:	00023238 	rdprs	zero,zero,2248
   22a90:	00022b88 	cmpgei	zero,zero,2222
   22a94:	00022b88 	cmpgei	zero,zero,2222
   22a98:	00022b88 	cmpgei	zero,zero,2222
   22a9c:	00022b88 	cmpgei	zero,zero,2222
   22aa0:	00022b88 	cmpgei	zero,zero,2222
   22aa4:	00022b88 	cmpgei	zero,zero,2222
   22aa8:	00022b88 	cmpgei	zero,zero,2222
   22aac:	00022b88 	cmpgei	zero,zero,2222
   22ab0:	00022eb4 	movhi	zero,2234
   22ab4:	00023238 	rdprs	zero,zero,2248
   22ab8:	00022b88 	cmpgei	zero,zero,2222
   22abc:	00023238 	rdprs	zero,zero,2248
   22ac0:	00022b88 	cmpgei	zero,zero,2222
   22ac4:	00022b88 	cmpgei	zero,zero,2222
   22ac8:	00022b88 	cmpgei	zero,zero,2222
   22acc:	00023238 	rdprs	zero,zero,2248
   22ad0:	00022b88 	cmpgei	zero,zero,2222
   22ad4:	00022b88 	cmpgei	zero,zero,2222
   22ad8:	00022b88 	cmpgei	zero,zero,2222
   22adc:	00022b88 	cmpgei	zero,zero,2222
   22ae0:	00022b88 	cmpgei	zero,zero,2222
   22ae4:	00022b88 	cmpgei	zero,zero,2222
   22ae8:	00022b88 	cmpgei	zero,zero,2222
   22aec:	00022b88 	cmpgei	zero,zero,2222
   22af0:	000230a8 	cmpgeui	zero,zero,2242
   22af4:	00022b88 	cmpgei	zero,zero,2222
   22af8:	00023238 	rdprs	zero,zero,2248
   22afc:	00023108 	cmpgei	zero,zero,2244
   22b00:	00022b88 	cmpgei	zero,zero,2222
   22b04:	00022b88 	cmpgei	zero,zero,2222
   22b08:	00022b88 	cmpgei	zero,zero,2222
   22b0c:	00022ff4 	movhi	zero,2239
   22b10:	102f883a 	mov	r23,r2
    else if ((nAlStatus & STATE_CHANGE)
   22b14:	8880040c 	andi	r2,r17,16
   22b18:	10000226 	beq	r2,zero,22b24 <AL_ControlInd+0x1ac>
        && (alControl & STATE_MASK) != STATE_INIT)
   22b1c:	98800058 	cmpnei	r2,r19,1
   22b20:	1000d91e 	bne	r2,zero,22e88 <AL_ControlInd+0x510>
        nAlStatus &= STATE_MASK;
   22b24:	8c4003cc 	andi	r17,r17,15
   22b28:	003fab06 	br	229d8 <AL_ControlInd+0x60>
    switch ( stateTrans )
   22b2c:	908004a0 	cmpeqi	r2,r18,18
   22b30:	10004d1e 	bne	r2,zero,22c68 <AL_ControlInd+0x2f0>
   22b34:	908008a0 	cmpeqi	r2,r18,34
   22b38:	10004b1e 	bne	r2,zero,22c68 <AL_ControlInd+0x2f0>
        nEcatStateTrans = 0;
   22b3c:	d0215a0d 	sth	zero,-31384(gp)
        switch ( stateTrans )
   22b40:	90800468 	cmpgeui	r2,r18,17
   22b44:	10001026 	beq	r2,zero,22b88 <AL_ControlInd+0x210>
   22b48:	003fb006 	br	22a0c <AL_ControlInd+0x94>
    switch ( stateTrans )
   22b4c:	908020a0 	cmpeqi	r2,r18,130
   22b50:	1000281e 	bne	r2,zero,22bf4 <AL_ControlInd+0x27c>
   22b54:	908020e8 	cmpgeui	r2,r18,131
   22b58:	1000101e 	bne	r2,zero,22b9c <AL_ControlInd+0x224>
   22b5c:	90801120 	cmpeqi	r2,r18,68
   22b60:	10005d1e 	bne	r2,zero,22cd8 <AL_ControlInd+0x360>
   22b64:	90801220 	cmpeqi	r2,r18,72
   22b68:	10005b1e 	bne	r2,zero,22cd8 <AL_ControlInd+0x360>
        nEcatStateTrans = 0;
   22b6c:	d0215a0d 	sth	zero,-31384(gp)
        switch ( stateTrans )
   22b70:	90801270 	cmpltui	r2,r18,73
   22b74:	103fa51e 	bne	r2,zero,22a0c <AL_ControlInd+0x94>
   22b78:	8c401fc4 	addi	r17,r17,127
   22b7c:	8c403fcc 	andi	r17,r17,255
   22b80:	8c400228 	cmpgeui	r17,r17,8
   22b84:	88014226 	beq	r17,zero,23090 <AL_ControlInd+0x718>
                break;
        }
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22b88:	d12157c3 	ldbu	r4,-31393(gp)
   22b8c:	208003cc 	andi	r2,r4,15
   22b90:	98806426 	beq	r19,r2,22d24 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
   22b94:	04000484 	movi	r16,18
   22b98:	00009606 	br	22df4 <AL_ControlInd+0x47c>
    switch ( stateTrans )
   22b9c:	90802120 	cmpeqi	r2,r18,132
   22ba0:	10004d1e 	bne	r2,zero,22cd8 <AL_ControlInd+0x360>
   22ba4:	90802220 	cmpeqi	r2,r18,136
   22ba8:	10004b1e 	bne	r2,zero,22cd8 <AL_ControlInd+0x360>
        nEcatStateTrans = 0;
   22bac:	d0215a0d 	sth	zero,-31384(gp)
        switch ( stateTrans )
   22bb0:	8c401fc4 	addi	r17,r17,127
   22bb4:	8c403fcc 	andi	r17,r17,255
   22bb8:	88800228 	cmpgeui	r2,r17,8
   22bbc:	103ff21e 	bne	r2,zero,22b88 <AL_ControlInd+0x210>
   22bc0:	882290ba 	slli	r17,r17,2
   22bc4:	008000b4 	movhi	r2,2
   22bc8:	8885883a 	add	r2,r17,r2
   22bcc:	108af517 	ldw	r2,11220(r2)
   22bd0:	1000683a 	jmp	r2
   22bd4:	00023090 	cmplti	zero,zero,2242
   22bd8:	00022c0c 	andi	zero,zero,2224
   22bdc:	00023238 	rdprs	zero,zero,2248
   22be0:	00023080 	call	2308 <__reset-0x1dcf8>
   22be4:	00022b88 	cmpgei	zero,zero,2222
   22be8:	00022b88 	cmpgei	zero,zero,2222
   22bec:	00022b88 	cmpgei	zero,zero,2222
   22bf0:	00023108 	cmpgei	zero,zero,2244
        result = CheckSmSettings(MAILBOX_READ+1);
   22bf4:	01000084 	movi	r4,2
   22bf8:	0021de80 	call	21de8 <CheckSmSettings>
   22bfc:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22c00:	10803fcc 	andi	r2,r2,255
   22c04:	10001d1e 	bne	r2,zero,22c7c <AL_ControlInd+0x304>
        nEcatStateTrans = 0;
   22c08:	d0215a0d 	sth	zero,-31384(gp)
            result = APPL_StopOutputHandler();
   22c0c:	00200b00 	call	200b0 <APPL_StopOutputHandler>
   22c10:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22c14:	00228200 	call	22820 <StopOutputHandler>
            if (result != 0)
   22c18:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22c1c:	d0215ac5 	stb	zero,-31381(gp)
            if (result != 0)
   22c20:	10000e26 	beq	r2,zero,22c5c <AL_ControlInd+0x2e4>
    if ( result == NOERROR_INWORK )
   22c24:	10803fd8 	cmpnei	r2,r2,255
   22c28:	10006f1e 	bne	r2,zero,22de8 <AL_ControlInd+0x470>
        bEcatWaitForAlControlRes = TRUE;
   22c2c:	00800044 	movi	r2,1
   22c30:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   22c34:	00802084 	movi	r2,130
   22c38:	d0a15a0d 	sth	r2,-31384(gp)
                break;
   22c3c:	04003204 	movi	r16,200
   22c40:	00008c06 	br	22e74 <AL_ControlInd+0x4fc>
        result = CheckSmSettings(MAILBOX_READ+1);
   22c44:	01000084 	movi	r4,2
   22c48:	0021de80 	call	21de8 <CheckSmSettings>
   22c4c:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22c50:	10803fcc 	andi	r2,r2,255
   22c54:	1000091e 	bne	r2,zero,22c7c <AL_ControlInd+0x304>
        nEcatStateTrans = 0;
   22c58:	d0215a0d 	sth	zero,-31384(gp)
            APPL_StopInputHandler();
   22c5c:	00200a00 	call	200a0 <APPL_StopInputHandler>
            StopInputHandler();
   22c60:	002282c0 	call	2282c <StopInputHandler>
   22c64:	00010806 	br	23088 <AL_ControlInd+0x710>
        result = CheckSmSettings(MAILBOX_READ+1);
   22c68:	01000084 	movi	r4,2
   22c6c:	0021de80 	call	21de8 <CheckSmSettings>
   22c70:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22c74:	10803fcc 	andi	r2,r2,255
   22c78:	103fb026 	beq	r2,zero,22b3c <AL_ControlInd+0x1c4>
        switch (nAlStatus)
   22c7c:	d12157c3 	ldbu	r4,-31393(gp)
   22c80:	85ffffcc 	andi	r23,r16,65535
   22c84:	20803fcc 	andi	r2,r4,255
   22c88:	10c00120 	cmpeqi	r3,r2,4
   22c8c:	1801351e 	bne	r3,zero,23164 <AL_ControlInd+0x7ec>
   22c90:	10c00220 	cmpeqi	r3,r2,8
   22c94:	1801311e 	bne	r3,zero,2315c <AL_ControlInd+0x7e4>
   22c98:	10c000a0 	cmpeqi	r3,r2,2
   22c9c:	1801331e 	bne	r3,zero,2316c <AL_ControlInd+0x7f4>
    if ( result == NOERROR_INWORK )
   22ca0:	bdc03fe0 	cmpeqi	r23,r23,255
   22ca4:	b801561e 	bne	r23,zero,23200 <AL_ControlInd+0x888>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ca8:	20c003cc 	andi	r3,r4,15
   22cac:	98c0511e 	bne	r19,r3,22df4 <AL_ControlInd+0x47c>
   22cb0:	1009883a 	mov	r4,r2
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
   22cb4:	d0215a85 	stb	zero,-31382(gp)

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
   22cb8:	000b883a 	mov	r5,zero
   22cbc:	00003606 	br	22d98 <AL_ControlInd+0x420>
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
   22cc0:	d1615904 	addi	r5,gp,-31388
   22cc4:	d1215984 	addi	r4,gp,-31386
   22cc8:	00200b80 	call	200b8 <APPL_GenerateMapping>
   22ccc:	1021883a 	mov	r16,r2
            if (result != 0)
   22cd0:	10bfffcc 	andi	r2,r2,65535
   22cd4:	103fe91e 	bne	r2,zero,22c7c <AL_ControlInd+0x304>
        result = CheckSmSettings(nMaxSyncMan);
   22cd8:	d1215883 	ldbu	r4,-31390(gp)
   22cdc:	0021de80 	call	21de8 <CheckSmSettings>
   22ce0:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22ce4:	10803fcc 	andi	r2,r2,255
   22ce8:	103fe41e 	bne	r2,zero,22c7c <AL_ControlInd+0x304>
        nEcatStateTrans = 0;
   22cec:	d0215a0d 	sth	zero,-31384(gp)
        switch ( stateTrans )
   22cf0:	90801268 	cmpgeui	r2,r18,73
   22cf4:	103f9226 	beq	r2,zero,22b40 <AL_ControlInd+0x1c8>
   22cf8:	003fad06 	br	22bb0 <AL_ControlInd+0x238>
            bBootMode = TRUE;
   22cfc:	04400044 	movi	r17,1
            if ( CheckSmSettings(MAILBOX_READ+1) != 0 )
   22d00:	01000084 	movi	r4,2
            bBootMode = TRUE;
   22d04:	d46164c5 	stb	r17,-31341(gp)
            if ( CheckSmSettings(MAILBOX_READ+1) != 0 )
   22d08:	0021de80 	call	21de8 <CheckSmSettings>
   22d0c:	10803fcc 	andi	r2,r2,255
   22d10:	10000626 	beq	r2,zero,22d2c <AL_ControlInd+0x3b4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d14:	d12157c3 	ldbu	r4,-31393(gp)
                bBootMode = FALSE;
   22d18:	d02164c5 	stb	zero,-31341(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d1c:	208003cc 	andi	r2,r4,15
   22d20:	98814a1e 	bne	r19,r2,2324c <AL_ControlInd+0x8d4>
   22d24:	21003fcc 	andi	r4,r4,255
   22d28:	003fe206 	br	22cb4 <AL_ControlInd+0x33c>
            ResetALEventMask(0);
   22d2c:	0009883a 	mov	r4,zero
   22d30:	0021c2c0 	call	21c2c <ResetALEventMask>
            result = MBX_StartMailboxHandler();
   22d34:	0023dc80 	call	23dc8 <MBX_StartMailboxHandler>
   22d38:	1021883a 	mov	r16,r2
            if (result == 0)
   22d3c:	10bfffcc 	andi	r2,r2,65535
   22d40:	1000201e 	bne	r2,zero,22dc4 <AL_ControlInd+0x44c>
                bApplEsmPending = FALSE;
   22d44:	d0215ac5 	stb	zero,-31381(gp)
                result = APPL_StartMailboxHandler();
   22d48:	00200880 	call	20088 <APPL_StartMailboxHandler>
   22d4c:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22d50:	10bfffcc 	andi	r2,r2,65535
   22d54:	10001b1e 	bne	r2,zero,22dc4 <AL_ControlInd+0x44c>
            BL_Start( STATE_BOOT );
   22d58:	010000c4 	movi	r4,3
                    bMbxRunning = TRUE;
   22d5c:	d4616d45 	stb	r17,-31307(gp)
            BL_Start( STATE_BOOT );
   22d60:	00207500 	call	20750 <BL_Start>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d64:	d12157c3 	ldbu	r4,-31393(gp)
   22d68:	208003cc 	andi	r2,r4,15
   22d6c:	98bfed26 	beq	r19,r2,22d24 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22d70:	a0bfffcc 	andi	r2,r20,65535
   22d74:	10014326 	beq	r2,zero,23284 <AL_ControlInd+0x90c>
   22d78:	9908b03a 	or	r4,r19,r4
   22d7c:	2100020c 	andi	r4,r4,8
   22d80:	2001381e 	bne	r4,zero,23264 <AL_ControlInd+0x8ec>
                alControl |= STATE_CHANGE;
   22d84:	9d400414 	ori	r21,r19,16
            nAlStatus |= STATE_CHANGE;
   22d88:	d56157c5 	stb	r21,-31393(gp)
        bEcatWaitForAlControlRes = FALSE;
   22d8c:	d0215a85 	stb	zero,-31382(gp)
        SetALStatus(nAlStatus, result);
   22d90:	b17fffcc 	andi	r5,r22,65535
   22d94:	a9003fcc 	andi	r4,r21,255
    }
    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 state machine from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/

}
   22d98:	dfc00817 	ldw	ra,32(sp)
   22d9c:	ddc00717 	ldw	r23,28(sp)
   22da0:	dd800617 	ldw	r22,24(sp)
   22da4:	dd400517 	ldw	r21,20(sp)
   22da8:	dd000417 	ldw	r20,16(sp)
   22dac:	dcc00317 	ldw	r19,12(sp)
   22db0:	dc800217 	ldw	r18,8(sp)
   22db4:	dc400117 	ldw	r17,4(sp)
   22db8:	dc000017 	ldw	r16,0(sp)
   22dbc:	dec00904 	addi	sp,sp,36
        SetALStatus(nAlStatus, 0);
   22dc0:	00228d41 	jmpi	228d4 <SetALStatus>
            if(result != 0 && result != NOERROR_INWORK)
   22dc4:	80bfffcc 	andi	r2,r16,65535
   22dc8:	10803fe0 	cmpeqi	r2,r2,255
   22dcc:	1000211e 	bne	r2,zero,22e54 <AL_ControlInd+0x4dc>
                    if (!bApplEsmPending)
   22dd0:	d0a15ac3 	ldbu	r2,-31381(gp)
   22dd4:	10001d26 	beq	r2,zero,22e4c <AL_ControlInd+0x4d4>
                 MBX_StopMailboxHandler();
   22dd8:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
            BL_Start( STATE_BOOT );
   22ddc:	010000c4 	movi	r4,3
   22de0:	00207500 	call	20750 <BL_Start>
                bBootMode = FALSE;
   22de4:	d02164c5 	stb	zero,-31341(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22de8:	d12157c3 	ldbu	r4,-31393(gp)
   22dec:	208003cc 	andi	r2,r4,15
   22df0:	98bfcc26 	beq	r19,r2,22d24 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22df4:	9908b03a 	or	r4,r19,r4
   22df8:	2100020c 	andi	r4,r4,8
   22dfc:	20000a26 	beq	r4,zero,22e28 <AL_ControlInd+0x4b0>
            if(bEcatOutputUpdateRunning)
   22e00:	d0a16483 	ldbu	r2,-31342(gp)
   22e04:	10000226 	beq	r2,zero,22e10 <AL_ControlInd+0x498>
                APPL_StopOutputHandler();
   22e08:	00200b00 	call	200b0 <APPL_StopOutputHandler>
                StopOutputHandler();
   22e0c:	00228200 	call	22820 <StopOutputHandler>
            if(nPdOutputSize > 0)
   22e10:	d0a1590b 	ldhu	r2,-31388(gp)
   22e14:	10011526 	beq	r2,zero,2326c <AL_ControlInd+0x8f4>
                DisableSyncManChannel(PROCESS_DATA_OUT);
   22e18:	01000084 	movi	r4,2
                DisableSyncManChannel(PROCESS_DATA_IN);
   22e1c:	0021d2c0 	call	21d2c <DisableSyncManChannel>
        if ( result != 0 )
   22e20:	80bfffcc 	andi	r2,r16,65535
   22e24:	10011526 	beq	r2,zero,2327c <AL_ControlInd+0x904>
                if (nAlStatus == STATE_OP)
   22e28:	d0a157c3 	ldbu	r2,-31393(gp)
   22e2c:	10800218 	cmpnei	r2,r2,8
   22e30:	1000021e 	bne	r2,zero,22e3c <AL_ControlInd+0x4c4>
                    nAlStatus = STATE_SAFEOP;
   22e34:	00800104 	movi	r2,4
   22e38:	d0a157c5 	stb	r2,-31393(gp)
            nAlStatus |= STATE_CHANGE;
   22e3c:	d56157c3 	ldbu	r21,-31393(gp)
   22e40:	802d883a 	mov	r22,r16
   22e44:	ad400414 	ori	r21,r21,16
   22e48:	003fcf06 	br	22d88 <AL_ControlInd+0x410>
                        APPL_StopMailboxHandler();
   22e4c:	00200900 	call	20090 <APPL_StopMailboxHandler>
   22e50:	003fe106 	br	22dd8 <AL_ControlInd+0x460>
            BL_Start( STATE_BOOT );
   22e54:	010000c4 	movi	r4,3
   22e58:	00207500 	call	20750 <BL_Start>
        bEcatWaitForAlControlRes = TRUE;
   22e5c:	00800044 	movi	r2,1
   22e60:	d0a15a85 	stb	r2,-31382(gp)
                bBootMode = FALSE;
   22e64:	d02164c5 	stb	zero,-31341(gp)
        nEcatStateTrans = stateTrans;
   22e68:	008004c4 	movi	r2,19
   22e6c:	d0a15a0d 	sth	r2,-31384(gp)
            break;
   22e70:	0401f404 	movi	r16,2000
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
   22e74:	813fffcc 	andi	r4,r16,65535
   22e78:	01400284 	movi	r5,10
   22e7c:	0026f6c0 	call	26f6c <__udivsi3>
   22e80:	80a1c83a 	sub	r16,r16,r2
   22e84:	d421630d 	sth	r16,-31348(gp)
}
   22e88:	dfc00817 	ldw	ra,32(sp)
   22e8c:	ddc00717 	ldw	r23,28(sp)
   22e90:	dd800617 	ldw	r22,24(sp)
   22e94:	dd400517 	ldw	r21,20(sp)
   22e98:	dd000417 	ldw	r20,16(sp)
   22e9c:	dcc00317 	ldw	r19,12(sp)
   22ea0:	dc800217 	ldw	r18,8(sp)
   22ea4:	dc400117 	ldw	r17,4(sp)
   22ea8:	dc000017 	ldw	r16,0(sp)
   22eac:	dec00904 	addi	sp,sp,36
   22eb0:	f800283a 	ret
            if(bBootMode)
   22eb4:	d0a164c3 	ldbu	r2,-31341(gp)
   22eb8:	1000031e 	bne	r2,zero,22ec8 <AL_ControlInd+0x550>
            BL_Stop();
   22ebc:	00207540 	call	20754 <BL_Stop>
    bSyncSetByUser = FALSE;
   22ec0:	d0216e85 	stb	zero,-31302(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ec4:	003fa706 	br	22d64 <AL_ControlInd+0x3ec>
                ResetALEventMask(0);
   22ec8:	0009883a 	mov	r4,zero
                bBootMode = FALSE;
   22ecc:	d02164c5 	stb	zero,-31341(gp)
                ResetALEventMask(0);
   22ed0:	0021c2c0 	call	21c2c <ResetALEventMask>
                MBX_StopMailboxHandler();
   22ed4:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
                result = APPL_StopMailboxHandler();
   22ed8:	00200900 	call	20090 <APPL_StopMailboxHandler>
   22edc:	1021883a 	mov	r16,r2
            BL_Stop();
   22ee0:	00207540 	call	20754 <BL_Stop>
    if ( result == NOERROR_INWORK )
   22ee4:	80bfffcc 	andi	r2,r16,65535
    bSyncSetByUser = FALSE;
   22ee8:	d0216e85 	stb	zero,-31302(gp)
    if ( result == NOERROR_INWORK )
   22eec:	10803fe0 	cmpeqi	r2,r2,255
   22ef0:	1000bf1e 	bne	r2,zero,231f0 <AL_ControlInd+0x878>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ef4:	d12157c3 	ldbu	r4,-31393(gp)
   22ef8:	208003cc 	andi	r2,r4,15
   22efc:	98bf8926 	beq	r19,r2,22d24 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22f00:	80bfffcc 	andi	r2,r16,65535
   22f04:	103f9a26 	beq	r2,zero,22d70 <AL_ControlInd+0x3f8>
   22f08:	003fba06 	br	22df4 <AL_ControlInd+0x47c>
           UpdateEEPROMLoadedState();
   22f0c:	0021cc40 	call	21cc4 <UpdateEEPROMLoadedState>
            if (EepromLoaded == FALSE)
   22f10:	d0a15203 	ldbu	r2,-31416(gp)
   22f14:	1000ab26 	beq	r2,zero,231c4 <AL_ControlInd+0x84c>
            result = MBX_StartMailboxHandler();
   22f18:	0023dc80 	call	23dc8 <MBX_StartMailboxHandler>
   22f1c:	1021883a 	mov	r16,r2
            if (result == 0)
   22f20:	10bfffcc 	andi	r2,r2,65535
   22f24:	1000081e 	bne	r2,zero,22f48 <AL_ControlInd+0x5d0>
                bApplEsmPending = FALSE;
   22f28:	d0215ac5 	stb	zero,-31381(gp)
                result = APPL_StartMailboxHandler();
   22f2c:	00200880 	call	20088 <APPL_StartMailboxHandler>
   22f30:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22f34:	10bfffcc 	andi	r2,r2,65535
   22f38:	1000031e 	bne	r2,zero,22f48 <AL_ControlInd+0x5d0>
                    bMbxRunning = TRUE;
   22f3c:	00800044 	movi	r2,1
   22f40:	d0a16d45 	stb	r2,-31307(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22f44:	003f8706 	br	22d64 <AL_ControlInd+0x3ec>
            if(result != 0 && result != NOERROR_INWORK)
   22f48:	80bfffcc 	andi	r2,r16,65535
   22f4c:	10803fd8 	cmpnei	r2,r2,255
   22f50:	1000041e 	bne	r2,zero,22f64 <AL_ControlInd+0x5ec>
        bEcatWaitForAlControlRes = TRUE;
   22f54:	00800044 	movi	r2,1
   22f58:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   22f5c:	00800484 	movi	r2,18
   22f60:	003fc206 	br	22e6c <AL_ControlInd+0x4f4>
                    if (!bApplEsmPending)
   22f64:	d0a15ac3 	ldbu	r2,-31381(gp)
   22f68:	10000226 	beq	r2,zero,22f74 <AL_ControlInd+0x5fc>
                 MBX_StopMailboxHandler();
   22f6c:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
   22f70:	003f9d06 	br	22de8 <AL_ControlInd+0x470>
                        APPL_StopMailboxHandler();
   22f74:	00200900 	call	20090 <APPL_StopMailboxHandler>
   22f78:	003ffc06 	br	22f6c <AL_ControlInd+0x5f4>
            result = StartInputHandler();
   22f7c:	00220580 	call	22058 <StartInputHandler>
   22f80:	1021883a 	mov	r16,r2
            if ( result == 0 )
   22f84:	10bfffcc 	andi	r2,r2,65535
   22f88:	10000b1e 	bne	r2,zero,22fb8 <AL_ControlInd+0x640>
                result = APPL_StartInputHandler(&u16ALEventMask);
   22f8c:	d1215584 	addi	r4,gp,-31402
                bApplEsmPending = FALSE;
   22f90:	d0215ac5 	stb	zero,-31381(gp)
                result = APPL_StartInputHandler(&u16ALEventMask);
   22f94:	00200980 	call	20098 <APPL_StartInputHandler>
   22f98:	1021883a 	mov	r16,r2
                if(result == 0)
   22f9c:	10bfffcc 	andi	r2,r2,65535
   22fa0:	1000051e 	bne	r2,zero,22fb8 <AL_ControlInd+0x640>
                    SetALEventMask( u16ALEventMask );
   22fa4:	d121558b 	ldhu	r4,-31402(gp)
   22fa8:	0021c780 	call	21c78 <SetALEventMask>
                    bEcatInputUpdateRunning = TRUE;
   22fac:	00800044 	movi	r2,1
   22fb0:	d0a16445 	stb	r2,-31343(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22fb4:	003f6b06 	br	22d64 <AL_ControlInd+0x3ec>
            if(result != 0 && result != NOERROR_INWORK)
   22fb8:	80bfffcc 	andi	r2,r16,65535
   22fbc:	10803fd8 	cmpnei	r2,r2,255
   22fc0:	1000061e 	bne	r2,zero,22fdc <AL_ControlInd+0x664>
        bEcatWaitForAlControlRes = TRUE;
   22fc4:	00800044 	movi	r2,1
   22fc8:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   22fcc:	00800904 	movi	r2,36
   22fd0:	d0a15a0d 	sth	r2,-31384(gp)
                break;
   22fd4:	0408ca04 	movi	r16,9000
   22fd8:	003fa606 	br	22e74 <AL_ControlInd+0x4fc>
                if(!bApplEsmPending)
   22fdc:	d0a15ac3 	ldbu	r2,-31381(gp)
   22fe0:	10000226 	beq	r2,zero,22fec <AL_ControlInd+0x674>
                StopInputHandler();
   22fe4:	002282c0 	call	2282c <StopInputHandler>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22fe8:	003f7f06 	br	22de8 <AL_ControlInd+0x470>
                    APPL_StopInputHandler();
   22fec:	00200a00 	call	200a0 <APPL_StopInputHandler>
   22ff0:	003ffc06 	br	22fe4 <AL_ControlInd+0x66c>
            if (bErrAck)
   22ff4:	bdc03fcc 	andi	r23,r23,255
   22ff8:	b8000426 	beq	r23,zero,2300c <AL_ControlInd+0x694>
                if (nPdOutputSize > 0)
   22ffc:	d0a1590b 	ldhu	r2,-31388(gp)
   23000:	10000e26 	beq	r2,zero,2303c <AL_ControlInd+0x6c4>
                    EnableSyncManChannel(PROCESS_DATA_OUT);
   23004:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   23008:	0021d8c0 	call	21d8c <EnableSyncManChannel>
            result = StartOutputHandler();
   2300c:	00227c40 	call	227c4 <StartOutputHandler>
   23010:	1021883a 	mov	r16,r2
            if(result == 0)
   23014:	10bfffcc 	andi	r2,r2,65535
   23018:	10000c1e 	bne	r2,zero,2304c <AL_ControlInd+0x6d4>
                bApplEsmPending = FALSE;
   2301c:	d0215ac5 	stb	zero,-31381(gp)
                result = APPL_StartOutputHandler();
   23020:	00200a80 	call	200a8 <APPL_StartOutputHandler>
   23024:	1021883a 	mov	r16,r2
                if(result == 0)
   23028:	10bfffcc 	andi	r2,r2,65535
   2302c:	1000071e 	bne	r2,zero,2304c <AL_ControlInd+0x6d4>
                    bEcatOutputUpdateRunning = TRUE;
   23030:	00800044 	movi	r2,1
   23034:	d0a16485 	stb	r2,-31342(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23038:	003f4a06 	br	22d64 <AL_ControlInd+0x3ec>
                    if (nPdInputSize > 0)
   2303c:	d0a1598b 	ldhu	r2,-31386(gp)
   23040:	103ff226 	beq	r2,zero,2300c <AL_ControlInd+0x694>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   23044:	010000c4 	movi	r4,3
   23048:	003fef06 	br	23008 <AL_ControlInd+0x690>
            if ( result != 0 && result != NOERROR_INWORK)
   2304c:	80bfffcc 	andi	r2,r16,65535
   23050:	10803fd8 	cmpnei	r2,r2,255
   23054:	1000041e 	bne	r2,zero,23068 <AL_ControlInd+0x6f0>
        bEcatWaitForAlControlRes = TRUE;
   23058:	00800044 	movi	r2,1
   2305c:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   23060:	00801204 	movi	r2,72
   23064:	003fda06 	br	22fd0 <AL_ControlInd+0x658>
                    if (!bApplEsmPending)
   23068:	d0a15ac3 	ldbu	r2,-31381(gp)
   2306c:	10000226 	beq	r2,zero,23078 <AL_ControlInd+0x700>
                StopOutputHandler();
   23070:	00228200 	call	22820 <StopOutputHandler>
    if ( result == NOERROR_INWORK )
   23074:	003f5c06 	br	22de8 <AL_ControlInd+0x470>
                        APPL_StopOutputHandler();
   23078:	00200b00 	call	200b0 <APPL_StopOutputHandler>
   2307c:	003ffc06 	br	23070 <AL_ControlInd+0x6f8>
            APPL_StopOutputHandler();
   23080:	00200b00 	call	200b0 <APPL_StopOutputHandler>
            StopOutputHandler();
   23084:	00228200 	call	22820 <StopOutputHandler>
            bApplEsmPending = FALSE;
   23088:	d0215ac5 	stb	zero,-31381(gp)
   2308c:	003f3506 	br	22d64 <AL_ControlInd+0x3ec>
            result = APPL_StopOutputHandler();
   23090:	00200b00 	call	200b0 <APPL_StopOutputHandler>
   23094:	1021883a 	mov	r16,r2
            StopOutputHandler();
   23098:	00228200 	call	22820 <StopOutputHandler>
            if (result != 0)
   2309c:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   230a0:	d0215ac5 	stb	zero,-31381(gp)
            if (result != 0)
   230a4:	10004c1e 	bne	r2,zero,231d8 <AL_ControlInd+0x860>
            result = APPL_StopInputHandler();
   230a8:	00200a00 	call	200a0 <APPL_StopInputHandler>
   230ac:	1021883a 	mov	r16,r2
            StopInputHandler();
   230b0:	002282c0 	call	2282c <StopInputHandler>
            if (result != 0)
   230b4:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   230b8:	d0215ac5 	stb	zero,-31381(gp)
            if (result != 0)
   230bc:	10000626 	beq	r2,zero,230d8 <AL_ControlInd+0x760>
    if ( result == NOERROR_INWORK )
   230c0:	10803fd8 	cmpnei	r2,r2,255
   230c4:	103f481e 	bne	r2,zero,22de8 <AL_ControlInd+0x470>
        bEcatWaitForAlControlRes = TRUE;
   230c8:	00800044 	movi	r2,1
   230cc:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   230d0:	00801044 	movi	r2,65
   230d4:	003ed806 	br	22c38 <AL_ControlInd+0x2c0>
            MBX_StopMailboxHandler();
   230d8:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
   230dc:	00200900 	call	20090 <APPL_StopMailboxHandler>
   230e0:	1021883a 	mov	r16,r2
    if ( result == NOERROR_INWORK )
   230e4:	10bfffcc 	andi	r2,r2,65535
    bSyncSetByUser = FALSE;
   230e8:	d0216e85 	stb	zero,-31302(gp)
    if ( result == NOERROR_INWORK )
   230ec:	10803fe0 	cmpeqi	r2,r2,255
   230f0:	103f8026 	beq	r2,zero,22ef4 <AL_ControlInd+0x57c>
        bEcatWaitForAlControlRes = TRUE;
   230f4:	00800044 	movi	r2,1
   230f8:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   230fc:	00800844 	movi	r2,33
   23100:	003ecd06 	br	22c38 <AL_ControlInd+0x2c0>
    bSyncSetByUser = FALSE;
   23104:	d0216e85 	stb	zero,-31302(gp)
            if(bErrAck)
   23108:	bdc03fcc 	andi	r23,r23,255
   2310c:	b8000226 	beq	r23,zero,23118 <AL_ControlInd+0x7a0>
                APPL_AckErrorInd(stateTrans);
   23110:	9009883a 	mov	r4,r18
   23114:	00200840 	call	20084 <APPL_AckErrorInd>
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
   23118:	d12157c3 	ldbu	r4,-31393(gp)
   2311c:	9c003fcc 	andi	r16,r19,255
   23120:	2080030c 	andi	r2,r4,12
   23124:	10000526 	beq	r2,zero,2313c <AL_ControlInd+0x7c4>
                    if(nPdOutputSize > 0)
   23128:	d0a1590b 	ldhu	r2,-31388(gp)
   2312c:	10000726 	beq	r2,zero,2314c <AL_ControlInd+0x7d4>
                        EnableSyncManChannel(PROCESS_DATA_OUT);
   23130:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   23134:	0021d8c0 	call	21d8c <EnableSyncManChannel>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23138:	d12157c3 	ldbu	r4,-31393(gp)
   2313c:	208003cc 	andi	r2,r4,15
   23140:	80bef826 	beq	r16,r2,22d24 <AL_ControlInd+0x3ac>
            result = NOERROR_NOSTATECHANGE;
   23144:	04003f84 	movi	r16,254
   23148:	003f2a06 	br	22df4 <AL_ControlInd+0x47c>
                    if(nPdInputSize > 0)
   2314c:	d0a1598b 	ldhu	r2,-31386(gp)
   23150:	103ffa26 	beq	r2,zero,2313c <AL_ControlInd+0x7c4>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   23154:	010000c4 	movi	r4,3
   23158:	003ff606 	br	23134 <AL_ControlInd+0x7bc>
            APPL_StopOutputHandler();
   2315c:	00200b00 	call	200b0 <APPL_StopOutputHandler>
            StopOutputHandler();
   23160:	00228200 	call	22820 <StopOutputHandler>
            APPL_StopInputHandler();
   23164:	00200a00 	call	200a0 <APPL_StopInputHandler>
            StopInputHandler();
   23168:	002282c0 	call	2282c <StopInputHandler>
            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
   2316c:	b8800598 	cmpnei	r2,r23,22
   23170:	10000c1e 	bne	r2,zero,231a4 <AL_ControlInd+0x82c>
                MBX_StopMailboxHandler();
   23174:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
   23178:	00200900 	call	20090 <APPL_StopMailboxHandler>
                DisableSyncManChannel(MAILBOX_WRITE);
   2317c:	0009883a 	mov	r4,zero
   23180:	0021d2c0 	call	21d2c <DisableSyncManChannel>
                DisableSyncManChannel(MAILBOX_READ);
   23184:	01000044 	movi	r4,1
   23188:	0021d2c0 	call	21d2c <DisableSyncManChannel>
                nAlStatus = STATE_INIT;
   2318c:	00800044 	movi	r2,1
   23190:	d0a157c5 	stb	r2,-31393(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23194:	98800058 	cmpnei	r2,r19,1
   23198:	10002e1e 	bne	r2,zero,23254 <AL_ControlInd+0x8dc>
   2319c:	01000044 	movi	r4,1
   231a0:	003ec406 	br	22cb4 <AL_ControlInd+0x33c>
                nAlStatus = STATE_PREOP;
   231a4:	00800084 	movi	r2,2
   231a8:	d0a157c5 	stb	r2,-31393(gp)
    if ( result == NOERROR_INWORK )
   231ac:	bdc03fe0 	cmpeqi	r23,r23,255
   231b0:	b800131e 	bne	r23,zero,23200 <AL_ControlInd+0x888>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   231b4:	98800098 	cmpnei	r2,r19,2
   231b8:	1000281e 	bne	r2,zero,2325c <AL_ControlInd+0x8e4>
   231bc:	01000084 	movi	r4,2
   231c0:	003ebc06 	br	22cb4 <AL_ControlInd+0x33c>
   231c4:	d12157c3 	ldbu	r4,-31393(gp)
   231c8:	208003cc 	andi	r2,r4,15
   231cc:	98bed526 	beq	r19,r2,22d24 <AL_ControlInd+0x3ac>
                result = ALSTATUSCODE_EE_ERROR;
   231d0:	04001444 	movi	r16,81
   231d4:	003f0706 	br	22df4 <AL_ControlInd+0x47c>
    if ( result == NOERROR_INWORK )
   231d8:	10803fd8 	cmpnei	r2,r2,255
   231dc:	103f021e 	bne	r2,zero,22de8 <AL_ControlInd+0x470>
        bEcatWaitForAlControlRes = TRUE;
   231e0:	00800044 	movi	r2,1
   231e4:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   231e8:	00802044 	movi	r2,129
   231ec:	003e9206 	br	22c38 <AL_ControlInd+0x2c0>
        bEcatWaitForAlControlRes = TRUE;
   231f0:	00800044 	movi	r2,1
   231f4:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   231f8:	00800c44 	movi	r2,49
   231fc:	003e8e06 	br	22c38 <AL_ControlInd+0x2c0>
        bEcatWaitForAlControlRes = TRUE;
   23200:	00800044 	movi	r2,1
        nEcatStateTrans = stateTrans;
   23204:	8c403fcc 	andi	r17,r17,255
        bEcatWaitForAlControlRes = TRUE;
   23208:	d0a15a85 	stb	r2,-31382(gp)
        nEcatStateTrans = stateTrans;
   2320c:	d4615a0d 	sth	r17,-31384(gp)
        switch(nEcatStateTrans)
   23210:	90800528 	cmpgeui	r2,r18,20
   23214:	1000031e 	bne	r2,zero,23224 <AL_ControlInd+0x8ac>
   23218:	948004a8 	cmpgeui	r18,r18,18
   2321c:	903f141e 	bne	r18,zero,22e70 <AL_ControlInd+0x4f8>
   23220:	003e8606 	br	22c3c <AL_ControlInd+0x2c4>
   23224:	90800920 	cmpeqi	r2,r18,36
   23228:	103f6a1e 	bne	r2,zero,22fd4 <AL_ControlInd+0x65c>
   2322c:	94801220 	cmpeqi	r18,r18,72
   23230:	903f681e 	bne	r18,zero,22fd4 <AL_ControlInd+0x65c>
   23234:	003e8106 	br	22c3c <AL_ControlInd+0x2c4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23238:	d12157c3 	ldbu	r4,-31393(gp)
   2323c:	208003cc 	andi	r2,r4,15
   23240:	98beb826 	beq	r19,r2,22d24 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_INVALIDALCONTROL;
   23244:	04000444 	movi	r16,17
   23248:	003eea06 	br	22df4 <AL_ControlInd+0x47c>
                result = ALSTATUSCODE_INVALIDMBXCFGINBOOT;
   2324c:	04000544 	movi	r16,21
   23250:	003ee806 	br	22df4 <AL_ControlInd+0x47c>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   23254:	01000044 	movi	r4,1
   23258:	003ee606 	br	22df4 <AL_ControlInd+0x47c>
   2325c:	01000084 	movi	r4,2
   23260:	003ee406 	br	22df4 <AL_ControlInd+0x47c>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   23264:	0021883a 	mov	r16,zero
   23268:	003ee506 	br	22e00 <AL_ControlInd+0x488>
                if(nPdInputSize > 0)
   2326c:	d0a1598b 	ldhu	r2,-31386(gp)
   23270:	103eeb26 	beq	r2,zero,22e20 <AL_ControlInd+0x4a8>
                DisableSyncManChannel(PROCESS_DATA_IN);
   23274:	010000c4 	movi	r4,3
   23278:	003ee806 	br	22e1c <AL_ControlInd+0x4a4>
            if ( alStatusCode != 0 )
   2327c:	a53fffcc 	andi	r20,r20,65535
   23280:	a03ec01e 	bne	r20,zero,22d84 <AL_ControlInd+0x40c>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   23284:	002d883a 	mov	r22,zero
            nAlStatus = alControl;
   23288:	003ebf06 	br	22d88 <AL_ControlInd+0x410>

0002328c <AL_ControlRes>:
 \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the application specific state transition function is called.
 \brief    If the pending state transition is triggered by the application the transition need to be completed by the application (ECAT_StateChange())
  *////////////////////////////////////////////////////////////////////////////////////////
void AL_ControlRes(void)
{
    if(bEcatWaitForAlControlRes)
   2328c:	d0a15a83 	ldbu	r2,-31382(gp)
   23290:	1000bf26 	beq	r2,zero,23590 <AL_ControlRes+0x304>
        UINT8 Status = 0;
        UINT16 StatusCode = 0;

        if(EsmTimeoutCounter == 0)
        {
            Status =  (UINT8)(nEcatStateTrans >> 4);
   23294:	d0a15a0b 	ldhu	r2,-31384(gp)
        if(EsmTimeoutCounter == 0)
   23298:	d121630f 	ldh	r4,-31348(gp)
{
   2329c:	defffc04 	addi	sp,sp,-16
   232a0:	dfc00315 	stw	ra,12(sp)
   232a4:	dc800215 	stw	r18,8(sp)
   232a8:	dc400115 	stw	r17,4(sp)
   232ac:	dc000015 	stw	r16,0(sp)
   232b0:	10ffffcc 	andi	r3,r2,65535
        if(EsmTimeoutCounter == 0)
   232b4:	2000551e 	bne	r4,zero,2340c <AL_ControlRes+0x180>
            Status =  (UINT8)(nEcatStateTrans >> 4);
   232b8:	1822d13a 	srli	r17,r3,4

            /* ESM timeout expired*/
            switch(nEcatStateTrans)
   232bc:	19000920 	cmpeqi	r4,r3,36
            Status =  (UINT8)(nEcatStateTrans >> 4);
   232c0:	8825883a 	mov	r18,r17
            switch(nEcatStateTrans)
   232c4:	2000331e 	bne	r4,zero,23394 <AL_ControlRes+0x108>
   232c8:	19000968 	cmpgeui	r4,r3,37
   232cc:	2000091e 	bne	r4,zero,232f4 <AL_ControlRes+0x68>
   232d0:	10bffb84 	addi	r2,r2,-18
   232d4:	10bfffcc 	andi	r2,r2,65535
   232d8:	108000a8 	cmpgeui	r2,r2,2
   232dc:	10001e26 	beq	r2,zero,23358 <AL_ControlRes+0xcc>
                    }             
                break;
            }//Switch - transition
        }

        if(Status != 0)
   232e0:	8c403fcc 	andi	r17,r17,255
   232e4:	88005126 	beq	r17,zero,2342c <AL_ControlRes+0x1a0>
        {
            /*Pending state transition finished => write AL Status and AL Status Code*/
            bEcatWaitForAlControlRes = FALSE;
   232e8:	d0215a85 	stb	zero,-31382(gp)
        UINT16 StatusCode = 0;
   232ec:	0021883a 	mov	r16,zero
   232f0:	00001106 	br	23338 <AL_ControlRes+0xac>
            switch(nEcatStateTrans)
   232f4:	18c01220 	cmpeqi	r3,r3,72
   232f8:	183ff926 	beq	r3,zero,232e0 <AL_ControlRes+0x54>
                    if(bDcSyncActive)
   232fc:	d0a16383 	ldbu	r2,-31346(gp)
   23300:	10002c26 	beq	r2,zero,233b4 <AL_ControlRes+0x128>
                        if(!bDcRunning)
   23304:	d0a16283 	ldbu	r2,-31350(gp)
   23308:	10003a26 	beq	r2,zero,233f4 <AL_ControlRes+0x168>
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
   2330c:	d0a16403 	ldbu	r2,-31344(gp)
   23310:	1000021e 	bne	r2,zero,2331c <AL_ControlRes+0x90>
   23314:	d0a1590b 	ldhu	r2,-31388(gp)
   23318:	1000381e 	bne	r2,zero,233fc <AL_ControlRes+0x170>
                        else if (!bSmSyncSequenceValid)
   2331c:	d0a16103 	ldbu	r2,-31356(gp)
   23320:	10003826 	beq	r2,zero,23404 <AL_ControlRes+0x178>
                            bEcatOutputUpdateRunning = TRUE;
   23324:	00800044 	movi	r2,1
   23328:	d0a16485 	stb	r2,-31342(gp)
            bEcatWaitForAlControlRes = FALSE;
   2332c:	d0215a85 	stb	zero,-31382(gp)
                            StatusCode = 0;
   23330:	0021883a 	mov	r16,zero
                            Status = STATE_OP;
   23334:	04800204 	movi	r18,8
            if (StatusCode != 0)
            {
                Status |= STATE_CHANGE;
            }

            SetALStatus(Status,StatusCode);
   23338:	817fffcc 	andi	r5,r16,65535
   2333c:	91003fcc 	andi	r4,r18,255
        }
    }// Pending state transition (bEcatWaitForAlControlRes == true)
}
   23340:	dfc00317 	ldw	ra,12(sp)
   23344:	dc800217 	ldw	r18,8(sp)
   23348:	dc400117 	ldw	r17,4(sp)
   2334c:	dc000017 	ldw	r16,0(sp)
   23350:	dec00404 	addi	sp,sp,16
            SetALStatus(Status,StatusCode);
   23354:	00228d41 	jmpi	228d4 <SetALStatus>
                        if (!bApplEsmPending)
   23358:	d0a15ac3 	ldbu	r2,-31381(gp)
   2335c:	1000011e 	bne	r2,zero,23364 <AL_ControlRes+0xd8>
                            APPL_StopMailboxHandler();
   23360:	00200900 	call	20090 <APPL_StopMailboxHandler>
                    MBX_StopMailboxHandler();
   23364:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
                    if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
   23368:	d0a15b03 	ldbu	r2,-31380(gp)
   2336c:	108003cc 	andi	r2,r2,15
   23370:	10800058 	cmpnei	r2,r2,1
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   23374:	1000811e 	bne	r2,zero,2357c <AL_ControlRes+0x2f0>
        if(Status != 0)
   23378:	88803fcc 	andi	r2,r17,255
                        StatusCode = u16LocalErrorCode;
   2337c:	d4215b8b 	ldhu	r16,-31378(gp)
        if(Status != 0)
   23380:	10002a26 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   23384:	d0215a85 	stb	zero,-31382(gp)
            if (StatusCode != 0)
   23388:	80bfffcc 	andi	r2,r16,65535
   2338c:	1000171e 	bne	r2,zero,233ec <AL_ControlRes+0x160>
   23390:	003fe906 	br	23338 <AL_ControlRes+0xac>
                        if (!bApplEsmPending)
   23394:	d0a15ac3 	ldbu	r2,-31381(gp)
   23398:	1000011e 	bne	r2,zero,233a0 <AL_ControlRes+0x114>
                            APPL_StopInputHandler();
   2339c:	00200a00 	call	200a0 <APPL_StopInputHandler>
                    StopInputHandler();
   233a0:	002282c0 	call	2282c <StopInputHandler>
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   233a4:	d0a15b03 	ldbu	r2,-31380(gp)
   233a8:	108003cc 	andi	r2,r2,15
   233ac:	10800098 	cmpnei	r2,r2,2
   233b0:	003ff006 	br	23374 <AL_ControlRes+0xe8>
                            if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
   233b4:	d0a15b03 	ldbu	r2,-31380(gp)
   233b8:	108003cc 	andi	r2,r2,15
   233bc:	10800118 	cmpnei	r2,r2,4
   233c0:	103fd81e 	bne	r2,zero,23324 <AL_ControlRes+0x98>
                                StatusCode = u16LocalErrorCode;
   233c4:	d4215b8b 	ldhu	r16,-31378(gp)
                    if(StatusCode != 0)
   233c8:	80bfffcc 	andi	r2,r16,65535
   233cc:	103fc426 	beq	r2,zero,232e0 <AL_ControlRes+0x54>
                            if (!bApplEsmPending)
   233d0:	d0a15ac3 	ldbu	r2,-31381(gp)
   233d4:	1000011e 	bne	r2,zero,233dc <AL_ControlRes+0x150>
                                APPL_StopOutputHandler();
   233d8:	00200b00 	call	200b0 <APPL_StopOutputHandler>
                        StopOutputHandler();
   233dc:	00228200 	call	22820 <StopOutputHandler>
        if(Status != 0)
   233e0:	88803fcc 	andi	r2,r17,255
   233e4:	10001126 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   233e8:	d0215a85 	stb	zero,-31382(gp)
                Status |= STATE_CHANGE;
   233ec:	8c800414 	ori	r18,r17,16
   233f0:	003fd106 	br	23338 <AL_ControlRes+0xac>
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
   233f4:	04000b44 	movi	r16,45
   233f8:	003ff506 	br	233d0 <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
   233fc:	040006c4 	movi	r16,27
   23400:	003ff306 	br	233d0 <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SYNCERROR;
   23404:	04000684 	movi	r16,26
   23408:	003ff106 	br	233d0 <AL_ControlRes+0x144>
            switch(nEcatStateTrans)
   2340c:	19000920 	cmpeqi	r4,r3,36
   23410:	20003d1e 	bne	r4,zero,23508 <AL_ControlRes+0x27c>
   23414:	19000968 	cmpgeui	r4,r3,37
   23418:	20000a1e 	bne	r4,zero,23444 <AL_ControlRes+0x1b8>
   2341c:	10bffb84 	addi	r2,r2,-18
   23420:	10bfffcc 	andi	r2,r2,65535
   23424:	108000a8 	cmpgeui	r2,r2,2
   23428:	10001f26 	beq	r2,zero,234a8 <AL_ControlRes+0x21c>
}
   2342c:	dfc00317 	ldw	ra,12(sp)
   23430:	dc800217 	ldw	r18,8(sp)
   23434:	dc400117 	ldw	r17,4(sp)
   23438:	dc000017 	ldw	r16,0(sp)
   2343c:	dec00404 	addi	sp,sp,16
   23440:	f800283a 	ret
            switch(nEcatStateTrans)
   23444:	18c01220 	cmpeqi	r3,r3,72
   23448:	183ff826 	beq	r3,zero,2342c <AL_ControlRes+0x1a0>
                   if(bApplEsmPending)
   2344c:	d0a15ac3 	ldbu	r2,-31381(gp)
   23450:	103ff626 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
                        if(bDcSyncActive)
   23454:	d0a16383 	ldbu	r2,-31346(gp)
   23458:	10004126 	beq	r2,zero,23560 <AL_ControlRes+0x2d4>
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
   2345c:	d0a1608f 	ldh	r2,-31358(gp)
   23460:	00bff20e 	bge	zero,r2,2342c <AL_ControlRes+0x1a0>
   23464:	d0e1600f 	ldh	r3,-31360(gp)
   23468:	18bff016 	blt	r3,r2,2342c <AL_ControlRes+0x1a0>
                                i16WaitForPllRunningTimeout = 0;
   2346c:	d021608d 	sth	zero,-31358(gp)
                                i16WaitForPllRunningCnt = 0;
   23470:	d021600d 	sth	zero,-31360(gp)
                                bApplEsmPending = FALSE;
   23474:	d0215ac5 	stb	zero,-31381(gp)
                                result = APPL_StartOutputHandler();
   23478:	00200a80 	call	200a8 <APPL_StartOutputHandler>
                                if(result == 0)
   2347c:	10bfffcc 	andi	r2,r2,65535
   23480:	103fa826 	beq	r2,zero,23324 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   23484:	10803fe0 	cmpeqi	r2,r2,255
   23488:	103fe81e 	bne	r2,zero,2342c <AL_ControlRes+0x1a0>
                                        APPL_StopOutputHandler();
   2348c:	00200b00 	call	200b0 <APPL_StopOutputHandler>
}
   23490:	dfc00317 	ldw	ra,12(sp)
   23494:	dc800217 	ldw	r18,8(sp)
   23498:	dc400117 	ldw	r17,4(sp)
   2349c:	dc000017 	ldw	r16,0(sp)
   234a0:	dec00404 	addi	sp,sp,16
                                        StopOutputHandler();
   234a4:	00228201 	jmpi	22820 <StopOutputHandler>
                    if(bApplEsmPending)
   234a8:	d0a15ac3 	ldbu	r2,-31381(gp)
   234ac:	103fdf26 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
                        bApplEsmPending = FALSE;
   234b0:	d0215ac5 	stb	zero,-31381(gp)
                        result = APPL_StartMailboxHandler();
   234b4:	00200880 	call	20088 <APPL_StartMailboxHandler>
   234b8:	1021883a 	mov	r16,r2
                        if(result == 0)
   234bc:	10bfffcc 	andi	r2,r2,65535
   234c0:	1000081e 	bne	r2,zero,234e4 <AL_ControlRes+0x258>
                            bMbxRunning = TRUE;
   234c4:	00800044 	movi	r2,1
   234c8:	d0a16d45 	stb	r2,-31307(gp)
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   234cc:	d0a15a03 	ldbu	r2,-31384(gp)
   234d0:	108003cc 	andi	r2,r2,15
   234d4:	1025883a 	mov	r18,r2
        if(Status != 0)
   234d8:	103fd426 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   234dc:	d0215a85 	stb	zero,-31382(gp)
            if (StatusCode != 0)
   234e0:	003f9506 	br	23338 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   234e4:	10803fe0 	cmpeqi	r2,r2,255
   234e8:	103fd01e 	bne	r2,zero,2342c <AL_ControlRes+0x1a0>
                                APPL_StopMailboxHandler();
   234ec:	00200900 	call	20090 <APPL_StopMailboxHandler>
}
   234f0:	dfc00317 	ldw	ra,12(sp)
   234f4:	dc800217 	ldw	r18,8(sp)
   234f8:	dc400117 	ldw	r17,4(sp)
   234fc:	dc000017 	ldw	r16,0(sp)
   23500:	dec00404 	addi	sp,sp,16
                                MBX_StopMailboxHandler();
   23504:	0023ea41 	jmpi	23ea4 <MBX_StopMailboxHandler>
                    if(bApplEsmPending)
   23508:	d0a15ac3 	ldbu	r2,-31381(gp)
   2350c:	103fc726 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23510:	d1215584 	addi	r4,gp,-31402
                        bApplEsmPending = FALSE;
   23514:	d0215ac5 	stb	zero,-31381(gp)
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23518:	00200980 	call	20098 <APPL_StartInputHandler>
   2351c:	1021883a 	mov	r16,r2
                        if(result == 0)
   23520:	10bfffcc 	andi	r2,r2,65535
   23524:	1000051e 	bne	r2,zero,2353c <AL_ControlRes+0x2b0>
                            bEcatInputUpdateRunning = TRUE;
   23528:	00800044 	movi	r2,1
   2352c:	d0a16445 	stb	r2,-31343(gp)
            bEcatWaitForAlControlRes = FALSE;
   23530:	d0215a85 	stb	zero,-31382(gp)
                            Status = STATE_SAFEOP;
   23534:	04800104 	movi	r18,4
   23538:	003f7f06 	br	23338 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   2353c:	10803fe0 	cmpeqi	r2,r2,255
   23540:	103fba1e 	bne	r2,zero,2342c <AL_ControlRes+0x1a0>
                                APPL_StopInputHandler();
   23544:	00200a00 	call	200a0 <APPL_StopInputHandler>
}
   23548:	dfc00317 	ldw	ra,12(sp)
   2354c:	dc800217 	ldw	r18,8(sp)
   23550:	dc400117 	ldw	r17,4(sp)
   23554:	dc000017 	ldw	r16,0(sp)
   23558:	dec00404 	addi	sp,sp,16
                                StopInputHandler();
   2355c:	002282c1 	jmpi	2282c <StopInputHandler>
                                bApplEsmPending = FALSE;  
   23560:	d0215ac5 	stb	zero,-31381(gp)
                                result = APPL_StartOutputHandler();
   23564:	00200a80 	call	200a8 <APPL_StartOutputHandler>
                                if(result == 0)
   23568:	10bfffcc 	andi	r2,r2,65535
   2356c:	103f6d26 	beq	r2,zero,23324 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   23570:	10803fd8 	cmpnei	r2,r2,255
   23574:	103fad26 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
   23578:	003fc406 	br	2348c <AL_ControlRes+0x200>
        if(Status != 0)
   2357c:	88803fcc 	andi	r2,r17,255
   23580:	103faa26 	beq	r2,zero,2342c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   23584:	d0215a85 	stb	zero,-31382(gp)
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
   23588:	04000044 	movi	r16,1
   2358c:	003f9706 	br	233ec <AL_ControlRes+0x160>
   23590:	f800283a 	ret

00023594 <DC_CheckWatchdog>:

*////////////////////////////////////////////////////////////////////////////////////////
void DC_CheckWatchdog(void)
{

    if(bDcSyncActive && bEcatInputUpdateRunning)
   23594:	d0a16383 	ldbu	r2,-31346(gp)
   23598:	10002d26 	beq	r2,zero,23650 <DC_CheckWatchdog+0xbc>
   2359c:	d0a16443 	ldbu	r2,-31343(gp)
   235a0:	10002b26 	beq	r2,zero,23650 <DC_CheckWatchdog+0xbc>
    {
        /*If Sync0 watchdog is enabled and expired*/
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
   235a4:	d0e15f0b 	ldhu	r3,-31364(gp)
   235a8:	18000926 	beq	r3,zero,235d0 <DC_CheckWatchdog+0x3c>
   235ac:	d0a15f8b 	ldhu	r2,-31362(gp)
   235b0:	113fffcc 	andi	r4,r2,65535
   235b4:	20c00436 	bltu	r4,r3,235c8 <DC_CheckWatchdog+0x34>
                {
                    i16WaitForPllRunningCnt = 0;
                }
            }
        }
        else if(bSmSyncSequenceValid)
   235b8:	d0a16103 	ldbu	r2,-31356(gp)
                bDcRunning = FALSE;        
   235bc:	d0216285 	stb	zero,-31350(gp)
        else if(bSmSyncSequenceValid)
   235c0:	1000211e 	bne	r2,zero,23648 <DC_CheckWatchdog+0xb4>
   235c4:	f800283a 	ret
                Sync0WdCounter ++;
   235c8:	10800044 	addi	r2,r2,1
   235cc:	d0a15f8d 	sth	r2,-31362(gp)
            if(Sync1WdValue > 0)
   235d0:	d0e15e0b 	ldhu	r3,-31368(gp)
            bDcRunning = TRUE;
   235d4:	00800044 	movi	r2,1
   235d8:	d0a16285 	stb	r2,-31350(gp)
            if(Sync1WdValue > 0)
   235dc:	18000526 	beq	r3,zero,235f4 <DC_CheckWatchdog+0x60>
                if(Sync1WdCounter < Sync1WdValue)
   235e0:	d0a15e8b 	ldhu	r2,-31366(gp)
   235e4:	113fffcc 	andi	r4,r2,65535
   235e8:	20fff32e 	bgeu	r4,r3,235b8 <DC_CheckWatchdog+0x24>
                    Sync1WdCounter ++;
   235ec:	10800044 	addi	r2,r2,1
   235f0:	d0a15e8d 	sth	r2,-31366(gp)
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
   235f4:	008000f4 	movhi	r2,3
   235f8:	10a0dd0b 	ldhu	r2,-31884(r2)
   235fc:	10000326 	beq	r2,zero,2360c <DC_CheckWatchdog+0x78>
   23600:	00c000f4 	movhi	r3,3
   23604:	18e33f0b 	ldhu	r3,-29444(r3)
   23608:	1880082e 	bgeu	r3,r2,2362c <DC_CheckWatchdog+0x98>
                bSmSyncSequenceValid = TRUE;
   2360c:	00800044 	movi	r2,1
   23610:	d0a16105 	stb	r2,-31356(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23614:	d0a1608f 	ldh	r2,-31358(gp)
   23618:	00800d0e 	bge	zero,r2,23650 <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt++;
   2361c:	d0a1600b 	ldhu	r2,-31360(gp)
   23620:	10800044 	addi	r2,r2,1
   23624:	d0a1600d 	sth	r2,-31360(gp)
   23628:	f800283a 	ret
            else if (bSmSyncSequenceValid)
   2362c:	d0a16103 	ldbu	r2,-31356(gp)
   23630:	10000726 	beq	r2,zero,23650 <DC_CheckWatchdog+0xbc>
                if (i16WaitForPllRunningTimeout > 0)
   23634:	d0a1608f 	ldh	r2,-31358(gp)
                    bSmSyncSequenceValid = FALSE;
   23638:	d0216105 	stb	zero,-31356(gp)
                if (i16WaitForPllRunningTimeout > 0)
   2363c:	0080040e 	bge	zero,r2,23650 <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt = 0;
   23640:	d021600d 	sth	zero,-31360(gp)
   23644:	f800283a 	ret
        {
           bSmSyncSequenceValid = FALSE;
   23648:	d0216105 	stb	zero,-31356(gp)
        }
    }
}
   2364c:	f800283a 	ret
   23650:	f800283a 	ret

00023654 <CheckIfEcatError>:
*////////////////////////////////////////////////////////////////////////////////////////
void CheckIfEcatError(void)
{
   /*if the watchdog is enabled check the process data watchdog in the ESC
   and set the AL status code 0x1B if the watchdog expired*/
   if (EcatWdValue != 0)
   23654:	d0a1570b 	ldhu	r2,-31396(gp)
   23658:	10002626 	beq	r2,zero,236f4 <CheckIfEcatError+0xa0>
{
   2365c:	defffe04 	addi	sp,sp,-8
   {
      /*watchdog time is set => watchdog is active*/
      UINT16 WdStatusOK = 0;

      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   23660:	01800084 	movi	r6,2
   23664:	01411004 	movi	r5,1088
   23668:	d9000084 	addi	r4,sp,2
{
   2366c:	dfc00115 	stw	ra,4(sp)
      UINT16 WdStatusOK = 0;
   23670:	d800008d 	sth	zero,2(sp)
      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   23674:	00205e80 	call	205e8 <HW_EscRead>
      WdStatusOK = SWAPWORD(WdStatusOK);

      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
   23678:	d880008b 	ldhu	r2,2(sp)
   2367c:	1080004c 	andi	r2,r2,1
   23680:	10000d1e 	bne	r2,zero,236b8 <CheckIfEcatError+0x64>
   23684:	d0a1590b 	ldhu	r2,-31388(gp)
   23688:	10000b26 	beq	r2,zero,236b8 <CheckIfEcatError+0x64>
      {
         /*The device is in OP state*/

         if (bEcatOutputUpdateRunning
   2368c:	d0a16483 	ldbu	r2,-31342(gp)
   23690:	10000826 	beq	r2,zero,236b4 <CheckIfEcatError+0x60>
            && bEcatFirstOutputsReceived
   23694:	d0a16403 	ldbu	r2,-31344(gp)
   23698:	10000626 	beq	r2,zero,236b4 <CheckIfEcatError+0x60>
            )
         {
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
   2369c:	014006c4 	movi	r5,27
   236a0:	01000104 	movi	r4,4
   236a4:	00229780 	call	22978 <AL_ControlInd>
               return;
           }
        
       }
   }
}
   236a8:	dfc00117 	ldw	ra,4(sp)
   236ac:	dec00204 	addi	sp,sp,8
   236b0:	f800283a 	ret
            bEcatFirstOutputsReceived = FALSE;
   236b4:	d0216405 	stb	zero,-31344(gp)
   if(bDcSyncActive)
   236b8:	d0a16383 	ldbu	r2,-31346(gp)
   236bc:	103ffa26 	beq	r2,zero,236a8 <CheckIfEcatError+0x54>
       if(bEcatOutputUpdateRunning)
   236c0:	d0a16483 	ldbu	r2,-31342(gp)
   236c4:	103ff826 	beq	r2,zero,236a8 <CheckIfEcatError+0x54>
           if(!bDcRunning)
   236c8:	d0a16283 	ldbu	r2,-31350(gp)
   236cc:	1000051e 	bne	r2,zero,236e4 <CheckIfEcatError+0x90>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   236d0:	01400b04 	movi	r5,44
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   236d4:	01000104 	movi	r4,4
}
   236d8:	dfc00117 	ldw	ra,4(sp)
   236dc:	dec00204 	addi	sp,sp,8
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   236e0:	00229781 	jmpi	22978 <AL_ControlInd>
           else if(!bSmSyncSequenceValid)
   236e4:	d0a16103 	ldbu	r2,-31356(gp)
   236e8:	103fef1e 	bne	r2,zero,236a8 <CheckIfEcatError+0x54>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   236ec:	01400684 	movi	r5,26
   236f0:	003ff806 	br	236d4 <CheckIfEcatError+0x80>
   if(bDcSyncActive)
   236f4:	d0a16383 	ldbu	r2,-31346(gp)
   236f8:	10000b26 	beq	r2,zero,23728 <CheckIfEcatError+0xd4>
       if(bEcatOutputUpdateRunning)
   236fc:	d0a16483 	ldbu	r2,-31342(gp)
   23700:	10000926 	beq	r2,zero,23728 <CheckIfEcatError+0xd4>
           if(!bDcRunning)
   23704:	d0a16283 	ldbu	r2,-31350(gp)
   23708:	1000031e 	bne	r2,zero,23718 <CheckIfEcatError+0xc4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   2370c:	01400b04 	movi	r5,44
   23710:	01000104 	movi	r4,4
   23714:	003ff206 	br	236e0 <CheckIfEcatError+0x8c>
           else if(!bSmSyncSequenceValid)
   23718:	d0a16103 	ldbu	r2,-31356(gp)
   2371c:	1000021e 	bne	r2,zero,23728 <CheckIfEcatError+0xd4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   23720:	01400684 	movi	r5,26
   23724:	003ffa06 	br	23710 <CheckIfEcatError+0xbc>
   23728:	f800283a 	ret

0002372c <ECAT_StateChange>:
 \brief    This function changes the state of the EtherCAT slave if the requested state
             is lower than the actual state, otherwise the error condition will be reset.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
{
   2372c:	defffe04 	addi	sp,sp,-8
   23730:	dc000015 	stw	r16,0(sp)
   23734:	dfc00115 	stw	ra,4(sp)
    UINT8 Status = alStatus;

    /*ECATCHANGE_START(V5.13) ESM1*/
    /*return in case of invalid parameters*/
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23738:	2c3fffcc 	andi	r16,r5,65535
   2373c:	8000201e 	bne	r16,zero,237c0 <ECAT_StateChange+0x94>
    {
        return;
    }

    /* call the application requested state transition only once*/
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   23740:	d0a15a83 	ldbu	r2,-31382(gp)
   23744:	10000a1e 	bne	r2,zero,23770 <ECAT_StateChange+0x44>
   23748:	d0a15b03 	ldbu	r2,-31380(gp)
   2374c:	21003fcc 	andi	r4,r4,255
   23750:	2080021e 	bne	r4,r2,2375c <ECAT_StateChange+0x30>
   23754:	d0a15b8b 	ldhu	r2,-31378(gp)
   23758:	10002526 	beq	r2,zero,237f0 <ECAT_StateChange+0xc4>
               /* no error pending and the target state is lower than the current one*/
                AL_ControlInd(alStatus, alStatusCode);
            }
        }
        /*ECATCHANGE_START(V5.13) ESM1*/
        else if (u8LocalErrorState != 0)
   2375c:	d0a15b03 	ldbu	r2,-31380(gp)
   23760:	10002326 	beq	r2,zero,237f0 <ECAT_StateChange+0xc4>
                u8LocalErrorState = 0;
   23764:	d0215b05 	stb	zero,-31380(gp)
                u16LocalErrorCode = alStatusCode;
   23768:	d0215b8d 	sth	zero,-31378(gp)
   2376c:	00002006 	br	237f0 <ECAT_StateChange+0xc4>
        if(bApplEsmPending)
   23770:	d0a15ac3 	ldbu	r2,-31381(gp)
   23774:	103ffb1e 	bne	r2,zero,23764 <ECAT_StateChange+0x38>
                switch(nEcatStateTrans)
   23778:	d0a15a0b 	ldhu	r2,-31384(gp)
   2377c:	10ffffcc 	andi	r3,r2,65535
   23780:	19000920 	cmpeqi	r4,r3,36
   23784:	20004b1e 	bne	r4,zero,238b4 <ECAT_StateChange+0x188>
   23788:	19000968 	cmpgeui	r4,r3,37
   2378c:	2000411e 	bne	r4,zero,23894 <ECAT_StateChange+0x168>
   23790:	10bffb84 	addi	r2,r2,-18
   23794:	10bfffcc 	andi	r2,r2,65535
   23798:	108000a8 	cmpgeui	r2,r2,2
   2379c:	10004226 	beq	r2,zero,238a8 <ECAT_StateChange+0x17c>
                else if (u8LocalErrorState != 0)
   237a0:	d0a15b03 	ldbu	r2,-31380(gp)
                bEcatWaitForAlControlRes = FALSE;
   237a4:	d0215a85 	stb	zero,-31382(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   237a8:	d1215a0b 	ldhu	r4,-31384(gp)
                else if (u8LocalErrorState != 0)
   237ac:	10000226 	beq	r2,zero,237b8 <ECAT_StateChange+0x8c>
                    u8LocalErrorState = 0;
   237b0:	d0215b05 	stb	zero,-31380(gp)
                    u16LocalErrorCode = 0x00;
   237b4:	d0215b8d 	sth	zero,-31378(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   237b8:	210003cc 	andi	r4,r4,15
   237bc:	00002406 	br	23850 <ECAT_StateChange+0x124>
   237c0:	208003cc 	andi	r2,r4,15
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   237c4:	00c04584 	movi	r3,278
   237c8:	1886d83a 	srl	r3,r3,r2
   237cc:	18c0004c 	andi	r3,r3,1
   237d0:	18000726 	beq	r3,zero,237f0 <ECAT_StateChange+0xc4>
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   237d4:	d0e15a83 	ldbu	r3,-31382(gp)
   237d8:	1800091e 	bne	r3,zero,23800 <ECAT_StateChange+0xd4>
   237dc:	d0e15b03 	ldbu	r3,-31380(gp)
   237e0:	21003fcc 	andi	r4,r4,255
   237e4:	1900381e 	bne	r3,r4,238c8 <ECAT_StateChange+0x19c>
   237e8:	d0e15b8b 	ldhu	r3,-31378(gp)
   237ec:	80c0361e 	bne	r16,r3,238c8 <ECAT_StateChange+0x19c>
            u8LocalErrorState = 0;
            u16LocalErrorCode = 0x00;
        }
        /*ECATCHANGE_END(V5.13) ESM1*/
    }
}
   237f0:	dfc00117 	ldw	ra,4(sp)
   237f4:	dc000017 	ldw	r16,0(sp)
   237f8:	dec00204 	addi	sp,sp,8
   237fc:	f800283a 	ret
        if(bApplEsmPending)
   23800:	d0e15ac3 	ldbu	r3,-31381(gp)
                u8LocalErrorState = (alStatus & STATE_MASK);
   23804:	d0a15b05 	stb	r2,-31380(gp)
                u16LocalErrorCode = alStatusCode;
   23808:	d1615b8d 	sth	r5,-31378(gp)
        if(bApplEsmPending)
   2380c:	18000226 	beq	r3,zero,23818 <ECAT_StateChange+0xec>
                EsmTimeoutCounter = 0;
   23810:	d021630d 	sth	zero,-31348(gp)
   23814:	003ff606 	br	237f0 <ECAT_StateChange+0xc4>
                switch(nEcatStateTrans)
   23818:	d0a15a0b 	ldhu	r2,-31384(gp)
   2381c:	10ffffcc 	andi	r3,r2,65535
   23820:	19000920 	cmpeqi	r4,r3,36
   23824:	2000181e 	bne	r4,zero,23888 <ECAT_StateChange+0x15c>
   23828:	19000968 	cmpgeui	r4,r3,37
   2382c:	20000e1e 	bne	r4,zero,23868 <ECAT_StateChange+0x13c>
   23830:	10bffb84 	addi	r2,r2,-18
   23834:	10bfffcc 	andi	r2,r2,65535
   23838:	108000a8 	cmpgeui	r2,r2,2
   2383c:	10000f26 	beq	r2,zero,2387c <ECAT_StateChange+0x150>
                Status =  (UINT8)(nEcatStateTrans >> 4);
   23840:	d1215a0b 	ldhu	r4,-31384(gp)
                bEcatWaitForAlControlRes = FALSE;
   23844:	d0215a85 	stb	zero,-31382(gp)
                Status =  (UINT8)(nEcatStateTrans >> 4);
   23848:	2008d13a 	srli	r4,r4,4
                    Status |= STATE_CHANGE;
   2384c:	21000414 	ori	r4,r4,16
                SetALStatus(Status,alStatusCode);
   23850:	800b883a 	mov	r5,r16
   23854:	21003fcc 	andi	r4,r4,255
}
   23858:	dfc00117 	ldw	ra,4(sp)
   2385c:	dc000017 	ldw	r16,0(sp)
   23860:	dec00204 	addi	sp,sp,8
                SetALStatus(Status,alStatusCode);
   23864:	00228d41 	jmpi	228d4 <SetALStatus>
                switch(nEcatStateTrans)
   23868:	18c01220 	cmpeqi	r3,r3,72
   2386c:	183ff426 	beq	r3,zero,23840 <ECAT_StateChange+0x114>
                          APPL_StopOutputHandler();
   23870:	00200b00 	call	200b0 <APPL_StopOutputHandler>
                          StopOutputHandler();
   23874:	00228200 	call	22820 <StopOutputHandler>
                    break;
   23878:	003ff106 	br	23840 <ECAT_StateChange+0x114>
                          APPL_StopMailboxHandler();
   2387c:	00200900 	call	20090 <APPL_StopMailboxHandler>
                          MBX_StopMailboxHandler();
   23880:	0023ea40 	call	23ea4 <MBX_StopMailboxHandler>
                    break;
   23884:	003fee06 	br	23840 <ECAT_StateChange+0x114>
                          APPL_StopInputHandler();
   23888:	00200a00 	call	200a0 <APPL_StopInputHandler>
                          StopInputHandler();
   2388c:	002282c0 	call	2282c <StopInputHandler>
                    break;
   23890:	003feb06 	br	23840 <ECAT_StateChange+0x114>
                switch(nEcatStateTrans)
   23894:	18c01220 	cmpeqi	r3,r3,72
   23898:	183fc126 	beq	r3,zero,237a0 <ECAT_StateChange+0x74>
                          bEcatOutputUpdateRunning = TRUE;
   2389c:	00800044 	movi	r2,1
   238a0:	d0a16485 	stb	r2,-31342(gp)
                    break;
   238a4:	003fbe06 	br	237a0 <ECAT_StateChange+0x74>
                        bMbxRunning = TRUE;
   238a8:	00800044 	movi	r2,1
   238ac:	d0a16d45 	stb	r2,-31307(gp)
                    break;
   238b0:	003fbb06 	br	237a0 <ECAT_StateChange+0x74>
                        SetALEventMask(u16ALEventMask);
   238b4:	d121558b 	ldhu	r4,-31402(gp)
   238b8:	0021c780 	call	21c78 <SetALEventMask>
                        bEcatInputUpdateRunning = TRUE;
   238bc:	00800044 	movi	r2,1
   238c0:	d0a16445 	stb	r2,-31343(gp)
                    break;
   238c4:	003fb606 	br	237a0 <ECAT_StateChange+0x74>
        if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
   238c8:	10c00220 	cmpeqi	r3,r2,8
   238cc:	11803fcc 	andi	r6,r2,255
   238d0:	183fa21e 	bne	r3,zero,2375c <ECAT_StateChange+0x30>
   238d4:	00c00584 	movi	r3,22
   238d8:	1986d83a 	srl	r3,r3,r6
   238dc:	18c0004c 	andi	r3,r3,1
   238e0:	183f9e26 	beq	r3,zero,2375c <ECAT_StateChange+0x30>
            u8LocalErrorState = (alStatus & STATE_MASK);
   238e4:	d0a15b05 	stb	r2,-31380(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   238e8:	d0a157c3 	ldbu	r2,-31393(gp)
            u16LocalErrorCode = alStatusCode;
   238ec:	d1615b8d 	sth	r5,-31378(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   238f0:	108003cc 	andi	r2,r2,15
   238f4:	10800218 	cmpnei	r2,r2,8
   238f8:	103fbd1e 	bne	r2,zero,237f0 <ECAT_StateChange+0xc4>
                AL_ControlInd(alStatus, alStatusCode);
   238fc:	800b883a 	mov	r5,r16
}
   23900:	dfc00117 	ldw	ra,4(sp)
   23904:	dc000017 	ldw	r16,0(sp)
   23908:	dec00204 	addi	sp,sp,8
                AL_ControlInd(alStatus, alStatusCode);
   2390c:	00229781 	jmpi	22978 <AL_ControlInd>

00023910 <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
   23910:	defffe04 	addi	sp,sp,-8
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23914:	01800044 	movi	r6,1
   23918:	01400144 	movi	r5,5
   2391c:	d1215884 	addi	r4,gp,-31390
{
   23920:	dfc00115 	stw	ra,4(sp)
   23924:	dc000015 	stw	r16,0(sp)
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23928:	00205e80 	call	205e8 <HW_EscRead>

    HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
   2392c:	01800084 	movi	r6,2
   23930:	01400184 	movi	r5,6
   23934:	d1215804 	addi	r4,gp,-31392
   23938:	00205e80 	call	205e8 <HW_EscRead>
    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   2393c:	d0a1580b 	ldhu	r2,-31392(gp)

/*ECATCHANGE_START(V5.13) ECAT2*/
    u16IdValue = 0;
   23940:	d021550d 	sth	zero,-31404(gp)

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
   23944:	0021883a 	mov	r16,zero
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23948:	100492ba 	slli	r2,r2,10
   2394c:	1083ffc4 	addi	r2,r2,4095
   23950:	d0a1580d 	sth	r2,-31392(gp)
    UpdateEEPROMLoadedState();
   23954:	0021cc40 	call	21cc4 <UpdateEEPROMLoadedState>
    for (i = 0; i < nMaxSyncMan; i++)
   23958:	d0a15883 	ldbu	r2,-31390(gp)
   2395c:	81003fcc 	andi	r4,r16,255
   23960:	20802136 	bltu	r4,r2,239e8 <ECAT_Init+0xd8>
    {
        DisableSyncManChannel(i);
    }

    /* initialize the mailbox handler */
    MBX_Init();
   23964:	0023d180 	call	23d18 <MBX_Init>
    u16ALEventMask = 0;
    nPdOutputSize = 0;
    nPdInputSize = 0;

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
   23968:	00800044 	movi	r2,1
    SetALStatus(nAlStatus, 0);
   2396c:	000b883a 	mov	r5,zero
   23970:	01000044 	movi	r4,1
    nAlStatus    = STATE_INIT;
   23974:	d0a157c5 	stb	r2,-31393(gp)
    bBootMode = FALSE;
   23978:	d02164c5 	stb	zero,-31341(gp)
    bApplEsmPending = FALSE;
   2397c:	d0215ac5 	stb	zero,-31381(gp)
    bEcatWaitForAlControlRes = FALSE;
   23980:	d0215a85 	stb	zero,-31382(gp)
    bEcatFirstOutputsReceived = FALSE;
   23984:	d0216405 	stb	zero,-31344(gp)
     bEcatOutputUpdateRunning = FALSE;
   23988:	d0216485 	stb	zero,-31342(gp)
     bEcatInputUpdateRunning = FALSE;
   2398c:	d0216445 	stb	zero,-31343(gp)
     bExplicitDevIdRequested = FALSE;
   23990:	d0215785 	stb	zero,-31394(gp)
    bWdTrigger = FALSE;
   23994:	d02163c5 	stb	zero,-31345(gp)
    EcatWdValue = 0;
   23998:	d021570d 	sth	zero,-31396(gp)
    Sync0WdCounter = 0;
   2399c:	d0215f8d 	sth	zero,-31362(gp)
    Sync0WdValue = 0;
   239a0:	d0215f0d 	sth	zero,-31364(gp)
    Sync1WdCounter = 0;
   239a4:	d0215e8d 	sth	zero,-31366(gp)
    Sync1WdValue = 0;
   239a8:	d0215e0d 	sth	zero,-31368(gp)
    bDcSyncActive = FALSE;
   239ac:	d0216385 	stb	zero,-31346(gp)
    u8LocalErrorState = 0;
   239b0:	d0215b05 	stb	zero,-31380(gp)
    u16LocalErrorCode = 0x00;
   239b4:	d0215b8d 	sth	zero,-31378(gp)
    u16ALEventMask = 0;
   239b8:	d021558d 	sth	zero,-31402(gp)
    nPdOutputSize = 0;
   239bc:	d021590d 	sth	zero,-31388(gp)
    nPdInputSize = 0;
   239c0:	d021598d 	sth	zero,-31386(gp)
    SetALStatus(nAlStatus, 0);
   239c4:	00228d40 	call	228d4 <SetALStatus>
    nEcatStateTrans = 0;
   239c8:	d0215a0d 	sth	zero,-31384(gp)

    bEscIntEnabled = FALSE;
   239cc:	d0215c45 	stb	zero,-31375(gp)

    /* initialize the COE part */
    COE_Init();
   239d0:	00217900 	call	21790 <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
   239d4:	0009883a 	mov	r4,zero
}
   239d8:	dfc00117 	ldw	ra,4(sp)
   239dc:	dc000017 	ldw	r16,0(sp)
   239e0:	dec00204 	addi	sp,sp,8
    ResetALEventMask(0);
   239e4:	0021c2c1 	jmpi	21c2c <ResetALEventMask>
        DisableSyncManChannel(i);
   239e8:	0021d2c0 	call	21d2c <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
   239ec:	84000044 	addi	r16,r16,1
   239f0:	003fd906 	br	23958 <ECAT_Init+0x48>

000239f4 <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
   239f4:	defffc04 	addi	sp,sp,-16
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
/*ECATCHANGE_START(V5.13) MBX1*/
    UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
   239f8:	00800044 	movi	r2,1
   239fc:	d8800005 	stb	r2,0(sp)
{
   23a00:	dfc00315 	stw	ra,12(sp)
   23a04:	dc400215 	stw	r17,8(sp)
   23a08:	dc000115 	stw	r16,4(sp)
    UINT16 EscAlControl = 0x0000;
   23a0c:	d800008d 	sth	zero,2(sp)
    UINT8 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
   23a10:	d8000045 	stb	zero,1(sp)
/*ECATCHANGE_END(V5.13) MBX1*/


    /* check if services are stored in the mailbox */
    MBX_Main();
   23a14:	00245600 	call	24560 <MBX_Main>


    if ( bMbxRunning )
   23a18:	d0a16d43 	ldbu	r2,-31307(gp)
   23a1c:	10000826 	beq	r2,zero,23a40 <ECAT_Main+0x4c>
    {
        /* Slave is at least in PREOP, Mailbox is running */

/*ECATCHANGE_START(V5.13) MBX1*/
        /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
        HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
   23a20:	01800044 	movi	r6,1
   23a24:	01420384 	movi	r5,2062
   23a28:	d809883a 	mov	r4,sp
   23a2c:	00205e80 	call	205e8 <HW_EscRead>

        HW_EscReadByte(sm1Status, (ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23a30:	01800044 	movi	r6,1
   23a34:	01420344 	movi	r5,2061
   23a38:	d9000044 	addi	r4,sp,1
   23a3c:	00205e80 	call	205e8 <HW_EscRead>
/*ECATCHANGE_END(V5.13) MBX1*/
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
   23a40:	00206200 	call	20620 <HW_GetALEventRegister>
   23a44:	1021883a 	mov	r16,r2
    ALEventReg = SWAPWORD(ALEventReg);


    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
   23a48:	8080004c 	andi	r2,r16,1
   23a4c:	10001526 	beq	r2,zero,23aa4 <ECAT_Main+0xb0>
   23a50:	d4615a83 	ldbu	r17,-31382(gp)
   23a54:	88803fcc 	andi	r2,r17,255
   23a58:	1000121e 	bne	r2,zero,23aa4 <ECAT_Main+0xb0>
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */

        HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
   23a5c:	01800044 	movi	r6,1
   23a60:	01404804 	movi	r5,288
   23a64:	d9000084 	addi	r4,sp,2
   23a68:	00205e80 	call	205e8 <HW_EscRead>
        EscAlControl = SWAPWORD(EscAlControl);


            /*ECATCHANGE_START(V5.13) ECAT2*/
                /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
            if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
   23a6c:	d880008b 	ldhu	r2,2(sp)
   23a70:	1080080c 	andi	r2,r2,32
   23a74:	10000526 	beq	r2,zero,23a8c <ECAT_Main+0x98>
            {
                if (bExplicitDevIdRequested == FALSE)
   23a78:	d0a15783 	ldbu	r2,-31394(gp)
   23a7c:	1000021e 	bne	r2,zero,23a88 <ECAT_Main+0x94>
                {
                    u16IdValue = APPL_GetDeviceID();
   23a80:	00203240 	call	20324 <APPL_GetDeviceID>
   23a84:	d0a1550d 	sth	r2,-31404(gp)
                }

                bExplicitDevIdRequested = TRUE;
   23a88:	04400044 	movi	r17,1

        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));

            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23a8c:	d9000083 	ldbu	r4,2(sp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   23a90:	00bffb84 	movi	r2,-18
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23a94:	000b883a 	mov	r5,zero
                bExplicitDevIdRequested = TRUE;
   23a98:	d4615785 	stb	r17,-31394(gp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   23a9c:	1420703a 	and	r16,r2,r16
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   23aa0:	00229780 	call	22978 <AL_ControlInd>

            /* SM-Change-Event was handled too */

    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   23aa4:	8400040c 	andi	r16,r16,16
   23aa8:	d0a15a83 	ldbu	r2,-31382(gp)
   23aac:	80002e26 	beq	r16,zero,23b68 <ECAT_Main+0x174>
   23ab0:	10803fcc 	andi	r2,r2,255
   23ab4:	10002326 	beq	r2,zero,23b44 <ECAT_Main+0x150>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
    }

    if(bEcatWaitForAlControlRes)
    {
        AL_ControlRes();
   23ab8:	002328c0 	call	2328c <AL_ControlRes>
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
   23abc:	d0a16d43 	ldbu	r2,-31307(gp)
   23ac0:	10001b26 	beq	r2,zero,23b30 <ECAT_Main+0x13c>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
            if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
   23ac4:	d8800003 	ldbu	r2,0(sp)
   23ac8:	1080004c 	andi	r2,r2,1
   23acc:	1000041e 	bne	r2,zero,23ae0 <ECAT_Main+0xec>
            {
                AL_ControlInd(nAlStatus & STATE_MASK, 0);
   23ad0:	d12157c3 	ldbu	r4,-31393(gp)
   23ad4:	000b883a 	mov	r5,zero
   23ad8:	210003cc 	andi	r4,r4,15
   23adc:	00229780 	call	22978 <AL_ControlInd>
            }

/*ECATCHANGE_START(V5.13) MBX1*/
        if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
   23ae0:	d8800043 	ldbu	r2,1(sp)
   23ae4:	1080020c 	andi	r2,r2,8
   23ae8:	1000081e 	bne	r2,zero,23b0c <ECAT_Main+0x118>
            && bSendMbxIsFull) 
   23aec:	d0a16d83 	ldbu	r2,-31306(gp)
   23af0:	10000626 	beq	r2,zero,23b0c <ECAT_Main+0x118>
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u8dummy = 0;
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   23af4:	d1616b0b 	ldhu	r5,-31316(gp)
   23af8:	01800044 	movi	r6,1
   23afc:	d12154c4 	addi	r4,gp,-31405
            u8dummy = 0;
   23b00:	d02154c5 	stb	zero,-31405(gp)
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   23b04:	002066c0 	call	2066c <HW_EscWrite>

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
            MBX_MailboxReadInd();
   23b08:	00241440 	call	24144 <MBX_MailboxReadInd>
        }

            /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

            if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
   23b0c:	d8800003 	ldbu	r2,0(sp)
   23b10:	d0e16d03 	ldbu	r3,-31308(gp)
   23b14:	1080008c 	andi	r2,r2,2
   23b18:	10001626 	beq	r2,zero,23b74 <ECAT_Main+0x180>
   23b1c:	18001626 	beq	r3,zero,23b78 <ECAT_Main+0x184>
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
            }


        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
   23b20:	00206200 	call	20620 <HW_GetALEventRegister>
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
   23b24:	1080400c 	andi	r2,r2,256
   23b28:	10000126 	beq	r2,zero,23b30 <ECAT_Main+0x13c>
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
            MBX_CheckAndCopyMailbox();
   23b2c:	002442c0 	call	2442c <MBX_CheckAndCopyMailbox>

        }
    }
}
   23b30:	dfc00317 	ldw	ra,12(sp)
   23b34:	dc400217 	ldw	r17,8(sp)
   23b38:	dc000117 	ldw	r16,4(sp)
   23b3c:	dec00404 	addi	sp,sp,16
   23b40:	f800283a 	ret
    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   23b44:	d12157c3 	ldbu	r4,-31393(gp)
   23b48:	2080040c 	andi	r2,r4,16
   23b4c:	103fdb1e 	bne	r2,zero,23abc <ECAT_Main+0xc8>
   23b50:	20803bcc 	andi	r2,r4,239
   23b54:	10800060 	cmpeqi	r2,r2,1
   23b58:	103fd81e 	bne	r2,zero,23abc <ECAT_Main+0xc8>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
   23b5c:	000b883a 	mov	r5,zero
   23b60:	210003cc 	andi	r4,r4,15
   23b64:	00229780 	call	22978 <AL_ControlInd>
    if(bEcatWaitForAlControlRes)
   23b68:	d0a15a83 	ldbu	r2,-31382(gp)
   23b6c:	103fd326 	beq	r2,zero,23abc <ECAT_Main+0xc8>
   23b70:	003fd106 	br	23ab8 <ECAT_Main+0xc4>
                || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
   23b74:	183fea26 	beq	r3,zero,23b20 <ECAT_Main+0x12c>
                MBX_MailboxRepeatReq();
   23b78:	00242040 	call	24204 <MBX_MailboxRepeatReq>
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23b7c:	d8800003 	ldbu	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23b80:	01800044 	movi	r6,1
   23b84:	014203c4 	movi	r5,2063
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23b88:	1080008c 	andi	r2,r2,2
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23b8c:	d809883a 	mov	r4,sp
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   23b90:	d8800005 	stb	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23b94:	002066c0 	call	2066c <HW_EscWrite>
   23b98:	003fe106 	br	23b20 <ECAT_Main+0x12c>

00023b9c <FOE_Read>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Read(UINT16 MBXMEM * pName, UINT16 nameSize, UINT16 MBXMEM * pData, UINT32 password)
{
    
    if (pAPPL_FoeRead != NULL)
   23b9c:	d0e14917 	ldw	r3,-31452(gp)
   23ba0:	18000b26 	beq	r3,zero,23bd0 <FOE_Read+0x34>
   23ba4:	3005883a 	mov	r2,r6
   23ba8:	380d883a 	mov	r6,r7
    {
        return  pAPPL_FoeRead(pName, nameSize, password, u16FoeMaxSendBlockSize, pData);
   23bac:	d1e14c0b 	ldhu	r7,-31440(gp)
{
   23bb0:	defffe04 	addi	sp,sp,-8
   23bb4:	dfc00115 	stw	ra,4(sp)
        return  pAPPL_FoeRead(pName, nameSize, password, u16FoeMaxSendBlockSize, pData);
   23bb8:	d8800015 	stw	r2,0(sp)
   23bbc:	297fffcc 	andi	r5,r5,65535
   23bc0:	183ee83a 	callr	r3
    }


    return ECAT_FOE_ERRCODE_NOTDEFINED;
}
   23bc4:	dfc00117 	ldw	ra,4(sp)
   23bc8:	dec00204 	addi	sp,sp,8
   23bcc:	f800283a 	ret
    return ECAT_FOE_ERRCODE_NOTDEFINED;
   23bd0:	00a00004 	movi	r2,-32768
}
   23bd4:	f800283a 	ret

00023bd8 <FOE_Write>:

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Write(UINT16 MBXMEM * pName, UINT16 nameSize, UINT32 password)
{
    if (pAPPL_FoeWrite != NULL)
   23bd8:	d0a14617 	ldw	r2,-31464(gp)
   23bdc:	10000226 	beq	r2,zero,23be8 <FOE_Write+0x10>
    {
        return pAPPL_FoeWrite(pName,nameSize,password);
   23be0:	297fffcc 	andi	r5,r5,65535
   23be4:	1000683a 	jmp	r2
    }

    return ECAT_FOE_ERRCODE_NOTDEFINED;
}
   23be8:	00a00004 	movi	r2,-32768
   23bec:	f800283a 	ret

00023bf0 <FOE_Data>:
 \brief    The function is called to write the next part of a file

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Data(UINT16 MBXMEM * pData, UINT16 Size)
{
   23bf0:	defffd04 	addi	sp,sp,-12
   23bf4:	dc400115 	stw	r17,4(sp)
    BOOL bDataFollowing = FALSE;

    if(Size == (u16ReceiveMbxSize - MBX_HEADER_SIZE - FOE_HEADER_SIZE) )
   23bf8:	d4616c0b 	ldhu	r17,-31312(gp)
    {
        bDataFollowing = TRUE;
    }

    if(pAPPL_FoeWriteData != NULL)
   23bfc:	d0a14517 	ldw	r2,-31468(gp)
{
   23c00:	dc000015 	stw	r16,0(sp)
    if(Size == (u16ReceiveMbxSize - MBX_HEADER_SIZE - FOE_HEADER_SIZE) )
   23c04:	8c7ffd04 	addi	r17,r17,-12
   23c08:	2c3fffcc 	andi	r16,r5,65535
{
   23c0c:	dfc00215 	stw	ra,8(sp)
    if(Size == (u16ReceiveMbxSize - MBX_HEADER_SIZE - FOE_HEADER_SIZE) )
   23c10:	844d003a 	cmpeq	r6,r16,r17
    if(pAPPL_FoeWriteData != NULL)
   23c14:	10000b26 	beq	r2,zero,23c44 <FOE_Data+0x54>
    {
        UINT16 error = 0;
        error = pAPPL_FoeWriteData(pData, Size, bDataFollowing);
   23c18:	800b883a 	mov	r5,r16
   23c1c:	103ee83a 	callr	r2

        if (error > 0)
   23c20:	10ffffcc 	andi	r3,r2,65535
   23c24:	1800021e 	bne	r3,zero,23c30 <FOE_Data+0x40>
        {
            return error;
        }
        else if (bDataFollowing == FALSE)
   23c28:	84400126 	beq	r16,r17,23c30 <FOE_Data+0x40>
        {
            return FOE_ACKFINISHED;
   23c2c:	009fff04 	movi	r2,32764
    }


    return ECAT_FOE_ERRCODE_NOTDEFINED;

}
   23c30:	dfc00217 	ldw	ra,8(sp)
   23c34:	dc400117 	ldw	r17,4(sp)
   23c38:	dc000017 	ldw	r16,0(sp)
   23c3c:	dec00304 	addi	sp,sp,12
   23c40:	f800283a 	ret
    return ECAT_FOE_ERRCODE_NOTDEFINED;
   23c44:	00a00004 	movi	r2,-32768
   23c48:	003ff906 	br	23c30 <FOE_Data+0x40>

00023c4c <FOE_Ack>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Ack(UINT32 fileOffset, UINT16 MBXMEM * pData)
{

    if (pAPPL_FoeReadData != NULL)
   23c4c:	d0a14817 	ldw	r2,-31456(gp)
{
   23c50:	280d883a 	mov	r6,r5
    if (pAPPL_FoeReadData != NULL)
   23c54:	10000226 	beq	r2,zero,23c60 <FOE_Ack+0x14>
    {
        return pAPPL_FoeReadData(fileOffset, u16FoeMaxSendBlockSize, pData);
   23c58:	d1614c0b 	ldhu	r5,-31440(gp)
   23c5c:	1000683a 	jmp	r2
    }

    return ECAT_FOE_ERRCODE_NOTDEFINED;
}
   23c60:	00a00004 	movi	r2,-32768
   23c64:	f800283a 	ret

00023c68 <FOE_Busy>:
 \brief    The function is called when the reading of a part of a file should be repeated

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 FOE_Busy(UINT16 done, UINT32 fileOffset, UINT16 MBXMEM * pData)
{
   23c68:	2809883a 	mov	r4,r5
   23c6c:	300b883a 	mov	r5,r6
    /* send last part again */
    return FOE_Ack(fileOffset, pData);
   23c70:	0023c4c1 	jmpi	23c4c <FOE_Ack>

00023c74 <FOE_Error>:

*////////////////////////////////////////////////////////////////////////////////////////

void FOE_Error(UINT32 errorCode)
{
    if (pAPPL_FoeError != NULL)
   23c74:	d0a14717 	ldw	r2,-31460(gp)
   23c78:	10000126 	beq	r2,zero,23c80 <FOE_Error+0xc>
    {
        pAPPL_FoeError(errorCode);
   23c7c:	1000683a 	jmp	r2
    }
}
   23c80:	f800283a 	ret

00023c84 <PutInMbxQueue>:
{
    UINT16 lastInQueue;
    ENTER_MBX_CRITICAL;


    lastInQueue = pQueue->lastInQueue+1;
   23c84:	2880008b 	ldhu	r2,2(r5)
    if (lastInQueue == pQueue->maxQueueSize)
   23c88:	29c0010b 	ldhu	r7,4(r5)
    lastInQueue = pQueue->lastInQueue+1;
   23c8c:	10c00044 	addi	r3,r2,1
   23c90:	180d883a 	mov	r6,r3
    if (lastInQueue == pQueue->maxQueueSize)
   23c94:	18ffffcc 	andi	r3,r3,65535
   23c98:	38c0011e 	bne	r7,r3,23ca0 <PutInMbxQueue+0x1c>
    {
        // Umbruch der Queue
        lastInQueue = 0;
   23c9c:	000d883a 	mov	r6,zero
    }

    if (pQueue->firstInQueue == lastInQueue)
   23ca0:	29c0000b 	ldhu	r7,0(r5)
   23ca4:	30ffffcc 	andi	r3,r6,65535
   23ca8:	38c00826 	beq	r7,r3,23ccc <PutInMbxQueue+0x48>
        // Ueberlauf der Queue -> letztes Element wieder herausnehmen
        LEAVE_MBX_CRITICAL;
        return MBXERR_NOMOREMEMORY;
    }

    pQueue->queue[pQueue->lastInQueue] = pMbx;
   23cac:	10bfffcc 	andi	r2,r2,65535
   23cb0:	10800084 	addi	r2,r2,2
   23cb4:	100490ba 	slli	r2,r2,2
   23cb8:	2885883a 	add	r2,r5,r2
   23cbc:	11000015 	stw	r4,0(r2)
    pQueue->lastInQueue = lastInQueue;
   23cc0:	2980008d 	sth	r6,2(r5)

    LEAVE_MBX_CRITICAL;

    return 0;
   23cc4:	0005883a 	mov	r2,zero
   23cc8:	f800283a 	ret
        return MBXERR_NOMOREMEMORY;
   23ccc:	008001c4 	movi	r2,7
}
   23cd0:	f800283a 	ret

00023cd4 <GetOutOfMbxQueue>:
TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
   23cd4:	20c0000b 	ldhu	r3,0(r4)
   23cd8:	2140008b 	ldhu	r5,2(r4)
   23cdc:	18bfffcc 	andi	r2,r3,65535
   23ce0:	11400b26 	beq	r2,r5,23d10 <GetOutOfMbxQueue+0x3c>
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
        pMbx = pQueue->queue[firstInQueue];
   23ce4:	10800084 	addi	r2,r2,2
   23ce8:	100490ba 	slli	r2,r2,2
        firstInQueue++;
        pQueue->firstInQueue = firstInQueue;
        
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23cec:	2140010b 	ldhu	r5,4(r4)
        firstInQueue++;
   23cf0:	18c00044 	addi	r3,r3,1
        pMbx = pQueue->queue[firstInQueue];
   23cf4:	2085883a 	add	r2,r4,r2
   23cf8:	10800017 	ldw	r2,0(r2)
        pQueue->firstInQueue = firstInQueue;
   23cfc:	20c0000d 	sth	r3,0(r4)
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23d00:	18ffffcc 	andi	r3,r3,65535
   23d04:	28c0031e 	bne	r5,r3,23d14 <GetOutOfMbxQueue+0x40>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
   23d08:	2000000d 	sth	zero,0(r4)
   23d0c:	f800283a 	ret
        }
    }
    else
    {
        pMbx = 0;
   23d10:	0005883a 	mov	r2,zero


    LEAVE_MBX_CRITICAL;

    return pMbx;
}
   23d14:	f800283a 	ret

00023d18 <MBX_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
   23d18:	00800904 	movi	r2,36
   23d1c:	d0a16c0d 	sth	r2,-31312(gp)
    u16SendMbxSize = MAX_MBX_SIZE;
   23d20:	00802004 	movi	r2,128
   23d24:	d0a16c8d 	sth	r2,-31310(gp)
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
   23d28:	00840004 	movi	r2,4096
   23d2c:	d0a16b8d 	sth	r2,-31314(gp)
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
   23d30:	d0a16b0d 	sth	r2,-31316(gp)

    sMbxReceiveQueue.firstInQueue    = 0;
   23d34:	008000f4 	movhi	r2,3
   23d38:	10230a15 	stw	zero,-29656(r2)
    sMbxReceiveQueue.lastInQueue     = 0;
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   23d3c:	00c000f4 	movhi	r3,3
   23d40:	00800284 	movi	r2,10
{
   23d44:	defffe04 	addi	sp,sp,-8
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   23d48:	18a30b0d 	sth	r2,-29652(r3)
    sMbxSendQueue.firstInQueue        = 0;
   23d4c:	00c000f4 	movhi	r3,3

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d50:	d90000c4 	addi	r4,sp,3
    sMbxSendQueue.firstInQueue        = 0;
   23d54:	18231715 	stw	zero,-29604(r3)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d58:	01800044 	movi	r6,1
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   23d5c:	00c000f4 	movhi	r3,3
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d60:	014203c4 	movi	r5,2063
{
   23d64:	dfc00115 	stw	ra,4(sp)
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   23d68:	18a3180d 	sth	r2,-29600(r3)
        UINT8 sm1Activate = 0;
   23d6c:	d80000c5 	stb	zero,3(sp)
    psWriteMbx  = NULL;
   23d70:	d0216915 	stw	zero,-31324(gp)
    psRepeatMbx = NULL;
   23d74:	d0216715 	stw	zero,-31332(gp)
    psReadMbx    = NULL;
   23d78:	d0216815 	stw	zero,-31328(gp)
    psStoreMbx    = NULL;
   23d7c:	d0216615 	stw	zero,-31336(gp)
    bMbxRepeatToggle    = FALSE;
   23d80:	d0216d05 	stb	zero,-31308(gp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d84:	00205e80 	call	205e8 <HW_EscRead>
        sm1Activate &= ~0x02;
   23d88:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d8c:	01800044 	movi	r6,1
   23d90:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23d94:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23d98:	d90000c4 	addi	r4,sp,3
        sm1Activate &= ~0x02;
   23d9c:	d88000c5 	stb	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23da0:	002066c0 	call	2066c <HW_EscWrite>
    }
    bMbxRunning = FALSE;
   23da4:	d0216d45 	stb	zero,-31307(gp)
    bSendMbxIsFull = FALSE;
   23da8:	d0216d85 	stb	zero,-31306(gp)
    bReceiveMbxIsLocked = FALSE;
   23dac:	d0216dc5 	stb	zero,-31305(gp)
    u8MailboxSendReqStored    = 0;
   23db0:	d0216a05 	stb	zero,-31320(gp)
    u8MbxWriteCounter = 0;
   23db4:	d0216a85 	stb	zero,-31318(gp)
    u8MbxReadCounter    = 0;
   23db8:	d0216a45 	stb	zero,-31319(gp)
}
   23dbc:	dfc00117 	ldw	ra,4(sp)
   23dc0:	dec00204 	addi	sp,sp,8
   23dc4:	f800283a 	ret

00023dc8 <MBX_StartMailboxHandler>:
 \brief     it is checked if the mailbox areas overlaps each other
 \brief     and the Sync Manager channels 0 and 1 are enabled.
 \brief     This function shall only be called if mailbox is supported.
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 MBX_StartMailboxHandler(void)
{
   23dc8:	defffe04 	addi	sp,sp,-8
    UINT16 result = 0;
    
    /* get address of the receive mailbox sync manager (SM0) */
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   23dcc:	0009883a 	mov	r4,zero
{
   23dd0:	dfc00115 	stw	ra,4(sp)
   23dd4:	dc000015 	stw	r16,0(sp)
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   23dd8:	0021cfc0 	call	21cfc <GetSyncMan>

    /* store size of the receive mailbox */
    u16ReceiveMbxSize     = pSyncMan->Length;
   23ddc:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the receive mailbox */
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23de0:	1080000b 	ldhu	r2,0(r2)

    /* get address of the send mailbox sync manager (SM1) */
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23de4:	01000044 	movi	r4,1
    u16ReceiveMbxSize     = pSyncMan->Length;
   23de8:	d0e16c0d 	sth	r3,-31312(gp)
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23dec:	d0a16b8d 	sth	r2,-31314(gp)
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23df0:	0021cfc0 	call	21cfc <GetSyncMan>

    /* store the size of the send mailbox */
    u16SendMbxSize = pSyncMan->Length;
   23df4:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the send mailbox */
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;

    // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23df8:	d1616b8b 	ldhu	r5,-31314(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23dfc:	1080000b 	ldhu	r2,0(r2)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23e00:	d1216c0b 	ldhu	r4,-31312(gp)
    u16SendMbxSize = pSyncMan->Length;
   23e04:	d0e16c8d 	sth	r3,-31310(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23e08:	d0a16b0d 	sth	r2,-31316(gp)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23e0c:	2149883a 	add	r4,r4,r5
   23e10:	10bfffcc 	andi	r2,r2,65535
   23e14:	1100030e 	bge	r2,r4,23e24 <MBX_StartMailboxHandler+0x5c>
   23e18:	193fffcc 	andi	r4,r3,65535
   23e1c:	2085883a 	add	r2,r4,r2
   23e20:	28801e16 	blt	r5,r2,23e9c <MBX_StartMailboxHandler+0xd4>
    {
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
    }

    u16FoeMaxSendBlockSize = (u16SendMbxSize - SIZEOF(TFOEHEADER) - MBX_HEADER_SIZE);
   23e24:	18fffd04 	addi	r3,r3,-12

    /* enable the receive mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_WRITE);
   23e28:	0009883a 	mov	r4,zero
    u16FoeMaxSendBlockSize = (u16SendMbxSize - SIZEOF(TFOEHEADER) - MBX_HEADER_SIZE);
   23e2c:	d0e14c0d 	sth	r3,-31440(gp)
    EnableSyncManChannel(MAILBOX_WRITE);
   23e30:	0021d8c0 	call	21d8c <EnableSyncManChannel>
    /* enable the send mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_READ);
   23e34:	01000044 	movi	r4,1
   23e38:	0021d8c0 	call	21d8c <EnableSyncManChannel>

        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   23e3c:	d1216c0b 	ldhu	r4,-31312(gp)
   23e40:	00270540 	call	27054 <malloc>
   23e44:	d0a16915 	stw	r2,-31324(gp)
   23e48:	1009883a 	mov	r4,r2
        if(psWriteMbx == NULL)
   23e4c:	10000e1e 	bne	r2,zero,23e88 <MBX_StartMailboxHandler+0xc0>
        {
            bNoMbxMemoryAvailable = TRUE;
   23e50:	00800044 	movi	r2,1

            //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23e54:	01000284 	movi	r4,10
            bNoMbxMemoryAvailable = TRUE;
   23e58:	d0a16505 	stb	r2,-31340(gp)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23e5c:	00270540 	call	27054 <malloc>
            if(psWriteMbx == NULL)
   23e60:	1021003a 	cmpeq	r16,r2,zero
   23e64:	8020907a 	slli	r16,r16,1
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23e68:	1009883a 	mov	r4,r2
            {
                result = ALSTATUSCODE_NOMEMORY;
            }

            APPL_FreeMailboxBuffer(psWriteMbx);
   23e6c:	00270640 	call	27064 <free>
            psWriteMbx = NULL;
   23e70:	d0216915 	stw	zero,-31324(gp)
            APPL_FreeMailboxBuffer(psWriteMbx);
            psWriteMbx = NULL;
        }

    return result;
}
   23e74:	8005883a 	mov	r2,r16
   23e78:	dfc00117 	ldw	ra,4(sp)
   23e7c:	dc000017 	ldw	r16,0(sp)
   23e80:	dec00204 	addi	sp,sp,8
   23e84:	f800283a 	ret
            bNoMbxMemoryAvailable = FALSE;
   23e88:	d0216505 	stb	zero,-31340(gp)
    UINT16 result = 0;
   23e8c:	0021883a 	mov	r16,zero
            APPL_FreeMailboxBuffer(psWriteMbx);
   23e90:	00270640 	call	27064 <free>
            psWriteMbx = NULL;
   23e94:	d0216915 	stw	zero,-31324(gp)
   23e98:	003ff606 	br	23e74 <MBX_StartMailboxHandler+0xac>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
   23e9c:	04000584 	movi	r16,22
   23ea0:	003ff406 	br	23e74 <MBX_StartMailboxHandler+0xac>

00023ea4 <MBX_StopMailboxHandler>:
 \brief  local management service Stop Mailbox Handler
 \brief  the Sync Manager channels 0 and 1 are disabled
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_StopMailboxHandler(void)
{
   23ea4:	defffd04 	addi	sp,sp,-12
    TMBX MBXMEM * pMbx;

    /* mailbox handler is stopped */
    bMbxRunning = FALSE;
    /* disable the receive mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_WRITE);
   23ea8:	0009883a 	mov	r4,zero
{
   23eac:	dfc00215 	stw	ra,8(sp)
   23eb0:	dc000115 	stw	r16,4(sp)
    bMbxRunning = FALSE;
   23eb4:	d0216d45 	stb	zero,-31307(gp)
    DisableSyncManChannel(MAILBOX_WRITE);
   23eb8:	0021d2c0 	call	21d2c <DisableSyncManChannel>
    /* disable the send mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_READ);
   23ebc:	01000044 	movi	r4,1
   23ec0:	0021d2c0 	call	21d2c <DisableSyncManChannel>
    /* initialize variables again */


    if (psRepeatMbx != NULL)
   23ec4:	d1216717 	ldw	r4,-31332(gp)
   23ec8:	20000126 	beq	r4,zero,23ed0 <MBX_StopMailboxHandler+0x2c>
    {
        APPL_FreeMailboxBuffer(psRepeatMbx);
   23ecc:	00270640 	call	27064 <free>
    }

    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
   23ed0:	d1216617 	ldw	r4,-31336(gp)
   23ed4:	20000326 	beq	r4,zero,23ee4 <MBX_StopMailboxHandler+0x40>
   23ed8:	d0a16717 	ldw	r2,-31332(gp)
   23edc:	20800126 	beq	r4,r2,23ee4 <MBX_StopMailboxHandler+0x40>
    {
        APPL_FreeMailboxBuffer(psStoreMbx);
   23ee0:	00270640 	call	27064 <free>
    }

    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
   23ee4:	d1216817 	ldw	r4,-31328(gp)
   23ee8:	20000526 	beq	r4,zero,23f00 <MBX_StopMailboxHandler+0x5c>
   23eec:	d0a16717 	ldw	r2,-31332(gp)
   23ef0:	20800326 	beq	r4,r2,23f00 <MBX_StopMailboxHandler+0x5c>
   23ef4:	d0a16617 	ldw	r2,-31336(gp)
   23ef8:	20800126 	beq	r4,r2,23f00 <MBX_StopMailboxHandler+0x5c>
    {
        APPL_FreeMailboxBuffer(psReadMbx);
   23efc:	00270640 	call	27064 <free>
    }


    SDOS_ClearPendingResponse();
   23f00:	00266e40 	call	266e4 <SDOS_ClearPendingResponse>


    FOE_Init();
   23f04:	002184c0 	call	2184c <FOE_Init>

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f08:	01800044 	movi	r6,1
   23f0c:	014203c4 	movi	r5,2063
   23f10:	d90000c4 	addi	r4,sp,3
    psWriteMbx = NULL;
   23f14:	d0216915 	stw	zero,-31324(gp)
    psRepeatMbx = NULL;
   23f18:	d0216715 	stw	zero,-31332(gp)
    psReadMbx = NULL;
   23f1c:	d0216815 	stw	zero,-31328(gp)
    psStoreMbx = NULL;
   23f20:	d0216615 	stw	zero,-31336(gp)
    bMbxRepeatToggle    = FALSE;
   23f24:	d0216d05 	stb	zero,-31308(gp)
        UINT8 sm1Activate = 0;
   23f28:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f2c:	00205e80 	call	205e8 <HW_EscRead>
        sm1Activate &= ~0x02;
   23f30:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f34:	01800044 	movi	r6,1
   23f38:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23f3c:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f40:	d90000c4 	addi	r4,sp,3
    u8MbxWriteCounter         = 0;
    u8MbxReadCounter        = 0;

    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23f44:	040000f4 	movhi	r16,3
        sm1Activate &= ~0x02;
   23f48:	d88000c5 	stb	r2,3(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23f4c:	84230a04 	addi	r16,r16,-29656
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23f50:	002066c0 	call	2066c <HW_EscWrite>
    bSendMbxIsFull         = FALSE;
   23f54:	d0216d85 	stb	zero,-31306(gp)
    bReceiveMbxIsLocked = FALSE;
   23f58:	d0216dc5 	stb	zero,-31305(gp)
    u8MailboxSendReqStored    = 0;
   23f5c:	d0216a05 	stb	zero,-31320(gp)
    u8MbxWriteCounter         = 0;
   23f60:	d0216a85 	stb	zero,-31318(gp)
    u8MbxReadCounter        = 0;
   23f64:	d0216a45 	stb	zero,-31319(gp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23f68:	8009883a 	mov	r4,r16
   23f6c:	0023cd40 	call	23cd4 <GetOutOfMbxQueue>
   23f70:	1009883a 	mov	r4,r2
        if (pMbx)
   23f74:	1000081e 	bne	r2,zero,23f98 <MBX_StopMailboxHandler+0xf4>
        }
    } while (pMbx != NULL);
    
    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23f78:	040000f4 	movhi	r16,3
   23f7c:	84231704 	addi	r16,r16,-29604
   23f80:	8009883a 	mov	r4,r16
   23f84:	0023cd40 	call	23cd4 <GetOutOfMbxQueue>
   23f88:	1009883a 	mov	r4,r2
        if (pMbx)
   23f8c:	10000426 	beq	r2,zero,23fa0 <MBX_StopMailboxHandler+0xfc>
        {
            APPL_FreeMailboxBuffer(pMbx);
   23f90:	00270640 	call	27064 <free>
        }
    } while (pMbx != NULL);
   23f94:	003ffa06 	br	23f80 <MBX_StopMailboxHandler+0xdc>
            APPL_FreeMailboxBuffer(pMbx);
   23f98:	00270640 	call	27064 <free>
    } while (pMbx != NULL);
   23f9c:	003ff206 	br	23f68 <MBX_StopMailboxHandler+0xc4>

}
   23fa0:	dfc00217 	ldw	ra,8(sp)
   23fa4:	dc000117 	ldw	r16,4(sp)
   23fa8:	dec00304 	addi	sp,sp,12
   23fac:	f800283a 	ret

00023fb0 <MailboxServiceInd>:
UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
{
    UINT8 result;

    /*only FoE is allowed in Boot mode*/
    if(bBootMode == TRUE && (MBX_TYPE_FOE != ((pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )))
   23fb0:	2080010b 	ldhu	r2,4(r4)
   23fb4:	d16164c3 	ldbu	r5,-31341(gp)
{
   23fb8:	2007883a 	mov	r3,r4
    if(bBootMode == TRUE && (MBX_TYPE_FOE != ((pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )))
   23fbc:	1005d23a 	srai	r2,r2,8
   23fc0:	29400058 	cmpnei	r5,r5,1
   23fc4:	108003cc 	andi	r2,r2,15
   23fc8:	2800041e 	bne	r5,zero,23fdc <MailboxServiceInd+0x2c>
   23fcc:	10800118 	cmpnei	r2,r2,4
   23fd0:	10000626 	beq	r2,zero,23fec <MailboxServiceInd+0x3c>
        result = MBXERR_UNSUPPORTEDPROTOCOL;
        break;
    }

    return result;
}
   23fd4:	00800084 	movi	r2,2
   23fd8:	f800283a 	ret
    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
   23fdc:	114000e0 	cmpeqi	r5,r2,3
   23fe0:	2800041e 	bne	r5,zero,23ff4 <MailboxServiceInd+0x44>
   23fe4:	10800120 	cmpeqi	r2,r2,4
   23fe8:	103ffa26 	beq	r2,zero,23fd4 <MailboxServiceInd+0x24>
        result = FOE_ServiceInd((TFOEMBX MBXMEM *) pMbx);
   23fec:	1809883a 	mov	r4,r3
   23ff0:	002185c1 	jmpi	2185c <FOE_ServiceInd>
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
   23ff4:	002179c1 	jmpi	2179c <COE_ServiceInd>

00023ff8 <MBX_CopyToSendMailbox>:
 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23ff8:	d0a157c3 	ldbu	r2,-31393(gp)
{
   23ffc:	defff804 	addi	sp,sp,-32
   24000:	dfc00715 	stw	ra,28(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   24004:	108003cc 	andi	r2,r2,15
{
   24008:	dd400615 	stw	r21,24(sp)
   2400c:	dd000515 	stw	r20,20(sp)
   24010:	dcc00415 	stw	r19,16(sp)
   24014:	dc800315 	stw	r18,12(sp)
   24018:	dc400215 	stw	r17,8(sp)
   2401c:	dc000115 	stw	r16,4(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   24020:	10800060 	cmpeqi	r2,r2,1
   24024:	1000431e 	bne	r2,zero,24134 <MBX_CopyToSendMailbox+0x13c>
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }


    if ( !bMbxRunning )
   24028:	d0a16d43 	ldbu	r2,-31307(gp)
   2402c:	10004126 	beq	r2,zero,24134 <MBX_CopyToSendMailbox+0x13c>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }

    if ( bSendMbxIsFull )
   24030:	d4e16d83 	ldbu	r19,-31306(gp)
   24034:	98803fcc 	andi	r2,r19,255
   24038:	1000401e 	bne	r2,zero,2413c <MBX_CopyToSendMailbox+0x144>
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
/*ECATCHANGE_START(V5.13) MBX2*/
        /*Reset the not used mailbox memory*/
        {
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   2403c:	d4216b0b 	ldhu	r16,-31316(gp)
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   24040:	d5216c8b 	ldhu	r20,-31310(gp)
        UINT16 mbxSize = pMbx->MbxHeader.Length;
   24044:	2440000b 	ldhu	r17,0(r4)
   24048:	2025883a 	mov	r18,r4
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   2404c:	a429883a 	add	r20,r20,r16
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   24050:	84000184 	addi	r16,r16,6
            LastAddrToReset = LastAddrToReset - 1;
   24054:	a53fffc4 	addi	r20,r20,-1
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   24058:	8461883a 	add	r16,r16,r17
            u8dummy = 0;
   2405c:	d02154c5 	stb	zero,-31405(gp)

            /*clear all unused bytes*/
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   24060:	843fffcc 	andi	r16,r16,65535
   24064:	a53fffcc 	andi	r20,r20,65535
            {
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   24068:	d56154c4 	addi	r21,gp,-31405
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   2406c:	80bfffcc 	andi	r2,r16,65535
   24070:	15002a36 	bltu	r2,r20,2411c <MBX_CopyToSendMailbox+0x124>
                LastUsedAddr = LastUsedAddr + 1;
            }
        }
/*ECATCHANGE_END(V5.13) MBX2*/

        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
   24074:	d1616b0b 	ldhu	r5,-31316(gp)
   24078:	89800184 	addi	r6,r17,6
   2407c:	31bfffcc 	andi	r6,r6,65535
   24080:	9009883a 	mov	r4,r18
   24084:	002066c0 	call	2066c <HW_EscWrite>


        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT8 smstate = 0x00;
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   24088:	01800044 	movi	r6,1
   2408c:	01420344 	movi	r5,2061
   24090:	d90000c4 	addi	r4,sp,3
        VARVOLATILE UINT8 smstate = 0x00;
   24094:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   24098:	00205e80 	call	205e8 <HW_EscRead>

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
   2409c:	d88000c3 	ldbu	r2,3(sp)
   240a0:	1080020c 	andi	r2,r2,8
   240a4:	10000d1e 	bne	r2,zero,240dc <MBX_CopyToSendMailbox+0xe4>
        {
            UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
   240a8:	d0a16c8b 	ldhu	r2,-31310(gp)
   240ac:	1463c83a 	sub	r17,r2,r17

            /*in case of a slow ESC the buffer status may not indicate 'full' even if the complete buffer was written, trigger an additional write access only if not the complete buffer was written*/
            if (BytesLeft > 0)
   240b0:	8c7fffcc 	andi	r17,r17,65535
   240b4:	8c4001a0 	cmpeqi	r17,r17,6
   240b8:	8800081e 	bne	r17,zero,240dc <MBX_CopyToSendMailbox+0xe4>
            {
                /*Write last Byte to trigger mailbox full flag*/
            u8dummy = 0;
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   240bc:	d1616b0b 	ldhu	r5,-31316(gp)
   240c0:	01800044 	movi	r6,1
   240c4:	d12154c4 	addi	r4,gp,-31405
   240c8:	288b883a 	add	r5,r5,r2
   240cc:	297fffc4 	addi	r5,r5,-1
   240d0:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   240d4:	d02154c5 	stb	zero,-31405(gp)
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   240d8:	002066c0 	call	2066c <HW_EscWrite>
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
   240dc:	d0a16817 	ldw	r2,-31328(gp)
   240e0:	10000126 	beq	r2,zero,240e8 <MBX_CopyToSendMailbox+0xf0>
        {
            psWriteMbx = NULL;
   240e4:	d0216915 	stw	zero,-31324(gp)
        }
        psReadMbx = pMbx;

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
   240e8:	00800044 	movi	r2,1
        psReadMbx = pMbx;
   240ec:	d4a16815 	stw	r18,-31328(gp)
        bSendMbxIsFull = TRUE;
   240f0:	d0a16d85 	stb	r2,-31306(gp)


        return 0;
    }
}
   240f4:	9805883a 	mov	r2,r19
   240f8:	dfc00717 	ldw	ra,28(sp)
   240fc:	dd400617 	ldw	r21,24(sp)
   24100:	dd000517 	ldw	r20,20(sp)
   24104:	dcc00417 	ldw	r19,16(sp)
   24108:	dc800317 	ldw	r18,12(sp)
   2410c:	dc400217 	ldw	r17,8(sp)
   24110:	dc000117 	ldw	r16,4(sp)
   24114:	dec00804 	addi	sp,sp,32
   24118:	f800283a 	ret
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   2411c:	800b883a 	mov	r5,r16
   24120:	01800044 	movi	r6,1
   24124:	a809883a 	mov	r4,r21
   24128:	002066c0 	call	2066c <HW_EscWrite>
                LastUsedAddr = LastUsedAddr + 1;
   2412c:	84000044 	addi	r16,r16,1
   24130:	003fce06 	br	2406c <MBX_CopyToSendMailbox+0x74>
        return( ERROR_INVALIDSTATE );
   24134:	04fffc04 	movi	r19,-16
   24138:	003fee06 	br	240f4 <MBX_CopyToSendMailbox+0xfc>
        return MBXERR_NOMOREMEMORY;
   2413c:	04c001c4 	movi	r19,7
   24140:	003fec06 	br	240f4 <MBX_CopyToSendMailbox+0xfc>

00024144 <MBX_MailboxReadInd>:
    if (psRepeatMbx && psStoreMbx == NULL)
   24144:	d1216717 	ldw	r4,-31332(gp)
{
   24148:	deffff04 	addi	sp,sp,-4
   2414c:	dfc00015 	stw	ra,0(sp)
    bSendMbxIsFull = FALSE;
   24150:	d0216d85 	stb	zero,-31306(gp)
    if (psRepeatMbx && psStoreMbx == NULL)
   24154:	20000526 	beq	r4,zero,2416c <MBX_MailboxReadInd+0x28>
   24158:	d0a16617 	ldw	r2,-31336(gp)
   2415c:	1000031e 	bne	r2,zero,2416c <MBX_MailboxReadInd+0x28>
        if (psReadMbx != psRepeatMbx)
   24160:	d0a16817 	ldw	r2,-31328(gp)
   24164:	20800126 	beq	r4,r2,2416c <MBX_MailboxReadInd+0x28>
            APPL_FreeMailboxBuffer(psRepeatMbx);
   24168:	00270640 	call	27064 <free>
    psRepeatMbx = psReadMbx;
   2416c:	d0a16817 	ldw	r2,-31328(gp)
      if ( psStoreMbx )
   24170:	d1216617 	ldw	r4,-31336(gp)
    psRepeatMbx = psReadMbx;
   24174:	d0a16715 	stw	r2,-31332(gp)
      if ( psStoreMbx )
   24178:	20001326 	beq	r4,zero,241c8 <MBX_MailboxReadInd+0x84>
        MBX_CopyToSendMailbox(psStoreMbx);
   2417c:	0023ff80 	call	23ff8 <MBX_CopyToSendMailbox>
        psStoreMbx = NULL;
   24180:	d0216615 	stw	zero,-31336(gp)
      if ( u8MailboxSendReqStored )
   24184:	d0a16a03 	ldbu	r2,-31320(gp)
   24188:	10c03fcc 	andi	r3,r2,255
   2418c:	18000b26 	beq	r3,zero,241bc <MBX_MailboxReadInd+0x78>
        if ( u8MailboxSendReqStored & COE_SERVICE )
   24190:	10c0008c 	andi	r3,r2,2
   24194:	18001326 	beq	r3,zero,241e4 <MBX_MailboxReadInd+0xa0>
            result = COE_ContinueInd(psWriteMbx);
   24198:	d1216917 	ldw	r4,-31324(gp)
            u8MailboxSendReqStored &= ~COE_SERVICE;
   2419c:	10803f4c 	andi	r2,r2,253
   241a0:	d0a16a05 	stb	r2,-31320(gp)
            result = COE_ContinueInd(psWriteMbx);
   241a4:	00217e40 	call	217e4 <COE_ContinueInd>
            if (result != 0)
   241a8:	10803fcc 	andi	r2,r2,255
   241ac:	10000326 	beq	r2,zero,241bc <MBX_MailboxReadInd+0x78>
                u8MailboxSendReqStored |= COE_SERVICE;
   241b0:	d0a16a03 	ldbu	r2,-31320(gp)
   241b4:	10800094 	ori	r2,r2,2
   241b8:	d0a16a05 	stb	r2,-31320(gp)
}
   241bc:	dfc00017 	ldw	ra,0(sp)
   241c0:	dec00104 	addi	sp,sp,4
   241c4:	f800283a 	ret
        TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   241c8:	010000f4 	movhi	r4,3
   241cc:	21231704 	addi	r4,r4,-29604
   241d0:	0023cd40 	call	23cd4 <GetOutOfMbxQueue>
   241d4:	1009883a 	mov	r4,r2
        if (pMbx)
   241d8:	103fea26 	beq	r2,zero,24184 <MBX_MailboxReadInd+0x40>
            MBX_CopyToSendMailbox(pMbx);
   241dc:	0023ff80 	call	23ff8 <MBX_CopyToSendMailbox>
   241e0:	003fe806 	br	24184 <MBX_MailboxReadInd+0x40>
        if ( u8MailboxSendReqStored & FOE_SERVICE )
   241e4:	10c0100c 	andi	r3,r2,64
   241e8:	183ff426 	beq	r3,zero,241bc <MBX_MailboxReadInd+0x78>
            FOE_ContinueInd(psWriteMbx);
   241ec:	d1216917 	ldw	r4,-31324(gp)
            u8MailboxSendReqStored &= ~FOE_SERVICE;
   241f0:	10802fcc 	andi	r2,r2,191
   241f4:	d0a16a05 	stb	r2,-31320(gp)
}
   241f8:	dfc00017 	ldw	ra,0(sp)
   241fc:	dec00104 	addi	sp,sp,4
            FOE_ContinueInd(psWriteMbx);
   24200:	0021bf81 	jmpi	21bf8 <FOE_ContinueInd>

00024204 <MBX_MailboxRepeatReq>:
{
   24204:	defffe04 	addi	sp,sp,-8
   24208:	dc000015 	stw	r16,0(sp)
    if (psRepeatMbx)
   2420c:	d4216717 	ldw	r16,-31332(gp)
{
   24210:	dfc00115 	stw	ra,4(sp)
    if (psRepeatMbx)
   24214:	80000e26 	beq	r16,zero,24250 <MBX_MailboxRepeatReq+0x4c>
       if (bSendMbxIsFull && psStoreMbx == NULL)
   24218:	d0a16d83 	ldbu	r2,-31306(gp)
   2421c:	10000926 	beq	r2,zero,24244 <MBX_MailboxRepeatReq+0x40>
   24220:	d0a16617 	ldw	r2,-31336(gp)
   24224:	1000071e 	bne	r2,zero,24244 <MBX_MailboxRepeatReq+0x40>
            DisableSyncManChannel(MAILBOX_READ);
   24228:	01000044 	movi	r4,1
   2422c:	0021d2c0 	call	21d2c <DisableSyncManChannel>
            psStoreMbx = psReadMbx;
   24230:	d0a16817 	ldw	r2,-31328(gp)
            EnableSyncManChannel(MAILBOX_READ);
   24234:	01000044 	movi	r4,1
            psStoreMbx = psReadMbx;
   24238:	d0a16615 	stw	r2,-31336(gp)
            EnableSyncManChannel(MAILBOX_READ);
   2423c:	0021d8c0 	call	21d8c <EnableSyncManChannel>
            bSendMbxIsFull = FALSE;
   24240:	d0216d85 	stb	zero,-31306(gp)
        MBX_CopyToSendMailbox(pMbx);
   24244:	8009883a 	mov	r4,r16
   24248:	0023ff80 	call	23ff8 <MBX_CopyToSendMailbox>
        psRepeatMbx = NULL;
   2424c:	d0216715 	stw	zero,-31332(gp)
    bMbxRepeatToggle = !bMbxRepeatToggle;
   24250:	d0a16d03 	ldbu	r2,-31308(gp)
   24254:	1005003a 	cmpeq	r2,r2,zero
   24258:	d0a16d05 	stb	r2,-31308(gp)
}
   2425c:	dfc00117 	ldw	ra,4(sp)
   24260:	dc000017 	ldw	r16,0(sp)
   24264:	dec00204 	addi	sp,sp,8
   24268:	f800283a 	ret

0002426c <MBX_MailboxSendReq>:
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
   2426c:	d0a157c3 	ldbu	r2,-31393(gp)
   24270:	108003cc 	andi	r2,r2,15
   24274:	10800060 	cmpeqi	r2,r2,1
   24278:	1000321e 	bne	r2,zero,24344 <MBX_MailboxSendReq+0xd8>
    if ( (u8MbxReadCounter & 0x07) == 0 )
   2427c:	d0e16a43 	ldbu	r3,-31319(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   24280:	2080010b 	ldhu	r2,4(r4)
{
   24284:	defffc04 	addi	sp,sp,-16
   24288:	dc800215 	stw	r18,8(sp)
   2428c:	dc400115 	stw	r17,4(sp)
   24290:	dc000015 	stw	r16,0(sp)
   24294:	dfc00315 	stw	ra,12(sp)
    if ( (u8MbxReadCounter & 0x07) == 0 )
   24298:	18c001cc 	andi	r3,r3,7
   2429c:	2025883a 	mov	r18,r4
   242a0:	2823883a 	mov	r17,r5
   242a4:	2821883a 	mov	r16,r5
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   242a8:	1083ffcc 	andi	r2,r2,4095
    if ( (u8MbxReadCounter & 0x07) == 0 )
   242ac:	1800021e 	bne	r3,zero,242b8 <MBX_MailboxSendReq+0x4c>
        u8MbxReadCounter = 1;
   242b0:	00c00044 	movi	r3,1
   242b4:	d0e16a45 	stb	r3,-31319(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   242b8:	d0e16a43 	ldbu	r3,-31319(gp)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   242bc:	9009883a 	mov	r4,r18
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   242c0:	1806933a 	slli	r3,r3,12
   242c4:	10c4b03a 	or	r2,r2,r3
   242c8:	9080010d 	sth	r2,4(r18)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   242cc:	0023ff80 	call	23ff8 <MBX_CopyToSendMailbox>
   242d0:	10803fcc 	andi	r2,r2,255
   242d4:	10000d26 	beq	r2,zero,2430c <MBX_MailboxSendReq+0xa0>
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
   242d8:	014000f4 	movhi	r5,3
   242dc:	29631704 	addi	r5,r5,-29604
   242e0:	9009883a 	mov	r4,r18
   242e4:	0023c840 	call	23c84 <PutInMbxQueue>
        if (result != 0)
   242e8:	10c03fcc 	andi	r3,r2,255
   242ec:	18000726 	beq	r3,zero,2430c <MBX_MailboxSendReq+0xa0>
            flags |= FRAGMENTS_FOLLOW;
   242f0:	043fe004 	movi	r16,-128
   242f4:	8c20b03a 	or	r16,r17,r16
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
   242f8:	d0e16a03 	ldbu	r3,-31320(gp)
   242fc:	84001fcc 	andi	r16,r16,127
   24300:	80e0b03a 	or	r16,r16,r3
   24304:	d4216a05 	stb	r16,-31320(gp)
   24308:	00000806 	br	2432c <MBX_MailboxSendReq+0xc0>
        u8MbxReadCounter++;
   2430c:	d0a16a43 	ldbu	r2,-31319(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   24310:	8c403fcc 	andi	r17,r17,255
   24314:	8c40201c 	xori	r17,r17,128
        u8MbxReadCounter++;
   24318:	10800044 	addi	r2,r2,1
   2431c:	d0a16a45 	stb	r2,-31319(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   24320:	8c7fe004 	addi	r17,r17,-128
   24324:	0005883a 	mov	r2,zero
   24328:	883ff316 	blt	r17,zero,242f8 <MBX_MailboxSendReq+0x8c>
}
   2432c:	dfc00317 	ldw	ra,12(sp)
   24330:	dc800217 	ldw	r18,8(sp)
   24334:	dc400117 	ldw	r17,4(sp)
   24338:	dc000017 	ldw	r16,0(sp)
   2433c:	dec00404 	addi	sp,sp,16
   24340:	f800283a 	ret
        return ERROR_INVALIDSTATE;
   24344:	00bffc04 	movi	r2,-16
}
   24348:	f800283a 	ret

0002434c <MBX_MailboxWriteInd>:
    if(MbxLen > MAX_MBX_SIZE)
   2434c:	2080000b 	ldhu	r2,0(r4)
{
   24350:	defffd04 	addi	sp,sp,-12
   24354:	dc400115 	stw	r17,4(sp)
   24358:	dc000015 	stw	r16,0(sp)
   2435c:	dfc00215 	stw	ra,8(sp)
    if(MbxLen > MAX_MBX_SIZE)
   24360:	10802070 	cmpltui	r2,r2,129
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   24364:	2440010b 	ldhu	r17,4(r4)
{
   24368:	2021883a 	mov	r16,r4
    if(MbxLen > MAX_MBX_SIZE)
   2436c:	10000e1e 	bne	r2,zero,243a8 <MBX_MailboxWriteInd+0x5c>
        pMbx->MbxHeader.Length     = 4;
   24370:	00800104 	movi	r2,4
   24374:	2080000d 	sth	r2,0(r4)
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24378:	00800044 	movi	r2,1
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   2437c:	8c7c3fcc 	andi	r17,r17,61695
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24380:	2080018d 	sth	r2,6(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   24384:	00800204 	movi	r2,8
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   24388:	2440010d 	sth	r17,4(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   2438c:	2080020d 	sth	r2,8(r4)
        MBX_MailboxSendReq(pMbx, 0);
   24390:	000b883a 	mov	r5,zero
}
   24394:	dfc00217 	ldw	ra,8(sp)
   24398:	dc400117 	ldw	r17,4(sp)
   2439c:	dc000017 	ldw	r16,0(sp)
   243a0:	dec00304 	addi	sp,sp,12
            MBX_MailboxSendReq(pMbx, 0);
   243a4:	002426c1 	jmpi	2426c <MBX_MailboxSendReq>
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   243a8:	88bfffcc 	andi	r2,r17,65535
   243ac:	1006d33a 	srli	r3,r2,12
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
   243b0:	18000226 	beq	r3,zero,243bc <MBX_MailboxWriteInd+0x70>
   243b4:	d0a16a83 	ldbu	r2,-31318(gp)
   243b8:	10c01226 	beq	r2,r3,24404 <MBX_MailboxWriteInd+0xb8>
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   243bc:	014000f4 	movhi	r5,3
   243c0:	29630a04 	addi	r5,r5,-29656
   243c4:	8009883a 	mov	r4,r16
        u8MbxWriteCounter = mbxCounter;
   243c8:	d0e16a85 	stb	r3,-31318(gp)
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   243cc:	0023c840 	call	23c84 <PutInMbxQueue>
        if ( result != 0 )
   243d0:	10c03fcc 	andi	r3,r2,255
   243d4:	18001026 	beq	r3,zero,24418 <MBX_MailboxWriteInd+0xcc>
            pMbx->MbxHeader.Length     = 4;
   243d8:	00c00104 	movi	r3,4
   243dc:	80c0000d 	sth	r3,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   243e0:	8c7c3fcc 	andi	r17,r17,61695
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   243e4:	00c00044 	movi	r3,1
            pMbx->Data[1]                        = SWAPWORD(result);
   243e8:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   243ec:	8440010d 	sth	r17,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   243f0:	80c0018d 	sth	r3,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   243f4:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   243f8:	000b883a 	mov	r5,zero
   243fc:	8009883a 	mov	r4,r16
   24400:	003fe406 	br	24394 <MBX_MailboxWriteInd+0x48>
}
   24404:	dfc00217 	ldw	ra,8(sp)
   24408:	dc400117 	ldw	r17,4(sp)
   2440c:	dc000017 	ldw	r16,0(sp)
   24410:	dec00304 	addi	sp,sp,12
        APPL_FreeMailboxBuffer(pMbx);
   24414:	00270641 	jmpi	27064 <free>
}
   24418:	dfc00217 	ldw	ra,8(sp)
   2441c:	dc400117 	ldw	r17,4(sp)
   24420:	dc000017 	ldw	r16,0(sp)
   24424:	dec00304 	addi	sp,sp,12
   24428:	f800283a 	ret

0002442c <MBX_CheckAndCopyMailbox>:
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   2442c:	d1616b8b 	ldhu	r5,-31314(gp)
{
   24430:	defffc04 	addi	sp,sp,-16
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   24434:	01800084 	movi	r6,2
   24438:	d9000084 	addi	r4,sp,2
{
   2443c:	dc400215 	stw	r17,8(sp)
   24440:	dfc00315 	stw	ra,12(sp)
   24444:	dc000115 	stw	r16,4(sp)
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   24448:	00205e80 	call	205e8 <HW_EscRead>
    if(bNoMbxMemoryAvailable == TRUE)
   2444c:	d4616503 	ldbu	r17,-31340(gp)
   24450:	88800060 	cmpeqi	r2,r17,1
   24454:	10001226 	beq	r2,zero,244a0 <MBX_CheckAndCopyMailbox+0x74>
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   24458:	01000284 	movi	r4,10
   2445c:	00270540 	call	27054 <malloc>
   24460:	1021883a 	mov	r16,r2
        if(pMbx != NULL)
   24464:	10000e26 	beq	r2,zero,244a0 <MBX_CheckAndCopyMailbox+0x74>
            HMEMSET(pMbx,0x00,10);
   24468:	01800204 	movi	r6,8
   2446c:	000b883a 	mov	r5,zero
   24470:	11000084 	addi	r4,r2,2
   24474:	00273840 	call	27384 <memset>
            pMbx->MbxHeader.Length     = 4;
   24478:	00800104 	movi	r2,4
   2447c:	8080000d 	sth	r2,0(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   24480:	008001c4 	movi	r2,7
            MBX_MailboxSendReq(pMbx, 0);
   24484:	8009883a 	mov	r4,r16
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24488:	8440018d 	sth	r17,6(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   2448c:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   24490:	000b883a 	mov	r5,zero
   24494:	002426c0 	call	2426c <MBX_MailboxSendReq>
            APPL_FreeMailboxBuffer(pMbx);
   24498:	8009883a 	mov	r4,r16
   2449c:	00270640 	call	27064 <free>
    mbxLen += MBX_HEADER_SIZE;
   244a0:	d880008b 	ldhu	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   244a4:	d0e16d83 	ldbu	r3,-31306(gp)
   244a8:	d1216a03 	ldbu	r4,-31320(gp)
    mbxLen += MBX_HEADER_SIZE;
   244ac:	10800184 	addi	r2,r2,6
   244b0:	d880008d 	sth	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   244b4:	1906b03a 	or	r3,r3,r4
   244b8:	18c03fcc 	andi	r3,r3,255
   244bc:	18000726 	beq	r3,zero,244dc <MBX_CheckAndCopyMailbox+0xb0>
            bReceiveMbxIsLocked = TRUE;
   244c0:	00800044 	movi	r2,1
   244c4:	d0a16dc5 	stb	r2,-31305(gp)
}
   244c8:	dfc00317 	ldw	ra,12(sp)
   244cc:	dc400217 	ldw	r17,8(sp)
   244d0:	dc000117 	ldw	r16,4(sp)
   244d4:	dec00404 	addi	sp,sp,16
   244d8:	f800283a 	ret
        if (mbxLen > u16ReceiveMbxSize)
   244dc:	d0e16c0b 	ldhu	r3,-31312(gp)
        bReceiveMbxIsLocked = FALSE;
   244e0:	d0216dc5 	stb	zero,-31305(gp)
        if (mbxLen > u16ReceiveMbxSize)
   244e4:	10bfffcc 	andi	r2,r2,65535
   244e8:	193fffcc 	andi	r4,r3,65535
   244ec:	2080012e 	bgeu	r4,r2,244f4 <MBX_CheckAndCopyMailbox+0xc8>
            mbxLen = u16ReceiveMbxSize;
   244f0:	d8c0008d 	sth	r3,2(sp)
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   244f4:	00270540 	call	27054 <malloc>
   244f8:	d0a16915 	stw	r2,-31324(gp)
   244fc:	1009883a 	mov	r4,r2
        if (psWriteMbx == NULL)
   24500:	103fef26 	beq	r2,zero,244c0 <MBX_CheckAndCopyMailbox+0x94>
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
   24504:	d980008b 	ldhu	r6,2(sp)
   24508:	d1616b8b 	ldhu	r5,-31314(gp)
   2450c:	00205e80 	call	205e8 <HW_EscRead>
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   24510:	01800044 	movi	r6,1
   24514:	01420144 	movi	r5,2053
   24518:	d9000044 	addi	r4,sp,1
        VARVOLATILE UINT8 smstate = 0x00;
   2451c:	d8000045 	stb	zero,1(sp)
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   24520:	00205e80 	call	205e8 <HW_EscRead>
        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
   24524:	d8800043 	ldbu	r2,1(sp)
   24528:	1080020c 	andi	r2,r2,8
   2452c:	10000926 	beq	r2,zero,24554 <MBX_CheckAndCopyMailbox+0x128>
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   24530:	d1616b8b 	ldhu	r5,-31314(gp)
   24534:	d0a16c0b 	ldhu	r2,-31312(gp)
   24538:	01800044 	movi	r6,1
   2453c:	d12154c4 	addi	r4,gp,-31405
   24540:	288b883a 	add	r5,r5,r2
   24544:	297fffc4 	addi	r5,r5,-1
   24548:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   2454c:	d02154c5 	stb	zero,-31405(gp)
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   24550:	00205e80 	call	205e8 <HW_EscRead>
        MBX_MailboxWriteInd( psWriteMbx );
   24554:	d1216917 	ldw	r4,-31324(gp)
   24558:	002434c0 	call	2434c <MBX_MailboxWriteInd>
   2455c:	003fda06 	br	244c8 <MBX_CheckAndCopyMailbox+0x9c>

00024560 <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
   24560:	defffa04 	addi	sp,sp,-24
   24564:	dc400115 	stw	r17,4(sp)

    do
    {
        UINT8 result = 0;

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24568:	044000f4 	movhi	r17,3
{
   2456c:	dd000415 	stw	r20,16(sp)
   24570:	dcc00315 	stw	r19,12(sp)
   24574:	dc800215 	stw	r18,8(sp)
   24578:	dfc00515 	stw	ra,20(sp)
   2457c:	dc000015 	stw	r16,0(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24580:	8c630a04 	addi	r17,r17,-29656
        }

        if ( result != 0 )
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
   24584:	05000104 	movi	r20,4
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   24588:	04fc3fc4 	movi	r19,-3841
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   2458c:	04800044 	movi	r18,1
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24590:	8809883a 	mov	r4,r17
   24594:	0023cd40 	call	23cd4 <GetOutOfMbxQueue>
   24598:	1021883a 	mov	r16,r2
        if ( pMbx )
   2459c:	10000a1e 	bne	r2,zero,245c8 <MBX_Main+0x68>
        }
    }
    while ( pMbx != NULL );


    if (bReceiveMbxIsLocked)
   245a0:	d0a16dc3 	ldbu	r2,-31305(gp)
   245a4:	10001726 	beq	r2,zero,24604 <MBX_Main+0xa4>
    if (u8MailboxSendReqStored)
    {
        /* there are mailbox services stored to be sent */
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   245a8:	dfc00517 	ldw	ra,20(sp)
   245ac:	dd000417 	ldw	r20,16(sp)
   245b0:	dcc00317 	ldw	r19,12(sp)
   245b4:	dc800217 	ldw	r18,8(sp)
   245b8:	dc400117 	ldw	r17,4(sp)
   245bc:	dc000017 	ldw	r16,0(sp)
   245c0:	dec00604 	addi	sp,sp,24
        MBX_CheckAndCopyMailbox();
   245c4:	002442c1 	jmpi	2442c <MBX_CheckAndCopyMailbox>
            result = MailboxServiceInd(pMbx);
   245c8:	1009883a 	mov	r4,r2
   245cc:	0023fb00 	call	23fb0 <MailboxServiceInd>
        if ( result != 0 )
   245d0:	10c03fcc 	andi	r3,r2,255
   245d4:	183fee26 	beq	r3,zero,24590 <MBX_Main+0x30>
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   245d8:	80c0010b 	ldhu	r3,4(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   245dc:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Length     = 4;
   245e0:	8500000d 	sth	r20,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   245e4:	1cc6703a 	and	r3,r3,r19
   245e8:	80c0010d 	sth	r3,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   245ec:	8480018d 	sth	r18,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   245f0:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   245f4:	000b883a 	mov	r5,zero
   245f8:	8009883a 	mov	r4,r16
   245fc:	002426c0 	call	2426c <MBX_MailboxSendReq>
   24600:	003fe306 	br	24590 <MBX_Main+0x30>
}
   24604:	dfc00517 	ldw	ra,20(sp)
   24608:	dd000417 	ldw	r20,16(sp)
   2460c:	dcc00317 	ldw	r19,12(sp)
   24610:	dc800217 	ldw	r18,8(sp)
   24614:	dc400117 	ldw	r17,4(sp)
   24618:	dc000017 	ldw	r16,0(sp)
   2461c:	dec00604 	addi	sp,sp,24
   24620:	f800283a 	ret

00024624 <OBJ_GetObjectHandle>:
             and returns a handle if found.

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
{
   24624:	defffe04 	addi	sp,sp,-8
   24628:	dc000015 	stw	r16,0(sp)
   2462c:	2021883a 	mov	r16,r4
   24630:	dfc00115 	stw	ra,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();

    while (pObjEntry!= NULL)
    {
        
        if (pObjEntry->Index == index)
   24634:	843fffcc 	andi	r16,r16,65535
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24638:	00208680 	call	20868 <COE_GetObjectDictionary>
    while (pObjEntry!= NULL)
   2463c:	1000041e 	bne	r2,zero,24650 <OBJ_GetObjectHandle+0x2c>
            return pObjEntry;
        }
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
    }
    return 0;
}
   24640:	dfc00117 	ldw	ra,4(sp)
   24644:	dc000017 	ldw	r16,0(sp)
   24648:	dec00204 	addi	sp,sp,8
   2464c:	f800283a 	ret
        if (pObjEntry->Index == index)
   24650:	10c0020b 	ldhu	r3,8(r2)
   24654:	1c3ffa26 	beq	r3,r16,24640 <OBJ_GetObjectHandle+0x1c>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24658:	10800117 	ldw	r2,4(r2)
   2465c:	003ff706 	br	2463c <OBJ_GetObjectHandle+0x18>

00024660 <OBJ_GetObjectLength>:

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24660:	30c0030b 	ldhu	r3,12(r6)
{
   24664:	defffe04 	addi	sp,sp,-8
   24668:	dc000015 	stw	r16,0(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2466c:	1804d23a 	srli	r2,r3,8
{
   24670:	dfc00115 	stw	ra,4(sp)
    
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
    UINT32 size = 0;

    if ( bCompleteAccess )
   24674:	39c03fcc 	andi	r7,r7,255
{
   24678:	2821883a 	mov	r16,r5
   2467c:	108003cc 	andi	r2,r2,15
    if ( bCompleteAccess )
   24680:	38002026 	beq	r7,zero,24704 <OBJ_GetObjectLength+0xa4>
    {
        if ( objCode == OBJCODE_VAR )
   24684:	110001e0 	cmpeqi	r4,r2,7
   24688:	2000361e 	bne	r4,zero,24764 <OBJ_GetObjectLength+0x104>
        {
            return 0;
        }
        else if ((objCode == OBJCODE_ARR)
   2468c:	10800218 	cmpnei	r2,r2,8
   24690:	1000171e 	bne	r2,zero,246f0 <OBJ_GetObjectLength+0x90>
            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   24694:	30800417 	ldw	r2,16(r6)
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   24698:	30c00617 	ldw	r3,24(r6)
            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   2469c:	1100020b 	ldhu	r4,8(r2)
   246a0:	19400003 	ldbu	r5,0(r3)
   246a4:	002702c0 	call	2702c <__mulsi3>
            for (i = 1; i <= maxSubindex; i++)
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
   246a8:	108001c4 	addi	r2,r2,7

            if ( subindex == 0 )
   246ac:	81403fcc 	andi	r5,r16,255
            size = BIT2BYTE(size);
   246b0:	1004d0fa 	srli	r2,r2,3
            if ( subindex == 0 )
   246b4:	2800011e 	bne	r5,zero,246bc <OBJ_GetObjectLength+0x5c>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
   246b8:	10800084 	addi	r2,r2,2
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
                }
            }
        }
    }
}
   246bc:	dfc00117 	ldw	ra,4(sp)
   246c0:	dc000017 	ldw	r16,0(sp)
   246c4:	dec00204 	addi	sp,sp,8
   246c8:	f800283a 	ret
                size += pObjEntry->pEntryDesc[i].BitLength;
   246cc:	31c00417 	ldw	r7,16(r6)
            for (i = 1; i <= maxSubindex; i++)
   246d0:	21000044 	addi	r4,r4,1
                size += pObjEntry->pEntryDesc[i].BitLength;
   246d4:	394f883a 	add	r7,r7,r5
   246d8:	39c0008b 	ldhu	r7,2(r7)
   246dc:	29400184 	addi	r5,r5,6
   246e0:	11c5883a 	add	r2,r2,r7
            for (i = 1; i <= maxSubindex; i++)
   246e4:	21ffffcc 	andi	r7,r4,65535
   246e8:	19fff82e 	bgeu	r3,r7,246cc <OBJ_GetObjectLength+0x6c>
   246ec:	003fee06 	br	246a8 <OBJ_GetObjectLength+0x48>
   246f0:	01400184 	movi	r5,6
   246f4:	01000044 	movi	r4,1
    UINT32 size = 0;
   246f8:	0005883a 	mov	r2,zero
            for (i = 1; i <= maxSubindex; i++)
   246fc:	18c03fcc 	andi	r3,r3,255
   24700:	003ff806 	br	246e4 <OBJ_GetObjectLength+0x84>
        if ( objCode == OBJCODE_VAR )
   24704:	110001d8 	cmpnei	r4,r2,7
   24708:	2000031e 	bne	r4,zero,24718 <OBJ_GetObjectLength+0xb8>
            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
   2470c:	30800417 	ldw	r2,16(r6)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24710:	1080008b 	ldhu	r2,2(r2)
   24714:	00000606 	br	24730 <OBJ_GetObjectLength+0xd0>
        else if ( subindex == 0 )
   24718:	29403fcc 	andi	r5,r5,255
   2471c:	28000f26 	beq	r5,zero,2475c <OBJ_GetObjectLength+0xfc>
        else if((objCode == OBJCODE_ARR)
   24720:	10800218 	cmpnei	r2,r2,8
   24724:	1000051e 	bne	r2,zero,2473c <OBJ_GetObjectLength+0xdc>
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
   24728:	30800417 	ldw	r2,16(r6)
   2472c:	1080020b 	ldhu	r2,8(r2)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24730:	108001c4 	addi	r2,r2,7
   24734:	1005d0fa 	srai	r2,r2,3
   24738:	003fe006 	br	246bc <OBJ_GetObjectLength+0x5c>
                if (maxSubindex < subindex)
   2473c:	18c03fcc 	andi	r3,r3,255
   24740:	19400836 	bltu	r3,r5,24764 <OBJ_GetObjectLength+0x104>
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24744:	2804907a 	slli	r2,r5,1
   24748:	30c00417 	ldw	r3,16(r6)
   2474c:	1145883a 	add	r2,r2,r5
   24750:	1004907a 	slli	r2,r2,1
   24754:	1885883a 	add	r2,r3,r2
   24758:	003fed06 	br	24710 <OBJ_GetObjectLength+0xb0>
            return 1;
   2475c:	00800044 	movi	r2,1
   24760:	003fd606 	br	246bc <OBJ_GetObjectLength+0x5c>
            return 0;
   24764:	0005883a 	mov	r2,zero
   24768:	003fd406 	br	246bc <OBJ_GetObjectLength+0x5c>

0002476c <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
   2476c:	defffd04 	addi	sp,sp,-12
   24770:	dc400115 	stw	r17,4(sp)
    UINT8 Modulo;

    pStr[2] = '0';
    pStr[0] += (Number / 100);
   24774:	2c403fcc 	andi	r17,r5,255
{
   24778:	dc000015 	stw	r16,0(sp)
    pStr[0] += (Number / 100);
   2477c:	01401904 	movi	r5,100
{
   24780:	2021883a 	mov	r16,r4
    pStr[0] += (Number / 100);
   24784:	8809883a 	mov	r4,r17
{
   24788:	dfc00215 	stw	ra,8(sp)
    pStr[0] += (Number / 100);
   2478c:	0026f6c0 	call	26f6c <__udivsi3>
   24790:	80c00003 	ldbu	r3,0(r16)
    Modulo = Number % 100;
   24794:	8809883a 	mov	r4,r17
   24798:	01401904 	movi	r5,100
    pStr[0] += (Number / 100);
   2479c:	10c5883a 	add	r2,r2,r3
   247a0:	80800005 	stb	r2,0(r16)
    Modulo = Number % 100;
   247a4:	0026fd00 	call	26fd0 <__umodsi3>
    pStr[1] += (Modulo / 10);
   247a8:	14403fcc 	andi	r17,r2,255
   247ac:	8809883a 	mov	r4,r17
   247b0:	01400284 	movi	r5,10
   247b4:	0026f6c0 	call	26f6c <__udivsi3>
   247b8:	80c00043 	ldbu	r3,1(r16)
    pStr[2] += (Modulo % 10);
   247bc:	01400284 	movi	r5,10
   247c0:	8809883a 	mov	r4,r17
    pStr[1] += (Modulo / 10);
   247c4:	10c5883a 	add	r2,r2,r3
   247c8:	80800045 	stb	r2,1(r16)
    pStr[2] += (Modulo % 10);
   247cc:	0026fd00 	call	26fd0 <__umodsi3>
   247d0:	10800c04 	addi	r2,r2,48
   247d4:	80800085 	stb	r2,2(r16)
}
   247d8:	dfc00217 	ldw	ra,8(sp)
   247dc:	dc400117 	ldw	r17,4(sp)
   247e0:	dc000017 	ldw	r16,0(sp)
   247e4:	dec00304 	addi	sp,sp,12
   247e8:	f800283a 	ret

000247ec <OBJ_GetDesc>:
                0xFF                                            <br>
            }
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
{
   247ec:	defff604 	addi	sp,sp,-40
   247f0:	dcc00715 	stw	r19,28(sp)
   247f4:	dc800615 	stw	r18,24(sp)
   247f8:	dc000415 	stw	r16,16(sp)
   247fc:	dfc00915 	stw	ra,36(sp)
   24800:	dd000815 	stw	r20,32(sp)
   24804:	dc400515 	stw	r17,20(sp)
/* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;



    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24808:	2cc03fcc 	andi	r19,r5,255
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
   2480c:	34000517 	ldw	r16,20(r6)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24810:	3080030b 	ldhu	r2,12(r6)
{
   24814:	3825883a 	mov	r18,r7
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24818:	98000426 	beq	r19,zero,2482c <OBJ_GetDesc+0x40>
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2481c:	1004d23a 	srli	r2,r2,8
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24820:	108003cc 	andi	r2,r2,15
   24824:	10c001d8 	cmpnei	r3,r2,7
   24828:	1800091e 	bne	r3,zero,24850 <OBJ_GetDesc+0x64>
    {
        // Get object description length
       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
   2482c:	8009883a 	mov	r4,r16
   24830:	00273a40 	call	273a4 <strlen>
   24834:	1023883a 	mov	r17,r2

        // If there is a pointer given, copy data:
        if ( pData )
   24838:	90001a26 	beq	r18,zero,248a4 <OBJ_GetDesc+0xb8>
        {
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
   2483c:	11bfffcc 	andi	r6,r2,65535
                if ( i == tmpSubindex )
                {
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
                    if ( pData && strSize )
                    {
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   24840:	800b883a 	mov	r5,r16
   24844:	9009883a 	mov	r4,r18
   24848:	002735c0 	call	2735c <memcpy>
            }
            }
            }
        }

        if ( strSize == 0 )
   2484c:	00001506 	br	248a4 <OBJ_GetDesc+0xb8>
        if ( objCode == OBJCODE_REC )
   24850:	10800258 	cmpnei	r2,r2,9
   24854:	1000251e 	bne	r2,zero,248ec <OBJ_GetDesc+0x100>
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24858:	8009883a 	mov	r4,r16
            UINT16 tmpSubindex = subindex;
   2485c:	2c403fcc 	andi	r17,r5,255
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24860:	00273a40 	call	273a4 <strlen>
   24864:	10800044 	addi	r2,r2,1
   24868:	80a1883a 	add	r16,r16,r2
            UINT16 i = 1;
   2486c:	05000044 	movi	r20,1
                if ( i == tmpSubindex )
   24870:	8c7fffcc 	andi	r17,r17,65535
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   24874:	80800003 	ldbu	r2,0(r16)
   24878:	10803fb0 	cmpltui	r2,r2,254
   2487c:	10001b26 	beq	r2,zero,248ec <OBJ_GetDesc+0x100>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   24880:	8009883a 	mov	r4,r16
   24884:	00273a40 	call	273a4 <strlen>
                if ( i == tmpSubindex )
   24888:	a0ffffcc 	andi	r3,r20,65535
   2488c:	88c0111e 	bne	r17,r3,248d4 <OBJ_GetDesc+0xe8>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   24890:	1023883a 	mov	r17,r2
                    if ( pData && strSize )
   24894:	10ffffcc 	andi	r3,r2,65535
   24898:	90000b1e 	bne	r18,zero,248c8 <OBJ_GetDesc+0xdc>
        if ( strSize == 0 )
   2489c:	1800011e 	bne	r3,zero,248a4 <OBJ_GetDesc+0xb8>
        {
            // no string found for subindex x -> name is Subindex x
            strSize =    12;
   248a0:	04400304 	movi	r17,12
            }
        }
    }

    return strSize;
}
   248a4:	8805883a 	mov	r2,r17
   248a8:	dfc00917 	ldw	ra,36(sp)
   248ac:	dd000817 	ldw	r20,32(sp)
   248b0:	dcc00717 	ldw	r19,28(sp)
   248b4:	dc800617 	ldw	r18,24(sp)
   248b8:	dc400517 	ldw	r17,20(sp)
   248bc:	dc000417 	ldw	r16,16(sp)
   248c0:	dec00a04 	addi	sp,sp,40
   248c4:	f800283a 	ret
                    if ( pData && strSize )
   248c8:	18000926 	beq	r3,zero,248f0 <OBJ_GetDesc+0x104>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   248cc:	11bfffcc 	andi	r6,r2,65535
   248d0:	003fdb06 	br	24840 <OBJ_GetDesc+0x54>
                    i++;
   248d4:	a0c00044 	addi	r3,r20,1
   248d8:	1829883a 	mov	r20,r3
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   248dc:	10800044 	addi	r2,r2,1
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   248e0:	18ffffcc 	andi	r3,r3,65535
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   248e4:	80a1883a 	add	r16,r16,r2
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   248e8:	88ffe22e 	bgeu	r17,r3,24874 <OBJ_GetDesc+0x88>
            if ( pData )
   248ec:	903fec26 	beq	r18,zero,248a0 <OBJ_GetDesc+0xb4>
                MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
   248f0:	014000f4 	movhi	r5,3
   248f4:	01800344 	movi	r6,13
   248f8:	d90000c4 	addi	r4,sp,3
   248fc:	2960d704 	addi	r5,r5,-31908
   24900:	002735c0 	call	2735c <memcpy>
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
   24904:	980b883a 	mov	r5,r19
   24908:	d9000304 	addi	r4,sp,12
   2490c:	002476c0 	call	2476c <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
   24910:	01800344 	movi	r6,13
   24914:	d94000c4 	addi	r5,sp,3
   24918:	9009883a 	mov	r4,r18
   2491c:	002735c0 	call	2735c <memcpy>
   24920:	003fdf06 	br	248a0 <OBJ_GetDesc+0xb4>

00024924 <OBJ_GetEntryDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24924:	20c0030b 	ldhu	r3,12(r4)
   24928:	20800417 	ldw	r2,16(r4)
   2492c:	29403fcc 	andi	r5,r5,255
   24930:	1807d23a 	srai	r3,r3,8

    if ((objCode == OBJCODE_ARR)
   24934:	18c003cc 	andi	r3,r3,15
   24938:	18c00218 	cmpnei	r3,r3,8
   2493c:	1800031e 	bne	r3,zero,2494c <OBJ_GetEntryDesc+0x28>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
   24940:	28000626 	beq	r5,zero,2495c <OBJ_GetEntryDesc+0x38>
            pEntry = &pObjEntry->pEntryDesc[0];
        }
        else
        {
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
   24944:	10800184 	addi	r2,r2,6
   24948:	f800283a 	ret
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
   2494c:	2806907a 	slli	r3,r5,1
   24950:	1947883a 	add	r3,r3,r5
   24954:	1806907a 	slli	r3,r3,1
   24958:	10c5883a 	add	r2,r2,r3
        }
    }

    return pEntry;
}
   2495c:	f800283a 	ret

00024960 <OBJ_GetNoOfObjects>:
{
   24960:	defff904 	addi	sp,sp,-28
   24964:	dd000415 	stw	r20,16(sp)
   24968:	dcc00315 	stw	r19,12(sp)
   2496c:	2029883a 	mov	r20,r4
    UINT16 listFlags = 0x0020 << listType;
   24970:	04c00804 	movi	r19,32
   24974:	21003fcc 	andi	r4,r4,255
{
   24978:	dc800215 	stw	r18,8(sp)
   2497c:	dc000015 	stw	r16,0(sp)
    UINT16 listFlags = 0x0020 << listType;
   24980:	9926983a 	sll	r19,r19,r4
{
   24984:	dfc00615 	stw	ra,24(sp)
   24988:	dd400515 	stw	r21,20(sp)
   2498c:	dc400115 	stw	r17,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24990:	00208680 	call	20868 <COE_GetObjectDictionary>
   24994:	1021883a 	mov	r16,r2
    UINT16 n = 0;
   24998:	0025883a 	mov	r18,zero
            if ( t )
   2499c:	a5003fcc 	andi	r20,r20,255
    while (pObjEntry != NULL)
   249a0:	80000a1e 	bne	r16,zero,249cc <OBJ_GetNoOfObjects+0x6c>
}
   249a4:	9005883a 	mov	r2,r18
   249a8:	dfc00617 	ldw	ra,24(sp)
   249ac:	dd400517 	ldw	r21,20(sp)
   249b0:	dd000417 	ldw	r20,16(sp)
   249b4:	dcc00317 	ldw	r19,12(sp)
   249b8:	dc800217 	ldw	r18,8(sp)
   249bc:	dc400117 	ldw	r17,4(sp)
   249c0:	dc000017 	ldw	r16,0(sp)
   249c4:	dec00704 	addi	sp,sp,28
   249c8:	f800283a 	ret
        if ( pObjEntry->Index >= 0x1000 )
   249cc:	8080020b 	ldhu	r2,8(r16)
   249d0:	10840030 	cmpltui	r2,r2,4096
   249d4:	10000c1e 	bne	r2,zero,24a08 <OBJ_GetNoOfObjects+0xa8>
            if ( t )
   249d8:	a0000d26 	beq	r20,zero,24a10 <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   249dc:	85400303 	ldbu	r21,12(r16)
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   249e0:	0023883a 	mov	r17,zero
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
   249e4:	880b883a 	mov	r5,r17
   249e8:	8009883a 	mov	r4,r16
   249ec:	00249240 	call	24924 <OBJ_GetEntryDesc>
   249f0:	1080010b 	ldhu	r2,4(r2)
   249f4:	14c4703a 	and	r2,r2,r19
   249f8:	1000051e 	bne	r2,zero,24a10 <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   249fc:	8c400044 	addi	r17,r17,1
   24a00:	88bfffcc 	andi	r2,r17,65535
   24a04:	a8bff72e 	bgeu	r21,r2,249e4 <OBJ_GetNoOfObjects+0x84>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24a08:	84000117 	ldw	r16,4(r16)
   24a0c:	003fe406 	br	249a0 <OBJ_GetNoOfObjects+0x40>
                n++;
   24a10:	94800044 	addi	r18,r18,1
   24a14:	003ffc06 	br	24a08 <OBJ_GetNoOfObjects+0xa8>

00024a18 <OBJ_GetObjectList>:
    if ( pIndex[0] == 0x1000 )
   24a18:	2880000b 	ldhu	r2,0(r5)
{
   24a1c:	defff604 	addi	sp,sp,-40
   24a20:	ddc00715 	stw	r23,28(sp)
   24a24:	dd800615 	stw	r22,24(sp)
   24a28:	dd400515 	stw	r21,20(sp)
   24a2c:	dd000415 	stw	r20,16(sp)
   24a30:	dcc00315 	stw	r19,12(sp)
   24a34:	dc800215 	stw	r18,8(sp)
   24a38:	dc400115 	stw	r17,4(sp)
   24a3c:	dfc00915 	stw	ra,36(sp)
   24a40:	df000815 	stw	fp,32(sp)
   24a44:	dc000015 	stw	r16,0(sp)
    if ( pIndex[0] == 0x1000 )
   24a48:	10840018 	cmpnei	r2,r2,4096
{
   24a4c:	ddc00a17 	ldw	r23,40(sp)
   24a50:	2025883a 	mov	r18,r4
   24a54:	2827883a 	mov	r19,r5
   24a58:	3023883a 	mov	r17,r6
   24a5c:	3829883a 	mov	r20,r7
   24a60:	202d883a 	mov	r22,r4
   24a64:	302b883a 	mov	r21,r6
    if ( pIndex[0] == 0x1000 )
   24a68:	10001c1e 	bne	r2,zero,24adc <OBJ_GetObjectList+0xc4>
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24a6c:	00208680 	call	20868 <COE_GetObjectDictionary>
   24a70:	1021883a 	mov	r16,r2
        if((pObjEntry == NULL) && (pAbort != NULL))
   24a74:	10001326 	beq	r2,zero,24ac4 <OBJ_GetObjectList+0xac>
        while (pObjEntry != NULL && size > 1 )
   24a78:	8c7fffcc 	andi	r17,r17,65535
   24a7c:	8c4000a8 	cmpgeui	r17,r17,2
   24a80:	8800191e 	bne	r17,zero,24ae8 <OBJ_GetObjectList+0xd0>
            pIndex[0] = pObjEntry->Index;
   24a84:	8080020b 	ldhu	r2,8(r16)
   24a88:	9880000d 	sth	r2,0(r19)
}
   24a8c:	a805883a 	mov	r2,r21
    pSdoInfoObjEntry = pObjEntry;
   24a90:	d4217615 	stw	r16,-31272(gp)
}
   24a94:	dfc00917 	ldw	ra,36(sp)
   24a98:	df000817 	ldw	fp,32(sp)
   24a9c:	ddc00717 	ldw	r23,28(sp)
   24aa0:	dd800617 	ldw	r22,24(sp)
   24aa4:	dd400517 	ldw	r21,20(sp)
   24aa8:	dd000417 	ldw	r20,16(sp)
   24aac:	dcc00317 	ldw	r19,12(sp)
   24ab0:	dc800217 	ldw	r18,8(sp)
   24ab4:	dc400117 	ldw	r17,4(sp)
   24ab8:	dc000017 	ldw	r16,0(sp)
   24abc:	dec00a04 	addi	sp,sp,40
   24ac0:	f800283a 	ret
        if((pObjEntry == NULL) && (pAbort != NULL))
   24ac4:	b8000226 	beq	r23,zero,24ad0 <OBJ_GetObjectList+0xb8>
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
   24ac8:	008006c4 	movi	r2,27
   24acc:	b8800005 	stb	r2,0(r23)
            pIndex[0] = 0xFFFF;
   24ad0:	00bfffc4 	movi	r2,-1
   24ad4:	0021883a 	mov	r16,zero
   24ad8:	003feb06 	br	24a88 <OBJ_GetObjectList+0x70>
        pObjEntry = pSdoInfoObjEntry;
   24adc:	d4217617 	ldw	r16,-31272(gp)
    if ( pObjEntry != NULL )
   24ae0:	803fe51e 	bne	r16,zero,24a78 <OBJ_GetObjectList+0x60>
   24ae4:	003ffa06 	br	24ad0 <OBJ_GetObjectList+0xb8>
    UINT16 listFlags = 0x0020 << listType;
   24ae8:	94bfffcc 	andi	r18,r18,65535
   24aec:	00800804 	movi	r2,32
   24af0:	14a4983a 	sll	r18,r2,r18
                if ( t )
   24af4:	b5bfffcc 	andi	r22,r22,65535
            if ( pObjEntry->Index >= 0x1000 )
   24af8:	85c0020b 	ldhu	r23,8(r16)
   24afc:	b8bfffcc 	andi	r2,r23,65535
   24b00:	10840030 	cmpltui	r2,r2,4096
   24b04:	10000c1e 	bne	r2,zero,24b38 <OBJ_GetObjectList+0x120>
                if ( t )
   24b08:	b0001126 	beq	r22,zero,24b50 <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   24b0c:	87000303 	ldbu	fp,12(r16)
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   24b10:	0023883a 	mov	r17,zero
                        if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
   24b14:	880b883a 	mov	r5,r17
   24b18:	8009883a 	mov	r4,r16
   24b1c:	00249240 	call	24924 <OBJ_GetEntryDesc>
   24b20:	1080010b 	ldhu	r2,4(r2)
   24b24:	1484703a 	and	r2,r2,r18
   24b28:	1000091e 	bne	r2,zero,24b50 <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   24b2c:	8c400044 	addi	r17,r17,1
   24b30:	88bfffcc 	andi	r2,r17,65535
   24b34:	e0bff72e 	bgeu	fp,r2,24b14 <OBJ_GetObjectList+0xfc>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24b38:	84000117 	ldw	r16,4(r16)
        while (pObjEntry != NULL && size > 1 )
   24b3c:	803fe426 	beq	r16,zero,24ad0 <OBJ_GetObjectList+0xb8>
   24b40:	a8bfffcc 	andi	r2,r21,65535
   24b44:	108000a8 	cmpgeui	r2,r2,2
   24b48:	103feb1e 	bne	r2,zero,24af8 <OBJ_GetObjectList+0xe0>
   24b4c:	003fcd06 	br	24a84 <OBJ_GetObjectList+0x6c>
                    *pData = SWAPWORD(pObjEntry->Index);
   24b50:	a5c0000d 	sth	r23,0(r20)
                    size -= 2;
   24b54:	ad7fff84 	addi	r21,r21,-2
                    pData++;
   24b58:	a5000084 	addi	r20,r20,2
                    size -= 2;
   24b5c:	003ff606 	br	24b38 <OBJ_GetObjectList+0x120>

00024b60 <OBJ_GetObjDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    return &pObjEntry->ObjDesc;
}
   24b60:	20800284 	addi	r2,r4,10
   24b64:	f800283a 	ret

00024b68 <OBJ_GetEntryOffset>:
UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    UINT16 i;
    /* bitOffset will be initialized with the bit offset of subindex 1 */
    UINT16 bitOffset = 0;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24b68:	28c0030b 	ldhu	r3,12(r5)
   24b6c:	1807d23a 	srai	r3,r3,8
   24b70:	18c003cc 	andi	r3,r3,15
   24b74:	1811883a 	mov	r8,r3
    {
        /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
        bitOffset +=16;
    }

    if (objCode == OBJCODE_VAR)
   24b78:	18c001e0 	cmpeqi	r3,r3,7
   24b7c:	1800531e 	bne	r3,zero,24ccc <OBJ_GetEntryOffset+0x164>
   24b80:	20803fcc 	andi	r2,r4,255
    {
        return 0;
    }

    for (i = 1; i <= subindex; i++)
   24b84:	02800044 	movi	r10,1
   24b88:	1004c03a 	cmpne	r2,r2,zero
    {
        /* get the entry description */
        if ((objCode == OBJCODE_ARR)
   24b8c:	42003fcc 	andi	r8,r8,255
        else
        {
            pEntry = &pObjEntry->pEntryDesc[i];
        }

        switch (pEntry->DataType)
   24b90:	02d00074 	movhi	r11,16385
   24b94:	03080034 	movhi	r12,8192
    for (i = 1; i <= subindex; i++)
   24b98:	21003fcc 	andi	r4,r4,255
   24b9c:	51bfffcc 	andi	r6,r10,65535
   24ba0:	1004913a 	slli	r2,r2,4
   24ba4:	02400184 	movi	r9,6
        if ((objCode == OBJCODE_ARR)
   24ba8:	42000218 	cmpnei	r8,r8,8
        case    DEFTYPE_ARRAY_OF_INT :

#if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
            /* the 16-bit variables in the structure are word-aligned,
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
   24bac:	03fffc04 	movi	r15,-16
        case    DEFTYPE_ARRAY_OF_DINT :
        case    DEFTYPE_ARRAY_OF_UDINT:
#if OBJ_DWORD_ALIGN
            /* the 32-bit variables in the structure are dword-aligned,
               align the actual bitOffset to a dword */
            bitOffset = (bitOffset+31) & 0xFFE0;
   24bb0:	037ff804 	movi	r13,-32
   24bb4:	03800044 	movi	r14,1
        switch (pEntry->DataType)
   24bb8:	5ae00004 	addi	r11,r11,-32768
   24bbc:	63100004 	addi	r12,r12,16384
    for (i = 1; i <= subindex; i++)
   24bc0:	2180462e 	bgeu	r4,r6,24cdc <OBJ_GetEntryOffset+0x174>
            break;
        }
    }

    return bitOffset;
}
   24bc4:	f800283a 	ret
            pEntry = &pObjEntry->pEntryDesc[i];
   24bc8:	3a4f883a 	add	r7,r7,r9
   24bcc:	00004906 	br	24cf4 <OBJ_GetEntryOffset+0x18c>
        switch (pEntry->DataType)
   24bd0:	18fffbc4 	addi	r3,r3,-17
   24bd4:	18ffffcc 	andi	r3,r3,65535
   24bd8:	70c6983a 	sll	r3,r14,r3
   24bdc:	1c01044c 	andi	r16,r3,1041
   24be0:	8000341e 	bne	r16,zero,24cb4 <OBJ_GetEntryOffset+0x14c>
   24be4:	1ae0703a 	and	r16,r3,r11
   24be8:	80002b1e 	bne	r16,zero,24c98 <OBJ_GetEntryOffset+0x130>
   24bec:	1b06703a 	and	r3,r3,r12
   24bf0:	18004a26 	beq	r3,zero,24d1c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24bf4:	108003c4 	addi	r2,r2,15
   24bf8:	00fffc04 	movi	r3,-16
   24bfc:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24c00:	31003436 	bltu	r6,r4,24cd4 <OBJ_GetEntryOffset+0x16c>
    for (i = 1; i <= subindex; i++)
   24c04:	52800044 	addi	r10,r10,1
   24c08:	51bfffcc 	andi	r6,r10,65535
   24c0c:	4a400184 	addi	r9,r9,6
   24c10:	2180352e 	bgeu	r4,r6,24ce8 <OBJ_GetEntryOffset+0x180>
}
   24c14:	dfc00117 	ldw	ra,4(sp)
   24c18:	dc000017 	ldw	r16,0(sp)
   24c1c:	dec00204 	addi	sp,sp,8
   24c20:	f800283a 	ret
   24c24:	77c6983a 	sll	r3,r14,ra
        switch (pEntry->DataType)
   24c28:	1c00640c 	andi	r16,r3,400
   24c2c:	80001a1e 	bne	r16,zero,24c98 <OBJ_GetEntryOffset+0x130>
   24c30:	18c2120c 	andi	r3,r3,2120
   24c34:	18003926 	beq	r3,zero,24d1c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24c38:	108003c4 	addi	r2,r2,15
   24c3c:	00fffc04 	movi	r3,-16
   24c40:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24c44:	313fef2e 	bgeu	r6,r4,24c04 <OBJ_GetEntryOffset+0x9c>
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
   24c48:	ffc002d8 	cmpnei	ra,ra,11
   24c4c:	f800211e 	bne	ra,zero,24cd4 <OBJ_GetEntryOffset+0x16c>
                bitOffset += pEntry->BitLength;
   24c50:	38c0008b 	ldhu	r3,2(r7)
   24c54:	00000b06 	br	24c84 <OBJ_GetEntryOffset+0x11c>
        switch (pEntry->DataType)
   24c58:	ffc09820 	cmpeqi	ra,ra,608
   24c5c:	f8000b1e 	bne	ra,zero,24c8c <OBJ_GetEntryOffset+0x124>
   24c60:	18ff6784 	addi	r3,r3,-610
   24c64:	18ffffcc 	andi	r3,r3,65535
   24c68:	18c000a8 	cmpgeui	r3,r3,2
   24c6c:	18002b1e 	bne	r3,zero,24d1c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24c70:	10c007c4 	addi	r3,r2,31
   24c74:	1b46703a 	and	r3,r3,r13
   24c78:	1805883a 	mov	r2,r3
            if (i < subindex)
   24c7c:	313fe12e 	bgeu	r6,r4,24c04 <OBJ_GetEntryOffset+0x9c>
                    bitOffset += pEntry->BitLength;
   24c80:	3880008b 	ldhu	r2,2(r7)
                bitOffset += pEntry->BitLength;
   24c84:	1885883a 	add	r2,r3,r2
   24c88:	003fde06 	br	24c04 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24c8c:	108003c4 	addi	r2,r2,15
   24c90:	13c4703a 	and	r2,r2,r15
            if (i < subindex)
   24c94:	00002106 	br	24d1c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24c98:	10c007c4 	addi	r3,r2,31
   24c9c:	00bff804 	movi	r2,-32
   24ca0:	1886703a 	and	r3,r3,r2
   24ca4:	1805883a 	mov	r2,r3
            if (i < subindex)
   24ca8:	313fd62e 	bgeu	r6,r4,24c04 <OBJ_GetEntryOffset+0x9c>
                   bitOffset += 32;
   24cac:	18800804 	addi	r2,r3,32
   24cb0:	003fd406 	br	24c04 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset + 31) & 0xFFE0;
   24cb4:	10c007c4 	addi	r3,r2,31
   24cb8:	1b46703a 	and	r3,r3,r13
   24cbc:	1805883a 	mov	r2,r3
            if (i < subindex)
   24cc0:	313fd02e 	bgeu	r6,r4,24c04 <OBJ_GetEntryOffset+0x9c>
                bitOffset += 64;
   24cc4:	18801004 	addi	r2,r3,64
   24cc8:	003fce06 	br	24c04 <OBJ_GetEntryOffset+0x9c>
        return 0;
   24ccc:	0005883a 	mov	r2,zero
   24cd0:	f800283a 	ret
                    bitOffset += 16;
   24cd4:	10800404 	addi	r2,r2,16
   24cd8:	003fca06 	br	24c04 <OBJ_GetEntryOffset+0x9c>
{
   24cdc:	defffe04 	addi	sp,sp,-8
   24ce0:	dfc00115 	stw	ra,4(sp)
   24ce4:	dc000015 	stw	r16,0(sp)
            pEntry = &pObjEntry->pEntryDesc[1];
   24ce8:	29c00417 	ldw	r7,16(r5)
        if ((objCode == OBJCODE_ARR)
   24cec:	403fb61e 	bne	r8,zero,24bc8 <OBJ_GetEntryOffset+0x60>
            pEntry = &pObjEntry->pEntryDesc[1];
   24cf0:	39c00184 	addi	r7,r7,6
        switch (pEntry->DataType)
   24cf4:	38c0000b 	ldhu	r3,0(r7)
   24cf8:	1fffffcc 	andi	ra,r3,65535
   24cfc:	fc000c28 	cmpgeui	r16,ra,48
   24d00:	803fd51e 	bne	r16,zero,24c58 <OBJ_GetEntryOffset+0xf0>
   24d04:	fc000468 	cmpgeui	r16,ra,17
   24d08:	803fb11e 	bne	r16,zero,24bd0 <OBJ_GetEntryOffset+0x68>
   24d0c:	18ffff44 	addi	r3,r3,-3
   24d10:	18ffffcc 	andi	r3,r3,65535
   24d14:	18c00268 	cmpgeui	r3,r3,9
   24d18:	183fc226 	beq	r3,zero,24c24 <OBJ_GetEntryOffset+0xbc>
            if (i < subindex)
   24d1c:	313fb92e 	bgeu	r6,r4,24c04 <OBJ_GetEntryOffset+0x9c>
   24d20:	003fcb06 	br	24c50 <OBJ_GetEntryOffset+0xe8>

00024d24 <CheckSyncTypeValue>:

 \brief    Checks if the new Sync type value is valid
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
{
    switch (NewSyncType)
   24d24:	297fffcc 	andi	r5,r5,65535
   24d28:	288000a0 	cmpeqi	r2,r5,2
   24d2c:	1000281e 	bne	r2,zero,24dd0 <CheckSyncTypeValue+0xac>
   24d30:	288000e8 	cmpgeui	r2,r5,3
   24d34:	1000031e 	bne	r2,zero,24d44 <CheckSyncTypeValue+0x20>
   24d38:	2800081e 	bne	r5,zero,24d5c <CheckSyncTypeValue+0x38>
    {
    case SYNCTYPE_FREERUN:
        return 0; //free run sync mode is always accepted
   24d3c:	0005883a 	mov	r2,zero
   24d40:	f800283a 	ret
    switch (NewSyncType)
   24d44:	288000e0 	cmpeqi	r2,r5,3
   24d48:	10002d1e 	bne	r2,zero,24e00 <CheckSyncTypeValue+0xdc>
   24d4c:	294008a0 	cmpeqi	r5,r5,34
   24d50:	2800161e 	bne	r5,zero,24dac <CheckSyncTypeValue+0x88>
        {
            return 0;
        }
        break;
    } //switch 
    return ABORTIDX_VALUE_EXCEEDED;
   24d54:	00800484 	movi	r2,18

}
   24d58:	f800283a 	ret
        if ((index == 0x1C32) 
   24d5c:	213fffcc 	andi	r4,r4,65535
   24d60:	20870c98 	cmpnei	r2,r4,7218
   24d64:	1000071e 	bne	r2,zero,24d84 <CheckSyncTypeValue+0x60>
            && (nPdOutputSize > 0) 
   24d68:	d0a1590b 	ldhu	r2,-31388(gp)
   24d6c:	103ff926 	beq	r2,zero,24d54 <CheckSyncTypeValue+0x30>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
   24d70:	008000f4 	movhi	r2,3
   24d74:	10a3380b 	ldhu	r2,-29472(r2)
   24d78:	1080008c 	andi	r2,r2,2
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24d7c:	103ff526 	beq	r2,zero,24d54 <CheckSyncTypeValue+0x30>
   24d80:	003fee06 	br	24d3c <CheckSyncTypeValue+0x18>
        if ((index == 0x1C33) 
   24d84:	21070cd8 	cmpnei	r4,r4,7219
   24d88:	203ff21e 	bne	r4,zero,24d54 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24d8c:	008000f4 	movhi	r2,3
   24d90:	10a3270b 	ldhu	r2,-29540(r2)
   24d94:	1080008c 	andi	r2,r2,2
   24d98:	103fee26 	beq	r2,zero,24d54 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize == 0) 
   24d9c:	d0a1590b 	ldhu	r2,-31388(gp)
   24da0:	103fec1e 	bne	r2,zero,24d54 <CheckSyncTypeValue+0x30>
            && (nPdInputSize > 0))
   24da4:	d0a1598b 	ldhu	r2,-31386(gp)
   24da8:	003ff406 	br	24d7c <CheckSyncTypeValue+0x58>
        if ((index == 0x1C33) 
   24dac:	213fffcc 	andi	r4,r4,65535
   24db0:	21070cd8 	cmpnei	r4,r4,7219
   24db4:	203fe71e 	bne	r4,zero,24d54 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24db8:	008000f4 	movhi	r2,3
   24dbc:	10a3270b 	ldhu	r2,-29540(r2)
   24dc0:	1080008c 	andi	r2,r2,2
   24dc4:	103fe326 	beq	r2,zero,24d54 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize > 0))
   24dc8:	d0a1590b 	ldhu	r2,-31388(gp)
   24dcc:	003feb06 	br	24d7c <CheckSyncTypeValue+0x58>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   24dd0:	213fffcc 	andi	r4,r4,65535
   24dd4:	20870c98 	cmpnei	r2,r4,7218
   24dd8:	1000041e 	bne	r2,zero,24dec <CheckSyncTypeValue+0xc8>
   24ddc:	008000f4 	movhi	r2,3
   24de0:	10a3380b 	ldhu	r2,-29472(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   24de4:	1080010c 	andi	r2,r2,4
   24de8:	003fe406 	br	24d7c <CheckSyncTypeValue+0x58>
   24dec:	21070cd8 	cmpnei	r4,r4,7219
   24df0:	203fd81e 	bne	r4,zero,24d54 <CheckSyncTypeValue+0x30>
   24df4:	008000f4 	movhi	r2,3
   24df8:	10a3270b 	ldhu	r2,-29540(r2)
   24dfc:	003ff906 	br	24de4 <CheckSyncTypeValue+0xc0>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24e00:	213fffcc 	andi	r4,r4,65535
   24e04:	20870c98 	cmpnei	r2,r4,7218
   24e08:	1000041e 	bne	r2,zero,24e1c <CheckSyncTypeValue+0xf8>
   24e0c:	008000f4 	movhi	r2,3
   24e10:	10a3380b 	ldhu	r2,-29472(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24e14:	1080020c 	andi	r2,r2,8
   24e18:	003fd806 	br	24d7c <CheckSyncTypeValue+0x58>
   24e1c:	21070cd8 	cmpnei	r4,r4,7219
   24e20:	203fcc1e 	bne	r4,zero,24d54 <CheckSyncTypeValue+0x30>
   24e24:	008000f4 	movhi	r2,3
   24e28:	10a3270b 	ldhu	r2,-29540(r2)
   24e2c:	003ff906 	br	24e14 <CheckSyncTypeValue+0xf0>

00024e30 <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
   24e30:	defff004 	addi	sp,sp,-64
   24e34:	dd400b15 	stw	r21,44(sp)
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e38:	3d40030b 	ldhu	r21,12(r7)
{
   24e3c:	df000e15 	stw	fp,56(sp)
   24e40:	ddc00d15 	stw	r23,52(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e44:	a804d23a 	srli	r2,r21,8
{
   24e48:	dd800c15 	stw	r22,48(sp)
   24e4c:	dd000a15 	stw	r20,40(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e50:	108003cc 	andi	r2,r2,15
{
   24e54:	dcc00915 	stw	r19,36(sp)
   24e58:	dc400715 	stw	r17,28(sp)
   24e5c:	dc000615 	stw	r16,24(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24e60:	102f883a 	mov	r23,r2
{
   24e64:	dfc00f15 	stw	ra,60(sp)
   24e68:	dc800815 	stw	r18,32(sp)
   24e6c:	d9800115 	stw	r6,4(sp)
   24e70:	d900008d 	sth	r4,2(sp)
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24e74:	108001e0 	cmpeqi	r2,r2,7
{
   24e78:	dd801017 	ldw	r22,64(sp)
   24e7c:	dcc01103 	ldbu	r19,68(sp)
   24e80:	2023883a 	mov	r17,r4
   24e84:	2839883a 	mov	fp,r5
   24e88:	3821883a 	mov	r16,r7
    UINT16 i = subindex;
   24e8c:	2d003fcc 	andi	r20,r5,255
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   24e90:	ad403fcc 	andi	r21,r21,255
    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24e94:	1000191e 	bne	r2,zero,24efc <OBJ_Read+0xcc>
   24e98:	20bfffcc 	andi	r2,r4,65535
   24e9c:	10840030 	cmpltui	r2,r2,4096
   24ea0:	1000161e 	bne	r2,zero,24efc <OBJ_Read+0xcc>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
   24ea4:	38800617 	ldw	r2,24(r7)
   24ea8:	14800003 	ldbu	r18,0(r2)
   24eac:	902b883a 	mov	r21,r18

    }

    if ( bCompleteAccess )
   24eb0:	9800211e 	bne	r19,zero,24f38 <OBJ_Read+0x108>

        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
    }
    else
        if ( subindex > maxSubindex )
   24eb4:	a0bfffcc 	andi	r2,r20,65535
   24eb8:	a93fffcc 	andi	r4,r21,65535
   24ebc:	20815c36 	bltu	r4,r2,25430 <OBJ_Read+0x600>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   24ec0:	8009883a 	mov	r4,r16
   24ec4:	e1403fcc 	andi	r5,fp,255
   24ec8:	00249240 	call	24924 <OBJ_GetEntryDesc>

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
   24ecc:	1100010b 	ldhu	r4,4(r2)
   24ed0:	20bfffcc 	andi	r2,r4,65535
   24ed4:	10000a26 	beq	r2,zero,24f00 <OBJ_Read+0xd0>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
   24ed8:	2004907a 	slli	r2,r4,1
   24edc:	d16157c3 	ldbu	r5,-31393(gp)
   24ee0:	1144703a 	and	r2,r2,r5
   24ee4:	1080038c 	andi	r2,r2,14
   24ee8:	1000191e 	bne	r2,zero,24f50 <OBJ_Read+0x120>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   24eec:	210001cc 	andi	r4,r4,7
   24ef0:	2001511e 	bne	r4,zero,25438 <OBJ_Read+0x608>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
   24ef4:	07000184 	movi	fp,6
   24ef8:	00000206 	br	24f04 <OBJ_Read+0xd4>
    if ( bCompleteAccess )
   24efc:	983fed26 	beq	r19,zero,24eb4 <OBJ_Read+0x84>
            return ABORTIDX_UNSUPPORTED_ACCESS;
   24f00:	07000144 	movi	fp,5
                return result;
            }
        }

    return 0;
}
   24f04:	e005883a 	mov	r2,fp
   24f08:	dfc00f17 	ldw	ra,60(sp)
   24f0c:	df000e17 	ldw	fp,56(sp)
   24f10:	ddc00d17 	ldw	r23,52(sp)
   24f14:	dd800c17 	ldw	r22,48(sp)
   24f18:	dd400b17 	ldw	r21,44(sp)
   24f1c:	dd000a17 	ldw	r20,40(sp)
   24f20:	dcc00917 	ldw	r19,36(sp)
   24f24:	dc800817 	ldw	r18,32(sp)
   24f28:	dc400717 	ldw	r17,28(sp)
   24f2c:	dc000617 	ldw	r16,24(sp)
   24f30:	dec01004 	addi	sp,sp,64
   24f34:	f800283a 	ret
        if (pAPPL_CoeReadInd != NULL)
   24f38:	d0a14417 	ldw	r2,-31472(gp)
   24f3c:	1000071e 	bne	r2,zero,24f5c <OBJ_Read+0x12c>
        if ( pObjEntry->Read != NULL )
   24f40:	38800717 	ldw	r2,28(r7)
   24f44:	10000b1e 	bne	r2,zero,24f74 <OBJ_Read+0x144>
    UINT16 i = subindex;
   24f48:	a023883a 	mov	r17,r20
   24f4c:	00002006 	br	24fd0 <OBJ_Read+0x1a0>
        if (pAPPL_CoeReadInd != NULL)
   24f50:	d0a14417 	ldw	r2,-31472(gp)
    UINT16 lastSubindex = subindex;
   24f54:	a025883a 	mov	r18,r20
        if (pAPPL_CoeReadInd != NULL)
   24f58:	10000426 	beq	r2,zero,24f6c <OBJ_Read+0x13c>
            pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
   24f5c:	980d883a 	mov	r6,r19
   24f60:	e1403fcc 	andi	r5,fp,255
   24f64:	893fffcc 	andi	r4,r17,65535
   24f68:	103ee83a 	callr	r2
        if ( pObjEntry->Read != NULL )
   24f6c:	80800717 	ldw	r2,28(r16)
   24f70:	10001126 	beq	r2,zero,24fb8 <OBJ_Read+0x188>
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24f74:	d9800117 	ldw	r6,4(sp)
   24f78:	b00f883a 	mov	r7,r22
   24f7c:	e1403fcc 	andi	r5,fp,255
   24f80:	893fffcc 	andi	r4,r17,65535
   24f84:	dcc01015 	stw	r19,64(sp)
}
   24f88:	dfc00f17 	ldw	ra,60(sp)
   24f8c:	df000e17 	ldw	fp,56(sp)
   24f90:	ddc00d17 	ldw	r23,52(sp)
   24f94:	dd800c17 	ldw	r22,48(sp)
   24f98:	dd400b17 	ldw	r21,44(sp)
   24f9c:	dd000a17 	ldw	r20,40(sp)
   24fa0:	dcc00917 	ldw	r19,36(sp)
   24fa4:	dc800817 	ldw	r18,32(sp)
   24fa8:	dc400717 	ldw	r17,28(sp)
   24fac:	dc000617 	ldw	r16,24(sp)
   24fb0:	dec01004 	addi	sp,sp,64
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24fb4:	1000683a 	jmp	r2
        else if ( index < 0x1000 && subindex != 0 )
   24fb8:	88ffffcc 	andi	r3,r17,65535
   24fbc:	18c40028 	cmpgeui	r3,r3,4096
   24fc0:	183fe11e 	bne	r3,zero,24f48 <OBJ_Read+0x118>
   24fc4:	e7003fcc 	andi	fp,fp,255
   24fc8:	e000111e 	bne	fp,zero,25010 <OBJ_Read+0x1e0>
            for (i = subindex; i <= lastSubindex; i++)
   24fcc:	0023883a 	mov	r17,zero
                else if ( index >= 0x1000 )
   24fd0:	d880008b 	ldhu	r2,2(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24fd4:	bdc03fcc 	andi	r23,r23,255
   24fd8:	8c7fffcc 	andi	r17,r17,65535
                else if ( index >= 0x1000 )
   24fdc:	10840030 	cmpltui	r2,r2,4096
   24fe0:	d8800215 	stw	r2,8(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24fe4:	b88001e0 	cmpeqi	r2,r23,7
                            bRead = 1;
   24fe8:	0039883a 	mov	fp,zero
   24fec:	000d883a 	mov	r6,zero
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24ff0:	d8800315 	stw	r2,12(sp)
            for (i = subindex; i <= lastSubindex; i++)
   24ff4:	dc40008d 	sth	r17,2(sp)
   24ff8:	88bfffcc 	andi	r2,r17,65535
   24ffc:	90ffffcc 	andi	r3,r18,65535
   25000:	1880392e 	bgeu	r3,r2,250e8 <OBJ_Read+0x2b8>
            if(bRead == 0)
   25004:	30803fcc 	andi	r2,r6,255
   25008:	1000221e 	bne	r2,zero,25094 <OBJ_Read+0x264>
   2500c:	003fbd06 	br	24f04 <OBJ_Read+0xd4>
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   25010:	e00b883a 	mov	r5,fp
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   25014:	84400617 	ldw	r17,24(r16)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   25018:	e03890ba 	slli	fp,fp,2
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   2501c:	8009883a 	mov	r4,r16
   25020:	00249240 	call	24924 <OBJ_GetEntryDesc>
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   25024:	8f23883a 	add	r17,r17,fp
            size = BIT2BYTE(pEntry->BitLength);
   25028:	1180008b 	ldhu	r6,2(r2)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   2502c:	897fff17 	ldw	r5,-4(r17)
            size = BIT2BYTE(pEntry->BitLength);
   25030:	318001c4 	addi	r6,r6,7
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   25034:	2880004c 	andi	r2,r5,1
            size = BIT2BYTE(pEntry->BitLength);
   25038:	300dd0fa 	srai	r6,r6,3
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   2503c:	10002126 	beq	r2,zero,250c4 <OBJ_Read+0x294>
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   25040:	00bfff84 	movi	r2,-2
                for(cnt = 0; cnt < (size / 2);cnt++)
   25044:	3006d07a 	srli	r3,r6,1
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   25048:	288a703a 	and	r5,r5,r2
                for(cnt = 0; cnt < (size / 2);cnt++)
   2504c:	b009883a 	mov	r4,r22
   25050:	0011883a 	mov	r8,zero
   25054:	2d95c83a 	sub	r10,r5,r22
   25058:	40bfffcc 	andi	r2,r8,65535
   2505c:	2293883a 	add	r9,r4,r10
   25060:	18800e1e 	bne	r3,r2,2509c <OBJ_Read+0x26c>
                if((size % 2) == 1)
   25064:	3180004c 	andi	r6,r6,1
   25068:	30000a26 	beq	r6,zero,25094 <OBJ_Read+0x264>
   2506c:	1806907a 	slli	r3,r3,1
   25070:	b0cf883a 	add	r7,r22,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   25074:	3880000b 	ldhu	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   25078:	28cb883a 	add	r5,r5,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   2507c:	10bfc00c 	andi	r2,r2,65280
   25080:	3880000d 	sth	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   25084:	28c0000b 	ldhu	r3,0(r5)
   25088:	1806d23a 	srli	r3,r3,8
   2508c:	10c4b03a 	or	r2,r2,r3
   25090:	3880000d 	sth	r2,0(r7)
    return 0;
   25094:	0039883a 	mov	fp,zero
   25098:	003f9a06 	br	24f04 <OBJ_Read+0xd4>
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   2509c:	4880000b 	ldhu	r2,0(r9)
                    pData++;
   250a0:	21000084 	addi	r4,r4,2
                for(cnt = 0; cnt < (size / 2);cnt++)
   250a4:	42000044 	addi	r8,r8,1
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   250a8:	1004d23a 	srli	r2,r2,8
   250ac:	20bfff8d 	sth	r2,-2(r4)
                    pData[0] |= (pVarPtr[1] & 0xFF) << 8;
   250b0:	4a40008b 	ldhu	r9,2(r9)
   250b4:	4812923a 	slli	r9,r9,8
   250b8:	1244b03a 	or	r2,r2,r9
   250bc:	20bfff8d 	sth	r2,-2(r4)
                for(cnt = 0; cnt < (size / 2);cnt++)
   250c0:	003fe506 	br	25058 <OBJ_Read+0x228>
            pData[0] = pVarPtr[0];
   250c4:	2880000b 	ldhu	r2,0(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   250c8:	31bfff04 	addi	r6,r6,-4
   250cc:	29400104 	addi	r5,r5,4
            pData[0] = pVarPtr[0];
   250d0:	b080000d 	sth	r2,0(r22)
            pData[1] = pVarPtr[1];
   250d4:	28bfff8b 	ldhu	r2,-2(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   250d8:	b1000104 	addi	r4,r22,4
            pData[1] = pVarPtr[1];
   250dc:	b080008d 	sth	r2,2(r22)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   250e0:	002735c0 	call	2735c <memcpy>
   250e4:	003feb06 	br	25094 <OBJ_Read+0x264>
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   250e8:	80c00617 	ldw	r3,24(r16)
   250ec:	d8c00115 	stw	r3,4(sp)
                if (i == 0)
   250f0:	10002226 	beq	r2,zero,2517c <OBJ_Read+0x34c>
                else if ( index >= 0x1000 )
   250f4:	d8800217 	ldw	r2,8(sp)
   250f8:	1000221e 	bne	r2,zero,25184 <OBJ_Read+0x354>
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   250fc:	800b883a 	mov	r5,r16
   25100:	8809883a 	mov	r4,r17
   25104:	d9800415 	stw	r6,16(sp)
   25108:	0024b680 	call	24b68 <OBJ_GetEntryOffset>
   2510c:	d9800417 	ldw	r6,16(sp)
   25110:	1007883a 	mov	r3,r2
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   25114:	8009883a 	mov	r4,r16
   25118:	880b883a 	mov	r5,r17
   2511c:	d8c00515 	stw	r3,20(sp)
   25120:	d9800415 	stw	r6,16(sp)
   25124:	00249240 	call	24924 <OBJ_GetEntryDesc>
   25128:	102f883a 	mov	r23,r2
                if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
   2512c:	10800103 	ldbu	r2,4(r2)
   25130:	d12157c3 	ldbu	r4,-31393(gp)
   25134:	d9800417 	ldw	r6,16(sp)
   25138:	1004907a 	slli	r2,r2,1
   2513c:	d8c00517 	ldw	r3,20(sp)
   25140:	1104703a 	and	r2,r2,r4
   25144:	1080038c 	andi	r2,r2,14
   25148:	10009e26 	beq	r2,zero,253c4 <OBJ_Read+0x594>
                    if ( i == subindex                                     /* requested entry */
   2514c:	d880008b 	ldhu	r2,2(sp)
   25150:	a13fffcc 	andi	r4,r20,65535
   25154:	11000226 	beq	r2,r4,25160 <OBJ_Read+0x330>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25158:	98000626 	beq	r19,zero,25174 <OBJ_Read+0x344>
   2515c:	11000536 	bltu	r2,r4,25174 <OBJ_Read+0x344>
                        if ( i == 0 && objCode != OBJCODE_VAR )
   25160:	10000a1e 	bne	r2,zero,2518c <OBJ_Read+0x35c>
   25164:	d8800317 	ldw	r2,12(sp)
   25168:	1000081e 	bne	r2,zero,2518c <OBJ_Read+0x35c>
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
   2516c:	b540000d 	sth	r21,0(r22)
                            pData++;
   25170:	b5800084 	addi	r22,r22,2
            for (i = subindex; i <= lastSubindex; i++)
   25174:	8c400044 	addi	r17,r17,1
   25178:	003f9e06 	br	24ff4 <OBJ_Read+0x1c4>
                UINT16 bitOffset = 0;
   2517c:	8807883a 	mov	r3,r17
   25180:	003fe406 	br	25114 <OBJ_Read+0x2e4>
   25184:	0007883a 	mov	r3,zero
   25188:	003fe206 	br	25114 <OBJ_Read+0x2e4>
                pVarPtr += (bitOffset >> 4);
   2518c:	180ad0fa 	srli	r5,r3,3
   25190:	d8800117 	ldw	r2,4(sp)
                            UINT16 dataType = pEntry->DataType;
   25194:	b900000b 	ldhu	r4,0(r23)
                pVarPtr += (bitOffset >> 4);
   25198:	2947ff8c 	andi	r5,r5,8190
   2519c:	114b883a 	add	r5,r2,r5
                            if (pEntry->DataType >= 0x700)
   251a0:	20bfffcc 	andi	r2,r4,65535
   251a4:	1181c030 	cmpltui	r6,r2,1792
   251a8:	3000201e 	bne	r6,zero,2522c <OBJ_Read+0x3fc>
                                if ( pEntry->BitLength <= 8 )
   251ac:	b900008b 	ldhu	r4,2(r23)
   251b0:	20bfffcc 	andi	r2,r4,65535
   251b4:	11800268 	cmpgeui	r6,r2,9
   251b8:	3000161e 	bne	r6,zero,25214 <OBJ_Read+0x3e4>
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   251bc:	21000bc4 	addi	r4,r4,47
                            switch (dataType)
   251c0:	213ff884 	addi	r4,r4,-30
   251c4:	213fffcc 	andi	r4,r4,65535
   251c8:	00800044 	movi	r2,1
   251cc:	1104983a 	sll	r2,r2,r4
   251d0:	0100ff74 	movhi	r4,1021
   251d4:	21200044 	addi	r4,r4,-32767
   251d8:	1108703a 	and	r4,r2,r4
   251dc:	2000591e 	bne	r4,zero,25344 <OBJ_Read+0x514>
   251e0:	010000b4 	movhi	r4,2
   251e4:	21000104 	addi	r4,r4,4
   251e8:	1108703a 	and	r4,r2,r4
   251ec:	20006d1e 	bne	r4,zero,253a4 <OBJ_Read+0x574>
   251f0:	01000074 	movhi	r4,1
   251f4:	21000084 	addi	r4,r4,2
   251f8:	1104703a 	and	r2,r2,r4
   251fc:	10000926 	beq	r2,zero,25224 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   25200:	18c003cc 	andi	r3,r3,15
   25204:	183f3e1e 	bne	r3,zero,24f00 <OBJ_Read+0xd0>
                                pData[0] = SWAPWORD(pVarPtr[0]);
   25208:	2880000b 	ldhu	r2,0(r5)
   2520c:	b080000d 	sth	r2,0(r22)
   25210:	00005f06 	br	25390 <OBJ_Read+0x560>
                                else if ( pEntry->BitLength == 16 )
   25214:	11000420 	cmpeqi	r4,r2,16
   25218:	203ff91e 	bne	r4,zero,25200 <OBJ_Read+0x3d0>
                                else if ( pEntry->BitLength == 32 )
   2521c:	10800820 	cmpeqi	r2,r2,32
   25220:	1000601e 	bne	r2,zero,253a4 <OBJ_Read+0x574>
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25224:	07000604 	movi	fp,24
   25228:	003f3606 	br	24f04 <OBJ_Read+0xd4>
                            switch (dataType)
   2522c:	11800328 	cmpgeui	r6,r2,12
   25230:	30000d1e 	bne	r6,zero,25268 <OBJ_Read+0x438>
   25234:	110002a8 	cmpgeui	r4,r2,10
   25238:	2000241e 	bne	r4,zero,252cc <OBJ_Read+0x49c>
   2523c:	11000260 	cmpeqi	r4,r2,9
   25240:	2000221e 	bne	r4,zero,252cc <OBJ_Read+0x49c>
   25244:	10003126 	beq	r2,zero,2530c <OBJ_Read+0x4dc>
   25248:	01000044 	movi	r4,1
   2524c:	2084983a 	sll	r2,r4,r2
   25250:	1100640c 	andi	r4,r2,400
   25254:	2000531e 	bne	r4,zero,253a4 <OBJ_Read+0x574>
   25258:	1100098c 	andi	r4,r2,38
   2525c:	2000391e 	bne	r4,zero,25344 <OBJ_Read+0x514>
   25260:	1080120c 	andi	r2,r2,72
   25264:	003fe506 	br	251fc <OBJ_Read+0x3cc>
   25268:	11800e28 	cmpgeui	r6,r2,56
   2526c:	3000131e 	bne	r6,zero,252bc <OBJ_Read+0x48c>
   25270:	118007a8 	cmpgeui	r6,r2,30
   25274:	303fd21e 	bne	r6,zero,251c0 <OBJ_Read+0x390>
   25278:	213ffecc 	andi	r4,r4,65531
   2527c:	21000460 	cmpeqi	r4,r4,17
   25280:	2000021e 	bne	r4,zero,2528c <OBJ_Read+0x45c>
   25284:	108006e0 	cmpeqi	r2,r2,27
   25288:	103fe626 	beq	r2,zero,25224 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   2528c:	18c003cc 	andi	r3,r3,15
   25290:	183f1b1e 	bne	r3,zero,24f00 <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   25294:	2880000b 	ldhu	r2,0(r5)
                                pData += 4;
   25298:	b5800204 	addi	r22,r22,8
                                pData[0] = pVarPtr[0];
   2529c:	b0bffe0d 	sth	r2,-8(r22)
                                pData[1] = pVarPtr[1];
   252a0:	2880008b 	ldhu	r2,2(r5)
   252a4:	b0bffe8d 	sth	r2,-6(r22)
                                pData[2] = pVarPtr[2];
   252a8:	2880010b 	ldhu	r2,4(r5)
   252ac:	b0bfff0d 	sth	r2,-4(r22)
                                pData[3] = pVarPtr[3];
   252b0:	2880018b 	ldhu	r2,6(r5)
   252b4:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   252b8:	00002006 	br	2533c <OBJ_Read+0x50c>
                            switch (dataType)
   252bc:	213f6804 	addi	r4,r4,-608
   252c0:	213fffcc 	andi	r4,r4,65535
   252c4:	21000128 	cmpgeui	r4,r4,4
   252c8:	203fd61e 	bne	r4,zero,25224 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   252cc:	18c003cc 	andi	r3,r3,15
   252d0:	183f0b1e 	bne	r3,zero,24f00 <OBJ_Read+0xd0>
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
   252d4:	b980008b 	ldhu	r6,2(r23)
   252d8:	b009883a 	mov	r4,r22
   252dc:	318001c4 	addi	r6,r6,7
   252e0:	300cd0fa 	srli	r6,r6,3
   252e4:	002735c0 	call	2735c <memcpy>
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   252e8:	b880008b 	ldhu	r2,2(r23)
   252ec:	10fffc0c 	andi	r3,r2,65520
   252f0:	1806d0fa 	srli	r3,r3,3
                                if((pEntry->BitLength & 0xF) != 0)
   252f4:	108003cc 	andi	r2,r2,15
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   252f8:	b0ed883a 	add	r22,r22,r3
                                if((pEntry->BitLength & 0xF) != 0)
   252fc:	10000f26 	beq	r2,zero,2533c <OBJ_Read+0x50c>
                                    *pData &= 0xFF;
   25300:	b0800003 	ldbu	r2,0(r22)
   25304:	b080000d 	sth	r2,0(r22)
   25308:	00000c06 	br	2533c <OBJ_Read+0x50c>
                                if(bCompleteAccess)
   2530c:	983fc526 	beq	r19,zero,25224 <OBJ_Read+0x3f4>
                                    if (((pEntry->BitLength & 0xF) > 0)
   25310:	b880008b 	ldhu	r2,2(r23)
   25314:	114003cc 	andi	r5,r2,15
   25318:	113fffcc 	andi	r4,r2,65535
   2531c:	28000426 	beq	r5,zero,25330 <OBJ_Read+0x500>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25320:	10c5883a 	add	r2,r2,r3
   25324:	108003cc 	andi	r2,r2,15
   25328:	1000011e 	bne	r2,zero,25330 <OBJ_Read+0x500>
                                        pData++;
   2532c:	b5800084 	addi	r22,r22,2
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
   25330:	2004d0fa 	srli	r2,r4,3
   25334:	1080078c 	andi	r2,r2,30
   25338:	b0ad883a 	add	r22,r22,r2
                            bRead = 1;
   2533c:	01800044 	movi	r6,1
   25340:	003f8c06 	br	25174 <OBJ_Read+0x344>
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25344:	b900008b 	ldhu	r4,2(r23)
   25348:	008000b4 	movhi	r2,2
   2534c:	198003cc 	andi	r6,r3,15
   25350:	2008907a 	slli	r4,r4,1
                                    TmpValue = SWAPWORD(pVarPtr[0]);
   25354:	2940000b 	ldhu	r5,0(r5)
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25358:	2085883a 	add	r2,r4,r2
   2535c:	109fd00b 	ldhu	r2,32576(r2)
   25360:	1184983a 	sll	r2,r2,r6
                                    if ((bitOffset & 0x0F) == 0) 
   25364:	3000011e 	bne	r6,zero,2536c <OBJ_Read+0x53c>
                                        pData[0] = 0;
   25368:	b000000d 	sth	zero,0(r22)
                                    pData[0] = SWAPWORD(pData[0]);
   2536c:	b100000b 	ldhu	r4,0(r22)
                                        pData[0] |= TmpValue & bitMask;
   25370:	1144703a 	and	r2,r2,r5
                                    if (bCompleteAccess) 
   25374:	98000826 	beq	r19,zero,25398 <OBJ_Read+0x568>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   25378:	1104b03a 	or	r2,r2,r4
                                        pData[0] |= TmpValue & bitMask;
   2537c:	b080000d 	sth	r2,0(r22)
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
   25380:	b880008b 	ldhu	r2,2(r23)
   25384:	10c5883a 	add	r2,r2,r3
   25388:	108003cc 	andi	r2,r2,15
   2538c:	103feb1e 	bne	r2,zero,2533c <OBJ_Read+0x50c>
                                pData++;
   25390:	b5800084 	addi	r22,r22,2
                                break;
   25394:	003fe906 	br	2533c <OBJ_Read+0x50c>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   25398:	10bfffcc 	andi	r2,r2,65535
   2539c:	1185d83a 	sra	r2,r2,r6
   253a0:	003ff506 	br	25378 <OBJ_Read+0x548>
                                if(bitOffset & 0xF)
   253a4:	18c003cc 	andi	r3,r3,15
   253a8:	183ed51e 	bne	r3,zero,24f00 <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   253ac:	2880000b 	ldhu	r2,0(r5)
                                pData += 2;
   253b0:	b5800104 	addi	r22,r22,4
                                pData[0] = pVarPtr[0];
   253b4:	b0bfff0d 	sth	r2,-4(r22)
                                pData[1] = pVarPtr[1];
   253b8:	2880008b 	ldhu	r2,2(r5)
   253bc:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   253c0:	003fde06 	br	2533c <OBJ_Read+0x50c>
                    if ((bitOffset & 0x0F) == 0) 
   253c4:	188003cc 	andi	r2,r3,15
   253c8:	1000011e 	bne	r2,zero,253d0 <OBJ_Read+0x5a0>
                        *pData = 0;
   253cc:	b000000d 	sth	zero,0(r22)
                    if (((pEntry->BitLength & 0xF) > 0)
   253d0:	b880008b 	ldhu	r2,2(r23)
   253d4:	110003cc 	andi	r4,r2,15
   253d8:	20000526 	beq	r4,zero,253f0 <OBJ_Read+0x5c0>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   253dc:	10c5883a 	add	r2,r2,r3
   253e0:	108003cc 	andi	r2,r2,15
   253e4:	1000021e 	bne	r2,zero,253f0 <OBJ_Read+0x5c0>
                        *pData = 0;
   253e8:	b000008d 	sth	zero,2(r22)
                        pData++;
   253ec:	b5800084 	addi	r22,r22,2
   253f0:	0007883a 	mov	r3,zero
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   253f4:	b880008b 	ldhu	r2,2(r23)
   253f8:	1005d13a 	srai	r2,r2,4
   253fc:	108003cc 	andi	r2,r2,15
   25400:	18800516 	blt	r3,r2,25418 <OBJ_Read+0x5e8>
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   25404:	b880010b 	ldhu	r2,4(r23)
   25408:	108001cc 	andi	r2,r2,7
   2540c:	1000061e 	bne	r2,zero,25428 <OBJ_Read+0x5f8>
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
   25410:	07000184 	movi	fp,6
   25414:	003f5706 	br	25174 <OBJ_Read+0x344>
                        pData++;
   25418:	b5800084 	addi	r22,r22,2
                        *pData = 0;
   2541c:	18c00044 	addi	r3,r3,1
   25420:	b000000d 	sth	zero,0(r22)
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   25424:	003ff306 	br	253f4 <OBJ_Read+0x5c4>
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25428:	07000684 	movi	fp,26
   2542c:	003f5106 	br	25174 <OBJ_Read+0x344>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25430:	07000444 	movi	fp,17
   25434:	003eb306 	br	24f04 <OBJ_Read+0xd4>
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25438:	07000684 	movi	fp,26
   2543c:	003eb106 	br	24f04 <OBJ_Read+0xd4>

00025440 <OBJ_Write>:

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   25440:	3880030b 	ldhu	r2,12(r7)
{
   25444:	deffec04 	addi	sp,sp,-80
   25448:	ddc01115 	stw	r23,68(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2544c:	1006d23a 	srli	r3,r2,8
    UINT16 maxSubindex = 0;
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   25450:	10803fcc 	andi	r2,r2,255
{
   25454:	dd801015 	stw	r22,64(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   25458:	18c003cc 	andi	r3,r3,15
{
   2545c:	dd400f15 	stw	r21,60(sp)
   25460:	dd000e15 	stw	r20,56(sp)
   25464:	dc800c15 	stw	r18,48(sp)
   25468:	dc000a15 	stw	r16,40(sp)
   2546c:	3825883a 	mov	r18,r7
   25470:	dfc01315 	stw	ra,76(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   25474:	180f883a 	mov	r7,r3
{
   25478:	df001215 	stw	fp,72(sp)
   2547c:	dcc00d15 	stw	r19,52(sp)
   25480:	dc400b15 	stw	r17,44(sp)
   25484:	d900010d 	sth	r4,4(sp)
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   25488:	d880038d 	sth	r2,14(sp)
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
   2548c:	18c001d8 	cmpnei	r3,r3,7
{
   25490:	dc001417 	ldw	r16,80(sp)
   25494:	dd001503 	ldbu	r20,84(sp)
   25498:	202f883a 	mov	r23,r4
   2549c:	282d883a 	mov	r22,r5
   254a0:	302b883a 	mov	r21,r6
    UINT16 i = subindex;
   254a4:	2a003fcc 	andi	r8,r5,255
    if ( objCode != OBJCODE_VAR )
   254a8:	1800271e 	bne	r3,zero,25548 <OBJ_Write+0x108>
            maxSubindex = maxConfiguredSubindex;
        }
    }


    if ( bCompleteAccess )
   254ac:	a0007e26 	beq	r20,zero,256a8 <OBJ_Write+0x268>
    {
        if ( objCode == OBJCODE_VAR )
        {
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
   254b0:	07000144 	movi	fp,5
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
    }
    /* ECATCHANGE_END(V5.13) COE4*/

    return 0;
}
   254b4:	e005883a 	mov	r2,fp
   254b8:	dfc01317 	ldw	ra,76(sp)
   254bc:	df001217 	ldw	fp,72(sp)
   254c0:	ddc01117 	ldw	r23,68(sp)
   254c4:	dd801017 	ldw	r22,64(sp)
   254c8:	dd400f17 	ldw	r21,60(sp)
   254cc:	dd000e17 	ldw	r20,56(sp)
   254d0:	dcc00d17 	ldw	r19,52(sp)
   254d4:	dc800c17 	ldw	r18,48(sp)
   254d8:	dc400b17 	ldw	r17,44(sp)
   254dc:	dc000a17 	ldw	r16,40(sp)
   254e0:	dec01404 	addi	sp,sp,80
   254e4:	f800283a 	ret
    if ( bCompleteAccess )
   254e8:	a001a21e 	bne	r20,zero,25b74 <OBJ_Write+0x734>
   254ec:	d9c00415 	stw	r7,16(sp)
    if (subindex > maxSubindex)
   254f0:	40bfffcc 	andi	r2,r8,65535
   254f4:	da000215 	stw	r8,8(sp)
   254f8:	8c7fffcc 	andi	r17,r17,65535
   254fc:	88819536 	bltu	r17,r2,25b54 <OBJ_Write+0x714>
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   25500:	b4403fcc 	andi	r17,r22,255
   25504:	880b883a 	mov	r5,r17
   25508:	9009883a 	mov	r4,r18
   2550c:	00249240 	call	24924 <OBJ_GetEntryDesc>
        if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25510:	10c0010b 	ldhu	r3,4(r2)
   25514:	d16157c3 	ldbu	r5,-31393(gp)
   25518:	da000217 	ldw	r8,8(sp)
   2551c:	193fffcc 	andi	r4,r3,65535
   25520:	2005d0ba 	srai	r2,r4,2
   25524:	d9c00417 	ldw	r7,16(sp)
   25528:	1144703a 	and	r2,r2,r5
   2552c:	1080038c 	andi	r2,r2,14
   25530:	1000611e 	bne	r2,zero,256b8 <OBJ_Write+0x278>
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
   25534:	18c00e0c 	andi	r3,r3,56
   25538:	1801881e 	bne	r3,zero,25b5c <OBJ_Write+0x71c>
                if (pEntry->ObjAccess == 0)
   2553c:	203fdc26 	beq	r4,zero,254b0 <OBJ_Write+0x70>
                        return ABORTIDX_READ_ONLY_ENTRY;
   25540:	070001c4 	movi	fp,7
   25544:	003fdb06 	br	254b4 <OBJ_Write+0x74>
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   25548:	90c00617 	ldw	r3,24(r18)
   2554c:	18c00003 	ldbu	r3,0(r3)
   25550:	1823883a 	mov	r17,r3
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   25554:	1800331e 	bne	r3,zero,25624 <OBJ_Write+0x1e4>
   25558:	20f8fc04 	addi	r3,r4,-7184
   2555c:	18ffffcc 	andi	r3,r3,65535
   25560:	18c00830 	cmpltui	r3,r3,32
   25564:	1800081e 	bne	r3,zero,25588 <OBJ_Write+0x148>
   25568:	20fa8004 	addi	r3,r4,-5632
   2556c:	18ffffcc 	andi	r3,r3,65535
   25570:	18c08030 	cmpltui	r3,r3,512
   25574:	1800041e 	bne	r3,zero,25588 <OBJ_Write+0x148>
   25578:	20f98004 	addi	r3,r4,-6656
   2557c:	18ffffcc 	andi	r3,r3,65535
   25580:	18c08028 	cmpgeui	r3,r3,512
   25584:	18001b1e 	bne	r3,zero,255f4 <OBJ_Write+0x1b4>
    if ( bCompleteAccess )
   25588:	a0004926 	beq	r20,zero,256b0 <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   2558c:	b0c03fcc 	andi	r3,r22,255
   25590:	18002726 	beq	r3,zero,25630 <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   25594:	1023883a 	mov	r17,r2
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
   25598:	90800617 	ldw	r2,24(r18)
        if(Subindex0 != 0x00)
   2559c:	14c00003 	ldbu	r19,0(r2)
   255a0:	9826c03a 	cmpne	r19,r19,zero
    if ( pObjEntry->Write != NULL )
   255a4:	90800817 	ldw	r2,32(r18)
   255a8:	10005526 	beq	r2,zero,25700 <OBJ_Write+0x2c0>
        result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
   255ac:	bdffffcc 	andi	r23,r23,65535
   255b0:	b5803fcc 	andi	r22,r22,255
   255b4:	dd000015 	stw	r20,0(sp)
   255b8:	800f883a 	mov	r7,r16
   255bc:	a80d883a 	mov	r6,r21
   255c0:	b00b883a 	mov	r5,r22
   255c4:	b809883a 	mov	r4,r23
   255c8:	103ee83a 	callr	r2
   255cc:	1039883a 	mov	fp,r2
        if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
   255d0:	10803fcc 	andi	r2,r2,255
   255d4:	103fb71e 	bne	r2,zero,254b4 <OBJ_Write+0x74>
   255d8:	d0a14317 	ldw	r2,-31476(gp)
   255dc:	10001726 	beq	r2,zero,2563c <OBJ_Write+0x1fc>
            pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   255e0:	a00d883a 	mov	r6,r20
   255e4:	b00b883a 	mov	r5,r22
   255e8:	b809883a 	mov	r4,r23
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   255ec:	103ee83a 	callr	r2
   255f0:	00001206 	br	2563c <OBJ_Write+0x1fc>
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   255f4:	20ffffcc 	andi	r3,r4,65535
   255f8:	013c0c14 	movui	r4,61488
   255fc:	193fba1e 	bne	r3,r4,254e8 <OBJ_Write+0xa8>
    if ( bCompleteAccess )
   25600:	a0002b26 	beq	r20,zero,256b0 <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   25604:	28c03fcc 	andi	r3,r5,255
   25608:	18000926 	beq	r3,zero,25630 <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   2560c:	1023883a 	mov	r17,r2
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   25610:	b8bfffcc 	andi	r2,r23,65535
   25614:	00fc0c14 	movui	r3,61488
   25618:	10ffdf26 	beq	r2,r3,25598 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   2561c:	0027883a 	mov	r19,zero
   25620:	003fe006 	br	255a4 <OBJ_Write+0x164>
    if ( bCompleteAccess )
   25624:	a03fb126 	beq	r20,zero,254ec <OBJ_Write+0xac>
        if ((subindex == 0) && (dataSize > 0))
   25628:	28803fcc 	andi	r2,r5,255
   2562c:	1000241e 	bne	r2,zero,256c0 <OBJ_Write+0x280>
    if ( pObjEntry->Write != NULL )
   25630:	90800817 	ldw	r2,32(r18)
        if ((subindex == 0) && (dataSize > 0))
   25634:	a800031e 	bne	r21,zero,25644 <OBJ_Write+0x204>
    if ( pObjEntry->Write != NULL )
   25638:	103fdc1e 	bne	r2,zero,255ac <OBJ_Write+0x16c>
           return 0; //no error
   2563c:	0039883a 	mov	fp,zero
   25640:	003f9c06 	br	254b4 <OBJ_Write+0x74>
    if ( pObjEntry->Write != NULL )
   25644:	103fd91e 	bne	r2,zero,255ac <OBJ_Write+0x16c>
   25648:	84400003 	ldbu	r17,0(r16)
    BOOL bClearSubindex0Required = FALSE;
   2564c:	0027883a 	mov	r19,zero
        for (i = subindex; i <= lastSubindex; i++)
   25650:	88bfffcc 	andi	r2,r17,65535
   25654:	d8800415 	stw	r2,16(sp)
   25658:	40bfffcc 	andi	r2,r8,65535
   2565c:	d8800215 	stw	r2,8(sp)
                    if (i == 0 && objCode != OBJCODE_VAR)
   25660:	38803fcc 	andi	r2,r7,255
   25664:	108001e0 	cmpeqi	r2,r2,7
   25668:	b5403fcc 	andi	r21,r22,255
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
   2566c:	070001c4 	movi	fp,7
        UINT8 bWritten = 0;
   25670:	000d883a 	mov	r6,zero
                    if (i == 0 && objCode != OBJCODE_VAR)
   25674:	d8800515 	stw	r2,20(sp)
        for (i = subindex; i <= lastSubindex; i++)
   25678:	d8800417 	ldw	r2,16(sp)
   2567c:	ab7fffcc 	andi	r13,r21,65535
   25680:	a819883a 	mov	r12,r21
   25684:	1340202e 	bgeu	r2,r13,25708 <OBJ_Write+0x2c8>
        if (bWritten == 0)
   25688:	31803fcc 	andi	r6,r6,255
   2568c:	303f8926 	beq	r6,zero,254b4 <OBJ_Write+0x74>
    if (pAPPL_CoeWriteInd != NULL)
   25690:	d0a14317 	ldw	r2,-31476(gp)
   25694:	103fe926 	beq	r2,zero,2563c <OBJ_Write+0x1fc>
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   25698:	a00d883a 	mov	r6,r20
   2569c:	b1403fcc 	andi	r5,r22,255
   256a0:	b93fffcc 	andi	r4,r23,65535
   256a4:	003fd106 	br	255ec <OBJ_Write+0x1ac>
    UINT16 maxSubindex = 0;
   256a8:	0023883a 	mov	r17,zero
   256ac:	003f8f06 	br	254ec <OBJ_Write+0xac>
            maxSubindex = maxConfiguredSubindex;
   256b0:	1023883a 	mov	r17,r2
   256b4:	003f8d06 	br	254ec <OBJ_Write+0xac>
    if((subindex > 0) &&
   256b8:	88000e26 	beq	r17,zero,256f4 <OBJ_Write+0x2b4>
    UINT16 lastSubindex = subindex;
   256bc:	4023883a 	mov	r17,r8
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   256c0:	b8b8fc04 	addi	r2,r23,-7184
    if((subindex > 0) &&
   256c4:	10bfffcc 	andi	r2,r2,65535
   256c8:	10800830 	cmpltui	r2,r2,32
   256cc:	103fb21e 	bne	r2,zero,25598 <OBJ_Write+0x158>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   256d0:	b8ba8004 	addi	r2,r23,-5632
   256d4:	10bfffcc 	andi	r2,r2,65535
   256d8:	10808030 	cmpltui	r2,r2,512
   256dc:	103fae1e 	bne	r2,zero,25598 <OBJ_Write+0x158>
   256e0:	b8b98004 	addi	r2,r23,-6656
   256e4:	10bfffcc 	andi	r2,r2,65535
   256e8:	10808030 	cmpltui	r2,r2,512
   256ec:	103fc826 	beq	r2,zero,25610 <OBJ_Write+0x1d0>
   256f0:	003fa906 	br	25598 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   256f4:	b027883a 	mov	r19,r22
    UINT16 lastSubindex = subindex;
   256f8:	0023883a 	mov	r17,zero
   256fc:	003fa906 	br	255a4 <OBJ_Write+0x164>
        if (dataSize == 0)
   25700:	a83fd31e 	bne	r21,zero,25650 <OBJ_Write+0x210>
   25704:	003fcd06 	br	2563c <OBJ_Write+0x1fc>
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   25708:	91c00617 	ldw	r7,24(r18)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   2570c:	a80b883a 	mov	r5,r21
   25710:	9009883a 	mov	r4,r18
   25714:	db400915 	stw	r13,36(sp)
   25718:	d9800715 	stw	r6,28(sp)
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   2571c:	db000815 	stw	r12,32(sp)
   25720:	d9c00615 	stw	r7,24(sp)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25724:	00249240 	call	24924 <OBJ_GetEntryDesc>
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25728:	900b883a 	mov	r5,r18
   2572c:	a809883a 	mov	r4,r21
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25730:	1023883a 	mov	r17,r2
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25734:	0024b680 	call	24b68 <OBJ_GetEntryOffset>
            if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25738:	8900010b 	ldhu	r4,4(r17)
   2573c:	d16157c3 	ldbu	r5,-31393(gp)
   25740:	d9800717 	ldw	r6,28(sp)
   25744:	2009d0ba 	srai	r4,r4,2
   25748:	db400917 	ldw	r13,36(sp)
   2574c:	2148703a 	and	r4,r4,r5
   25750:	2100038c 	andi	r4,r4,14
   25754:	2000f026 	beq	r4,zero,25b18 <OBJ_Write+0x6d8>
                if (i != 0)
   25758:	d9c00617 	ldw	r7,24(sp)
   2575c:	db000817 	ldw	r12,32(sp)
   25760:	68000926 	beq	r13,zero,25788 <OBJ_Write+0x348>
                    pVarPtr += (bitOffset >> 4);
   25764:	1008d0fa 	srli	r4,r2,3
                if ( i == subindex                                     /* requested entry */
   25768:	d8c00217 	ldw	r3,8(sp)
                    pVarPtr += (bitOffset >> 4);
   2576c:	2107ff8c 	andi	r4,r4,8190
   25770:	390f883a 	add	r7,r7,r4
                if ( i == subindex                                     /* requested entry */
   25774:	1b400f26 	beq	r3,r13,257b4 <OBJ_Write+0x374>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25778:	a0000126 	beq	r20,zero,25780 <OBJ_Write+0x340>
   2577c:	68c00d2e 	bgeu	r13,r3,257b4 <OBJ_Write+0x374>
        for (i = subindex; i <= lastSubindex; i++)
   25780:	ad400044 	addi	r21,r21,1
   25784:	003fbc06 	br	25678 <OBJ_Write+0x238>
                if ( i == subindex                                     /* requested entry */
   25788:	d8c00217 	ldw	r3,8(sp)
   2578c:	183ffc1e 	bne	r3,zero,25780 <OBJ_Write+0x340>
                    if (i == 0 && objCode != OBJCODE_VAR)
   25790:	d8c00517 	ldw	r3,20(sp)
   25794:	1800071e 	bne	r3,zero,257b4 <OBJ_Write+0x374>
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25798:	8100000b 	ldhu	r4,0(r16)
                        if(maxConfiguredSubindex < NewSubindex0)
   2579c:	d880038b 	ldhu	r2,14(sp)
   257a0:	21403fcc 	andi	r5,r4,255
   257a4:	1140ef36 	bltu	r2,r5,25b64 <OBJ_Write+0x724>
                        pVarPtr[0] = SWAPWORD(pData[0]);
   257a8:	3900000d 	sth	r4,0(r7)
                            pData++;
   257ac:	84000084 	addi	r16,r16,2
                            break;
   257b0:	00008d06 	br	259e8 <OBJ_Write+0x5a8>
                        UINT16 dataType = pEntry->DataType;
   257b4:	8980000b 	ldhu	r6,0(r17)
                        if (pEntry->DataType >= 0x700)
   257b8:	313fffcc 	andi	r4,r6,65535
   257bc:	2141c030 	cmpltui	r5,r4,1792
   257c0:	2800341e 	bne	r5,zero,25894 <OBJ_Write+0x454>
                            if ( pEntry->BitLength <= 8 )
   257c4:	8980008b 	ldhu	r6,2(r17)
   257c8:	313fffcc 	andi	r4,r6,65535
   257cc:	21400268 	cmpgeui	r5,r4,9
   257d0:	28002a1e 	bne	r5,zero,2587c <OBJ_Write+0x43c>
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   257d4:	31800bc4 	addi	r6,r6,47
                        switch (dataType)
   257d8:	31bff884 	addi	r6,r6,-30
   257dc:	31bfffcc 	andi	r6,r6,65535
   257e0:	01000044 	movi	r4,1
   257e4:	2188983a 	sll	r4,r4,r6
   257e8:	0140ff74 	movhi	r5,1021
   257ec:	29600044 	addi	r5,r5,-32767
   257f0:	214a703a 	and	r5,r4,r5
   257f4:	2800681e 	bne	r5,zero,25998 <OBJ_Write+0x558>
   257f8:	014000b4 	movhi	r5,2
   257fc:	29400104 	addi	r5,r5,4
   25800:	214a703a 	and	r5,r4,r5
   25804:	2800b41e 	bne	r5,zero,25ad8 <OBJ_Write+0x698>
   25808:	01400074 	movhi	r5,1
   2580c:	29400084 	addi	r5,r5,2
   25810:	2148703a 	and	r4,r4,r5
   25814:	20001d26 	beq	r4,zero,2588c <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25818:	108003cc 	andi	r2,r2,15
   2581c:	103f241e 	bne	r2,zero,254b0 <OBJ_Write+0x70>
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25820:	98803fcc 	andi	r2,r19,255
                            UINT16 u16NewData = SWAPWORD(pData[0]);
   25824:	8440000b 	ldhu	r17,0(r16)
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25828:	10000326 	beq	r2,zero,25838 <OBJ_Write+0x3f8>
   2582c:	3900000b 	ldhu	r4,0(r7)
   25830:	88bfffcc 	andi	r2,r17,65535
   25834:	2080cd1e 	bne	r4,r2,25b6c <OBJ_Write+0x72c>
                            if(IS_PDO_ASSIGN(index))  //PDO assign
   25838:	d8800117 	ldw	r2,4(sp)
   2583c:	10b8fc04 	addi	r2,r2,-7184
   25840:	10bfffcc 	andi	r2,r2,65535
   25844:	10800828 	cmpgeui	r2,r2,32
   25848:	1000721e 	bne	r2,zero,25a14 <OBJ_Write+0x5d4>
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
   2584c:	88ba8004 	addi	r2,r17,-5632
   25850:	10bfffcc 	andi	r2,r2,65535
   25854:	10808030 	cmpltui	r2,r2,512
   25858:	1000821e 	bne	r2,zero,25a64 <OBJ_Write+0x624>
   2585c:	88b98004 	addi	r2,r17,-6656
   25860:	10bfffcc 	andi	r2,r2,65535
   25864:	10808030 	cmpltui	r2,r2,512
   25868:	10007e1e 	bne	r2,zero,25a64 <OBJ_Write+0x624>
   2586c:	88bfffcc 	andi	r2,r17,65535
   25870:	10007c26 	beq	r2,zero,25a64 <OBJ_Write+0x624>
                                    return ABORTIDX_VALUE_EXCEEDED;
   25874:	07000484 	movi	fp,18
   25878:	003f0e06 	br	254b4 <OBJ_Write+0x74>
                            else if ( pEntry->BitLength == 16 )
   2587c:	21400420 	cmpeqi	r5,r4,16
   25880:	283fe51e 	bne	r5,zero,25818 <OBJ_Write+0x3d8>
                            else if ( pEntry->BitLength == 32 )
   25884:	21000820 	cmpeqi	r4,r4,32
   25888:	2000931e 	bne	r4,zero,25ad8 <OBJ_Write+0x698>
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   2588c:	07000604 	movi	fp,24
   25890:	003f0806 	br	254b4 <OBJ_Write+0x74>
                        switch (dataType)
   25894:	21400328 	cmpgeui	r5,r4,12
   25898:	28000d1e 	bne	r5,zero,258d0 <OBJ_Write+0x490>
   2589c:	214002a8 	cmpgeui	r5,r4,10
   258a0:	2800241e 	bne	r5,zero,25934 <OBJ_Write+0x4f4>
   258a4:	21400260 	cmpeqi	r5,r4,9
   258a8:	2800221e 	bne	r5,zero,25934 <OBJ_Write+0x4f4>
   258ac:	20002d26 	beq	r4,zero,25964 <OBJ_Write+0x524>
   258b0:	01400044 	movi	r5,1
   258b4:	2908983a 	sll	r4,r5,r4
   258b8:	2140640c 	andi	r5,r4,400
   258bc:	2800861e 	bne	r5,zero,25ad8 <OBJ_Write+0x698>
   258c0:	2140098c 	andi	r5,r4,38
   258c4:	2800341e 	bne	r5,zero,25998 <OBJ_Write+0x558>
   258c8:	2100120c 	andi	r4,r4,72
   258cc:	003fd106 	br	25814 <OBJ_Write+0x3d4>
   258d0:	21400e28 	cmpgeui	r5,r4,56
   258d4:	2800131e 	bne	r5,zero,25924 <OBJ_Write+0x4e4>
   258d8:	214007a8 	cmpgeui	r5,r4,30
   258dc:	283fbe1e 	bne	r5,zero,257d8 <OBJ_Write+0x398>
   258e0:	31bffecc 	andi	r6,r6,65531
   258e4:	31800460 	cmpeqi	r6,r6,17
   258e8:	3000021e 	bne	r6,zero,258f4 <OBJ_Write+0x4b4>
   258ec:	210006e0 	cmpeqi	r4,r4,27
   258f0:	203fe626 	beq	r4,zero,2588c <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   258f4:	108003cc 	andi	r2,r2,15
   258f8:	103eed1e 	bne	r2,zero,254b0 <OBJ_Write+0x70>
                            pVarPtr[0] = pData[0];
   258fc:	8080000b 	ldhu	r2,0(r16)
                            pData += 4;
   25900:	84000204 	addi	r16,r16,8
                            pVarPtr[0] = pData[0];
   25904:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   25908:	80bffe8b 	ldhu	r2,-6(r16)
   2590c:	3880008d 	sth	r2,2(r7)
                            pVarPtr[2] = pData[2];
   25910:	80bfff0b 	ldhu	r2,-4(r16)
   25914:	3880010d 	sth	r2,4(r7)
                            pVarPtr[3] = pData[3];
   25918:	80bfff8b 	ldhu	r2,-2(r16)
   2591c:	3880018d 	sth	r2,6(r7)
                            break;
   25920:	00003106 	br	259e8 <OBJ_Write+0x5a8>
                        switch (dataType)
   25924:	31bf6804 	addi	r6,r6,-608
   25928:	31bfffcc 	andi	r6,r6,65535
   2592c:	31800128 	cmpgeui	r6,r6,4
   25930:	303fd61e 	bne	r6,zero,2588c <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25934:	108003cc 	andi	r2,r2,15
   25938:	103edd1e 	bne	r2,zero,254b0 <OBJ_Write+0x70>
                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
   2593c:	8980008b 	ldhu	r6,2(r17)
   25940:	800b883a 	mov	r5,r16
   25944:	3809883a 	mov	r4,r7
   25948:	318001c4 	addi	r6,r6,7
   2594c:	300cd0fa 	srli	r6,r6,3
   25950:	002735c0 	call	2735c <memcpy>
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25954:	8880008b 	ldhu	r2,2(r17)
   25958:	1004d13a 	srli	r2,r2,4
   2595c:	1004907a 	slli	r2,r2,1
   25960:	00000b06 	br	25990 <OBJ_Write+0x550>
                            if(bCompleteAccess)
   25964:	a03fc926 	beq	r20,zero,2588c <OBJ_Write+0x44c>
                                if (((pEntry->BitLength & 0xF) > 0)
   25968:	8900008b 	ldhu	r4,2(r17)
   2596c:	218003cc 	andi	r6,r4,15
   25970:	217fffcc 	andi	r5,r4,65535
   25974:	30000426 	beq	r6,zero,25988 <OBJ_Write+0x548>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25978:	2089883a 	add	r4,r4,r2
   2597c:	210003cc 	andi	r4,r4,15
   25980:	2000011e 	bne	r4,zero,25988 <OBJ_Write+0x548>
                                    pData++;
   25984:	84000084 	addi	r16,r16,2
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
   25988:	2804d0fa 	srli	r2,r5,3
   2598c:	1080078c 	andi	r2,r2,30
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25990:	80a1883a 	add	r16,r16,r2
                            break;
   25994:	00001406 	br	259e8 <OBJ_Write+0x5a8>
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25998:	8940008b 	ldhu	r5,2(r17)
   2599c:	010000b4 	movhi	r4,2
   259a0:	130003cc 	andi	r12,r2,15
   259a4:	280a907a 	slli	r5,r5,1
                            TmpValue &= ~bitMask;
   259a8:	3b80000b 	ldhu	r14,0(r7)
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   259ac:	2909883a 	add	r4,r5,r4
   259b0:	211fd00b 	ldhu	r4,32576(r4)
   259b4:	217fffcc 	andi	r5,r4,65535
   259b8:	2b1a983a 	sll	r13,r5,r12
                            TmpValue &= ~bitMask;
   259bc:	034c303a 	nor	r6,zero,r13
   259c0:	338c703a 	and	r6,r6,r14
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   259c4:	8380000b 	ldhu	r14,0(r16)
                            if (bCompleteAccess) 
   259c8:	a0000926 	beq	r20,zero,259f0 <OBJ_Write+0x5b0>
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
   259cc:	6b9a703a 	and	r13,r13,r14
   259d0:	3348b03a 	or	r4,r6,r13
                            pVarPtr[0] = SWAPWORD(TmpValue);
   259d4:	3900000d 	sth	r4,0(r7)
                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
   259d8:	8900008b 	ldhu	r4,2(r17)
   259dc:	2085883a 	add	r2,r4,r2
   259e0:	108003cc 	andi	r2,r2,15
   259e4:	103f7126 	beq	r2,zero,257ac <OBJ_Write+0x36c>
                    bWritten = 1;
   259e8:	01800044 	movi	r6,1
   259ec:	003f6406 	br	25780 <OBJ_Write+0x340>
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
   259f0:	014a303a 	nor	r5,zero,r5
   259f4:	737fffcc 	andi	r13,r14,65535
   259f8:	2b4a703a 	and	r5,r5,r13
   259fc:	283f9d1e 	bne	r5,zero,25874 <OBJ_Write+0x434>
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
   25a00:	2388703a 	and	r4,r4,r14
   25a04:	213fffcc 	andi	r4,r4,65535
   25a08:	2308983a 	sll	r4,r4,r12
   25a0c:	3108b03a 	or	r4,r6,r4
   25a10:	003ff006 	br	259d4 <OBJ_Write+0x594>
                            if(index == 0x1C32 || index == 0x1C33)
   25a14:	d8800117 	ldw	r2,4(sp)
   25a18:	10b8f384 	addi	r2,r2,-7218
   25a1c:	10bfffcc 	andi	r2,r2,65535
   25a20:	108000b0 	cmpltui	r2,r2,2
   25a24:	10000f26 	beq	r2,zero,25a64 <OBJ_Write+0x624>
                               if (i == 1) /* "Synchronisation type" written */
   25a28:	633fffcc 	andi	r12,r12,65535
   25a2c:	60800058 	cmpnei	r2,r12,1
   25a30:	10000e1e 	bne	r2,zero,25a6c <OBJ_Write+0x62c>
                                  if (pVarPtr[0] != u16NewData)
   25a34:	3880000b 	ldhu	r2,0(r7)
   25a38:	897fffcc 	andi	r5,r17,65535
   25a3c:	11400726 	beq	r2,r5,25a5c <OBJ_Write+0x61c>
                                     result = CheckSyncTypeValue(index, u16NewData);
   25a40:	d900010b 	ldhu	r4,4(sp)
   25a44:	d9c00615 	stw	r7,24(sp)
   25a48:	0024d240 	call	24d24 <CheckSyncTypeValue>
   25a4c:	1039883a 	mov	fp,r2
                                     if (result != 0)
   25a50:	10803fcc 	andi	r2,r2,255
   25a54:	d9c00617 	ldw	r7,24(sp)
   25a58:	103e961e 	bne	r2,zero,254b4 <OBJ_Write+0x74>
                                  bSyncSetByUser = TRUE;
   25a5c:	00800044 	movi	r2,1
   25a60:	d0a16e85 	stb	r2,-31302(gp)
                            pVarPtr[0] = u16NewData;
   25a64:	3c40000d 	sth	r17,0(r7)
   25a68:	003f5006 	br	257ac <OBJ_Write+0x36c>
                               if (i == 8) /* "Get Cycle Time" written*/
   25a6c:	63000218 	cmpnei	r12,r12,8
   25a70:	603ffc1e 	bne	r12,zero,25a64 <OBJ_Write+0x624>
                                   sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   25a74:	008000f4 	movhi	r2,3
   25a78:	10233a15 	stw	zero,-29464(r2)
                                   sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25a7c:	008000b4 	movhi	r2,2
   25a80:	10a1a804 	addi	r2,r2,-31072
   25a84:	010000f4 	movhi	r4,3
   25a88:	20a33915 	stw	r2,-29468(r4)
                                   sSyncManOutPar.u32CycleTime = 0;
   25a8c:	010000f4 	movhi	r4,3
   25a90:	20233615 	stw	zero,-29480(r4)
                                   sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   25a94:	010000f4 	movhi	r4,3
   25a98:	20232915 	stw	zero,-29532(r4)
                                   sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25a9c:	010000f4 	movhi	r4,3
   25aa0:	20a32815 	stw	r2,-29536(r4)
                                   sSyncManInPar.u32CycleTime = 0;
   25aa4:	008000f4 	movhi	r2,3
   25aa8:	10232515 	stw	zero,-29548(r2)
                                  if ((u16NewData & 0x2) == 0x2)
   25aac:	8880008c 	andi	r2,r17,2
   25ab0:	103fec26 	beq	r2,zero,25a64 <OBJ_Write+0x624>
                                     sSyncManOutPar.u16SmEventMissedCounter = 0;
   25ab4:	008000f4 	movhi	r2,3
   25ab8:	10233f15 	stw	zero,-29444(r2)
                                     sSyncManOutPar.u8SyncError = 0;
   25abc:	008000f4 	movhi	r2,3
   25ac0:	10234505 	stb	zero,-29420(r2)
                                     sSyncManInPar.u16SmEventMissedCounter = 0;
   25ac4:	008000f4 	movhi	r2,3
   25ac8:	10232e15 	stw	zero,-29512(r2)
                                     sSyncManInPar.u8SyncError = 0;
   25acc:	008000f4 	movhi	r2,3
   25ad0:	10233405 	stb	zero,-29488(r2)
   25ad4:	003fe306 	br	25a64 <OBJ_Write+0x624>
                            if(bitOffset & 0xF)
   25ad8:	108003cc 	andi	r2,r2,15
   25adc:	103e741e 	bne	r2,zero,254b0 <OBJ_Write+0x70>
                            if(bClearSubindex0Required && 
   25ae0:	99003fcc 	andi	r4,r19,255
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25ae4:	8080000b 	ldhu	r2,0(r16)
                            if(bClearSubindex0Required && 
   25ae8:	20000626 	beq	r4,zero,25b04 <OBJ_Write+0x6c4>
   25aec:	3940000b 	ldhu	r5,0(r7)
   25af0:	113fffcc 	andi	r4,r2,65535
   25af4:	29001d1e 	bne	r5,r4,25b6c <OBJ_Write+0x72c>
                                || (pVarPtr[1] != pData[1])))
   25af8:	3940008b 	ldhu	r5,2(r7)
   25afc:	8100008b 	ldhu	r4,2(r16)
   25b00:	29001a1e 	bne	r5,r4,25b6c <OBJ_Write+0x72c>
                            pVarPtr[0] = pData[0];
   25b04:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   25b08:	8080008b 	ldhu	r2,2(r16)
                            pData += 2;
   25b0c:	84000104 	addi	r16,r16,4
                            pVarPtr[1] = pData[1];
   25b10:	3880008d 	sth	r2,2(r7)
                            break;
   25b14:	003fb406 	br	259e8 <OBJ_Write+0x5a8>
                if(i == 0)
   25b18:	6800031e 	bne	r13,zero,25b28 <OBJ_Write+0x6e8>
                    pData++;
   25b1c:	84000084 	addi	r16,r16,2
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25b20:	07000604 	movi	fp,24
   25b24:	003f1606 	br	25780 <OBJ_Write+0x340>
                    if (((pEntry->BitLength & 0xF) > 0)
   25b28:	88c0008b 	ldhu	r3,2(r17)
   25b2c:	190003cc 	andi	r4,r3,15
   25b30:	20000426 	beq	r4,zero,25b44 <OBJ_Write+0x704>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25b34:	1885883a 	add	r2,r3,r2
   25b38:	108003cc 	andi	r2,r2,15
   25b3c:	1000011e 	bne	r2,zero,25b44 <OBJ_Write+0x704>
                        pData++;
   25b40:	84000084 	addi	r16,r16,2
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
   25b44:	1806d0fa 	srli	r3,r3,3
   25b48:	18c7ff8c 	andi	r3,r3,8190
   25b4c:	80e1883a 	add	r16,r16,r3
   25b50:	003ff306 	br	25b20 <OBJ_Write+0x6e0>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25b54:	07000444 	movi	fp,17
   25b58:	003e5606 	br	254b4 <OBJ_Write+0x74>
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25b5c:	07000684 	movi	fp,26
   25b60:	003e5406 	br	254b4 <OBJ_Write+0x74>
                            return ABORTIDX_VALUE_TOO_GREAT;
   25b64:	070004c4 	movi	fp,19
   25b68:	003e5206 	br	254b4 <OBJ_Write+0x74>
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
   25b6c:	07000704 	movi	fp,28
   25b70:	003e5006 	br	254b4 <OBJ_Write+0x74>
        if ((subindex == 0) && (dataSize > 0))
   25b74:	b0803fcc 	andi	r2,r22,255
   25b78:	103ead26 	beq	r2,zero,25630 <OBJ_Write+0x1f0>
   25b7c:	003ea706 	br	2561c <OBJ_Write+0x1dc>

00025b80 <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
   25b80:	defffe04 	addi	sp,sp,-8
   25b84:	dc000015 	stw	r16,0(sp)
   25b88:	dc000317 	ldw	r16,12(sp)
	/* for an upload segment response the toggle bit was overwritten */
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25b8c:	29403fcc 	andi	r5,r5,255
{
   25b90:	dfc00115 	stw	ra,4(sp)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
	}
	if (abort == 0)
	{
		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25b94:	8080018b 	ldhu	r2,6(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25b98:	28c01818 	cmpnei	r3,r5,96
{
   25b9c:	da000217 	ldw	r8,8(sp)
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25ba0:	1083ffcc 	andi	r2,r2,4095
   25ba4:	21003fcc 	andi	r4,r4,255
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25ba8:	18000d1e 	bne	r3,zero,25be0 <SdoRes+0x60>
	if (abort == 0)
   25bac:	20003f1e 	bne	r4,zero,25cac <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25bb0:	108c0014 	ori	r2,r2,12288
   25bb4:	8080018d 	sth	r2,6(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
	}

	// HBu 02.05.06: if the CoE-response could not be sent because the
	//               send mailbox is full it should be stored
	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
   25bb8:	01400084 	movi	r5,2
   25bbc:	8009883a 	mov	r4,r16
   25bc0:	002426c0 	call	2426c <MBX_MailboxSendReq>
   25bc4:	10803fcc 	andi	r2,r2,255
   25bc8:	10000126 	beq	r2,zero,25bd0 <SdoRes+0x50>
	{
		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
   25bcc:	d4214b15 	stw	r16,-31444(gp)
	}
}
   25bd0:	dfc00117 	ldw	ra,4(sp)
   25bd4:	dc000017 	ldw	r16,0(sp)
   25bd8:	dec00204 	addi	sp,sp,8
   25bdc:	f800283a 	ret
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   25be0:	80c0020b 	ldhu	r3,8(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25be4:	2800081e 	bne	r5,zero,25c08 <SdoRes+0x88>
	if (abort == 0)
   25be8:	2000301e 	bne	r4,zero,25cac <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25bec:	108c0014 	ori	r2,r2,12288
   25bf0:	8080018d 	sth	r2,6(r16)
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   25bf4:	00800284 	movi	r2,10
   25bf8:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   25bfc:	18c00814 	ori	r3,r3,32
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   25c00:	80c0020d 	sth	r3,8(r16)
   25c04:	003fec06 	br	25bb8 <SdoRes+0x38>
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
   25c08:	027fc004 	movi	r9,-256
   25c0c:	1a46703a 	and	r3,r3,r9
   25c10:	80c0020d 	sth	r3,8(r16)
	if (abort == 0)
   25c14:	2000251e 	bne	r4,zero,25cac <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25c18:	108c0014 	ori	r2,r2,12288
   25c1c:	8080018d 	sth	r2,6(r16)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25c20:	29401018 	cmpnei	r5,r5,64
   25c24:	28001d1e 	bne	r5,zero,25c9c <SdoRes+0x11c>
			if ((objLength <= 4) && (objLength > 0))
   25c28:	40bfffc4 	addi	r2,r8,-1
   25c2c:	10800128 	cmpgeui	r2,r2,4
   25c30:	10000c1e 	bne	r2,zero,25c64 <SdoRes+0xe4>
				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
   25c34:	00800284 	movi	r2,10
   25c38:	8080000d 	sth	r2,0(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c3c:	00800104 	movi	r2,4
   25c40:	1205c83a 	sub	r2,r2,r8
   25c44:	100490ba 	slli	r2,r2,2
   25c48:	318000d4 	ori	r6,r6,3
   25c4c:	31803fcc 	andi	r6,r6,255
   25c50:	1184b03a 	or	r2,r2,r6
   25c54:	1884b03a 	or	r2,r3,r2
   25c58:	10801014 	ori	r2,r2,64
   25c5c:	8080020d 	sth	r2,8(r16)
   25c60:	003fd506 	br	25bb8 <SdoRes+0x38>
				if (dataSize < objLength)
   25c64:	38bfffcc 	andi	r2,r7,65535
   25c68:	12000a2e 	bgeu	r2,r8,25c94 <SdoRes+0x114>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25c6c:	39c00284 	addi	r7,r7,10
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
   25c70:	8200030d 	sth	r8,12(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c74:	31801054 	ori	r6,r6,65
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25c78:	4010d43a 	srli	r8,r8,16
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c7c:	31803fcc 	andi	r6,r6,255
   25c80:	198cb03a 	or	r6,r3,r6
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25c84:	81c0000d 	sth	r7,0(r16)
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25c88:	8200038d 	sth	r8,14(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25c8c:	8180020d 	sth	r6,8(r16)
   25c90:	003fc906 	br	25bb8 <SdoRes+0x38>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
   25c94:	41c00284 	addi	r7,r8,10
   25c98:	003ff506 	br	25c70 <SdoRes+0xf0>
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   25c9c:	00800284 	movi	r2,10
   25ca0:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   25ca4:	18c01814 	ori	r3,r3,96
   25ca8:	003fd506 	br	25c00 <SdoRes+0x80>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
   25cac:	10880014 	ori	r2,r2,8192
   25cb0:	8080018d 	sth	r2,6(r16)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   25cb4:	8080020b 	ldhu	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25cb8:	200890ba 	slli	r4,r4,2
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   25cbc:	00c00284 	movi	r3,10
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   25cc0:	10802014 	ori	r2,r2,128
   25cc4:	8080020d 	sth	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25cc8:	008000b4 	movhi	r2,2
   25ccc:	2085883a 	add	r2,r4,r2
   25cd0:	109fd817 	ldw	r2,32608(r2)
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   25cd4:	80c0000d 	sth	r3,0(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   25cd8:	80800315 	stw	r2,12(r16)
   25cdc:	003fb606 	br	25bb8 <SdoRes+0x38>

00025ce0 <SDOS_SdoInd>:
			is received from the master and calls depending from
			the command the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
{
   25ce0:	defff004 	addi	sp,sp,-64
   25ce4:	dd000a15 	stw	r20,40(sp)
	/* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
	UINT8 bCompleteAccess = 0;
	UINT32 objLength = 0;
	UINT32 dataSize = 0;

	if (bSdoInWork)
   25ce8:	d52174c3 	ldbu	r20,-31277(gp)
{
   25cec:	dd400b15 	stw	r21,44(sp)
	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK) >> SDOHEADER_COMMANDSHIFT;
   25cf0:	2540020b 	ldhu	r21,8(r4)
{
   25cf4:	dc800815 	stw	r18,32(sp)
   25cf8:	dfc00f15 	stw	ra,60(sp)
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   25cfc:	04bff804 	movi	r18,-32
{
   25d00:	df000e15 	stw	fp,56(sp)
   25d04:	ddc00d15 	stw	r23,52(sp)
   25d08:	dd800c15 	stw	r22,48(sp)
   25d0c:	dcc00915 	stw	r19,36(sp)
   25d10:	dc400715 	stw	r17,28(sp)
   25d14:	dc000615 	stw	r16,24(sp)
	if (bSdoInWork)
   25d18:	a0803fcc 	andi	r2,r20,255
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   25d1c:	9564703a 	and	r18,r18,r21
	if (bSdoInWork)
   25d20:	1002021e 	bne	r2,zero,2652c <SDOS_SdoInd+0x84c>
   25d24:	a880040c 	andi	r2,r21,16
	{
		bCompleteAccess = 1;
	}
/* ECATCHANGE_END(V5.13) COE5*/

	switch (command)
   25d28:	94803fcc 	andi	r18,r18,255
	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
   25d2c:	2440000b 	ldhu	r17,0(r4)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25d30:	2021883a 	mov	r16,r4
   25d34:	d8800315 	stw	r2,12(sp)
	switch (command)
   25d38:	91001020 	cmpeqi	r4,r18,64
   25d3c:	2000161e 	bne	r4,zero,25d98 <SDOS_SdoInd+0xb8>
   25d40:	91001068 	cmpgeui	r4,r18,65
   25d44:	2000071e 	bne	r4,zero,25d64 <SDOS_SdoInd+0x84>
   25d48:	9000fe26 	beq	r18,zero,26144 <SDOS_SdoInd+0x464>
   25d4c:	90800820 	cmpeqi	r2,r18,32
   25d50:	1000111e 	bne	r2,zero,25d98 <SDOS_SdoInd+0xb8>
		}
		break;

	case SDOSERVICE_DOWNLOADSEGMENTREQ:
	case SDOSERVICE_UPLOADSEGMENTREQ:
		if (command == nSdoSegService)
   25d54:	0013883a 	mov	r9,zero
   25d58:	0039883a 	mov	fp,zero
   25d5c:	044000c4 	movi	r17,3
   25d60:	00008206 	br	25f6c <SDOS_SdoInd+0x28c>
	switch (command)
   25d64:	90801820 	cmpeqi	r2,r18,96
   25d68:	103ffa26 	beq	r2,zero,25d54 <SDOS_SdoInd+0x74>
		if (command == nSdoSegService)
   25d6c:	d0a17483 	ldbu	r2,-31278(gp)
   25d70:	10801818 	cmpnei	r2,r2,96
   25d74:	103ff71e 	bne	r2,zero,25d54 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25d78:	80800203 	ldbu	r2,8(r16)
   25d7c:	d1217103 	ldbu	r4,-31292(gp)
   25d80:	15c0040c 	andi	r23,r2,16
   25d84:	25c1801e 	bne	r4,r23,26388 <SDOS_SdoInd+0x6a8>
	UINT32 dataSize = 0;
   25d88:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25d8c:	0039883a 	mov	fp,zero
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   25d90:	04400044 	movi	r17,1
   25d94:	00007506 	br	25f6c <SDOS_SdoInd+0x28c>
		index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
   25d98:	8580028b 	ldhu	r22,10(r16)
		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT) & SDOHEADER_INDEXLOMASK;
   25d9c:	acffffcc 	andi	r19,r21,65535
   25da0:	9826d23a 	srli	r19,r19,8
   25da4:	b004923a 	slli	r2,r22,8
   25da8:	98a7883a 	add	r19,r19,r2
		pObjEntry = OBJ_GetObjectHandle(index);
   25dac:	98bfffcc 	andi	r2,r19,65535
   25db0:	1009883a 	mov	r4,r2
   25db4:	d8800215 	stw	r2,8(sp)
   25db8:	00246240 	call	24624 <OBJ_GetObjectHandle>
   25dbc:	102f883a 	mov	r23,r2
		if (pObjEntry)
   25dc0:	1001d226 	beq	r2,zero,2650c <SDOS_SdoInd+0x82c>
		subindex = (pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT) & SDOHEADER_SUBINDEXMASK;
   25dc4:	b0bfffcc 	andi	r2,r22,65535
   25dc8:	102cd23a 	srli	r22,r2,8
				if (subindex > maxSubindex)
   25dcc:	b9000303 	ldbu	r4,12(r23)
   25dd0:	2581d236 	bltu	r4,r22,2651c <SDOS_SdoInd+0x83c>
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25dd4:	a880040c 	andi	r2,r21,16
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25dd8:	b17fffcc 	andi	r5,r22,65535
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25ddc:	1004c03a 	cmpne	r2,r2,zero
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25de0:	a9c0040c 	andi	r7,r21,16
   25de4:	b80d883a 	mov	r6,r23
   25de8:	993fffcc 	andi	r4,r19,65535
   25dec:	d9400415 	stw	r5,16(sp)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25df0:	d8800215 	stw	r2,8(sp)
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25df4:	00246600 	call	24660 <OBJ_GetObjectLength>
   25df8:	1039883a 	mov	fp,r2
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25dfc:	90801018 	cmpnei	r2,r18,64
   25e00:	d9400417 	ldw	r5,16(sp)
   25e04:	8c7fffcc 	andi	r17,r17,65535
   25e08:	1000151e 	bne	r2,zero,25e60 <SDOS_SdoInd+0x180>
						if (mbxSize != EXPEDITED_FRAME_SIZE)
   25e0c:	88800298 	cmpnei	r2,r17,10
   25e10:	1001c81e 	bne	r2,zero,26534 <SDOS_SdoInd+0x854>
						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
   25e14:	e0bfffc4 	addi	r2,fp,-1
   25e18:	10800128 	cmpgeui	r2,r2,4
   25e1c:	1000081e 	bne	r2,zero,25e40 <SDOS_SdoInd+0x160>
							pData[0] = 0;
   25e20:	8000030d 	sth	zero,12(r16)
							pData[1] = 0;
   25e24:	8000038d 	sth	zero,14(r16)
			if ((abort == 0) && (bCompleteAccess == 1))
   25e28:	a880040c 	andi	r2,r21,16
   25e2c:	1001e626 	beq	r2,zero,265c8 <SDOS_SdoInd+0x8e8>
				if (subindex > 1)
   25e30:	288000a8 	cmpgeui	r2,r5,2
   25e34:	1001e426 	beq	r2,zero,265c8 <SDOS_SdoInd+0x8e8>
   25e38:	e013883a 	mov	r9,fp
   25e3c:	0001e006 	br	265c0 <SDOS_SdoInd+0x8e0>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   25e40:	d2a16c8b 	ldhu	r10,-31310(gp)
   25e44:	52bffc04 	addi	r10,r10,-16
							if (dataSize < objLength)
   25e48:	57007336 	bltu	r10,fp,26018 <SDOS_SdoInd+0x338>
			if ((abort == 0) && (bCompleteAccess == 1))
   25e4c:	a880040c 	andi	r2,r21,16
								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
   25e50:	83000404 	addi	r12,r16,16
			if ((abort == 0) && (bCompleteAccess == 1))
   25e54:	10004f26 	beq	r2,zero,25f94 <SDOS_SdoInd+0x2b4>
   25e58:	5013883a 	mov	r9,r10
   25e5c:	00000b06 	br	25e8c <SDOS_SdoInd+0x1ac>
				if (bTransferType)
   25e60:	a880008c 	andi	r2,r21,2
   25e64:	10001226 	beq	r2,zero,25eb0 <SDOS_SdoInd+0x1d0>
					if (mbxSize != EXPEDITED_FRAME_SIZE)
   25e68:	8c400298 	cmpnei	r17,r17,10
   25e6c:	8801b11e 	bne	r17,zero,26534 <SDOS_SdoInd+0x854>
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25e70:	a804d0ba 	srli	r2,r21,2
   25e74:	02400104 	movi	r9,4
					pData = (UINT16 MBXMEM *) &pSdoInd[1];
   25e78:	83000304 	addi	r12,r16,12
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25e7c:	108000cc 	andi	r2,r2,3
   25e80:	4893c83a 	sub	r9,r9,r2
			if ((abort == 0) && (bCompleteAccess == 1))
   25e84:	a880040c 	andi	r2,r21,16
   25e88:	1001ac26 	beq	r2,zero,2653c <SDOS_SdoInd+0x85c>
				if (subindex > 1)
   25e8c:	288000a8 	cmpgeui	r2,r5,2
   25e90:	1001cb1e 	bne	r2,zero,265c0 <SDOS_SdoInd+0x8e0>
					if (objLength == 0)
   25e94:	e000031e 	bne	fp,zero,25ea4 <SDOS_SdoInd+0x1c4>
						nSdoSegIndex = index;
   25e98:	d4e1738d 	sth	r19,-31282(gp)
						nSdoSegSubindex = subindex;
   25e9c:	d5a17305 	stb	r22,-31284(gp)
						pSdoSegObjEntry = pObjEntry;
   25ea0:	d5e16f15 	stw	r23,-31300(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25ea4:	90801018 	cmpnei	r2,r18,64
   25ea8:	1001a81e 	bne	r2,zero,2654c <SDOS_SdoInd+0x86c>
   25eac:	00003b06 	br	25f9c <SDOS_SdoInd+0x2bc>
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   25eb0:	8280038b 	ldhu	r10,14(r16)
   25eb4:	8080030b 	ldhu	r2,12(r16)
   25eb8:	5014943a 	slli	r10,r10,16
   25ebc:	5094b03a 	or	r10,r10,r2
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   25ec0:	d0a16c0b 	ldhu	r2,-31312(gp)
   25ec4:	51000404 	addi	r4,r10,16
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   25ec8:	5013883a 	mov	r9,r10
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   25ecc:	11002f2e 	bgeu	r2,r4,25f8c <SDOS_SdoInd+0x2ac>
						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
   25ed0:	10bffe84 	addi	r2,r2,-6
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25ed4:	8881971e 	bne	r17,r2,26534 <SDOS_SdoInd+0x854>
					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
   25ed8:	88bffd84 	addi	r2,r17,-10
   25edc:	1280522e 	bgeu	r2,r10,26028 <SDOS_SdoInd+0x348>
			if ((abort == 0) && (bCompleteAccess == 1))
   25ee0:	a880040c 	andi	r2,r21,16
   25ee4:	10000226 	beq	r2,zero,25ef0 <SDOS_SdoInd+0x210>
				if (subindex > 1)
   25ee8:	288000a8 	cmpgeui	r2,r5,2
   25eec:	1001b41e 	bne	r2,zero,265c0 <SDOS_SdoInd+0x8e0>
					bSdoSegFollows = TRUE;
   25ef0:	00800044 	movi	r2,1
   25ef4:	d0a17445 	stb	r2,-31279(gp)
					bSdoSegLastToggle = 1;
   25ef8:	d0a17105 	stb	r2,-31292(gp)
					bSdoSegAccess = bCompleteAccess;
   25efc:	d8800217 	ldw	r2,8(sp)
					if (pSdoSegData != NULL)
   25f00:	d1217817 	ldw	r4,-31264(gp)
					nSdoSegIndex = index;
   25f04:	d4e1738d 	sth	r19,-31282(gp)
					bSdoSegAccess = bCompleteAccess;
   25f08:	d0a17405 	stb	r2,-31280(gp)
					nSdoSegSubindex = subindex;
   25f0c:	d5a17305 	stb	r22,-31284(gp)
					pSdoSegObjEntry = pObjEntry;
   25f10:	d5e16f15 	stw	r23,-31300(gp)
						nSdoSegCompleteSize = objLength;
   25f14:	d2617015 	stw	r9,-31296(gp)
					if (pSdoSegData != NULL)
   25f18:	20000526 	beq	r4,zero,25f30 <SDOS_SdoInd+0x250>
   25f1c:	da800515 	stw	r10,20(sp)
   25f20:	d9400415 	stw	r5,16(sp)
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25f24:	00270640 	call	27064 <free>
   25f28:	da800517 	ldw	r10,20(sp)
   25f2c:	d9400417 	ldw	r5,16(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25f30:	d0a17017 	ldw	r2,-31296(gp)
   25f34:	013fff84 	movi	r4,-2
   25f38:	da800515 	stw	r10,20(sp)
   25f3c:	10800044 	addi	r2,r2,1
   25f40:	1108703a 	and	r4,r2,r4
   25f44:	d9400415 	stw	r5,16(sp)
   25f48:	00270540 	call	27054 <malloc>
   25f4c:	d0a17815 	stw	r2,-31264(gp)
					if (pSdoSegData == NULL)
   25f50:	d9400417 	ldw	r5,16(sp)
   25f54:	da800517 	ldw	r10,20(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25f58:	1009883a 	mov	r4,r2
					if (pSdoSegData == NULL)
   25f5c:	1000341e 	bne	r2,zero,26030 <SDOS_SdoInd+0x350>
						if (bCompleteAccess)
   25f60:	d8800217 	ldw	r2,8(sp)
   25f64:	14400104 	addi	r17,r2,4
						nSdoSegBytesToHandle = dataSize;
   25f68:	5013883a 	mov	r9,r10
	}

	if (abort != ABORTIDX_WORKING)
	{
		/*  type cast was added because of warning */
		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
   25f6c:	d9800317 	ldw	r6,12(sp)
   25f70:	dc000115 	stw	r16,4(sp)
   25f74:	df000015 	stw	fp,0(sp)
   25f78:	49ffffcc 	andi	r7,r9,65535
   25f7c:	900b883a 	mov	r5,r18
   25f80:	89003fcc 	andi	r4,r17,255
   25f84:	0025b800 	call	25b80 <SdoRes>
   25f88:	00005506 	br	260e0 <SDOS_SdoInd+0x400>
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25f8c:	50800284 	addi	r2,r10,10
   25f90:	003fd006 	br	25ed4 <SDOS_SdoInd+0x1f4>
					if (objLength == 0)
   25f94:	e0006726 	beq	fp,zero,26134 <SDOS_SdoInd+0x454>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25f98:	5013883a 	mov	r9,r10
						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
   25f9c:	d8800217 	ldw	r2,8(sp)
   25fa0:	db000015 	stw	r12,0(sp)
   25fa4:	b80f883a 	mov	r7,r23
   25fa8:	d8800115 	stw	r2,4(sp)
   25fac:	e00d883a 	mov	r6,fp
   25fb0:	993fffcc 	andi	r4,r19,65535
   25fb4:	da400515 	stw	r9,20(sp)
   25fb8:	db000415 	stw	r12,16(sp)
   25fbc:	0024e300 	call	24e30 <OBJ_Read>
   25fc0:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   25fc4:	10803fcc 	andi	r2,r2,255
   25fc8:	10803fd8 	cmpnei	r2,r2,255
   25fcc:	db000417 	ldw	r12,16(sp)
   25fd0:	da400517 	ldw	r9,20(sp)
   25fd4:	103fe51e 	bne	r2,zero,25f6c <SDOS_SdoInd+0x28c>
							u8PendingSdo = SDO_PENDING_READ;
   25fd8:	008000c4 	movi	r2,3
   25fdc:	d0a17d05 	stb	r2,-31244(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25fe0:	d8800217 	ldw	r2,8(sp)
							u8StoreSubindex = subindex;
   25fe4:	d5a17c85 	stb	r22,-31246(gp)
							u16StoreIndex = index;
   25fe8:	d4e17c0d 	sth	r19,-31248(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25fec:	d0a17cc5 	stb	r2,-31245(gp)
							pSdoPendFunc = pObjEntry->Read;
   25ff0:	b8800717 	ldw	r2,28(r23)
							u32StoreDataSize = objLength;
   25ff4:	d7217b15 	stw	fp,-31252(gp)
							pStoreData = pData;
   25ff8:	d3217a15 	stw	r12,-31256(gp)
							pSdoPendFunc = pObjEntry->Read;
   25ffc:	d0a17915 	stw	r2,-31260(gp)
							bSdoInWork = TRUE;
   26000:	00800044 	movi	r2,1
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   26004:	a8c03c0c 	andi	r3,r21,240
							bSdoInWork = TRUE;
   26008:	d0a174c5 	stb	r2,-31277(gp)
							pSdoResStored = pSdoInd;
   2600c:	d4217515 	stw	r16,-31276(gp)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   26010:	80c00205 	stb	r3,8(r16)
							return 0;
   26014:	00003206 	br	260e0 <SDOS_SdoInd+0x400>
			if ((abort == 0) && (bCompleteAccess == 1))
   26018:	a880040c 	andi	r2,r21,16
   2601c:	1001651e 	bne	r2,zero,265b4 <SDOS_SdoInd+0x8d4>
				if (subindex > 1)
   26020:	e013883a 	mov	r9,fp
   26024:	003fb206 	br	25ef0 <SDOS_SdoInd+0x210>
					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
   26028:	83000404 	addi	r12,r16,16
   2602c:	003f9506 	br	25e84 <SDOS_SdoInd+0x1a4>
						if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26030:	90801018 	cmpnei	r2,r18,64
   26034:	1000371e 	bne	r2,zero,26114 <SDOS_SdoInd+0x434>
							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
   26038:	d8800217 	ldw	r2,8(sp)
   2603c:	d9000015 	stw	r4,0(sp)
   26040:	b80f883a 	mov	r7,r23
   26044:	d8800115 	stw	r2,4(sp)
   26048:	e00d883a 	mov	r6,fp
   2604c:	993fffcc 	andi	r4,r19,65535
   26050:	da800415 	stw	r10,16(sp)
   26054:	0024e300 	call	24e30 <OBJ_Read>
   26058:	1023883a 	mov	r17,r2
							if (abort == 0)
   2605c:	10803fcc 	andi	r2,r2,255
   26060:	da800417 	ldw	r10,16(sp)
   26064:	10000a1e 	bne	r2,zero,26090 <SDOS_SdoInd+0x3b0>
								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
   26068:	d1617817 	ldw	r5,-31264(gp)
   2606c:	500d883a 	mov	r6,r10
   26070:	81000404 	addi	r4,r16,16
   26074:	da800215 	stw	r10,8(sp)
   26078:	002735c0 	call	2735c <memcpy>
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   2607c:	00801804 	movi	r2,96
   26080:	d0a17485 	stb	r2,-31278(gp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   26084:	da800217 	ldw	r10,8(sp)
						nSdoSegBytesToHandle = dataSize;
   26088:	d2a17215 	stw	r10,-31288(gp)
   2608c:	003fb606 	br	25f68 <SDOS_SdoInd+0x288>
							else if (abort == ABORTIDX_WORKING)
   26090:	10803fd8 	cmpnei	r2,r2,255
   26094:	103ffc1e 	bne	r2,zero,26088 <SDOS_SdoInd+0x3a8>
								u8PendingSdo = SDO_PENDING_SEG_READ;
   26098:	00800104 	movi	r2,4
   2609c:	d0a17d05 	stb	r2,-31244(gp)
								bStoreCompleteAccess = bCompleteAccess;
   260a0:	d8800217 	ldw	r2,8(sp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   260a4:	a8c03c0c 	andi	r3,r21,240
								u8StoreSubindex = subindex;
   260a8:	d5a17c85 	stb	r22,-31246(gp)
								bStoreCompleteAccess = bCompleteAccess;
   260ac:	d0a17cc5 	stb	r2,-31245(gp)
								pStoreData = pSdoSegData;
   260b0:	d0a17817 	ldw	r2,-31264(gp)
								u16StoreIndex = index;
   260b4:	d4e17c0d 	sth	r19,-31248(gp)
								u32StoreDataSize = objLength;
   260b8:	d7217b15 	stw	fp,-31252(gp)
								pStoreData = pSdoSegData;
   260bc:	d0a17a15 	stw	r2,-31256(gp)
								pSdoPendFunc = pObjEntry->Read;
   260c0:	b8800717 	ldw	r2,28(r23)
								pSdoResStored = pSdoInd;
   260c4:	d4217515 	stw	r16,-31276(gp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   260c8:	80c00205 	stb	r3,8(r16)
								pSdoPendFunc = pObjEntry->Read;
   260cc:	d0a17915 	stw	r2,-31260(gp)
								bSdoInWork = TRUE;
   260d0:	00800044 	movi	r2,1
   260d4:	d0a174c5 	stb	r2,-31277(gp)
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   260d8:	00801804 	movi	r2,96
   260dc:	d0a17485 	stb	r2,-31278(gp)
	}

	return 0;
}
   260e0:	a005883a 	mov	r2,r20
   260e4:	dfc00f17 	ldw	ra,60(sp)
   260e8:	df000e17 	ldw	fp,56(sp)
   260ec:	ddc00d17 	ldw	r23,52(sp)
   260f0:	dd800c17 	ldw	r22,48(sp)
   260f4:	dd400b17 	ldw	r21,44(sp)
   260f8:	dd000a17 	ldw	r20,40(sp)
   260fc:	dcc00917 	ldw	r19,36(sp)
   26100:	dc800817 	ldw	r18,32(sp)
   26104:	dc400717 	ldw	r17,28(sp)
   26108:	dc000617 	ldw	r16,24(sp)
   2610c:	dec01004 	addi	sp,sp,64
   26110:	f800283a 	ret
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   26114:	8abffd84 	addi	r10,r17,-10
   26118:	500d883a 	mov	r6,r10
   2611c:	81400404 	addi	r5,r16,16
   26120:	da800215 	stw	r10,8(sp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   26124:	a023883a 	mov	r17,r20
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   26128:	002735c0 	call	2735c <memcpy>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   2612c:	d0217485 	stb	zero,-31278(gp)
							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   26130:	003fd406 	br	26084 <SDOS_SdoInd+0x3a4>
						nSdoSegIndex = index;
   26134:	d4e1738d 	sth	r19,-31282(gp)
						nSdoSegSubindex = subindex;
   26138:	d5a17305 	stb	r22,-31284(gp)
						pSdoSegObjEntry = pObjEntry;
   2613c:	d5e16f15 	stw	r23,-31300(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26140:	003f9506 	br	25f98 <SDOS_SdoInd+0x2b8>
		if (command == nSdoSegService)
   26144:	d1217483 	ldbu	r4,-31278(gp)
   26148:	203f021e 	bne	r4,zero,25d54 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   2614c:	d1617103 	ldbu	r5,-31292(gp)
		if (pSdoSegData)
   26150:	d1217817 	ldw	r4,-31264(gp)
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   26154:	28808826 	beq	r5,r2,26378 <SDOS_SdoInd+0x698>
		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
   26158:	d0a17105 	stb	r2,-31292(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   2615c:	d4e16c0b 	ldhu	r19,-31312(gp)
		if (pSdoSegData)
   26160:	20008726 	beq	r4,zero,26380 <SDOS_SdoInd+0x6a0>
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   26164:	d0a17217 	ldw	r2,-31288(gp)
   26168:	d1617017 	ldw	r5,-31296(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   2616c:	9cfffdc4 	addi	r19,r19,-9
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   26170:	a980004c 	andi	r6,r21,1
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   26174:	288bc83a 	sub	r5,r5,r2
				if (bytesToSave <= maxData)
   26178:	9cffffcc 	andi	r19,r19,65535
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   2617c:	30003d26 	beq	r6,zero,26274 <SDOS_SdoInd+0x594>
				if (bytesToSave <= maxData)
   26180:	9940092e 	bgeu	r19,r5,261a8 <SDOS_SdoInd+0x4c8>
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
   26184:	04400384 	movi	r17,14
		if (pSdoSegData)
   26188:	d1217817 	ldw	r4,-31264(gp)
		bSdoSegFollows = FALSE;
   2618c:	d0217445 	stb	zero,-31279(gp)
		nSdoSegService = 0;
   26190:	d0217485 	stb	zero,-31278(gp)
		if (pSdoSegData)
   26194:	20000226 	beq	r4,zero,261a0 <SDOS_SdoInd+0x4c0>
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   26198:	00270640 	call	27064 <free>
			pSdoSegData = NULL;
   2619c:	d0217815 	stw	zero,-31264(gp)
		nSdoSegBytesToHandle = 0;
   261a0:	d0217215 	stw	zero,-31288(gp)
   261a4:	00003006 	br	26268 <SDOS_SdoInd+0x588>
					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   261a8:	8c7fffcc 	andi	r17,r17,65535
   261ac:	8c7fff44 	addi	r17,r17,-3
   261b0:	897ff436 	bltu	r17,r5,26184 <SDOS_SdoInd+0x4a4>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   261b4:	a9bfffcc 	andi	r6,r21,65535
						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
   261b8:	300dd07a 	srai	r6,r6,1
   261bc:	018c303a 	nor	r6,zero,r6
   261c0:	318001cc 	andi	r6,r6,7
   261c4:	29800326 	beq	r5,r6,261d4 <SDOS_SdoInd+0x4f4>
						|| ((bytesToSave > MIN_SEGMENTED_DATA)
   261c8:	29800230 	cmpltui	r6,r5,8
   261cc:	303fed1e 	bne	r6,zero,26184 <SDOS_SdoInd+0x4a4>
							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   261d0:	2c7fec1e 	bne	r5,r17,26184 <SDOS_SdoInd+0x4a4>
						bSdoSegFollows = FALSE;
   261d4:	d0217445 	stb	zero,-31279(gp)
   261d8:	2827883a 	mov	r19,r5
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   261dc:	11c0004c 	andi	r7,r2,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   261e0:	1004d07a 	srli	r2,r2,1
   261e4:	81400284 	addi	r5,r16,10
   261e8:	1004907a 	slli	r2,r2,1
   261ec:	208d883a 	add	r6,r4,r2
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   261f0:	38002426 	beq	r7,zero,26284 <SDOS_SdoInd+0x5a4>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   261f4:	30c00003 	ldbu	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   261f8:	10800084 	addi	r2,r2,2
   261fc:	2089883a 	add	r4,r4,r2
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   26200:	30c0000d 	sth	r3,0(r6)
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
   26204:	81c0020b 	ldhu	r7,8(r16)
   26208:	39ffc00c 	andi	r7,r7,65280
   2620c:	19c6b03a 	or	r3,r3,r7
   26210:	30c0000d 	sth	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   26214:	99bfffc4 	addi	r6,r19,-1
   26218:	002735c0 	call	2735c <memcpy>
				if (bSdoSegFollows == FALSE)
   2621c:	d0a17443 	ldbu	r2,-31279(gp)
   26220:	10002b26 	beq	r2,zero,262d0 <SDOS_SdoInd+0x5f0>
		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   26224:	00800284 	movi	r2,10
   26228:	8080000d 	sth	r2,0(r16)
		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   2622c:	8080018b 	ldhu	r2,6(r16)
   26230:	1083ffcc 	andi	r2,r2,4095
		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   26234:	108c0014 	ori	r2,r2,12288
   26238:	8080018d 	sth	r2,6(r16)
		if (bSdoSegLastToggle)
   2623c:	d0a17103 	ldbu	r2,-31292(gp)
   26240:	10004b1e 	bne	r2,zero,26370 <SDOS_SdoInd+0x690>
   26244:	00800804 	movi	r2,32
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
   26248:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   2624c:	d0a17443 	ldbu	r2,-31279(gp)
   26250:	10800058 	cmpnei	r2,r2,1
   26254:	1000981e 	bne	r2,zero,264b8 <SDOS_SdoInd+0x7d8>
			nSdoSegBytesToHandle += bytesToSave;
   26258:	d0a17217 	ldw	r2,-31288(gp)
   2625c:	14c5883a 	add	r2,r2,r19
   26260:	d0a17215 	stw	r2,-31288(gp)
	if (abort != ABORTIDX_WORKING)
   26264:	a023883a 	mov	r17,r20
	UINT32 dataSize = 0;
   26268:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   2626c:	0039883a 	mov	fp,zero
   26270:	003f3e06 	br	25f6c <SDOS_SdoInd+0x28c>
				bSdoSegFollows = TRUE;
   26274:	01800044 	movi	r6,1
   26278:	d1a17445 	stb	r6,-31279(gp)
				if (bytesToSave <= maxData)
   2627c:	997fc12e 	bgeu	r19,r5,26184 <SDOS_SdoInd+0x4a4>
   26280:	003fd606 	br	261dc <SDOS_SdoInd+0x4fc>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   26284:	8080028b 	ldhu	r2,10(r16)
   26288:	a8ffffcc 	andi	r3,r21,65535
   2628c:	1806d23a 	srli	r3,r3,8
   26290:	1004923a 	slli	r2,r2,8
   26294:	10c4b03a 	or	r2,r2,r3
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   26298:	98c00044 	addi	r3,r19,1
   2629c:	1806d07a 	srli	r3,r3,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   262a0:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   262a4:	39c00044 	addi	r7,r7,1
   262a8:	29400084 	addi	r5,r5,2
   262ac:	31800084 	addi	r6,r6,2
   262b0:	38ffda2e 	bgeu	r7,r3,2621c <SDOS_SdoInd+0x53c>
						pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
   262b4:	28bfff8b 	ldhu	r2,-2(r5)
   262b8:	2900000b 	ldhu	r4,0(r5)
   262bc:	1004d23a 	srli	r2,r2,8
   262c0:	2008923a 	slli	r4,r4,8
   262c4:	1104b03a 	or	r2,r2,r4
   262c8:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   262cc:	003ff506 	br	262a4 <SDOS_SdoInd+0x5c4>
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   262d0:	d0a17403 	ldbu	r2,-31280(gp)
   262d4:	d1e16f17 	ldw	r7,-31300(gp)
   262d8:	d1a17017 	ldw	r6,-31296(gp)
   262dc:	d8800115 	stw	r2,4(sp)
   262e0:	d0a17817 	ldw	r2,-31264(gp)
   262e4:	d1617303 	ldbu	r5,-31284(gp)
   262e8:	d121738b 	ldhu	r4,-31282(gp)
   262ec:	d8800015 	stw	r2,0(sp)
   262f0:	00254400 	call	25440 <OBJ_Write>
					if (abort == ABORTIDX_WORKING)
   262f4:	15803fcc 	andi	r22,r2,255
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   262f8:	1023883a 	mov	r17,r2
					if (abort == ABORTIDX_WORKING)
   262fc:	b0803fd8 	cmpnei	r2,r22,255
   26300:	1000161e 	bne	r2,zero,2635c <SDOS_SdoInd+0x67c>
						u8PendingSdo = SDO_PENDING_SEG_WRITE;
   26304:	00800084 	movi	r2,2
   26308:	d0a17d05 	stb	r2,-31244(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   2630c:	d0a17403 	ldbu	r2,-31280(gp)
						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
   26310:	d4217515 	stw	r16,-31276(gp)
						bSdoSegFollows = FALSE;
   26314:	d0217445 	stb	zero,-31279(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   26318:	d0a17cc5 	stb	r2,-31245(gp)
						u8StoreSubindex = nSdoSegSubindex;
   2631c:	d0a17303 	ldbu	r2,-31284(gp)
						nSdoSegService = 0;
   26320:	d0217485 	stb	zero,-31278(gp)
						nSdoSegBytesToHandle = 0;
   26324:	d0217215 	stw	zero,-31288(gp)
						u8StoreSubindex = nSdoSegSubindex;
   26328:	d0a17c85 	stb	r2,-31246(gp)
						u16StoreIndex = nSdoSegIndex;
   2632c:	d0a1738b 	ldhu	r2,-31282(gp)
   26330:	d0a17c0d 	sth	r2,-31248(gp)
						u32StoreDataSize = nSdoSegCompleteSize;
   26334:	d0a17017 	ldw	r2,-31296(gp)
   26338:	d0a17b15 	stw	r2,-31252(gp)
						pStoreData = pSdoSegData;
   2633c:	d0a17817 	ldw	r2,-31264(gp)
   26340:	d0a17a15 	stw	r2,-31256(gp)
						pSdoPendFunc = pSdoSegObjEntry->Write;
   26344:	d0a16f17 	ldw	r2,-31300(gp)
   26348:	10800817 	ldw	r2,32(r2)
   2634c:	d0a17915 	stw	r2,-31260(gp)
						bSdoInWork = TRUE;
   26350:	00800044 	movi	r2,1
   26354:	d0a174c5 	stb	r2,-31277(gp)
	if (abort != ABORTIDX_WORKING)
   26358:	003f6106 	br	260e0 <SDOS_SdoInd+0x400>
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   2635c:	d1217817 	ldw	r4,-31264(gp)
   26360:	00270640 	call	27064 <free>
						pSdoSegData = NULL;
   26364:	d0217815 	stw	zero,-31264(gp)
	if (abort == 0)
   26368:	b03fae26 	beq	r22,zero,26224 <SDOS_SdoInd+0x544>
   2636c:	003f8606 	br	26188 <SDOS_SdoInd+0x4a8>
   26370:	00800c04 	movi	r2,48
   26374:	003fb406 	br	26248 <SDOS_SdoInd+0x568>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   26378:	04400044 	movi	r17,1
   2637c:	003f8206 	br	26188 <SDOS_SdoInd+0x4a8>
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   26380:	044000c4 	movi	r17,3
   26384:	003f8006 	br	26188 <SDOS_SdoInd+0x4a8>
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   26388:	d4616c8b 	ldhu	r17,-31310(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   2638c:	d4e17217 	ldw	r19,-31288(gp)
   26390:	d0a17017 	ldw	r2,-31296(gp)
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   26394:	8c7ffdc4 	addi	r17,r17,-9
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   26398:	8c7fffcc 	andi	r17,r17,65535
		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
   2639c:	d5e17105 	stb	r23,-31292(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   263a0:	8cc9883a 	add	r4,r17,r19
   263a4:	1100242e 	bgeu	r2,r4,26438 <SDOS_SdoInd+0x758>
			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   263a8:	14e3c83a 	sub	r17,r2,r19
			bSdoSegFollows = FALSE;
   263ac:	a039883a 	mov	fp,r20
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263b0:	980cd07a 	srli	r6,r19,1
   263b4:	d5a17817 	ldw	r22,-31264(gp)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   263b8:	a8c03fcc 	andi	r3,r21,255
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263bc:	300a907a 	slli	r5,r6,1
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   263c0:	80c0020d 	sth	r3,8(r16)
			bSdoSegFollows = FALSE;
   263c4:	d7217445 	stb	fp,-31279(gp)
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263c8:	b145883a 	add	r2,r22,r5
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   263cc:	9900004c 	andi	r4,r19,1
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263d0:	1080000b 	ldhu	r2,0(r2)
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   263d4:	20001a26 	beq	r4,zero,26440 <SDOS_SdoInd+0x760>
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263d8:	10bfc00c 	andi	r2,r2,65280
   263dc:	1886b03a 	or	r3,r3,r2
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   263e0:	29400084 	addi	r5,r5,2
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   263e4:	80c0020d 	sth	r3,8(r16)
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   263e8:	89bfffc4 	addi	r6,r17,-1
   263ec:	b14b883a 	add	r5,r22,r5
   263f0:	81000284 	addi	r4,r16,10
   263f4:	002735c0 	call	2735c <memcpy>
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   263f8:	8080018b 	ldhu	r2,6(r16)
		if (bSdoSegFollows)
   263fc:	e7003fcc 	andi	fp,fp,255
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   26400:	8807883a 	mov	r3,r17
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   26404:	1083ffcc 	andi	r2,r2,4095
		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   26408:	108c0014 	ori	r2,r2,12288
   2640c:	8080018d 	sth	r2,6(r16)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
   26410:	8080020b 	ldhu	r2,8(r16)
   26414:	890001f0 	cmpltui	r4,r17,7
   26418:	10bfc00c 	andi	r2,r2,65280
		if (bSdoSegFollows)
   2641c:	e0001d26 	beq	fp,zero,26494 <SDOS_SdoInd+0x7b4>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
   26420:	15c4b03a 	or	r2,r2,r23
   26424:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   26428:	20002e1e 	bne	r4,zero,264e4 <SDOS_SdoInd+0x804>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   2642c:	18c000c4 	addi	r3,r3,3
   26430:	80c0000d 	sth	r3,0(r16)
		if (bSdoSegFollows == TRUE)
   26434:	00003206 	br	26500 <SDOS_SdoInd+0x820>
   26438:	07000044 	movi	fp,1
   2643c:	003fdc06 	br	263b0 <SDOS_SdoInd+0x6d0>
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   26440:	1004923a 	slli	r2,r2,8
			for (i = 0; i < (size >> 1); i++)
   26444:	880ed07a 	srli	r7,r17,1
   26448:	000b883a 	mov	r5,zero
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   2644c:	1886b03a 	or	r3,r3,r2
   26450:	80c0020d 	sth	r3,8(r16)
			for (i = 0; i < (size >> 1); i++)
   26454:	28bfffcc 	andi	r2,r5,65535
   26458:	11ffe72e 	bgeu	r2,r7,263f8 <SDOS_SdoInd+0x718>
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   2645c:	1187883a 	add	r3,r2,r6
   26460:	1806907a 	slli	r3,r3,1
   26464:	10800104 	addi	r2,r2,4
   26468:	1004907a 	slli	r2,r2,1
   2646c:	b0c7883a 	add	r3,r22,r3
   26470:	1900008b 	ldhu	r4,2(r3)
   26474:	18c0000b 	ldhu	r3,0(r3)
   26478:	8085883a 	add	r2,r16,r2
   2647c:	2008923a 	slli	r4,r4,8
   26480:	1806d23a 	srli	r3,r3,8
			for (i = 0; i < (size >> 1); i++)
   26484:	29400044 	addi	r5,r5,1
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   26488:	20c6b03a 	or	r3,r4,r3
   2648c:	10c0008d 	sth	r3,2(r2)
			for (i = 0; i < (size >> 1); i++)
   26490:	003ff006 	br	26454 <SDOS_SdoInd+0x774>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
   26494:	bdc00054 	ori	r23,r23,1
   26498:	15c4b03a 	or	r2,r2,r23
   2649c:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   264a0:	2000081e 	bne	r4,zero,264c4 <SDOS_SdoInd+0x7e4>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   264a4:	18c000c4 	addi	r3,r3,3
   264a8:	80c0000d 	sth	r3,0(r16)
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   264ac:	b009883a 	mov	r4,r22
   264b0:	00270640 	call	27064 <free>
			pSdoSegData = NULL;
   264b4:	d0217815 	stw	zero,-31264(gp)
			nSdoSegBytesToHandle = 0;
   264b8:	d0217215 	stw	zero,-31288(gp)
			nSdoSegService = 0;
   264bc:	d0217485 	stb	zero,-31278(gp)
	if (abort != ABORTIDX_WORKING)
   264c0:	003f6806 	br	26264 <SDOS_SdoInd+0x584>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   264c4:	01000284 	movi	r4,10
   264c8:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   264cc:	010001c4 	movi	r4,7
   264d0:	20c7c83a 	sub	r3,r4,r3
   264d4:	1806907a 	slli	r3,r3,1
   264d8:	1884b03a 	or	r2,r3,r2
   264dc:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   264e0:	003ff206 	br	264ac <SDOS_SdoInd+0x7cc>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   264e4:	01000284 	movi	r4,10
   264e8:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   264ec:	010001c4 	movi	r4,7
   264f0:	20c7c83a 	sub	r3,r4,r3
   264f4:	1806907a 	slli	r3,r3,1
   264f8:	1884b03a 	or	r2,r3,r2
   264fc:	8080020d 	sth	r2,8(r16)
			nSdoSegBytesToHandle += size;
   26500:	9c67883a 	add	r19,r19,r17
   26504:	d4e17215 	stw	r19,-31288(gp)
	if (abort != ABORTIDX_WORKING)
   26508:	003f5606 	br	26264 <SDOS_SdoInd+0x584>
	UINT32 dataSize = 0;
   2650c:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   26510:	0039883a 	mov	fp,zero
			abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26514:	04400204 	movi	r17,8
   26518:	003e9406 	br	25f6c <SDOS_SdoInd+0x28c>
   2651c:	0013883a 	mov	r9,zero
   26520:	0039883a 	mov	fp,zero
   26524:	04400444 	movi	r17,17
   26528:	003e9006 	br	25f6c <SDOS_SdoInd+0x28c>
		return MBXERR_SERVICEINWORK;
   2652c:	05000244 	movi	r20,9
   26530:	003eeb06 	br	260e0 <SDOS_SdoInd+0x400>
							return MBXERR_INVALIDSIZE;
   26534:	05000204 	movi	r20,8
   26538:	003ee906 	br	260e0 <SDOS_SdoInd+0x400>
					if (objLength == 0)
   2653c:	e000031e 	bne	fp,zero,2654c <SDOS_SdoInd+0x86c>
						nSdoSegIndex = index;
   26540:	d4e1738d 	sth	r19,-31282(gp)
						nSdoSegSubindex = subindex;
   26544:	d5a17305 	stb	r22,-31284(gp)
						pSdoSegObjEntry = pObjEntry;
   26548:	d5e16f15 	stw	r23,-31300(gp)
						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
   2654c:	d8800217 	ldw	r2,8(sp)
   26550:	db000015 	stw	r12,0(sp)
   26554:	480d883a 	mov	r6,r9
   26558:	d8800115 	stw	r2,4(sp)
   2655c:	b80f883a 	mov	r7,r23
   26560:	993fffcc 	andi	r4,r19,65535
   26564:	db000515 	stw	r12,20(sp)
   26568:	da400415 	stw	r9,16(sp)
   2656c:	00254400 	call	25440 <OBJ_Write>
   26570:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   26574:	10803fcc 	andi	r2,r2,255
   26578:	10803fd8 	cmpnei	r2,r2,255
   2657c:	da400417 	ldw	r9,16(sp)
   26580:	db000517 	ldw	r12,20(sp)
   26584:	103e791e 	bne	r2,zero,25f6c <SDOS_SdoInd+0x28c>
							bStoreCompleteAccess = bCompleteAccess;
   26588:	d8c00217 	ldw	r3,8(sp)
							pSdoPendFunc = pObjEntry->Write;
   2658c:	b9000817 	ldw	r4,32(r23)
							u8PendingSdo = SDO_PENDING_WRITE;
   26590:	00800044 	movi	r2,1
   26594:	d0a17d05 	stb	r2,-31244(gp)
							bStoreCompleteAccess = bCompleteAccess;
   26598:	d0e17cc5 	stb	r3,-31245(gp)
							u8StoreSubindex = subindex;
   2659c:	d5a17c85 	stb	r22,-31246(gp)
							u16StoreIndex = index;
   265a0:	d4e17c0d 	sth	r19,-31248(gp)
							u32StoreDataSize = dataSize;
   265a4:	d2617b15 	stw	r9,-31252(gp)
							pStoreData = pData;
   265a8:	d3217a15 	stw	r12,-31256(gp)
							pSdoPendFunc = pObjEntry->Write;
   265ac:	d1217915 	stw	r4,-31260(gp)
   265b0:	003e9406 	br	26004 <SDOS_SdoInd+0x324>
				if (subindex > 1)
   265b4:	288000a8 	cmpgeui	r2,r5,2
   265b8:	103e9926 	beq	r2,zero,26020 <SDOS_SdoInd+0x340>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   265bc:	5013883a 	mov	r9,r10
							abort = ABORTIDX_UNSUPPORTED_ACCESS;
   265c0:	04400144 	movi	r17,5
   265c4:	003e6906 	br	25f6c <SDOS_SdoInd+0x28c>
							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
   265c8:	83000304 	addi	r12,r16,12
   265cc:	e013883a 	mov	r9,fp
   265d0:	003e7206 	br	25f9c <SDOS_SdoInd+0x2bc>

000265d4 <SDOS_SdoRes>:

void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
{
	UINT16 dataSize = 0;

	if (bSdoInWork)
   265d4:	d0a174c3 	ldbu	r2,-31277(gp)
   265d8:	10004126 	beq	r2,zero,266e0 <SDOS_SdoRes+0x10c>
{
   265dc:	defff604 	addi	sp,sp,-40
   265e0:	dcc00515 	stw	r19,20(sp)
	{
		/* SDO-Response is expected */
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   265e4:	d4e17517 	ldw	r19,-31276(gp)
{
   265e8:	dc800415 	stw	r18,16(sp)
   265ec:	dd400715 	stw	r21,28(sp)
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   265f0:	9c800203 	ldbu	r18,8(r19)
{
   265f4:	dd000615 	stw	r20,24(sp)
   265f8:	dc000215 	stw	r16,8(sp)
		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
   265fc:	9540040c 	andi	r21,r18,16

		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26600:	9480380c 	andi	r18,r18,224
{
   26604:	dfc00915 	stw	ra,36(sp)
   26608:	dd800815 	stw	r22,32(sp)
   2660c:	dc400315 	stw	r17,12(sp)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26610:	90801018 	cmpnei	r2,r18,64
   26614:	2029883a 	mov	r20,r4
   26618:	2821883a 	mov	r16,r5
   2661c:	10002e1e 	bne	r2,zero,266d8 <SDOS_SdoRes+0x104>
		{
			/* dataSize contains the available size in one mailbox */
			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   26620:	d4616c8b 	ldhu	r17,-31310(gp)
   26624:	300b883a 	mov	r5,r6
   26628:	8c7ffc04 	addi	r17,r17,-16
   2662c:	882d883a 	mov	r22,r17
			if (dataSize < objLength)
   26630:	8c7fffcc 	andi	r17,r17,65535
   26634:	8c001e2e 	bgeu	r17,r16,266b0 <SDOS_SdoRes+0xdc>
			{
				/* Segmented Upload, the variables for the segmented transfer should be initialized */
				bSdoSegFollows = TRUE;
   26638:	00800044 	movi	r2,1
   2663c:	d0a17445 	stb	r2,-31279(gp)
				bSdoSegLastToggle = 1;
   26640:	d0a17105 	stb	r2,-31292(gp)
				bSdoSegAccess = completeAccess;
				nSdoSegCompleteSize = objLength;
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
				pSdoSegData = (UINT16 VARMEM *) pData;
   26644:	d1a17815 	stw	r6,-31264(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26648:	00801804 	movi	r2,96
				/* the first segment shall be copied */
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   2664c:	880d883a 	mov	r6,r17
   26650:	99000404 	addi	r4,r19,16
				bSdoSegAccess = completeAccess;
   26654:	d5617405 	stb	r21,-31280(gp)
				nSdoSegCompleteSize = objLength;
   26658:	d4217015 	stw	r16,-31296(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   2665c:	d0a17485 	stb	r2,-31278(gp)
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   26660:	002735c0 	call	2735c <memcpy>
				nSdoSegBytesToHandle = dataSize;
   26664:	d4617215 	stw	r17,-31288(gp)
				}
		}

		/* SDO access is finished, send the response */
		bSdoInWork = FALSE;
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26668:	dcc00115 	stw	r19,4(sp)
   2666c:	dc000015 	stw	r16,0(sp)
   26670:	b1ffffcc 	andi	r7,r22,65535
   26674:	a80d883a 	mov	r6,r21
   26678:	900b883a 	mov	r5,r18
   2667c:	a1003fcc 	andi	r4,r20,255
		bSdoInWork = FALSE;
   26680:	d02174c5 	stb	zero,-31277(gp)
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26684:	0025b800 	call	25b80 <SdoRes>
	}
}
   26688:	dfc00917 	ldw	ra,36(sp)
   2668c:	dd800817 	ldw	r22,32(sp)
   26690:	dd400717 	ldw	r21,28(sp)
   26694:	dd000617 	ldw	r20,24(sp)
   26698:	dcc00517 	ldw	r19,20(sp)
   2669c:	dc800417 	ldw	r18,16(sp)
   266a0:	dc400317 	ldw	r17,12(sp)
   266a4:	dc000217 	ldw	r16,8(sp)
   266a8:	dec00a04 	addi	sp,sp,40
   266ac:	f800283a 	ret
				if ((objLength <= 4) && (objLength > 0))
   266b0:	80bfffc4 	addi	r2,r16,-1
   266b4:	10800128 	cmpgeui	r2,r2,4
   266b8:	1000051e 	bne	r2,zero,266d0 <SDOS_SdoRes+0xfc>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
   266bc:	99000304 	addi	r4,r19,12
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   266c0:	217fe926 	beq	r4,r5,26668 <SDOS_SdoRes+0x94>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
   266c4:	800d883a 	mov	r6,r16
   266c8:	002735c0 	call	2735c <memcpy>
   266cc:	003fe606 	br	26668 <SDOS_SdoRes+0x94>
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   266d0:	99000404 	addi	r4,r19,16
   266d4:	003ffa06 	br	266c0 <SDOS_SdoRes+0xec>
	UINT16 dataSize = 0;
   266d8:	002d883a 	mov	r22,zero
   266dc:	003fe206 	br	26668 <SDOS_SdoRes+0x94>
   266e0:	f800283a 	ret

000266e4 <SDOS_ClearPendingResponse>:
		   This function shall be called before the other mailbox data pointer are set to NULL
*////////////////////////////////////////////////////////////////////////////////////////

void  SDOS_ClearPendingResponse(void)
{
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   266e4:	d0a174c3 	ldbu	r2,-31277(gp)
{
   266e8:	deffff04 	addi	sp,sp,-4
   266ec:	dfc00015 	stw	ra,0(sp)
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   266f0:	10800058 	cmpnei	r2,r2,1
   266f4:	1000081e 	bne	r2,zero,26718 <SDOS_ClearPendingResponse+0x34>
   266f8:	d1217517 	ldw	r4,-31276(gp)
   266fc:	20000626 	beq	r4,zero,26718 <SDOS_ClearPendingResponse+0x34>
   26700:	d0a16717 	ldw	r2,-31332(gp)
   26704:	20800426 	beq	r4,r2,26718 <SDOS_ClearPendingResponse+0x34>
   26708:	d0a16617 	ldw	r2,-31336(gp)
   2670c:	20800226 	beq	r4,r2,26718 <SDOS_ClearPendingResponse+0x34>
	{
		APPL_FreeMailboxBuffer(pSdoResStored);
   26710:	00270640 	call	27064 <free>
		pSdoResStored = NULL;
   26714:	d0217515 	stw	zero,-31276(gp)
	u32StoreDataSize = 0;
	pStoreData = NULL;
	pSdoPendFunc = NULL;
	bSdoInWork = FALSE;

	if (pSdoSegData != NULL)
   26718:	d1217817 	ldw	r4,-31264(gp)
	u8PendingSdo = 0;
   2671c:	d0217d05 	stb	zero,-31244(gp)
	bStoreCompleteAccess = FALSE;
   26720:	d0217cc5 	stb	zero,-31245(gp)
	u16StoreIndex = 0;
   26724:	d0217c0d 	sth	zero,-31248(gp)
	u8StoreSubindex = 0;
   26728:	d0217c85 	stb	zero,-31246(gp)
	u32StoreDataSize = 0;
   2672c:	d0217b15 	stw	zero,-31252(gp)
	pStoreData = NULL;
   26730:	d0217a15 	stw	zero,-31256(gp)
	pSdoPendFunc = NULL;
   26734:	d0217915 	stw	zero,-31260(gp)
	bSdoInWork = FALSE;
   26738:	d02174c5 	stb	zero,-31277(gp)
	if (pSdoSegData != NULL)
   2673c:	20000226 	beq	r4,zero,26748 <SDOS_ClearPendingResponse+0x64>
	{
		FREEMEM((UINT16 VARMEM *) pSdoSegData);
   26740:	00270640 	call	27064 <free>
		pSdoSegData = NULL;
   26744:	d0217815 	stw	zero,-31264(gp)
	}

	nSdoSegBytesToHandle = 0;
   26748:	d0217215 	stw	zero,-31288(gp)
	nSdoSegService = 0;
   2674c:	d0217485 	stb	zero,-31278(gp)

}
   26750:	dfc00017 	ldw	ra,0(sp)
   26754:	dec00104 	addi	sp,sp,4
   26758:	f800283a 	ret

0002675c <SDOS_SdoInfoInd>:
			is received from the master and calls depending from
			the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
{
   2675c:	defff804 	addi	sp,sp,-32
   26760:	dcc00515 	stw	r19,20(sp)
	UINT8 abort = 0;
	/* the variable opCode contains the requested SDO Information type */
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26764:	24c00203 	ldbu	r19,8(r4)
{
   26768:	dc800415 	stw	r18,16(sp)
   2676c:	dc000215 	stw	r16,8(sp)
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26770:	9c801fcc 	andi	r18,r19,127
{
   26774:	dfc00715 	stw	ra,28(sp)
   26778:	dd000615 	stw	r20,24(sp)
   2677c:	dc400315 	stw	r17,12(sp)
	UINT8 abort = 0;
   26780:	d8000145 	stb	zero,5(sp)
	UINT16 index;
	UINT8 flags = COE_SERVICE;

	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
	   great enough for the service header of the requested SDO Information type */
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26784:	90c00158 	cmpnei	r3,r18,5
   26788:	2080000b 	ldhu	r2,0(r4)
{
   2678c:	2021883a 	mov	r16,r4
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26790:	9027883a 	mov	r19,r18
   26794:	1800041e 	bne	r3,zero,267a8 <SDOS_SdoInfoInd+0x4c>
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
   26798:	108002b0 	cmpltui	r2,r2,10
   2679c:	10000926 	beq	r2,zero,267c4 <SDOS_SdoInfoInd+0x68>
		{
			return MBXERR_SIZETOOSHORT;
   267a0:	00800184 	movi	r2,6
   267a4:	00004b06 	br	268d4 <SDOS_SdoInfoInd+0x178>
		}
	}
	else
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
   267a8:	10800230 	cmpltui	r2,r2,8
   267ac:	103ffc1e 	bne	r2,zero,267a0 <SDOS_SdoInfoInd+0x44>
		{
			return MBXERR_SIZETOOSHORT;
		}
	}

	switch (opCode)
   267b0:	90800060 	cmpeqi	r2,r18,1
   267b4:	10000b1e 	bne	r2,zero,267e4 <SDOS_SdoInfoInd+0x88>
   267b8:	9000dc26 	beq	r18,zero,26b2c <SDOS_SdoInfoInd+0x3d0>
   267bc:	908000e0 	cmpeqi	r2,r18,3
   267c0:	1000da26 	beq	r2,zero,26b2c <SDOS_SdoInfoInd+0x3d0>
		break;

	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
		/* get the requested index */
		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
   267c4:	8100030b 	ldhu	r4,12(r16)
   267c8:	d900018d 	sth	r4,6(sp)



		if (index < 0x1000)
   267cc:	213fffcc 	andi	r4,r4,65535
   267d0:	20840028 	cmpgeui	r2,r4,4096
   267d4:	1000741e 	bne	r2,zero,269a8 <SDOS_SdoInfoInd+0x24c>
		{
			/*SDO Info access is only allowed for objects >= 0x1000*/
			abort = ABORTIDX_UNSUPPORTED_ACCESS;
   267d8:	00800144 	movi	r2,5
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
			}
		}
		break;
	default:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   267dc:	d8800145 	stb	r2,5(sp)
   267e0:	00009506 	br	26a38 <SDOS_SdoInfoInd+0x2dc>
		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
   267e4:	2440030b 	ldhu	r17,12(r4)
   267e8:	8cbfffcc 	andi	r18,r17,65535
   267ec:	908001b0 	cmpltui	r2,r18,6
   267f0:	10009126 	beq	r2,zero,26a38 <SDOS_SdoInfoInd+0x2dc>
			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
   267f4:	200b883a 	mov	r5,r4
   267f8:	010000f4 	movhi	r4,3
   267fc:	01800384 	movi	r6,14
   26800:	21234604 	addi	r4,r4,-29416
   26804:	002735c0 	call	2735c <memcpy>
			if (listType-- == 0)
   26808:	90003a1e 	bne	r18,zero,268f4 <SDOS_SdoInfoInd+0x198>
				nSdoInfoFragmentsLeft = 0;
   2680c:	d021778d 	sth	zero,-31266(gp)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26810:	84800384 	addi	r18,r16,14
				nSdoInfoFragmentsLeft = 0;
   26814:	0023883a 	mov	r17,zero
					UINT16 n = OBJ_GetNoOfObjects(i);
   26818:	8809883a 	mov	r4,r17
   2681c:	00249600 	call	24960 <OBJ_GetNoOfObjects>
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26820:	8c400044 	addi	r17,r17,1
					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
   26824:	9080000d 	sth	r2,0(r18)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26828:	88800158 	cmpnei	r2,r17,5
   2682c:	94800084 	addi	r18,r18,2
   26830:	103ff91e 	bne	r2,zero,26818 <SDOS_SdoInfoInd+0xbc>
				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
   26834:	00800484 	movi	r2,18
			pSdoInfoInd->MbxHeader.Length = size;
   26838:	8080000d 	sth	r2,0(r16)
			if (abort == 0)
   2683c:	d8800143 	ldbu	r2,5(sp)
   26840:	10007d1e 	bne	r2,zero,26a38 <SDOS_SdoInfoInd+0x2dc>
				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26844:	8080020b 	ldhu	r2,8(r16)
   26848:	00ffe004 	movi	r3,-128
   2684c:	10c6703a 	and	r3,r2,r3
				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
   26850:	18c00094 	ori	r3,r3,2
   26854:	80c0020d 	sth	r3,8(r16)
				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
   26858:	d0e1778b 	ldhu	r3,-31266(gp)
   2685c:	80c0028d 	sth	r3,10(r16)
				if (nSdoInfoFragmentsLeft)
   26860:	18ffffcc 	andi	r3,r3,65535
   26864:	18007426 	beq	r3,zero,26a38 <SDOS_SdoInfoInd+0x2dc>
					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
   26868:	00ffc004 	movi	r3,-256
   2686c:	10c4703a 	and	r2,r2,r3
   26870:	10802094 	ori	r2,r2,130
   26874:	8080020d 	sth	r2,8(r16)
					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
   26878:	017fe084 	movi	r5,-126
	}

	if (abort)
   2687c:	d8c00143 	ldbu	r3,5(sp)
   26880:	18000d26 	beq	r3,zero,268b8 <SDOS_SdoInfoInd+0x15c>
	{
		/* send a SDO Information Error response */
		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
   26884:	00800284 	movi	r2,10
   26888:	8080000d 	sth	r2,0(r16)

		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   2688c:	8080020b 	ldhu	r2,8(r16)
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);

		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   26890:	180690ba 	slli	r3,r3,2
		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26894:	8000028d 	sth	zero,10(r16)
		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26898:	10bfe00c 	andi	r2,r2,65408
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
   2689c:	108001d4 	ori	r2,r2,7
   268a0:	8080020d 	sth	r2,8(r16)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   268a4:	008000b4 	movhi	r2,2
   268a8:	1885883a 	add	r2,r3,r2
   268ac:	109fd817 	ldw	r2,32608(r2)

		nSdoInfoFragmentsLeft = 0;
   268b0:	d021778d 	sth	zero,-31266(gp)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   268b4:	80800315 	stw	r2,12(r16)
	}

	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
   268b8:	29403fcc 	andi	r5,r5,255
   268bc:	8009883a 	mov	r4,r16
   268c0:	002426c0 	call	2426c <MBX_MailboxSendReq>
   268c4:	10803fcc 	andi	r2,r2,255
   268c8:	10000126 	beq	r2,zero,268d0 <SDOS_SdoInfoInd+0x174>
	{
		/* if the mailbox response could not be sent (or stored), the response will be
		   stored in the variable pCoeSendStored and will be sent automatically
			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
			the next time from the master */
		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
   268cc:	d4214b15 	stw	r16,-31444(gp)
	}

	return 0;
   268d0:	0005883a 	mov	r2,zero
}
   268d4:	dfc00717 	ldw	ra,28(sp)
   268d8:	dd000617 	ldw	r20,24(sp)
   268dc:	dcc00517 	ldw	r19,20(sp)
   268e0:	dc800417 	ldw	r18,16(sp)
   268e4:	dc400317 	ldw	r17,12(sp)
   268e8:	dc000217 	ldw	r16,8(sp)
   268ec:	dec00804 	addi	sp,sp,32
   268f0:	f800283a 	ret
				if (nSdoInfoFragmentsLeft)
   268f4:	d4a1778b 	ldhu	r18,-31266(gp)
			if (listType-- == 0)
   268f8:	8c7fffc4 	addi	r17,r17,-1
					n = OBJ_GetNoOfObjects(listType);
   268fc:	8c403fcc 	andi	r17,r17,255
				if (nSdoInfoFragmentsLeft)
   26900:	90bfffcc 	andi	r2,r18,65535
   26904:	10001426 	beq	r2,zero,26958 <SDOS_SdoInfoInd+0x1fc>
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   26908:	d4e16c8b 	ldhu	r19,-31310(gp)
					index = nSdoInfoIndex;
   2690c:	d0a1770b 	ldhu	r2,-31268(gp)
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
   26910:	85000304 	addi	r20,r16,12
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   26914:	9cfffd04 	addi	r19,r19,-12
					index = nSdoInfoIndex;
   26918:	d880018d 	sth	r2,6(sp)
					nSdoInfoFragmentsLeft--;
   2691c:	94bfffc4 	addi	r18,r18,-1
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   26920:	d8800144 	addi	r2,sp,5
   26924:	d8800015 	stw	r2,0(sp)
   26928:	a00f883a 	mov	r7,r20
   2692c:	99bfffcc 	andi	r6,r19,65535
   26930:	d9400184 	addi	r5,sp,6
   26934:	8809883a 	mov	r4,r17
					nSdoInfoFragmentsLeft--;
   26938:	d4a1778d 	sth	r18,-31266(gp)
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   2693c:	0024a180 	call	24a18 <OBJ_GetObjectList>
				nSdoInfoIndex = index;
   26940:	d8c0018b 	ldhu	r3,6(sp)
   26944:	d0e1770d 	sth	r3,-31268(gp)
					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
   26948:	d0e16c8b 	ldhu	r3,-31310(gp)
   2694c:	18fffe84 	addi	r3,r3,-6
   26950:	1885c83a 	sub	r2,r3,r2
   26954:	003fb806 	br	26838 <SDOS_SdoInfoInd+0xdc>
					n = OBJ_GetNoOfObjects(listType);
   26958:	8809883a 	mov	r4,r17
   2695c:	00249600 	call	24960 <OBJ_GetNoOfObjects>
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26960:	d1616c8b 	ldhu	r5,-31310(gp)
					if ((n << 1) > size)
   26964:	113fffcc 	andi	r4,r2,65535
					index = 0x1000;
   26968:	00c40004 	movi	r3,4096
					if ((n << 1) > size)
   2696c:	2008907a 	slli	r4,r4,1
					index = 0x1000;
   26970:	d8c0018d 	sth	r3,6(sp)
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26974:	28fffc84 	addi	r3,r5,-14
					if ((n << 1) > size)
   26978:	18bfffcc 	andi	r2,r3,65535
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   2697c:	1827883a 	mov	r19,r3
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
   26980:	85000384 	addi	r20,r16,14
					if ((n << 1) > size)
   26984:	113fe60e 	bge	r2,r4,26920 <SDOS_SdoInfoInd+0x1c4>
						UINT16 Fragsize = size + 2;
   26988:	297ffd04 	addi	r5,r5,-12
						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
   2698c:	297fffcc 	andi	r5,r5,65535
   26990:	2089c83a 	sub	r4,r4,r2
   26994:	28bfffc4 	addi	r2,r5,-1
   26998:	2089883a 	add	r4,r4,r2
   2699c:	0026e780 	call	26e78 <__divsi3>
   269a0:	1025883a 	mov	r18,r2
   269a4:	003fde06 	br	26920 <SDOS_SdoInfoInd+0x1c4>
			pObjEntry = OBJ_GetObjectHandle(index);
   269a8:	00246240 	call	24624 <OBJ_GetObjectHandle>
   269ac:	1023883a 	mov	r17,r2
			if (pObjEntry)
   269b0:	10005c26 	beq	r2,zero,26b24 <SDOS_SdoInfoInd+0x3c8>
				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
   269b4:	9cc000d8 	cmpnei	r19,r19,3
   269b8:	9800211e 	bne	r19,zero,26a40 <SDOS_SdoInfoInd+0x2e4>
					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
   269bc:	1009883a 	mov	r4,r2
   269c0:	0024b600 	call	24b60 <OBJ_GetObjDesc>
   269c4:	01800104 	movi	r6,4
   269c8:	100b883a 	mov	r5,r2
   269cc:	81000384 	addi	r4,r16,14
   269d0:	002735c0 	call	2735c <memcpy>
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   269d4:	d900018b 	ldhu	r4,6(sp)
   269d8:	000f883a 	mov	r7,zero
   269dc:	880d883a 	mov	r6,r17
   269e0:	000b883a 	mov	r5,zero
   269e4:	00247ec0 	call	247ec <OBJ_GetDesc>
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   269e8:	d0e16c8b 	ldhu	r3,-31310(gp)
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   269ec:	10800304 	addi	r2,r2,12
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   269f0:	10bfffcc 	andi	r2,r2,65535
   269f4:	18fffec4 	addi	r3,r3,-5
   269f8:	10c0460e 	bge	r2,r3,26b14 <SDOS_SdoInfoInd+0x3b8>
						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
   269fc:	d900018b 	ldhu	r4,6(sp)
   26a00:	81c00484 	addi	r7,r16,18
   26a04:	880d883a 	mov	r6,r17
   26a08:	000b883a 	mov	r5,zero
   26a0c:	00247ec0 	call	247ec <OBJ_GetDesc>
   26a10:	10800304 	addi	r2,r2,12
				if (abort == 0)
   26a14:	d8c00143 	ldbu	r3,5(sp)
   26a18:	1800071e 	bne	r3,zero,26a38 <SDOS_SdoInfoInd+0x2dc>
						pSdoInfoInd->MbxHeader.Length = size;
   26a1c:	8080000d 	sth	r2,0(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26a20:	8080020b 	ldhu	r2,8(r16)
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26a24:	94800044 	addi	r18,r18,1
						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26a28:	8000028d 	sth	zero,10(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26a2c:	10bfe00c 	andi	r2,r2,65408
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26a30:	14a4b03a 	or	r18,r2,r18
   26a34:	8480020d 	sth	r18,8(r16)
	UINT8 flags = COE_SERVICE;
   26a38:	01400084 	movi	r5,2
   26a3c:	003f8f06 	br	2687c <SDOS_SdoInfoInd+0x120>
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26a40:	1009883a 	mov	r4,r2
					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
   26a44:	84c00383 	ldbu	r19,14(r16)
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26a48:	0024b600 	call	24b60 <OBJ_GetObjDesc>
					if (subindex <= maxSubindex)
   26a4c:	10800083 	ldbu	r2,2(r2)
   26a50:	9cc03fcc 	andi	r19,r19,255
   26a54:	14c02b36 	bltu	r2,r19,26b04 <SDOS_SdoInfoInd+0x3a8>
						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
   26a58:	980b883a 	mov	r5,r19
   26a5c:	8809883a 	mov	r4,r17
   26a60:	00249240 	call	24924 <OBJ_GetEntryDesc>
   26a64:	01800184 	movi	r6,6
   26a68:	100b883a 	mov	r5,r2
   26a6c:	81000404 	addi	r4,r16,16
   26a70:	002735c0 	call	2735c <memcpy>
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26a74:	80800383 	ldbu	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26a78:	8809883a 	mov	r4,r17
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26a7c:	8080038d 	sth	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26a80:	0024b600 	call	24b60 <OBJ_GetObjDesc>
						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   26a84:	1080008b 	ldhu	r2,2(r2)
   26a88:	1005d23a 	srai	r2,r2,8
   26a8c:	108003cc 	andi	r2,r2,15
						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
   26a90:	10bffe04 	addi	r2,r2,-8
   26a94:	10bfffcc 	andi	r2,r2,65535
   26a98:	108000a8 	cmpgeui	r2,r2,2
   26a9c:	1000081e 	bne	r2,zero,26ac0 <SDOS_SdoInfoInd+0x364>
   26aa0:	9800071e 	bne	r19,zero,26ac0 <SDOS_SdoInfoInd+0x364>
							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
   26aa4:	014000f4 	movhi	r5,3
   26aa8:	01800344 	movi	r6,13
   26aac:	2960d704 	addi	r5,r5,-31908
   26ab0:	81000584 	addi	r4,r16,22
   26ab4:	002735c0 	call	2735c <memcpy>
							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
   26ab8:	00800704 	movi	r2,28
   26abc:	003fd506 	br	26a14 <SDOS_SdoInfoInd+0x2b8>
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26ac0:	d900018b 	ldhu	r4,6(sp)
   26ac4:	000f883a 	mov	r7,zero
   26ac8:	880d883a 	mov	r6,r17
   26acc:	980b883a 	mov	r5,r19
   26ad0:	00247ec0 	call	247ec <OBJ_GetDesc>
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   26ad4:	d0e16c8b 	ldhu	r3,-31310(gp)
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26ad8:	10800404 	addi	r2,r2,16
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   26adc:	10bfffcc 	andi	r2,r2,65535
   26ae0:	18fffec4 	addi	r3,r3,-5
   26ae4:	10c00d0e 	bge	r2,r3,26b1c <SDOS_SdoInfoInd+0x3c0>
								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26ae8:	d900018b 	ldhu	r4,6(sp)
   26aec:	81c00584 	addi	r7,r16,22
   26af0:	880d883a 	mov	r6,r17
   26af4:	980b883a 	mov	r5,r19
   26af8:	00247ec0 	call	247ec <OBJ_GetDesc>
   26afc:	10800404 	addi	r2,r2,16
   26b00:	003fc406 	br	26a14 <SDOS_SdoInfoInd+0x2b8>
						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
   26b04:	00800444 	movi	r2,17
   26b08:	d8800145 	stb	r2,5(sp)
				UINT16 size = 0;
   26b0c:	0005883a 	mov	r2,zero
   26b10:	003fc006 	br	26a14 <SDOS_SdoInfoInd+0x2b8>
						size = SIZEOF_SDOINFOOBJSTRUCT;
   26b14:	00800304 	movi	r2,12
   26b18:	003fbe06 	br	26a14 <SDOS_SdoInfoInd+0x2b8>
								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26b1c:	00800404 	movi	r2,16
   26b20:	003fbc06 	br	26a14 <SDOS_SdoInfoInd+0x2b8>
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26b24:	00800204 	movi	r2,8
   26b28:	003f2c06 	br	267dc <SDOS_SdoInfoInd+0x80>
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   26b2c:	008000c4 	movi	r2,3
   26b30:	003f2a06 	br	267dc <SDOS_SdoInfoInd+0x80>

00026b34 <delay_ms>:
#include "system.h"
#include "stdint.h"

// Delay function
// No Parameters
void delay_ms(int milliseconds) {
   26b34:	deffff04 	addi	sp,sp,-4
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b38:	0140fa04 	movi	r5,1000
void delay_ms(int milliseconds) {
   26b3c:	dfc00015 	stw	ra,0(sp)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b40:	002702c0 	call	2702c <__mulsi3>
   26b44:	1009883a 	mov	r4,r2
}
   26b48:	dfc00017 	ldw	ra,0(sp)
   26b4c:	dec00104 	addi	sp,sp,4
    usleep(milliseconds * 1000);  // Convert to microseconds
   26b50:	00277041 	jmpi	27704 <usleep>

00026b54 <adc_init>:
// Parameter 2: Base address for SPI Chip Select Manual
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){

	int spi_check = -1;
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   26b54:	008100f4 	movhi	r2,1027
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   26b58:	defff404 	addi	sp,sp,-48
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   26b5c:	10804044 	addi	r2,r2,257
   26b60:	d8800415 	stw	r2,16(sp)
	alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   26b64:	00954184 	movi	r2,21766
   26b68:	d8800515 	stw	r2,20(sp)
	alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
   26b6c:	008201f4 	movhi	r2,2055
   26b70:	10818144 	addi	r2,r2,1541
   26b74:	d8800615 	stw	r2,24(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26b78:	00954144 	movi	r2,21765
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   26b7c:	dc400a15 	stw	r17,40(sp)
   26b80:	dc000915 	stw	r16,36(sp)
   26b84:	dfc00b15 	stw	ra,44(sp)
   26b88:	2021883a 	mov	r16,r4
   26b8c:	2823883a 	mov	r17,r5
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26b90:	d8000315 	stw	zero,12(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26b94:	d8800715 	stw	r2,28(sp)
	uint8_t opcode_lock_receive[4] = {0x00, 0x00, 0x00, 0x00};
   26b98:	d8000815 	stw	zero,32(sp)

	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26b9c:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26ba0:	0104e204 	movi	r4,5000
   26ba4:	00277040 	call	27704 <usleep>
	delay_ms(5);
	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   26ba8:	00800044 	movi	r2,1
   26bac:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26bb0:	01138804 	movi	r4,20000
   26bb4:	00277040 	call	27704 <usleep>
	delay_ms(20);

	spi_check = alt_avalon_spi_command(base,
   26bb8:	d9c00304 	addi	r7,sp,12
   26bbc:	01800104 	movi	r6,4
   26bc0:	000b883a 	mov	r5,zero
   26bc4:	8009883a 	mov	r4,r16
   26bc8:	d8000215 	stw	zero,8(sp)
   26bcc:	d8000115 	stw	zero,4(sp)
   26bd0:	d8000015 	stw	zero,0(sp)
   26bd4:	00277b80 	call	277b8 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26bd8:	0130d414 	movui	r4,50000
   26bdc:	00277040 	call	27704 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26be0:	04400104 	movi	r17,4
   26be4:	d8800404 	addi	r2,sp,16
   26be8:	8009883a 	mov	r4,r16
   26bec:	d8000215 	stw	zero,8(sp)
   26bf0:	d8800115 	stw	r2,4(sp)
   26bf4:	dc400015 	stw	r17,0(sp)
   26bf8:	000f883a 	mov	r7,zero
   26bfc:	000d883a 	mov	r6,zero
   26c00:	000b883a 	mov	r5,zero
   26c04:	00277b80 	call	277b8 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_null_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26c08:	d9c00504 	addi	r7,sp,20
   26c0c:	01800104 	movi	r6,4
   26c10:	000b883a 	mov	r5,zero
   26c14:	8009883a 	mov	r4,r16
   26c18:	d8000215 	stw	zero,8(sp)
   26c1c:	d8000115 	stw	zero,4(sp)
   26c20:	d8000015 	stw	zero,0(sp)
   26c24:	00277b80 	call	277b8 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26c28:	0130d414 	movui	r4,50000
   26c2c:	00277040 	call	27704 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26c30:	d8800604 	addi	r2,sp,24
   26c34:	8009883a 	mov	r4,r16
   26c38:	d8000215 	stw	zero,8(sp)
   26c3c:	d8800115 	stw	r2,4(sp)
   26c40:	dc400015 	stw	r17,0(sp)
   26c44:	000f883a 	mov	r7,zero
   26c48:	000d883a 	mov	r6,zero
   26c4c:	000b883a 	mov	r5,zero
   26c50:	00277b80 	call	277b8 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26c54:	d9c00704 	addi	r7,sp,28
   26c58:	01800104 	movi	r6,4
   26c5c:	000b883a 	mov	r5,zero
   26c60:	8009883a 	mov	r4,r16
   26c64:	d8000215 	stw	zero,8(sp)
   26c68:	d8000115 	stw	zero,4(sp)
   26c6c:	d8000015 	stw	zero,0(sp)
   26c70:	00277b80 	call	277b8 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26c74:	0130d414 	movui	r4,50000
   26c78:	00277040 	call	27704 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26c7c:	d8800804 	addi	r2,sp,32
   26c80:	000f883a 	mov	r7,zero
   26c84:	000d883a 	mov	r6,zero
   26c88:	000b883a 	mov	r5,zero
   26c8c:	8009883a 	mov	r4,r16
   26c90:	d8000215 	stw	zero,8(sp)
   26c94:	d8800115 	stw	r2,4(sp)
   26c98:	dc400015 	stw	r17,0(sp)
   26c9c:	00277b80 	call	277b8 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26ca0:	0130d414 	movui	r4,50000
   26ca4:	00277040 	call	27704 <usleep>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);
	 delay_ms(50);
}
   26ca8:	dfc00b17 	ldw	ra,44(sp)
   26cac:	dc400a17 	ldw	r17,40(sp)
   26cb0:	dc000917 	ldw	r16,36(sp)
   26cb4:	dec00c04 	addi	sp,sp,48
   26cb8:	f800283a 	ret

00026cbc <spi_transmit_receive>:
    alt_u8 *rx_ptr = rx_buf;
    const alt_u8 *tx_end = tx_buf ? (tx_buf + length) : NULL;
    alt_u8 dummy_tx = 0xFF;

    // 1. Select slave
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26cbc:	00c00044 	movi	r3,1
{
   26cc0:	d8800017 	ldw	r2,0(sp)
   26cc4:	da000117 	ldw	r8,4(sp)
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26cc8:	1946983a 	sll	r3,r3,r5
   26ccc:	20c00535 	stwio	r3,20(r4)

    // 2. Assert CS unless toggle flag is set
    if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   26cd0:	40c0008c 	andi	r3,r8,2
   26cd4:	1800021e 	bne	r3,zero,26ce0 <spi_transmit_receive+0x24>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   26cd8:	00c10004 	movi	r3,1024
   26cdc:	20c00335 	stwio	r3,12(r4)
    }

    // 3. Clear stale RX
    IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26ce0:	20c00037 	ldwio	r3,0(r4)
    alt_32 credits = 1;
   26ce4:	00c00044 	movi	r3,1
    alt_u8 *rx_ptr = rx_buf;
   26ce8:	3813883a 	mov	r9,r7

    while ((rx_ptr - rx_buf) < length)
   26cec:	49cbc83a 	sub	r5,r9,r7
   26cf0:	22800204 	addi	r10,r4,8
   26cf4:	28800736 	bltu	r5,r2,26d14 <spi_transmit_receive+0x58>
        }
    }

    // Wait until TX FIFO is empty (transmit complete)
    do {
        status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26cf8:	50c00037 	ldwio	r3,0(r10)
    } while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   26cfc:	18c0080c 	andi	r3,r3,32
   26d00:	183ffd26 	beq	r3,zero,26cf8 <spi_transmit_receive+0x3c>

    // Release chip select unless merging
    if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0) {
   26d04:	4200004c 	andi	r8,r8,1
   26d08:	4000011e 	bne	r8,zero,26d10 <spi_transmit_receive+0x54>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   26d0c:	20000335 	stwio	zero,12(r4)
    }

    return length;
}
   26d10:	f800283a 	ret
            status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26d14:	51400037 	ldwio	r5,0(r10)
        } while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   26d18:	2ac0100c 	andi	r11,r5,64
   26d1c:	2940200c 	andi	r5,r5,128
   26d20:	58000126 	beq	r11,zero,26d28 <spi_transmit_receive+0x6c>
   26d24:	1800031e 	bne	r3,zero,26d34 <spi_transmit_receive+0x78>
   26d28:	283ffa26 	beq	r5,zero,26d14 <spi_transmit_receive+0x58>
        if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) && credits > 0) {
   26d2c:	58000726 	beq	r11,zero,26d4c <spi_transmit_receive+0x90>
   26d30:	18000626 	beq	r3,zero,26d4c <spi_transmit_receive+0x90>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   26d34:	30000b26 	beq	r6,zero,26d64 <spi_transmit_receive+0xa8>
   26d38:	32800003 	ldbu	r10,0(r6)
   26d3c:	31800044 	addi	r6,r6,1
            IOWR_ALTERA_AVALON_SPI_TXDATA(base, tx_data);
   26d40:	52803fcc 	andi	r10,r10,255
   26d44:	22800135 	stwio	r10,4(r4)
            credits--;
   26d48:	18ffffc4 	addi	r3,r3,-1
        if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) {
   26d4c:	283fe726 	beq	r5,zero,26cec <spi_transmit_receive+0x30>
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26d50:	21400037 	ldwio	r5,0(r4)
   26d54:	49400005 	stb	r5,0(r9)
            credits++;
   26d58:	18c00044 	addi	r3,r3,1
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26d5c:	4a400044 	addi	r9,r9,1
   26d60:	003fe206 	br	26cec <spi_transmit_receive+0x30>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   26d64:	02bfffc4 	movi	r10,-1
   26d68:	003ff506 	br	26d40 <spi_transmit_receive+0x84>

00026d6c <adc_init_spi_transmit_receive>:

// ADC Initialization Using Full-Duplex SPI
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26d6c:	defff304 	addi	sp,sp,-52
	int spi_check = -1;
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
		alt_u8 opcode_null_receive[4] = {0x01, 0x02, 0x03, 0x04};
		alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   26d70:	00954184 	movi	r2,21766
   26d74:	d8800515 	stw	r2,20(sp)
		alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
		uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26d78:	00954144 	movi	r2,21765
   26d7c:	d8800715 	stw	r2,28(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   26d80:	00824274 	movhi	r2,2313
   26d84:	108201c4 	addi	r2,r2,2055
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26d88:	dc400a15 	stw	r17,40(sp)
   26d8c:	dc000915 	stw	r16,36(sp)
   26d90:	dfc00c15 	stw	ra,48(sp)
   26d94:	dc800b15 	stw	r18,44(sp)
   26d98:	2021883a 	mov	r16,r4
   26d9c:	2823883a 	mov	r17,r5
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26da0:	d8000315 	stw	zero,12(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   26da4:	d8800815 	stw	r2,32(sp)

		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26da8:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26dac:	0104e204 	movi	r4,5000
   26db0:	00277040 	call	27704 <usleep>
		delay_ms(5);
		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   26db4:	00800044 	movi	r2,1
   26db8:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26dbc:	01138804 	movi	r4,20000
   26dc0:	00277040 	call	27704 <usleep>
		delay_ms(20);

		spi_check = spi_transmit_receive(	base,
   26dc4:	04400104 	movi	r17,4
   26dc8:	d9c00404 	addi	r7,sp,16
   26dcc:	d9800304 	addi	r6,sp,12
   26dd0:	000b883a 	mov	r5,zero
   26dd4:	8009883a 	mov	r4,r16
   26dd8:	d8000115 	stw	zero,4(sp)
   26ddc:	dc400015 	stw	r17,0(sp)
   26de0:	0026cbc0 	call	26cbc <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26de4:	0100fa04 	movi	r4,1000
   26de8:	00277040 	call	27704 <usleep>
											4,
											0							// Special control flags for the SPI command
											);

				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26dec:	d9c00604 	addi	r7,sp,24
   26df0:	d9800504 	addi	r6,sp,20
   26df4:	000b883a 	mov	r5,zero
   26df8:	8009883a 	mov	r4,r16
   26dfc:	d8000115 	stw	zero,4(sp)
   26e00:	dc400015 	stw	r17,0(sp)
   26e04:	0026cbc0 	call	26cbc <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26e08:	0100fa04 	movi	r4,1000
   26e0c:	00277040 	call	27704 <usleep>
											opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26e10:	dc800804 	addi	r18,sp,32
   26e14:	900f883a 	mov	r7,r18
   26e18:	d9800704 	addi	r6,sp,28
   26e1c:	000b883a 	mov	r5,zero
   26e20:	8009883a 	mov	r4,r16
   26e24:	d8000115 	stw	zero,4(sp)
   26e28:	dc400015 	stw	r17,0(sp)
   26e2c:	0026cbc0 	call	26cbc <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26e30:	0100fa04 	movi	r4,1000
   26e34:	00277040 	call	27704 <usleep>
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = alt_avalon_spi_command(base,
   26e38:	000f883a 	mov	r7,zero
   26e3c:	000d883a 	mov	r6,zero
   26e40:	000b883a 	mov	r5,zero
   26e44:	8009883a 	mov	r4,r16
   26e48:	d8000215 	stw	zero,8(sp)
   26e4c:	dc800115 	stw	r18,4(sp)
   26e50:	dc400015 	stw	r17,0(sp)
   26e54:	00277b80 	call	277b8 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26e58:	0100fa04 	movi	r4,1000
   26e5c:	00277040 	call	27704 <usleep>
											4,							// The number of bytes to read from the SPI slave, '0' if only writing
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
}
   26e60:	dfc00c17 	ldw	ra,48(sp)
   26e64:	dc800b17 	ldw	r18,44(sp)
   26e68:	dc400a17 	ldw	r17,40(sp)
   26e6c:	dc000917 	ldw	r16,36(sp)
   26e70:	dec00d04 	addi	sp,sp,52
   26e74:	f800283a 	ret

00026e78 <__divsi3>:
   26e78:	20001a16 	blt	r4,zero,26ee4 <__divsi3+0x6c>
   26e7c:	000f883a 	mov	r7,zero
   26e80:	2800020e 	bge	r5,zero,26e8c <__divsi3+0x14>
   26e84:	014bc83a 	sub	r5,zero,r5
   26e88:	39c0005c 	xori	r7,r7,1
   26e8c:	200d883a 	mov	r6,r4
   26e90:	00c00044 	movi	r3,1
   26e94:	2900092e 	bgeu	r5,r4,26ebc <__divsi3+0x44>
   26e98:	00800804 	movi	r2,32
   26e9c:	00c00044 	movi	r3,1
   26ea0:	00000106 	br	26ea8 <__divsi3+0x30>
   26ea4:	10001226 	beq	r2,zero,26ef0 <__divsi3+0x78>
   26ea8:	294b883a 	add	r5,r5,r5
   26eac:	10bfffc4 	addi	r2,r2,-1
   26eb0:	18c7883a 	add	r3,r3,r3
   26eb4:	293ffb36 	bltu	r5,r4,26ea4 <__divsi3+0x2c>
   26eb8:	18000d26 	beq	r3,zero,26ef0 <__divsi3+0x78>
   26ebc:	0005883a 	mov	r2,zero
   26ec0:	31400236 	bltu	r6,r5,26ecc <__divsi3+0x54>
   26ec4:	314dc83a 	sub	r6,r6,r5
   26ec8:	10c4b03a 	or	r2,r2,r3
   26ecc:	1806d07a 	srli	r3,r3,1
   26ed0:	280ad07a 	srli	r5,r5,1
   26ed4:	183ffa1e 	bne	r3,zero,26ec0 <__divsi3+0x48>
   26ed8:	38000126 	beq	r7,zero,26ee0 <__divsi3+0x68>
   26edc:	0085c83a 	sub	r2,zero,r2
   26ee0:	f800283a 	ret
   26ee4:	0109c83a 	sub	r4,zero,r4
   26ee8:	01c00044 	movi	r7,1
   26eec:	003fe406 	br	26e80 <__divsi3+0x8>
   26ef0:	0005883a 	mov	r2,zero
   26ef4:	003ff806 	br	26ed8 <__divsi3+0x60>

00026ef8 <__modsi3>:
   26ef8:	20001716 	blt	r4,zero,26f58 <__modsi3+0x60>
   26efc:	000f883a 	mov	r7,zero
   26f00:	2005883a 	mov	r2,r4
   26f04:	2800010e 	bge	r5,zero,26f0c <__modsi3+0x14>
   26f08:	014bc83a 	sub	r5,zero,r5
   26f0c:	00c00044 	movi	r3,1
   26f10:	2900092e 	bgeu	r5,r4,26f38 <__modsi3+0x40>
   26f14:	01800804 	movi	r6,32
   26f18:	00c00044 	movi	r3,1
   26f1c:	00000106 	br	26f24 <__modsi3+0x2c>
   26f20:	30001026 	beq	r6,zero,26f64 <__modsi3+0x6c>
   26f24:	294b883a 	add	r5,r5,r5
   26f28:	31bfffc4 	addi	r6,r6,-1
   26f2c:	18c7883a 	add	r3,r3,r3
   26f30:	293ffb36 	bltu	r5,r4,26f20 <__modsi3+0x28>
   26f34:	18000b26 	beq	r3,zero,26f64 <__modsi3+0x6c>
   26f38:	1806d07a 	srli	r3,r3,1
   26f3c:	11400136 	bltu	r2,r5,26f44 <__modsi3+0x4c>
   26f40:	1145c83a 	sub	r2,r2,r5
   26f44:	280ad07a 	srli	r5,r5,1
   26f48:	183ffb1e 	bne	r3,zero,26f38 <__modsi3+0x40>
   26f4c:	38000126 	beq	r7,zero,26f54 <__modsi3+0x5c>
   26f50:	0085c83a 	sub	r2,zero,r2
   26f54:	f800283a 	ret
   26f58:	0109c83a 	sub	r4,zero,r4
   26f5c:	01c00044 	movi	r7,1
   26f60:	003fe706 	br	26f00 <__modsi3+0x8>
   26f64:	2005883a 	mov	r2,r4
   26f68:	003ff806 	br	26f4c <__modsi3+0x54>

00026f6c <__udivsi3>:
   26f6c:	200d883a 	mov	r6,r4
   26f70:	2900152e 	bgeu	r5,r4,26fc8 <__udivsi3+0x5c>
   26f74:	28001416 	blt	r5,zero,26fc8 <__udivsi3+0x5c>
   26f78:	00800804 	movi	r2,32
   26f7c:	00c00044 	movi	r3,1
   26f80:	00000206 	br	26f8c <__udivsi3+0x20>
   26f84:	10000e26 	beq	r2,zero,26fc0 <__udivsi3+0x54>
   26f88:	28000416 	blt	r5,zero,26f9c <__udivsi3+0x30>
   26f8c:	294b883a 	add	r5,r5,r5
   26f90:	10bfffc4 	addi	r2,r2,-1
   26f94:	18c7883a 	add	r3,r3,r3
   26f98:	293ffa36 	bltu	r5,r4,26f84 <__udivsi3+0x18>
   26f9c:	18000826 	beq	r3,zero,26fc0 <__udivsi3+0x54>
   26fa0:	0005883a 	mov	r2,zero
   26fa4:	31400236 	bltu	r6,r5,26fb0 <__udivsi3+0x44>
   26fa8:	314dc83a 	sub	r6,r6,r5
   26fac:	10c4b03a 	or	r2,r2,r3
   26fb0:	1806d07a 	srli	r3,r3,1
   26fb4:	280ad07a 	srli	r5,r5,1
   26fb8:	183ffa1e 	bne	r3,zero,26fa4 <__udivsi3+0x38>
   26fbc:	f800283a 	ret
   26fc0:	0005883a 	mov	r2,zero
   26fc4:	f800283a 	ret
   26fc8:	00c00044 	movi	r3,1
   26fcc:	003ff406 	br	26fa0 <__udivsi3+0x34>

00026fd0 <__umodsi3>:
   26fd0:	2005883a 	mov	r2,r4
   26fd4:	2900132e 	bgeu	r5,r4,27024 <__umodsi3+0x54>
   26fd8:	28001216 	blt	r5,zero,27024 <__umodsi3+0x54>
   26fdc:	01800804 	movi	r6,32
   26fe0:	00c00044 	movi	r3,1
   26fe4:	00000206 	br	26ff0 <__umodsi3+0x20>
   26fe8:	30000c26 	beq	r6,zero,2701c <__umodsi3+0x4c>
   26fec:	28000416 	blt	r5,zero,27000 <__umodsi3+0x30>
   26ff0:	294b883a 	add	r5,r5,r5
   26ff4:	31bfffc4 	addi	r6,r6,-1
   26ff8:	18c7883a 	add	r3,r3,r3
   26ffc:	293ffa36 	bltu	r5,r4,26fe8 <__umodsi3+0x18>
   27000:	18000626 	beq	r3,zero,2701c <__umodsi3+0x4c>
   27004:	1806d07a 	srli	r3,r3,1
   27008:	11400136 	bltu	r2,r5,27010 <__umodsi3+0x40>
   2700c:	1145c83a 	sub	r2,r2,r5
   27010:	280ad07a 	srli	r5,r5,1
   27014:	183ffb1e 	bne	r3,zero,27004 <__umodsi3+0x34>
   27018:	f800283a 	ret
   2701c:	2005883a 	mov	r2,r4
   27020:	f800283a 	ret
   27024:	00c00044 	movi	r3,1
   27028:	003ff606 	br	27004 <__umodsi3+0x34>

0002702c <__mulsi3>:
   2702c:	0005883a 	mov	r2,zero
   27030:	20000726 	beq	r4,zero,27050 <__mulsi3+0x24>
   27034:	20c0004c 	andi	r3,r4,1
   27038:	2008d07a 	srli	r4,r4,1
   2703c:	18000126 	beq	r3,zero,27044 <__mulsi3+0x18>
   27040:	1145883a 	add	r2,r2,r5
   27044:	294b883a 	add	r5,r5,r5
   27048:	203ffa1e 	bne	r4,zero,27034 <__mulsi3+0x8>
   2704c:	f800283a 	ret
   27050:	f800283a 	ret

00027054 <malloc>:
   27054:	008000f4 	movhi	r2,3
   27058:	200b883a 	mov	r5,r4
   2705c:	11210b17 	ldw	r4,-31700(r2)
   27060:	00271001 	jmpi	27100 <_malloc_r>

00027064 <free>:
   27064:	008000f4 	movhi	r2,3
   27068:	200b883a 	mov	r5,r4
   2706c:	11210b17 	ldw	r4,-31700(r2)
   27070:	00274081 	jmpi	27408 <_free_r>

00027074 <sbrk_aligned>:
   27074:	008000f4 	movhi	r2,3
   27078:	10a27117 	ldw	r2,-30268(r2)
   2707c:	defffd04 	addi	sp,sp,-12
   27080:	dc400115 	stw	r17,4(sp)
   27084:	dc000015 	stw	r16,0(sp)
   27088:	dfc00215 	stw	ra,8(sp)
   2708c:	2023883a 	mov	r17,r4
   27090:	2821883a 	mov	r16,r5
   27094:	1000041e 	bne	r2,zero,270a8 <sbrk_aligned+0x34>
   27098:	000b883a 	mov	r5,zero
   2709c:	00273c00 	call	273c0 <_sbrk_r>
   270a0:	00c000f4 	movhi	r3,3
   270a4:	18a27115 	stw	r2,-30268(r3)
   270a8:	800b883a 	mov	r5,r16
   270ac:	8809883a 	mov	r4,r17
   270b0:	00273c00 	call	273c0 <_sbrk_r>
   270b4:	10ffffd8 	cmpnei	r3,r2,-1
   270b8:	1800071e 	bne	r3,zero,270d8 <sbrk_aligned+0x64>
   270bc:	043fffc4 	movi	r16,-1
   270c0:	8005883a 	mov	r2,r16
   270c4:	dfc00217 	ldw	ra,8(sp)
   270c8:	dc400117 	ldw	r17,4(sp)
   270cc:	dc000017 	ldw	r16,0(sp)
   270d0:	dec00304 	addi	sp,sp,12
   270d4:	f800283a 	ret
   270d8:	140000c4 	addi	r16,r2,3
   270dc:	00ffff04 	movi	r3,-4
   270e0:	80e0703a 	and	r16,r16,r3
   270e4:	143ff626 	beq	r2,r16,270c0 <sbrk_aligned+0x4c>
   270e8:	808bc83a 	sub	r5,r16,r2
   270ec:	8809883a 	mov	r4,r17
   270f0:	00273c00 	call	273c0 <_sbrk_r>
   270f4:	10bfffe0 	cmpeqi	r2,r2,-1
   270f8:	103ff126 	beq	r2,zero,270c0 <sbrk_aligned+0x4c>
   270fc:	003fef06 	br	270bc <sbrk_aligned+0x48>

00027100 <_malloc_r>:
   27100:	defffb04 	addi	sp,sp,-20
   27104:	00bfff04 	movi	r2,-4
   27108:	dc400115 	stw	r17,4(sp)
   2710c:	2c4000c4 	addi	r17,r5,3
   27110:	88a2703a 	and	r17,r17,r2
   27114:	8c400204 	addi	r17,r17,8
   27118:	dc800215 	stw	r18,8(sp)
   2711c:	dfc00415 	stw	ra,16(sp)
   27120:	dcc00315 	stw	r19,12(sp)
   27124:	dc000015 	stw	r16,0(sp)
   27128:	88800328 	cmpgeui	r2,r17,12
   2712c:	2025883a 	mov	r18,r4
   27130:	10002a1e 	bne	r2,zero,271dc <_malloc_r+0xdc>
   27134:	04400304 	movi	r17,12
   27138:	89402936 	bltu	r17,r5,271e0 <_malloc_r+0xe0>
   2713c:	9009883a 	mov	r4,r18
   27140:	00276b00 	call	276b0 <__malloc_lock>
   27144:	008000f4 	movhi	r2,3
   27148:	10a27217 	ldw	r2,-30264(r2)
   2714c:	1021883a 	mov	r16,r2
   27150:	80002d1e 	bne	r16,zero,27208 <_malloc_r+0x108>
   27154:	880b883a 	mov	r5,r17
   27158:	9009883a 	mov	r4,r18
   2715c:	00270740 	call	27074 <sbrk_aligned>
   27160:	1021883a 	mov	r16,r2
   27164:	10bfffd8 	cmpnei	r2,r2,-1
   27168:	1000561e 	bne	r2,zero,272c4 <_malloc_r+0x1c4>
   2716c:	008000f4 	movhi	r2,3
   27170:	14227217 	ldw	r16,-30264(r2)
   27174:	8005883a 	mov	r2,r16
   27178:	1000481e 	bne	r2,zero,2729c <_malloc_r+0x19c>
   2717c:	80004c26 	beq	r16,zero,272b0 <_malloc_r+0x1b0>
   27180:	84c00017 	ldw	r19,0(r16)
   27184:	000b883a 	mov	r5,zero
   27188:	9009883a 	mov	r4,r18
   2718c:	84e7883a 	add	r19,r16,r19
   27190:	00273c00 	call	273c0 <_sbrk_r>
   27194:	9880461e 	bne	r19,r2,272b0 <_malloc_r+0x1b0>
   27198:	80800017 	ldw	r2,0(r16)
   2719c:	9009883a 	mov	r4,r18
   271a0:	88a3c83a 	sub	r17,r17,r2
   271a4:	880b883a 	mov	r5,r17
   271a8:	00270740 	call	27074 <sbrk_aligned>
   271ac:	10bfffe0 	cmpeqi	r2,r2,-1
   271b0:	10003f1e 	bne	r2,zero,272b0 <_malloc_r+0x1b0>
   271b4:	80800017 	ldw	r2,0(r16)
   271b8:	1445883a 	add	r2,r2,r17
   271bc:	80800015 	stw	r2,0(r16)
   271c0:	008000f4 	movhi	r2,3
   271c4:	10a27217 	ldw	r2,-30264(r2)
   271c8:	10000226 	beq	r2,zero,271d4 <_malloc_r+0xd4>
   271cc:	10c00117 	ldw	r3,4(r2)
   271d0:	1c00351e 	bne	r3,r16,272a8 <_malloc_r+0x1a8>
   271d4:	10000115 	stw	zero,4(r2)
   271d8:	00001806 	br	2723c <_malloc_r+0x13c>
   271dc:	883fd60e 	bge	r17,zero,27138 <_malloc_r+0x38>
   271e0:	00800304 	movi	r2,12
   271e4:	90800015 	stw	r2,0(r18)
   271e8:	0005883a 	mov	r2,zero
   271ec:	dfc00417 	ldw	ra,16(sp)
   271f0:	dcc00317 	ldw	r19,12(sp)
   271f4:	dc800217 	ldw	r18,8(sp)
   271f8:	dc400117 	ldw	r17,4(sp)
   271fc:	dc000017 	ldw	r16,0(sp)
   27200:	dec00504 	addi	sp,sp,20
   27204:	f800283a 	ret
   27208:	81000017 	ldw	r4,0(r16)
   2720c:	2449c83a 	sub	r4,r4,r17
   27210:	20001f16 	blt	r4,zero,27290 <_malloc_r+0x190>
   27214:	20c00330 	cmpltui	r3,r4,12
   27218:	1800161e 	bne	r3,zero,27274 <_malloc_r+0x174>
   2721c:	84400015 	stw	r17,0(r16)
   27220:	8447883a 	add	r3,r16,r17
   27224:	1400111e 	bne	r2,r16,2726c <_malloc_r+0x16c>
   27228:	008000f4 	movhi	r2,3
   2722c:	10e27215 	stw	r3,-30264(r2)
   27230:	80800117 	ldw	r2,4(r16)
   27234:	19000015 	stw	r4,0(r3)
   27238:	18800115 	stw	r2,4(r3)
   2723c:	9009883a 	mov	r4,r18
   27240:	00276b40 	call	276b4 <__malloc_unlock>
   27244:	013ffe04 	movi	r4,-8
   27248:	808002c4 	addi	r2,r16,11
   2724c:	80c00104 	addi	r3,r16,4
   27250:	1104703a 	and	r2,r2,r4
   27254:	10c9c83a 	sub	r4,r2,r3
   27258:	10ffe426 	beq	r2,r3,271ec <_malloc_r+0xec>
   2725c:	8121883a 	add	r16,r16,r4
   27260:	1887c83a 	sub	r3,r3,r2
   27264:	80c00015 	stw	r3,0(r16)
   27268:	003fe006 	br	271ec <_malloc_r+0xec>
   2726c:	10c00115 	stw	r3,4(r2)
   27270:	003fef06 	br	27230 <_malloc_r+0x130>
   27274:	80c00117 	ldw	r3,4(r16)
   27278:	1400031e 	bne	r2,r16,27288 <_malloc_r+0x188>
   2727c:	008000f4 	movhi	r2,3
   27280:	10e27215 	stw	r3,-30264(r2)
   27284:	003fed06 	br	2723c <_malloc_r+0x13c>
   27288:	10c00115 	stw	r3,4(r2)
   2728c:	003feb06 	br	2723c <_malloc_r+0x13c>
   27290:	8005883a 	mov	r2,r16
   27294:	84000117 	ldw	r16,4(r16)
   27298:	003fad06 	br	27150 <_malloc_r+0x50>
   2729c:	1021883a 	mov	r16,r2
   272a0:	10800117 	ldw	r2,4(r2)
   272a4:	003fb406 	br	27178 <_malloc_r+0x78>
   272a8:	1805883a 	mov	r2,r3
   272ac:	003fc606 	br	271c8 <_malloc_r+0xc8>
   272b0:	00800304 	movi	r2,12
   272b4:	90800015 	stw	r2,0(r18)
   272b8:	9009883a 	mov	r4,r18
   272bc:	00276b40 	call	276b4 <__malloc_unlock>
   272c0:	003fc906 	br	271e8 <_malloc_r+0xe8>
   272c4:	84400015 	stw	r17,0(r16)
   272c8:	003fdc06 	br	2723c <_malloc_r+0x13c>

000272cc <_puts_r>:
   272cc:	defffd04 	addi	sp,sp,-12
   272d0:	dc000015 	stw	r16,0(sp)
   272d4:	2021883a 	mov	r16,r4
   272d8:	2809883a 	mov	r4,r5
   272dc:	dfc00215 	stw	ra,8(sp)
   272e0:	dc400115 	stw	r17,4(sp)
   272e4:	2823883a 	mov	r17,r5
   272e8:	00273a40 	call	273a4 <strlen>
   272ec:	81400217 	ldw	r5,8(r16)
   272f0:	00c000b4 	movhi	r3,2
   272f4:	18dd4204 	addi	r3,r3,29960
   272f8:	28c00115 	stw	r3,4(r5)
   272fc:	100f883a 	mov	r7,r2
   27300:	880d883a 	mov	r6,r17
   27304:	8009883a 	mov	r4,r16
   27308:	00275080 	call	27508 <__sfvwrite_small_dev>
   2730c:	10ffffe0 	cmpeqi	r3,r2,-1
   27310:	1800091e 	bne	r3,zero,27338 <_puts_r+0x6c>
   27314:	81400217 	ldw	r5,8(r16)
   27318:	018000b4 	movhi	r6,2
   2731c:	01c00044 	movi	r7,1
   27320:	28800117 	ldw	r2,4(r5)
   27324:	319ff604 	addi	r6,r6,32728
   27328:	8009883a 	mov	r4,r16
   2732c:	103ee83a 	callr	r2
   27330:	10bfffe0 	cmpeqi	r2,r2,-1
   27334:	0085c83a 	sub	r2,zero,r2
   27338:	dfc00217 	ldw	ra,8(sp)
   2733c:	dc400117 	ldw	r17,4(sp)
   27340:	dc000017 	ldw	r16,0(sp)
   27344:	dec00304 	addi	sp,sp,12
   27348:	f800283a 	ret

0002734c <puts>:
   2734c:	008000f4 	movhi	r2,3
   27350:	200b883a 	mov	r5,r4
   27354:	11210b17 	ldw	r4,-31700(r2)
   27358:	00272cc1 	jmpi	272cc <_puts_r>

0002735c <memcpy>:
   2735c:	2005883a 	mov	r2,r4
   27360:	0007883a 	mov	r3,zero
   27364:	30c0011e 	bne	r6,r3,2736c <memcpy+0x10>
   27368:	f800283a 	ret
   2736c:	28cf883a 	add	r7,r5,r3
   27370:	39c00003 	ldbu	r7,0(r7)
   27374:	10c9883a 	add	r4,r2,r3
   27378:	18c00044 	addi	r3,r3,1
   2737c:	21c00005 	stb	r7,0(r4)
   27380:	003ff806 	br	27364 <memcpy+0x8>

00027384 <memset>:
   27384:	2005883a 	mov	r2,r4
   27388:	218d883a 	add	r6,r4,r6
   2738c:	2007883a 	mov	r3,r4
   27390:	1980011e 	bne	r3,r6,27398 <memset+0x14>
   27394:	f800283a 	ret
   27398:	18c00044 	addi	r3,r3,1
   2739c:	197fffc5 	stb	r5,-1(r3)
   273a0:	003ffb06 	br	27390 <memset+0xc>

000273a4 <strlen>:
   273a4:	2005883a 	mov	r2,r4
   273a8:	10c00007 	ldb	r3,0(r2)
   273ac:	1800021e 	bne	r3,zero,273b8 <strlen+0x14>
   273b0:	1105c83a 	sub	r2,r2,r4
   273b4:	f800283a 	ret
   273b8:	10800044 	addi	r2,r2,1
   273bc:	003ffa06 	br	273a8 <strlen+0x4>

000273c0 <_sbrk_r>:
   273c0:	defffe04 	addi	sp,sp,-8
   273c4:	dc000015 	stw	r16,0(sp)
   273c8:	008000f4 	movhi	r2,3
   273cc:	2021883a 	mov	r16,r4
   273d0:	2809883a 	mov	r4,r5
   273d4:	dfc00115 	stw	ra,4(sp)
   273d8:	10227315 	stw	zero,-30260(r2)
   273dc:	00276b80 	call	276b8 <sbrk>
   273e0:	10ffffd8 	cmpnei	r3,r2,-1
   273e4:	1800041e 	bne	r3,zero,273f8 <_sbrk_r+0x38>
   273e8:	00c000f4 	movhi	r3,3
   273ec:	18e27317 	ldw	r3,-30260(r3)
   273f0:	18000126 	beq	r3,zero,273f8 <_sbrk_r+0x38>
   273f4:	80c00015 	stw	r3,0(r16)
   273f8:	dfc00117 	ldw	ra,4(sp)
   273fc:	dc000017 	ldw	r16,0(sp)
   27400:	dec00204 	addi	sp,sp,8
   27404:	f800283a 	ret

00027408 <_free_r>:
   27408:	28003e26 	beq	r5,zero,27504 <_free_r+0xfc>
   2740c:	28bfff17 	ldw	r2,-4(r5)
   27410:	defffd04 	addi	sp,sp,-12
   27414:	dc000115 	stw	r16,4(sp)
   27418:	dfc00215 	stw	ra,8(sp)
   2741c:	2c3fff04 	addi	r16,r5,-4
   27420:	1000010e 	bge	r2,zero,27428 <_free_r+0x20>
   27424:	80a1883a 	add	r16,r16,r2
   27428:	d9000015 	stw	r4,0(sp)
   2742c:	00276b00 	call	276b0 <__malloc_lock>
   27430:	008000f4 	movhi	r2,3
   27434:	10a27217 	ldw	r2,-30264(r2)
   27438:	d9000017 	ldw	r4,0(sp)
   2743c:	1000071e 	bne	r2,zero,2745c <_free_r+0x54>
   27440:	80000115 	stw	zero,4(r16)
   27444:	008000f4 	movhi	r2,3
   27448:	14227215 	stw	r16,-30264(r2)
   2744c:	dfc00217 	ldw	ra,8(sp)
   27450:	dc000117 	ldw	r16,4(sp)
   27454:	dec00304 	addi	sp,sp,12
   27458:	00276b41 	jmpi	276b4 <__malloc_unlock>
   2745c:	8080092e 	bgeu	r16,r2,27484 <_free_r+0x7c>
   27460:	81400017 	ldw	r5,0(r16)
   27464:	8147883a 	add	r3,r16,r5
   27468:	10c0041e 	bne	r2,r3,2747c <_free_r+0x74>
   2746c:	10c00017 	ldw	r3,0(r2)
   27470:	10800117 	ldw	r2,4(r2)
   27474:	1947883a 	add	r3,r3,r5
   27478:	80c00015 	stw	r3,0(r16)
   2747c:	80800115 	stw	r2,4(r16)
   27480:	003ff006 	br	27444 <_free_r+0x3c>
   27484:	1007883a 	mov	r3,r2
   27488:	10800117 	ldw	r2,4(r2)
   2748c:	10000126 	beq	r2,zero,27494 <_free_r+0x8c>
   27490:	80bffc2e 	bgeu	r16,r2,27484 <_free_r+0x7c>
   27494:	19400017 	ldw	r5,0(r3)
   27498:	194d883a 	add	r6,r3,r5
   2749c:	34000b1e 	bne	r6,r16,274cc <_free_r+0xc4>
   274a0:	81800017 	ldw	r6,0(r16)
   274a4:	298b883a 	add	r5,r5,r6
   274a8:	19400015 	stw	r5,0(r3)
   274ac:	194d883a 	add	r6,r3,r5
   274b0:	11bfe61e 	bne	r2,r6,2744c <_free_r+0x44>
   274b4:	11800017 	ldw	r6,0(r2)
   274b8:	10800117 	ldw	r2,4(r2)
   274bc:	314b883a 	add	r5,r6,r5
   274c0:	19400015 	stw	r5,0(r3)
   274c4:	18800115 	stw	r2,4(r3)
   274c8:	003fe006 	br	2744c <_free_r+0x44>
   274cc:	8180032e 	bgeu	r16,r6,274dc <_free_r+0xd4>
   274d0:	00800304 	movi	r2,12
   274d4:	20800015 	stw	r2,0(r4)
   274d8:	003fdc06 	br	2744c <_free_r+0x44>
   274dc:	81800017 	ldw	r6,0(r16)
   274e0:	818b883a 	add	r5,r16,r6
   274e4:	1140041e 	bne	r2,r5,274f8 <_free_r+0xf0>
   274e8:	11400017 	ldw	r5,0(r2)
   274ec:	10800117 	ldw	r2,4(r2)
   274f0:	298b883a 	add	r5,r5,r6
   274f4:	81400015 	stw	r5,0(r16)
   274f8:	80800115 	stw	r2,4(r16)
   274fc:	1c000115 	stw	r16,4(r3)
   27500:	003fd206 	br	2744c <_free_r+0x44>
   27504:	f800283a 	ret

00027508 <__sfvwrite_small_dev>:
   27508:	2880000b 	ldhu	r2,0(r5)
   2750c:	1080020c 	andi	r2,r2,8
   27510:	10002526 	beq	r2,zero,275a8 <__sfvwrite_small_dev+0xa0>
   27514:	2880008f 	ldh	r2,2(r5)
   27518:	defffb04 	addi	sp,sp,-20
   2751c:	dcc00315 	stw	r19,12(sp)
   27520:	dc800215 	stw	r18,8(sp)
   27524:	dc400115 	stw	r17,4(sp)
   27528:	dc000015 	stw	r16,0(sp)
   2752c:	dfc00415 	stw	ra,16(sp)
   27530:	2027883a 	mov	r19,r4
   27534:	2821883a 	mov	r16,r5
   27538:	3025883a 	mov	r18,r6
   2753c:	3823883a 	mov	r17,r7
   27540:	1000100e 	bge	r2,zero,27584 <__sfvwrite_small_dev+0x7c>
   27544:	8080000b 	ldhu	r2,0(r16)
   27548:	10801014 	ori	r2,r2,64
   2754c:	8080000d 	sth	r2,0(r16)
   27550:	00bfffc4 	movi	r2,-1
   27554:	00000d06 	br	2758c <__sfvwrite_small_dev+0x84>
   27558:	88810050 	cmplti	r2,r17,1025
   2755c:	880f883a 	mov	r7,r17
   27560:	1000011e 	bne	r2,zero,27568 <__sfvwrite_small_dev+0x60>
   27564:	01c10004 	movi	r7,1024
   27568:	8140008f 	ldh	r5,2(r16)
   2756c:	900d883a 	mov	r6,r18
   27570:	9809883a 	mov	r4,r19
   27574:	00275b00 	call	275b0 <_write_r>
   27578:	00bff20e 	bge	zero,r2,27544 <__sfvwrite_small_dev+0x3c>
   2757c:	88a3c83a 	sub	r17,r17,r2
   27580:	90a5883a 	add	r18,r18,r2
   27584:	047ff416 	blt	zero,r17,27558 <__sfvwrite_small_dev+0x50>
   27588:	0005883a 	mov	r2,zero
   2758c:	dfc00417 	ldw	ra,16(sp)
   27590:	dcc00317 	ldw	r19,12(sp)
   27594:	dc800217 	ldw	r18,8(sp)
   27598:	dc400117 	ldw	r17,4(sp)
   2759c:	dc000017 	ldw	r16,0(sp)
   275a0:	dec00504 	addi	sp,sp,20
   275a4:	f800283a 	ret
   275a8:	00bfffc4 	movi	r2,-1
   275ac:	f800283a 	ret

000275b0 <_write_r>:
   275b0:	defffe04 	addi	sp,sp,-8
   275b4:	dc000015 	stw	r16,0(sp)
   275b8:	008000f4 	movhi	r2,3
   275bc:	2021883a 	mov	r16,r4
   275c0:	2809883a 	mov	r4,r5
   275c4:	300b883a 	mov	r5,r6
   275c8:	380d883a 	mov	r6,r7
   275cc:	dfc00115 	stw	ra,4(sp)
   275d0:	10227315 	stw	zero,-30260(r2)
   275d4:	00277080 	call	27708 <write>
   275d8:	10ffffd8 	cmpnei	r3,r2,-1
   275dc:	1800041e 	bne	r3,zero,275f0 <_write_r+0x40>
   275e0:	00c000f4 	movhi	r3,3
   275e4:	18e27317 	ldw	r3,-30260(r3)
   275e8:	18000126 	beq	r3,zero,275f0 <_write_r+0x40>
   275ec:	80c00015 	stw	r3,0(r16)
   275f0:	dfc00117 	ldw	ra,4(sp)
   275f4:	dc000017 	ldw	r16,0(sp)
   275f8:	dec00204 	addi	sp,sp,8
   275fc:	f800283a 	ret

00027600 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   27600:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   27604:	010000b4 	movhi	r4,2
   27608:	014000f4 	movhi	r5,3
   2760c:	dfc00015 	stw	ra,0(sp)
   27610:	211ff704 	addi	r4,r4,32732
   27614:	29610f04 	addi	r5,r5,-31684
   27618:	21400426 	beq	r4,r5,2762c <alt_load+0x2c>
  {
    while( to != end )
    {
      *to++ = *from++;
   2761c:	018000f4 	movhi	r6,3
   27620:	31a10f04 	addi	r6,r6,-31684
   27624:	310dc83a 	sub	r6,r6,r4
   27628:	002735c0 	call	2735c <memcpy>
  if (to != from)
   2762c:	010000b4 	movhi	r4,2
   27630:	014000b4 	movhi	r5,2
   27634:	21000804 	addi	r4,r4,32
   27638:	29400804 	addi	r5,r5,32
   2763c:	21400426 	beq	r4,r5,27650 <alt_load+0x50>
      *to++ = *from++;
   27640:	018000b4 	movhi	r6,2
   27644:	31800804 	addi	r6,r6,32
   27648:	310dc83a 	sub	r6,r6,r4
   2764c:	002735c0 	call	2735c <memcpy>
  if (to != from)
   27650:	010000b4 	movhi	r4,2
   27654:	014000b4 	movhi	r5,2
   27658:	211e4c04 	addi	r4,r4,31024
   2765c:	295e4c04 	addi	r5,r5,31024
   27660:	21400426 	beq	r4,r5,27674 <alt_load+0x74>
      *to++ = *from++;
   27664:	018000b4 	movhi	r6,2
   27668:	319ff704 	addi	r6,r6,32732
   2766c:	310dc83a 	sub	r6,r6,r4
   27670:	002735c0 	call	2735c <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   27674:	00279200 	call	27920 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   27678:	dfc00017 	ldw	ra,0(sp)
   2767c:	dec00104 	addi	sp,sp,4
  alt_icache_flush_all();
   27680:	00279241 	jmpi	27924 <alt_icache_flush_all>

00027684 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   27684:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   27688:	0009883a 	mov	r4,zero
{
   2768c:	dfc00015 	stw	ra,0(sp)
  alt_irq_init (NULL);
   27690:	00277640 	call	27764 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   27694:	00277840 	call	27784 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   27698:	d1a18117 	ldw	r6,-31228(gp)
   2769c:	d1618217 	ldw	r5,-31224(gp)
   276a0:	d1218317 	ldw	r4,-31220(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   276a4:	dfc00017 	ldw	ra,0(sp)
   276a8:	dec00104 	addi	sp,sp,4
  main (alt_argc, alt_argv, alt_envp);
   276ac:	002005c1 	jmpi	2005c <main>

000276b0 <__malloc_lock>:
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
}
   276b0:	f800283a 	ret

000276b4 <__malloc_unlock>:

/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
   276b4:	f800283a 	ret

000276b8 <sbrk>:
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   276b8:	0007303a 	rdctl	r3,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   276bc:	00bfff84 	movi	r2,-2
   276c0:	1884703a 	and	r2,r3,r2
   276c4:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   276c8:	d0a01917 	ldw	r2,-32668(gp)
   276cc:	017fff04 	movi	r5,-4
   276d0:	108000c4 	addi	r2,r2,3
   276d4:	1144703a 	and	r2,r2,r5
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   276d8:	014000f4 	movhi	r5,3
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   276dc:	d0a01915 	stw	r2,-32668(gp)
  if ((heap_end + incr) > __alt_heap_limit) {
   276e0:	1109883a 	add	r4,r2,r4
   276e4:	29500004 	addi	r5,r5,16384
   276e8:	2900032e 	bgeu	r5,r4,276f8 <sbrk+0x40>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   276ec:	1801703a 	wrctl	status,r3
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   276f0:	00bfffc4 	movi	r2,-1
   276f4:	f800283a 	ret
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
   276f8:	d1201915 	stw	r4,-32668(gp)
   276fc:	1801703a 	wrctl	status,r3
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
   27700:	f800283a 	ret

00027704 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   27704:	00278901 	jmpi	27890 <alt_busy_sleep>

00027708 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   27708:	213fffc4 	addi	r4,r4,-1
   2770c:	210000a8 	cmpgeui	r4,r4,2
   27710:	2000041e 	bne	r4,zero,27724 <write+0x1c>
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
   27714:	010000f4 	movhi	r4,3
   27718:	000f883a 	mov	r7,zero
   2771c:	21210d04 	addi	r4,r4,-31692
   27720:	00277881 	jmpi	27788 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   27724:	d0a01b17 	ldw	r2,-32660(gp)
   27728:	10000926 	beq	r2,zero,27750 <write+0x48>
{
   2772c:	deffff04 	addi	sp,sp,-4
   27730:	dfc00015 	stw	ra,0(sp)
   27734:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   27738:	00c01444 	movi	r3,81
   2773c:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   27740:	00bfffc4 	movi	r2,-1
   27744:	dfc00017 	ldw	ra,0(sp)
   27748:	dec00104 	addi	sp,sp,4
   2774c:	f800283a 	ret
   27750:	d0a18004 	addi	r2,gp,-31232
        ALT_ERRNO = EBADFD;
   27754:	00c01444 	movi	r3,81
   27758:	10c00015 	stw	r3,0(r2)
}
   2775c:	00bfffc4 	movi	r2,-1
   27760:	f800283a 	ret

00027764 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   27764:	deffff04 	addi	sp,sp,-4
   27768:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, NIOS);
   2776c:	00279280 	call	27928 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   27770:	00800044 	movi	r2,1
   27774:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   27778:	dfc00017 	ldw	ra,0(sp)
   2777c:	dec00104 	addi	sp,sp,4
   27780:	f800283a 	ret

00027784 <alt_sys_init>:
void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
    ALTERA_AVALON_SPI_INIT ( ESC_SPI, ESC_SPI);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, SYSID);
}
   27784:	f800283a 	ret

00027788 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   27788:	20c00017 	ldw	r3,0(r4)
{
   2778c:	3005883a 	mov	r2,r6

  const char * end = ptr + count;
   27790:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   27794:	01bfffd4 	movui	r6,65535
  while (ptr < end)
   27798:	29000136 	bltu	r5,r4,277a0 <altera_avalon_jtag_uart_write+0x18>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
   2779c:	f800283a 	ret
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   277a0:	19c00137 	ldwio	r7,4(r3)
   277a4:	31fffc2e 	bgeu	r6,r7,27798 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   277a8:	29c00007 	ldb	r7,0(r5)
   277ac:	29400044 	addi	r5,r5,1
   277b0:	19c00035 	stwio	r7,0(r3)
   277b4:	003ff806 	br	27798 <altera_avalon_jtag_uart_write+0x10>

000277b8 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   277b8:	d8800017 	ldw	r2,0(sp)
   277bc:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   277c0:	00c00044 	movi	r3,1
{
   277c4:	da400217 	ldw	r9,8(sp)
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   277c8:	1946983a 	sll	r3,r3,r5
  const alt_u8 * write_end = write_data + write_length;
   277cc:	399b883a 	add	r13,r7,r6
  alt_u8 * read_end = read_data + read_length;
   277d0:	4099883a 	add	r12,r8,r2
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   277d4:	20c00535 	stwio	r3,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   277d8:	48c0008c 	andi	r3,r9,2
   277dc:	1800021e 	bne	r3,zero,277e8 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   277e0:	00c10004 	movi	r3,1024
   277e4:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   277e8:	20c00037 	ldwio	r3,0(r4)
  alt_32 credits = 1;
   277ec:	00c00044 	movi	r3,1
  alt_u32 write_zeros = read_length;
   277f0:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   277f4:	22c00204 	addi	r11,r4,8
   277f8:	21400237 	ldwio	r5,8(r4)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   277fc:	2b80100c 	andi	r14,r5,64
   27800:	2940200c 	andi	r5,r5,128
   27804:	70000126 	beq	r14,zero,2780c <alt_avalon_spi_command+0x54>
   27808:	1800101e 	bne	r3,zero,2784c <alt_avalon_spi_command+0x94>
      }
      else
        credits = -1024;
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   2780c:	283ff926 	beq	r5,zero,277f4 <alt_avalon_spi_command+0x3c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   27810:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
        read_ignore--;
      else
        *read_data++ = (alt_u8)rxdata;
      credits++;
   27814:	18c00044 	addi	r3,r3,1
      if (read_ignore > 0)
   27818:	30001a26 	beq	r6,zero,27884 <alt_avalon_spi_command+0xcc>
        read_ignore--;
   2781c:	31bfffc4 	addi	r6,r6,-1

      if (read_ignore == 0 && read_data == read_end)
   27820:	303ff41e 	bne	r6,zero,277f4 <alt_avalon_spi_command+0x3c>
   27824:	6200071e 	bne	r12,r8,27844 <alt_avalon_spi_command+0x8c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27828:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   2782c:	18c0080c 	andi	r3,r3,32
   27830:	183ffd26 	beq	r3,zero,27828 <alt_avalon_spi_command+0x70>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   27834:	4a40004c 	andi	r9,r9,1
   27838:	4800011e 	bne	r9,zero,27840 <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   2783c:	20000335 	stwio	zero,12(r4)

  return read_length;
}
   27840:	f800283a 	ret
   27844:	000d883a 	mov	r6,zero
   27848:	003fea06 	br	277f4 <alt_avalon_spi_command+0x3c>
    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   2784c:	00ffef0e 	bge	zero,r3,2780c <alt_avalon_spi_command+0x54>
      credits--;
   27850:	18ffffc4 	addi	r3,r3,-1
      if (write_data < write_end)
   27854:	3b40052e 	bgeu	r7,r13,2786c <alt_avalon_spi_command+0xb4>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   27858:	3b800044 	addi	r14,r7,1
   2785c:	39c00003 	ldbu	r7,0(r7)
   27860:	21c00135 	stwio	r7,4(r4)
   27864:	700f883a 	mov	r7,r14
   27868:	003fe806 	br	2780c <alt_avalon_spi_command+0x54>
      else if (write_zeros > 0)
   2786c:	50000326 	beq	r10,zero,2787c <alt_avalon_spi_command+0xc4>
        write_zeros--;
   27870:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   27874:	20000135 	stwio	zero,4(r4)
   27878:	003fe406 	br	2780c <alt_avalon_spi_command+0x54>
        credits = -1024;
   2787c:	00ff0004 	movi	r3,-1024
   27880:	003fe206 	br	2780c <alt_avalon_spi_command+0x54>
        *read_data++ = (alt_u8)rxdata;
   27884:	41400005 	stb	r5,0(r8)
   27888:	42000044 	addi	r8,r8,1
   2788c:	003fe506 	br	27824 <alt_avalon_spi_command+0x6c>

00027890 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   27890:	defffe04 	addi	sp,sp,-8
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   27894:	008666b4 	movhi	r2,6554
{
   27898:	dc000015 	stw	r16,0(sp)
   2789c:	dfc00115 	stw	ra,4(sp)
  if (big_loops)
   278a0:	10a66604 	addi	r2,r2,-26216
{
   278a4:	2021883a 	mov	r16,r4
  if (big_loops)
   278a8:	1100182e 	bgeu	r2,r4,2790c <alt_busy_sleep+0x7c>
  big_loops = us / (INT_MAX/
   278ac:	014666b4 	movhi	r5,6554
   278b0:	29666644 	addi	r5,r5,-26215
   278b4:	0026f6c0 	call	26f6c <__udivsi3>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   278b8:	00e00034 	movhi	r3,32768
  big_loops = us / (INT_MAX/
   278bc:	1009883a 	mov	r4,r2
      __asm__ volatile (
   278c0:	18ffffc4 	addi	r3,r3,-1
    for(i=0;i<big_loops;i++)
   278c4:	0005883a 	mov	r2,zero
      __asm__ volatile (
   278c8:	18ffffc4 	addi	r3,r3,-1
   278cc:	183ffe1e 	bne	r3,zero,278c8 <alt_busy_sleep+0x38>
    for(i=0;i<big_loops;i++)
   278d0:	10800044 	addi	r2,r2,1
   278d4:	113ffc16 	blt	r2,r4,278c8 <alt_busy_sleep+0x38>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   278d8:	017999b4 	movhi	r5,58982
   278dc:	295999c4 	addi	r5,r5,26215
   278e0:	002702c0 	call	2702c <__mulsi3>
   278e4:	1405883a 	add	r2,r2,r16
   278e8:	100690ba 	slli	r3,r2,2
   278ec:	1885883a 	add	r2,r3,r2
    __asm__ volatile (
   278f0:	10bfffc4 	addi	r2,r2,-1
   278f4:	103ffe1e 	bne	r2,zero,278f0 <alt_busy_sleep+0x60>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   278f8:	0005883a 	mov	r2,zero
   278fc:	dfc00117 	ldw	ra,4(sp)
   27900:	dc000017 	ldw	r16,0(sp)
   27904:	dec00204 	addi	sp,sp,8
   27908:	f800283a 	ret
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   2790c:	200490ba 	slli	r2,r4,2
   27910:	1105883a 	add	r2,r2,r4
    __asm__ volatile (
   27914:	10bfffc4 	addi	r2,r2,-1
   27918:	00bffe16 	blt	zero,r2,27914 <alt_busy_sleep+0x84>
   2791c:	003ff606 	br	278f8 <alt_busy_sleep+0x68>

00027920 <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   27920:	f800283a 	ret

00027924 <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   27924:	f800283a 	ret

00027928 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   27928:	000170fa 	wrctl	ienable,zero
}
   2792c:	f800283a 	ret
