
NIOS_Project_Small.elf:     file format elf32-littlenios2
NIOS_Project_Small.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00020188

Program Header:
    LOAD off    0x00001000 vaddr 0x00020000 paddr 0x00020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00020020 paddr 0x00020020 align 2**12
         filesz 0x00007c74 memsz 0x00007c74 flags r-x
    LOAD off    0x00008c94 vaddr 0x00027c94 paddr 0x000280f4 align 2**12
         filesz 0x00000460 memsz 0x00000460 flags rw-
    LOAD off    0x00000554 vaddr 0x00028554 paddr 0x00028554 align 2**12
         filesz 0x00000000 memsz 0x000003ac flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00020000  00020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000168  00020020  00020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000074b4  00020188  00020188  00001188  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000658  0002763c  0002763c  0000863c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000460  00027c94  000280f4  00008c94  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000003ac  00028554  00028554  00009554  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  00028900  00028900  000090f4  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  000090f4  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000628  00000000  00000000  00009128  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   0000e384  00000000  00000000  00009750  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00004567  00000000  00000000  00017ad4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   000081ec  00000000  00000000  0001c03b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  0000151c  00000000  00000000  00024228  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    00002d82  00000000  00000000  00025744  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000060  00000000  00000000  000284c8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000070  00000000  00000000  00028528  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000715  00000000  00000000  00028598  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00000fd8  00000000  00000000  00028cad  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 00005881  00000000  00000000  00029c85  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  00032fea  2**0
                  CONTENTS, READONLY
 20 .cpu          00000004  00000000  00000000  00032fed  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00032ff1  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00032ff2  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  00032ff3  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  00032ff7  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  00032ffb  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000005  00000000  00000000  00032fff  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000005  00000000  00000000  00033004  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000005  00000000  00000000  00033009  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000015  00000000  00000000  0003300e  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000004c  00000000  00000000  00033023  2**0
                  CONTENTS, READONLY
 31 .jdi          0000527d  00000000  00000000  0003306f  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     0005686f  00000000  00000000  000382ec  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00020000 l    d  .entry	00000000 .entry
00020020 l    d  .exceptions	00000000 .exceptions
00020188 l    d  .text	00000000 .text
0002763c l    d  .rodata	00000000 .rodata
00027c94 l    d  .rwdata	00000000 .rwdata
00028554 l    d  .bss	00000000 .bss
00028900 l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.o
000201d0 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00028070 l     O .rwdata	00000001 invert_me.0
00000000 l    df *ABS*	00000000 TENCL040_ESC.c
00000000 l    df *ABS*	00000000 ax58100_hw.c
000204ec l     F .text	00000144 HW_SPI_Read
00020630 l     F .text	00000118 HW_SPI_Write
00000000 l    df *ABS*	00000000 coeappl.c
00000000 l    df *ABS*	00000000 ecatappl.c
00000000 l    df *ABS*	00000000 ecatcoe.c
00000000 l    df *ABS*	00000000 ecatslv.c
00000000 l    df *ABS*	00000000 mailbox.c
00000000 l    df *ABS*	00000000 objdef.c
00000000 l    df *ABS*	00000000 sdoserv.c
00000000 l    df *ABS*	00000000 nios_it.c
00000000 l    df *ABS*	00000000 peripheral_linker.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00026bfc l     F .text	0000008c sbrk_aligned
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 freer.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
000280e8 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 alt_icache_flush.c
00028670 g     O .bss	00000004 alt_instruction_exception_handler
0002808c g     O .rwdata	00000008 DeviceIDProcessDataMapping0x1A01
000285c4 g     O .bss	00000001 b3BufferMode
0002664c g     F .text	00000048 init_exti0_it
000285bc g     O .bss	00000002 nEcatStateTrans
000285a8 g     O .bss	00000002 u16IdValue
00027300 g     F .text	0000002c alt_main
00026e54 g     F .text	00000080 _puts_r
00028800 g     O .bss	00000100 alt_irq
000280d6 g     O .rwdata	00000006 sEntryDesc0x1000
000280f4 g       *ABS*	00000000 __flash_rwdata_start
000207ec g     F .text	0000000c HW_EscReadIsr
00028900 g       *ABS*	00000000 __alt_heap_start
00027c94 g     O .rwdata	000001e0 GenObjDic
000280ca g     O .rwdata	00000006 sEntryDesc0x1008
000279b0 g     O .rodata	00000047 aName0x1018
00024650 g     F .text	00000008 OBJ_GetObjDesc
000285bf g     O .bss	00000001 bApplEsmPending
000208d0 g     F .text	00000004 HW_SYNC1_IRQHandler
0002251c g     F .text	0000005c StartOutputHandler
00020458 g     F .text	0000004c APPL_OutputMapping
00027330 g     F .text	00000004 __malloc_unlock
00028598 g     O .bss	00000004 pCoeSendStored
00027b44 g     O .rodata	0000002e aName0x1A01
00026828 g     F .text	000000f4 spi_transmit_receive
00023e6c g     F .text	000000e0 MBX_MailboxWriteInd
00028630 g     O .bss	00000002 nSdoInfoIndex
0002338c g     F .text	000001e4 ECAT_StateChange
0002863c g     O .bss	00000004 pStoreData
00028590 g     O .bss	00000004 pAPPL_CoeReadInd
000285fd g     O .bss	00000001 u8MbxReadCounter
00028078 g     O .rwdata	00000004 DeviceID0x6008
00021948 g     F .text	00000068 COE_ContinueInd
000285b3 g     O .bss	00000001 nAlStatus
000285b8 g     O .bss	00000002 nPdOutputSize
000275d8 g     F .text	00000008 altera_nios2_gen2_irq_init
00028674 g     O .bss	0000000c spiRxBuf
00020000 g     F .entry	0000001c __reset
00028570 g     O .bss	00000001 bInitFinished
0002864c g     O .bss	00000004 edge_capture
00020020 g       *ABS*	00000000 __flash_exceptions_start
000285c2 g     O .bss	00000002 u16LocalErrorCode
0002861c g     O .bss	00000004 nSdoSegBytesToHandle
000204b8 g     F .text	00000034 main_initial
000219b0 g     F .text	0000004c ResetALEventMask
0002865c g     O .bss	00000004 errno
00028554 g     O .bss	00000002 bootSwitchID
000285c0 g     O .bss	00000001 u8LocalErrorState
00027e88 g     O .rwdata	0000000d acDevicename
00027a9c g     O .rodata	0000000c asEntryDesc0x7000
00028734 g     O .bss	00000034 sMbxSendQueue
000285b2 g     O .bss	00000001 bExplicitDevIdRequested
00028010 g     O .rwdata	0000000c sErrorSettings
00028668 g     O .bss	00000004 alt_argv
000201fc g     F .text	00000004 APPL_AckErrorInd
00030070 g       *ABS*	00000000 _gp
00027380 g     F .text	00000004 usleep
000280b0 g     O .rwdata	00000006 sEntryDesc0x100A
00022584 g     F .text	000000a0 StopInputHandler
00028700 g     O .bss	00000034 sMbxReceiveQueue
000285e8 g     O .bss	00000001 bNoMbxMemoryAvailable
00023c84 g     F .text	000000a0 MBX_MailboxReadInd
00027e74 g     O .rwdata	00000014 sIdentity
000285d2 g     O .bss	00000002 Sync0WdCounter
00026ee4 g     F .text	00000028 memcpy
00024814 g     F .text	0000010c CheckSyncTypeValue
00028086 g     O .rwdata	00000004 sRxPDOassign
00028578 g     O .bss	00000001 bMinCycleTimeMeasurementStarted
00026ed4 g     F .text	00000010 puts
000275b4 g     F .text	00000024 alt_exception_cause_generated_bad_addr
000208c0 g     F .text	0000000c HW_EscWriteIsr
0002860a g     O .bss	00000001 bSendMbxIsFull
00028584 g     O .bss	00000004 u32CycleTimeStartValue
00027948 g     O .rodata	00000013 aName0x10F8
000285c8 g     O .bss	00000002 LatchInputSync0Counter
00026bdc g     F .text	00000010 malloc
000285d4 g     O .bss	00000002 i16WaitForPllRunningCnt
00026b1c g     F .text	00000064 .hidden __udivsi3
000285ae g     O .bss	00000002 nEscAddrOutputData
00028609 g     O .bss	00000001 bMbxRunning
000257d0 g     F .text	000008f4 SDOS_SdoInd
00028074 g     O .rwdata	00000004 OUT_GENERIC0x7000
00020228 g     F .text	00000008 APPL_StopOutputHandler
00021b6c g     F .text	00000270 CheckSmSettings
000275e0 g     F .text	0000005c alt_icache_flush
00027758 g     O .rodata	00000108 aName0x1C32
000285d0 g     O .bss	00000002 Sync0WdValue
00026f48 g     F .text	00000048 _sbrk_r
0002441c g     F .text	00000034 OBJ_GetEntryDesc
00027a74 g     O .rodata	0000000c aName0x1000
00020e78 g     F .text	00000068 GetSystemTimeDelay
00020218 g     F .text	00000008 APPL_StopInputHandler
000285d6 g     O .bss	00000002 i16WaitForPllRunningTimeout
00028624 g     O .bss	00000001 bSdoSegAccess
000285cc g     O .bss	00000002 Sync1WdValue
00021ddc g     F .text	00000740 StartInputHandler
000208d4 g     F .text	00000004 HW_TIMETASK_IRQHandler
00027b1c g     O .rodata	0000001b aName0x1C12
00028080 g     O .rwdata	00000006 sTxPDOassign
0002393c g     F .text	000000d4 MBX_StartMailboxHandler
00028900 g       *ABS*	00000000 __bss_end
00027214 g     F .text	00000068 alt_iic_isr_register
0002859c g     O .bss	00000001 EepromLoaded
00027acc g     O .rodata	00000019 aName0x6000
00027bec g     O .rodata	0000000c asEntryDesc0x1600
00028625 g     O .bss	00000001 bSdoSegFollows
00028614 g     O .bss	00000004 nSdoSegCompleteSize
000285a7 g     O .bss	00000001 u8dummy
000285aa g     O .bss	00000002 u16ALEventMask
000271fc g     F .text	00000018 alt_ic_irq_enabled
00027c18 g     O .rodata	00000078 cAbortCode
00028638 g     O .bss	00000004 pSdoPendFunc
000285de g     O .bss	00000001 bDcRunning
00028660 g     O .bss	00000004 alt_irq_active
00024920 g     F .text	00000610 OBJ_Read
000200fc g     F .exceptions	00000060 alt_irq_handler
00028594 g     O .bss	00000001 bRunApplication
00027a80 g     O .rodata	0000001c aName0x7000
00026804 g     F .text	00000024 appTimerRun
00028602 g     O .bss	00000002 u16EscAddrReceiveMbx
000285ec g     O .bss	00000004 psStoreMbx
00024080 g     F .text	000000c4 MBX_Main
0002859e g     O .bss	00000008 SyncManInfo
000280a4 g     O .rwdata	00000006 sSyncmanagertype
000285c6 g     O .bss	00000001 b32BitDc
00021b10 g     F .text	0000005c EnableSyncManChannel
00027590 g     F .text	00000018 alt_dcache_flush_all
00027bbc g     O .rodata	00000030 aName0x1600
000280f4 g       *ABS*	00000000 __ram_rwdata_end
000209e4 g     F .text	0000005c COE_UpdateSyncErrorStatus
0002809c g     O .rwdata	00000008 OUT_GENERICProcessDataMapping0x1600
00027384 g     F .text	0000005c write
0002857c g     O .bss	00000004 u32SystemTimeReadFailure
00023a10 g     F .text	00000108 MBX_StopMailboxHandler
0002795c g     O .rodata	0000003f aName0x10F1
00028648 g     O .bss	00000001 u8PendingSdo
00027c94 g       *ABS*	00000000 __ram_rodata_end
000280ec g     O .rwdata	00000004 DEBUG
00027e98 g     O .rwdata	00000168 ApplicationObjDic
00020f90 g     F .text	0000006c HandleCycleTimeMeasurement
000285ca g     O .bss	00000002 LatchInputSync0Value
00026b80 g     F .text	0000005c .hidden __umodsi3
00028094 g     O .rwdata	00000008 IN_GENERICProcessDataMapping0x1A00
000279f8 g     O .rodata	0000001e asEntryDesc0x1018
00027b72 g     O .rodata	0000000c asEntryDesc0x1A01
00028900 g       *ABS*	00000000 end
00020210 g     F .text	00000008 APPL_StartInputHandler
00028606 g     O .bss	00000002 u16SendMbxSize
000285be g     O .bss	00000001 bEcatWaitForAlControlRes
000261d4 g     F .text	00000078 SDOS_ClearPendingResponse
0002015c g     F .exceptions	0000002c alt_instruction_exception_entry
000285f4 g     O .bss	00000004 psReadMbx
00022578 g     F .text	0000000c StopOutputHandler
00027a38 g     O .rodata	0000001e aName0x1009
00028597 g     O .bss	00000001 bEcatWaitForInputUpdate
00021394 g     F .text	000001c0 PDI_Isr
00028768 g     O .bss	00000044 sSyncManInPar
00034000 g       *ABS*	00000000 __alt_stack_pointer
000280c4 g     O .rwdata	00000006 acHardwareversion
0002624c g     F .text	000003d8 SDOS_SdoInfoInd
00027404 g     F .text	00000030 altera_avalon_jtag_uart_write
00028574 g     O .bss	00000004 u32MinCycleTimeValue
000285ba g     O .bss	00000002 nPdInputSize
00026f90 g     F .text	00000100 _free_r
00027a64 g     O .rodata	0000000f aName0x1001
0002807c g     O .rwdata	00000004 IN_GENERIC0x6000
000207f8 g     F .text	00000038 HW_EscWrite
00020208 g     F .text	00000008 APPL_StopMailboxHandler
00028000 g     O .rwdata	0000000d aSubindexDesc
0002388c g     F .text	000000b0 MBX_Init
00020188 g     F .text	0000004c _start
0002691c g     F .text	0000010c adc_init_spi_transmit_receive
00028650 g     O .bss	00000004 timerCounter
00028627 g     O .bss	00000001 bSdoInWork
000208cc g     F .text	00000004 HW_SYNC0_IRQHandler
000285da g     O .bss	00000002 u16SmSync0Value
00028647 g     O .bss	00000001 bStoreCompleteAccess
00027434 g     F .text	000000d8 alt_avalon_spi_command
00024264 g     F .text	00000080 OBJ_CopyNumberToString
000209dc g     F .text	00000008 COE_GetObjectDictionary
00027400 g     F .text	00000004 alt_sys_init
00024450 g     F .text	000000b8 OBJ_GetNoOfObjects
000286f4 g     O .bss	0000000c aPdOutputData
00028618 g     O .bss	00000001 bSdoSegLastToggle
00023b38 g     F .text	0000014c MBX_CopyToSendMailbox
000226d0 g     F .text	0000081c AL_ControlInd
00027c94 g       *ABS*	00000000 __ram_rwdata_start
0002763c g       *ABS*	00000000 __ram_rodata_start
00027aa8 g     O .rodata	00000016 aName0x6008
00028626 g     O .bss	00000001 nSdoSegService
000280aa g     O .rwdata	00000006 sEntryDesc0x10F8
00020de8 g     F .text	00000090 ECAT_CheckTimer
00023650 g     F .text	000001a8 ECAT_Main
0002860b g     O .bss	00000001 bReceiveMbxIsLocked
00028600 g     O .bss	00000002 u16EscAddrSendMbx
000285b4 g     O .bss	00000002 nMaxEscAddress
000285e4 g     O .bss	00000001 bEcatFirstOutputsReceived
0002750c g     F .text	00000084 alt_busy_sleep
000285f8 g     O .bss	00000004 psWriteMbx
00027abe g     O .rodata	0000000c asEntryDesc0x6008
00028568 g     O .bss	00000008 u64Timestamp
0002793a g     O .rodata	0000000c asEntryDesc0x1C00
00020200 g     F .text	00000008 APPL_StartMailboxHandler
000285fe g     O .bss	00000001 u8MbxWriteCounter
00020830 g     F .text	00000090 HW_Init
00028900 g       *ABS*	00000000 __alt_stack_base
00027bf8 g     O .rodata	00000020 cBitMask
000285a6 g     O .bss	00000001 SMActivate
00028564 g     O .bss	00000004 u32LastDc32Value
00023b18 g     F .text	00000020 MailboxServiceInd
000237f8 g     F .text	00000050 PutInMbxQueue
000242e4 g     F .text	00000138 OBJ_GetDesc
00028560 g     O .bss	00000004 u32CheckForDcOverrunCnt
00023d24 g     F .text	00000068 MBX_MailboxRepeatReq
000285fc g     O .bss	00000001 u8MailboxSendReqStored
000218f4 g     F .text	0000000c COE_Init
00020acc g     F .text	00000054 COE_RemoveDicEntry
00020ee0 g     F .text	000000b0 PDO_InputMapping
000280b8 g     O .rwdata	00000006 acSoftwareversion
0002855c g     O .bss	00000002 u16ErrorRegister
0002732c g     F .text	00000004 __malloc_lock
00027334 g     F .text	0000004c sbrk
0002858c g     O .bss	00000004 pAPPL_CoeWriteInd
000260c4 g     F .text	00000110 SDOS_SdoRes
0002862c g     O .bss	00000004 pSdoInfoObjEntry
00021628 g     F .text	0000021c ESC_EepromAccess
00027090 g     F .text	000000a8 __sfvwrite_small_dev
000285d8 g     O .bss	00000001 bSmSyncSequenceValid
00028632 g     O .bss	00000002 nSdoInfoFragmentsLeft
00022eec g     F .text	00000308 AL_ControlRes
00028554 g       *ABS*	00000000 __bss_start
00026f0c g     F .text	00000020 memset
00024f30 g     F .text	00000740 OBJ_Write
000201d4 g     F .text	00000028 main
00020000 g       *ABS*	00000000 __alt_mem_RAM
00026694 g     F .text	00000008 delay_ms
00027b38 g     O .rodata	0000000c asEntryDesc0x1C12
00028664 g     O .bss	00000004 alt_envp
000280d0 g     O .rwdata	00000006 sEntryDesc0x1001
00020230 g     F .text	000001c0 APPL_GenerateMapping
0002074c g     F .text	00000028 HW_GetALEventRegister_Isr
000285e0 g     O .bss	00000002 EsmTimeoutCounter
00020d1c g     F .text	000000cc COE_Main
00034000 g       *ABS*	00000000 __alt_heap_limit
00021844 g     F .text	000000b0 ESC_EepromWriteCRC
00026c88 g     F .text	000001cc _malloc_r
00020944 g     F .text	00000098 Read0x10F8
00028556 g     O .bss	00000002 EscALEvent
00028604 g     O .bss	00000002 u16ReceiveMbxSize
00028558 g     O .bss	00000004 ObjDicList
000280f0 g     O .rwdata	00000004 alt_errno
000280be g     O .rwdata	00000006 sEntryDesc0x1009
00028628 g     O .bss	00000004 pSdoResStored
00028640 g     O .bss	00000004 u32StoreDataSize
00026a28 g     F .text	00000080 .hidden __divsi3
000231f4 g     F .text	000000c0 DC_CheckWatchdog
00028634 g     O .bss	00000004 pSdoSegData
0002763c g       *ABS*	00000000 __flash_rodata_start
00021ab0 g     F .text	00000060 DisableSyncManChannel
000285e2 g     O .bss	00000001 bDcSyncActive
000285e6 g     O .bss	00000001 bEcatOutputUpdateRunning
000273e0 g     F .text	00000020 alt_irq_init
00021554 g     F .text	000000d4 MainLoop
00023d8c g     F .text	000000e0 MBX_MailboxSendReq
00028588 g     O .bss	00000004 pAPPL_MainLoop
00021110 g     F .text	000000e8 MainInit
00020a40 g     F .text	0000008c COE_AddObjectToDic
00027138 g     F .text	00000050 _write_r
000287ac g     O .bss	00000044 sSyncManOutPar
000285ce g     O .bss	00000002 Sync1WdCounter
000280e0 g     O .rwdata	00000004 _impure_ptr
0002866c g     O .bss	00000004 alt_argc
0002669c g     F .text	00000168 adc_init
00021a80 g     F .text	00000030 GetSyncMan
00021900 g     F .text	00000048 COE_ServiceInd
0002799c g     O .rodata	00000012 asEntryDesc0x10F1
00027af4 g     O .rodata	0000001b aName0x1C13
00020020 g       .exceptions	00000000 alt_irq_entry
00027b10 g     O .rodata	0000000c asEntryDesc0x1C13
0002262c g     F .text	000000a4 SetALStatus
00021234 g     F .text	00000160 Sync0_Isr
000285b0 g     O .bss	00000002 EcatWdValue
00028595 g     O .bss	00000001 bEtherCATErrorLed
000208d8 g     F .text	0000006c COE_SyncTimeStamp
00020020 g       *ABS*	00000000 __ram_exceptions_start
000207ac g     F .text	00000040 HW_GetALEventRegister
00028580 g     O .bss	00000004 u32MinCycleTimeStartValue
00027188 g     F .text	00000004 alt_ic_isr_register
00027928 g     O .rodata	00000012 aName0x1C00
000280f4 g       *ABS*	00000000 _edata
000219fc g     F .text	0000004c SetALEventMask
0002860e g     O .bss	00000001 bSyncSetByUser
00028900 g       *ABS*	00000000 _end
00028608 g     O .bss	00000001 bMbxRepeatToggle
00027a18 g     O .rodata	0000001e aName0x100A
000285e5 g     O .bss	00000001 bEcatInputUpdateRunning
00021a48 g     F .text	00000038 UpdateEEPROMLoadedState
000210bc g     F .text	00000054 Sync1_Isr
00020188 g       *ABS*	00000000 __ram_exceptions_end
000285c5 g     O .bss	00000001 bEscIntEnabled
000285f0 g     O .bss	00000004 psRepeatMbx
000204b0 g     F .text	00000008 APPL_GetDeviceID
00027860 g     O .rodata	000000c6 asEntryDesc0x1C3x
00024144 g     F .text	0000003c OBJ_GetObjectHandle
00028622 g     O .bss	00000002 nSdoSegIndex
000287f0 g     O .bss	00000010 aSdoInfoHeader
000271c4 g     F .text	00000038 alt_ic_irq_disable
00027b80 g     O .rodata	0000002f aName0x1A00
00020220 g     F .text	00000008 APPL_StartOutputHandler
00028610 g     O .bss	00000004 pSdoSegObjEntry
00027bb0 g     O .rodata	0000000c asEntryDesc0x1A00
00024658 g     F .text	000001bc OBJ_GetEntryOffset
00020bac g     F .text	00000040 COE_ObjDictionaryInit
00023f4c g     F .text	00000134 MBX_CheckAndCopyMailbox
00020bec g     F .text	00000130 COE_ObjInit
0002868c g     O .bss	00000068 aPdInputData
00020b20 g     F .text	0000003c COE_ClearObjDictionary
000285e3 g     O .bss	00000001 bWdTrigger
00026aa8 g     F .text	00000074 .hidden __modsi3
00020ffc g     F .text	000000c0 PDO_OutputMapping
00028620 g     O .bss	00000001 nSdoSegSubindex
0002801c g     O .rwdata	00000054 _impure_data
00034000 g       *ABS*	00000000 __alt_data_end
00020020 g     F .exceptions	00000000 alt_exception
00025670 g     F .text	00000160 SdoRes
00020774 g     F .text	00000038 HW_EscRead
00028644 g     O .bss	00000002 u16StoreIndex
00028596 g     O .bss	00000001 bEtherCATRunLed
000232b4 g     F .text	000000d8 CheckIfEcatError
00024508 g     F .text	00000148 OBJ_GetObjectList
00027ae6 g     O .rodata	0000000c asEntryDesc0x6000
0002001c g       .entry	00000000 _exit
000285dc g     O .bss	00000002 u16SmSync0Counter
000285b6 g     O .bss	00000001 nMaxSyncMan
00026f2c g     F .text	0000001c strlen
000203f0 g     F .text	00000068 APPL_InputMapping
000204a4 g     F .text	0000000c APPL_Application
000280dc g     O .rwdata	00000004 u32Devicetype
00028654 g     O .bss	00000004 __malloc_sbrk_start
00028646 g     O .bss	00000001 u8StoreSubindex
00027650 g     O .rodata	00000107 aName0x1C33
00022624 g     F .text	00000008 BackToInitTransition
00024180 g     F .text	000000e4 OBJ_GetObjectLength
00023848 g     F .text	00000044 GetOutOfMbxQueue
000275a8 g     F .text	0000000c alt_icache_flush_all
000280e4 g     O .rwdata	00000004 alt_priority_mask
00028658 g     O .bss	00000004 __malloc_free_list
0002718c g     F .text	00000038 alt_ic_irq_enable
00020b5c g     F .text	00000050 AddObjectsToObjDictionary
00028680 g     O .bss	0000000c spiTxBuf
0002860c g     O .bss	00000002 sCycleDiag
000211f8 g     F .text	0000003c ECAT_Application
00027a58 g     O .rodata	0000000c aName0x1008
00023570 g     F .text	000000e0 ECAT_Init
0002727c g     F .text	00000084 alt_load
000285ac g     O .bss	00000002 nEscAddrInputData
00026bec g     F .text	00000010 free
00026624 g     F .text	00000028 exti0_isr
00020748 g     F .text	00000004 HW_Release



Disassembly of section .entry:

00020000 <__reset>:
#if NIOS2_ICACHE_SIZE > 0 && defined(ALT_ALLOW_CODE_AT_RESET) && (!defined(ALT_SIM_OPTIMIZE) || defined(NIOS2_ECC_PRESENT))
    /* Assume the instruction cache size is always a power of two. */
#if NIOS2_ICACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_ICACHE_SIZE)
#else
    movui r2, NIOS2_ICACHE_SIZE
   20000:	00840014 	movui	r2,4096
#endif

0:
    initi r2
   20004:	1001483a 	initi	r2
    addi r2, r2, -NIOS2_ICACHE_LINE_SIZE
   20008:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
   2000c:	00bffd16 	blt	zero,r2,20004 <__reset+0x4>
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   20010:	004000b4 	movhi	at,2
    ori r1, r1, %lo(_start)
   20014:	08406214 	ori	at,at,392
    jmp r1
   20018:	0800683a 	jmp	at

0002001c <_exit>:
   2001c:	00000000 	call	0 <__reset-0x20000>

Disassembly of section .exceptions:

00020020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   20020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   20024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   20028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   2002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   20030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   20034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   20038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   2003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   20040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   20044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   20048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   2004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   20050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   20054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   20058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   2005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   20060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   20064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   20068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   2006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   20070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   20074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   20078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   2007c:	10000326 	beq	r2,zero,2008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   20080:	20000226 	beq	r4,zero,2008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   20084:	00200fc0 	call	200fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   20088:	00000706 	br	200a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   2008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   20090:	e8bfff17 	ldw	r2,-4(ea)
   20094:	e93fff04 	addi	r4,ea,-4
   20098:	002015c0 	call	2015c <alt_instruction_exception_entry>
   2009c:	1000021e 	bne	r2,zero,200a8 <alt_exception+0x88>
   200a0:	ebffff04 	addi	r15,ea,-4
   200a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   200a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   200ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   200b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   200b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   200b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   200bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   200c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   200c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   200c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   200cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   200d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   200d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   200d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   200dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   200e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   200e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   200e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   200ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   200f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   200f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   200f8:	ef80083a 	eret

000200fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   200fc:	defffe04 	addi	sp,sp,-8
   20100:	dfc00115 	stw	ra,4(sp)
   20104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   20108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   2010c:	040000f4 	movhi	r16,3
   20110:	84220004 	addi	r16,r16,-30720
    i = 0;
   20114:	0005883a 	mov	r2,zero
    mask = 1;
   20118:	00c00044 	movi	r3,1
      if (active & mask)
   2011c:	20ca703a 	and	r5,r4,r3
   20120:	28000b26 	beq	r5,zero,20150 <alt_irq_handler+0x54>
        alt_irq[i].handler(alt_irq[i].context); 
   20124:	100490fa 	slli	r2,r2,3
   20128:	8085883a 	add	r2,r16,r2
   2012c:	10c00017 	ldw	r3,0(r2)
   20130:	11000117 	ldw	r4,4(r2)
   20134:	183ee83a 	callr	r3
   20138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   2013c:	203ff51e 	bne	r4,zero,20114 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   20140:	dfc00117 	ldw	ra,4(sp)
   20144:	dc000017 	ldw	r16,0(sp)
   20148:	dec00204 	addi	sp,sp,8
   2014c:	f800283a 	ret
      mask <<= 1;
   20150:	1806907a 	slli	r3,r3,1
      i++;
   20154:	10800044 	addi	r2,r2,1
      if (active & mask)
   20158:	003ff006 	br	2011c <alt_irq_handler+0x20>

0002015c <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
   2015c:	200b883a 	mov	r5,r4
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
   20160:	000531fa 	rdctl	r2,exception
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
   20164:	000d333a 	rdctl	r6,badaddr
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   20168:	d0e18017 	ldw	r3,-31232(gp)
   2016c:	18000326 	beq	r3,zero,2017c <alt_instruction_exception_entry+0x20>
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
   20170:	1004d0ba 	srli	r2,r2,2
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   20174:	110007cc 	andi	r4,r2,31
   20178:	1800683a 	jmp	r3
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   2017c:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
   20180:	0005883a 	mov	r2,zero
   20184:	f800283a 	ret

Disassembly of section .text:

00020188 <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
   20188:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
   2018c:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
   20190:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
   20194:	00bffd16 	blt	zero,r2,2018c <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   20198:	06c000f4 	movhi	sp,3
    ori sp, sp, %lo(__alt_stack_pointer)
   2019c:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
   201a0:	068000f4 	movhi	gp,3
    ori gp, gp, %lo(_gp)
   201a4:	d6801c14 	ori	gp,gp,112
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   201a8:	008000b4 	movhi	r2,2
    ori r2, r2, %lo(__bss_start)
   201ac:	10a15514 	ori	r2,r2,34132

    movhi r3, %hi(__bss_end)
   201b0:	00c000b4 	movhi	r3,2
    ori r3, r3, %lo(__bss_end)
   201b4:	18e24014 	ori	r3,r3,35072

    beq r2, r3, 1f
   201b8:	10c00326 	beq	r2,r3,201c8 <_start+0x40>

0:
    stw zero, (r2)
   201bc:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   201c0:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   201c4:	10fffd36 	bltu	r2,r3,201bc <_start+0x34>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   201c8:	002727c0 	call	2727c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   201cc:	00273000 	call	27300 <alt_main>

000201d0 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   201d0:	003fff06 	br	201d0 <alt_after_alt_main>

000201d4 <main>:
#include "imported_source/ax58100_hw.h"

int main()
{

  printf("Hello from Nios II!\n");
   201d4:	010000b4 	movhi	r4,2
{
   201d8:	deffff04 	addi	sp,sp,-4
  printf("Hello from Nios II!\n");
   201dc:	211d8f04 	addi	r4,r4,30268
{
   201e0:	dfc00015 	stw	ra,0(sp)
  printf("Hello from Nios II!\n");
   201e4:	0026ed40 	call	26ed4 <puts>
  	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, invert_me);
  	  delay_ms(1000);
  	  invert_me = ~invert_me;
  }*/

  main_initial();
   201e8:	00204b80 	call	204b8 <main_initial>

  return 0;
}
   201ec:	0005883a 	mov	r2,zero
   201f0:	dfc00017 	ldw	ra,0(sp)
   201f4:	dec00104 	addi	sp,sp,4
   201f8:	f800283a 	ret

000201fc <APPL_AckErrorInd>:
*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{

}
   201fc:	f800283a 	ret

00020200 <APPL_StartMailboxHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}
   20200:	0005883a 	mov	r2,zero
   20204:	f800283a 	ret

00020208 <APPL_StopMailboxHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
   20208:	0005883a 	mov	r2,zero
   2020c:	f800283a 	ret

00020210 <APPL_StartInputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
    return ALSTATUSCODE_NOERROR;
}
   20210:	0005883a 	mov	r2,zero
   20214:	f800283a 	ret

00020218 <APPL_StopInputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
   20218:	0005883a 	mov	r2,zero
   2021c:	f800283a 	ret

00020220 <APPL_StartOutputHandler>:
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
   20220:	0005883a 	mov	r2,zero
   20224:	f800283a 	ret

00020228 <APPL_StopOutputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
   20228:	0005883a 	mov	r2,zero
   2022c:	f800283a 	ret

00020230 <APPL_GenerateMapping>:

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
{
   20230:	defff404 	addi	sp,sp,-48
   20234:	dd800815 	stw	r22,32(sp)
   20238:	dd400715 	stw	r21,28(sp)
   2023c:	dd000615 	stw	r20,24(sp)
   20240:	dcc00515 	stw	r19,20(sp)
   20244:	dc000215 	stw	r16,8(sp)
   20248:	dfc00b15 	stw	ra,44(sp)
   2024c:	df000a15 	stw	fp,40(sp)
   20250:	ddc00915 	stw	r23,36(sp)
   20254:	dc800415 	stw	r18,16(sp)
   20258:	dc400315 	stw	r17,12(sp)
   2025c:	2029883a 	mov	r20,r4
   20260:	2827883a 	mov	r19,r5
    UINT32 *pPDOEntry = NULL;
    UINT16 PDOEntryCnt = 0;
   
#if MAX_PD_OUTPUT_SIZE > 0
    /*Scan object 0x1C12 RXPDO assign*/
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20264:	002d883a 	mov	r22,zero
    UINT16 OutputSize = 0;
   20268:	0021883a 	mov	r16,zero
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   2026c:	d5600584 	addi	r21,gp,-32746
   20270:	d0e0058b 	ldhu	r3,-32746(gp)
   20274:	b0bfffcc 	andi	r2,r22,65535
   20278:	10c01a36 	bltu	r2,r3,202e4 <APPL_GenerateMapping+0xb4>
    UINT16 result = ALSTATUSCODE_NOERROR;
   2027c:	0023883a 	mov	r17,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
            break;
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
   20280:	84bfffcc 	andi	r18,r16,65535
   20284:	948001c4 	addi	r18,r18,7
#endif

#if MAX_PD_INPUT_SIZE > 0
    if(result == 0)
   20288:	88bfffcc 	andi	r2,r17,65535
    OutputSize = (OutputSize + 7) >> 3;
   2028c:	9025d0fa 	srai	r18,r18,3
    if(result == 0)
   20290:	10005026 	beq	r2,zero,203d4 <APPL_GenerateMapping+0x1a4>
    UINT16 InputSize = 0;
   20294:	0021883a 	mov	r16,zero
   20298:	04400944 	movi	r17,37
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
                break;
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
   2029c:	843fffcc 	andi	r16,r16,65535
   202a0:	840001c4 	addi	r16,r16,7
   202a4:	8021d0fa 	srai	r16,r16,3
#endif

    *pInputSize = InputSize;
    *pOutputSize = OutputSize;
    return result;
}
   202a8:	8805883a 	mov	r2,r17
    InputSize = (InputSize + 7) >> 3;
   202ac:	a400000d 	sth	r16,0(r20)
    *pOutputSize = OutputSize;
   202b0:	9c80000d 	sth	r18,0(r19)
}
   202b4:	dfc00b17 	ldw	ra,44(sp)
   202b8:	df000a17 	ldw	fp,40(sp)
   202bc:	ddc00917 	ldw	r23,36(sp)
   202c0:	dd800817 	ldw	r22,32(sp)
   202c4:	dd400717 	ldw	r21,28(sp)
   202c8:	dd000617 	ldw	r20,24(sp)
   202cc:	dcc00517 	ldw	r19,20(sp)
   202d0:	dc800417 	ldw	r18,16(sp)
   202d4:	dc400317 	ldw	r17,12(sp)
   202d8:	dc000217 	ldw	r16,8(sp)
   202dc:	dec00c04 	addi	sp,sp,48
   202e0:	f800283a 	ret
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
   202e4:	1004907a 	slli	r2,r2,1
   202e8:	a885883a 	add	r2,r21,r2
   202ec:	1100008b 	ldhu	r4,2(r2)
   202f0:	00241440 	call	24144 <OBJ_GetObjectHandle>
   202f4:	1025883a 	mov	r18,r2
        if(pPDO != NULL)
   202f8:	10001326 	beq	r2,zero,20348 <APPL_GenerateMapping+0x118>
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   202fc:	10800617 	ldw	r2,24(r2)
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20300:	0007883a 	mov	r3,zero
   20304:	1700000b 	ldhu	fp,0(r2)
   20308:	18bfffcc 	andi	r2,r3,65535
   2030c:	1700021e 	bne	r2,fp,20318 <APPL_GenerateMapping+0xe8>
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20310:	b5800044 	addi	r22,r22,1
   20314:	003fd606 	br	20270 <APPL_GenerateMapping+0x40>
                pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   20318:	1c400044 	addi	r17,r3,1
   2031c:	900b883a 	mov	r5,r18
   20320:	89003fcc 	andi	r4,r17,255
   20324:	95c00617 	ldw	r23,24(r18)
   20328:	00246580 	call	24658 <OBJ_GetEntryOffset>
   2032c:	1004d0fa 	srli	r2,r2,3
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20330:	8807883a 	mov	r3,r17
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   20334:	1087ff8c 	andi	r2,r2,8190
   20338:	b8af883a 	add	r23,r23,r2
   2033c:	b8800003 	ldbu	r2,0(r23)
   20340:	1421883a 	add	r16,r2,r16
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20344:	003ff006 	br	20308 <APPL_GenerateMapping+0xd8>
            OutputSize = 0;
   20348:	0021883a 	mov	r16,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
   2034c:	04400944 	movi	r17,37
   20350:	003fcb06 	br	20280 <APPL_GenerateMapping+0x50>
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
   20354:	1004907a 	slli	r2,r2,1
   20358:	b885883a 	add	r2,r23,r2
   2035c:	1100008b 	ldhu	r4,2(r2)
   20360:	00241440 	call	24144 <OBJ_GetObjectHandle>
   20364:	102d883a 	mov	r22,r2
            if(pPDO != NULL)
   20368:	10001e26 	beq	r2,zero,203e4 <APPL_GenerateMapping+0x1b4>
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   2036c:	10800617 	ldw	r2,24(r2)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20370:	8807883a 	mov	r3,r17
   20374:	11c0000b 	ldhu	r7,0(r2)
   20378:	18bfffcc 	andi	r2,r3,65535
   2037c:	11c0051e 	bne	r2,r7,20394 <APPL_GenerateMapping+0x164>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20380:	e7000044 	addi	fp,fp,1
   20384:	d0e0040b 	ldhu	r3,-32752(gp)
   20388:	e0bfffcc 	andi	r2,fp,65535
   2038c:	10fff136 	bltu	r2,r3,20354 <APPL_GenerateMapping+0x124>
   20390:	003fc206 	br	2029c <APPL_GenerateMapping+0x6c>
                    pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   20394:	b1800617 	ldw	r6,24(r22)
   20398:	1d400044 	addi	r21,r3,1
   2039c:	b00b883a 	mov	r5,r22
   203a0:	a9003fcc 	andi	r4,r21,255
   203a4:	d9c00115 	stw	r7,4(sp)
   203a8:	d9800015 	stw	r6,0(sp)
   203ac:	00246580 	call	24658 <OBJ_GetEntryOffset>
   203b0:	1004d0fa 	srli	r2,r2,3
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   203b4:	d9800017 	ldw	r6,0(sp)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203b8:	d9c00117 	ldw	r7,4(sp)
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   203bc:	1087ff8c 	andi	r2,r2,8190
   203c0:	308d883a 	add	r6,r6,r2
   203c4:	30800003 	ldbu	r2,0(r6)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203c8:	a807883a 	mov	r3,r21
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   203cc:	1421883a 	add	r16,r2,r16
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203d0:	003fe906 	br	20378 <APPL_GenerateMapping+0x148>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   203d4:	8839883a 	mov	fp,r17
    UINT16 InputSize = 0;
   203d8:	8821883a 	mov	r16,r17
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   203dc:	d5e00404 	addi	r23,gp,-32752
   203e0:	003fe806 	br	20384 <APPL_GenerateMapping+0x154>
                InputSize = 0;
   203e4:	8821883a 	mov	r16,r17
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
   203e8:	04400904 	movi	r17,36
   203ec:	003fab06 	br	2029c <APPL_GenerateMapping+0x6c>

000203f0 <APPL_InputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
		for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   203f0:	0007883a 	mov	r3,zero
   203f4:	d1a00404 	addi	r6,gp,-32752
   203f8:	d160040b 	ldhu	r5,-32752(gp)
   203fc:	18803fcc 	andi	r2,r3,255
   20400:	11400136 	bltu	r2,r5,20408 <APPL_InputMapping+0x18>
						   sizeof(MLInferenceChannel0x6088.aEntries));
					pTmpData += sizeof(MLInferenceChannel0x6088.aEntries);
					break; */
			}
		}
}
   20404:	f800283a 	ret
			switch (sTxPDOassign.aEntries[j]) {
   20408:	18803fcc 	andi	r2,r3,255
   2040c:	1004907a 	slli	r2,r2,1
   20410:	3085883a 	add	r2,r6,r2
   20414:	1080008b 	ldhu	r2,2(r2)
   20418:	11468020 	cmpeqi	r5,r2,6656
   2041c:	2800041e 	bne	r5,zero,20430 <APPL_InputMapping+0x40>
   20420:	10868060 	cmpeqi	r2,r2,6657
   20424:	1000081e 	bne	r2,zero,20448 <APPL_InputMapping+0x58>
		for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   20428:	18c00044 	addi	r3,r3,1
   2042c:	003ff206 	br	203f8 <APPL_InputMapping+0x8>
					memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   20430:	d0a00383 	ldbu	r2,-32754(gp)
   20434:	20800005 	stb	r2,0(r4)
   20438:	d0a003c3 	ldbu	r2,-32753(gp)
					memcpy(pTmpData, &DeviceID0x6008.DeviceID,
   2043c:	20800045 	stb	r2,1(r4)
					pTmpData += sizeof(DeviceID0x6008.DeviceID);
   20440:	21000084 	addi	r4,r4,2
					break;
   20444:	003ff806 	br	20428 <APPL_InputMapping+0x38>
					memcpy(pTmpData, &DeviceID0x6008.DeviceID,
   20448:	d0a00283 	ldbu	r2,-32758(gp)
   2044c:	20800005 	stb	r2,0(r4)
   20450:	d0a002c3 	ldbu	r2,-32757(gp)
   20454:	003ff906 	br	2043c <APPL_InputMapping+0x4c>

00020458 <APPL_OutputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
		for (UINT8 j = 0; j < sRxPDOassign.u16SubIndex0; j++) {
   20458:	0007883a 	mov	r3,zero
   2045c:	d1a00584 	addi	r6,gp,-32746
   20460:	d160058b 	ldhu	r5,-32746(gp)
   20464:	18803fcc 	andi	r2,r3,255
   20468:	11400136 	bltu	r2,r5,20470 <APPL_OutputMapping+0x18>
						   sizeof(OUT_GENERIC0x7000.OUT_GEN_UINT1));
					pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_UINT1);
					break;
			}
		}
}
   2046c:	f800283a 	ret
			switch (sRxPDOassign.aEntries[j]) {
   20470:	18803fcc 	andi	r2,r3,255
   20474:	1004907a 	slli	r2,r2,1
   20478:	3085883a 	add	r2,r6,r2
   2047c:	1080008b 	ldhu	r2,2(r2)
   20480:	10858018 	cmpnei	r2,r2,5632
   20484:	1000051e 	bne	r2,zero,2049c <APPL_OutputMapping+0x44>
					memcpy(&OUT_GENERIC0x7000.OUT_GEN_UINT1, pTmpData,
   20488:	20800003 	ldbu	r2,0(r4)
					pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_UINT1);
   2048c:	21000084 	addi	r4,r4,2
					memcpy(&OUT_GENERIC0x7000.OUT_GEN_UINT1, pTmpData,
   20490:	d0a00185 	stb	r2,-32762(gp)
   20494:	20bfffc3 	ldbu	r2,-1(r4)
   20498:	d0a001c5 	stb	r2,-32761(gp)
		for (UINT8 j = 0; j < sRxPDOassign.u16SubIndex0; j++) {
   2049c:	18c00044 	addi	r3,r3,1
   204a0:	003fef06 	br	20460 <APPL_OutputMapping+0x8>

000204a4 <APPL_Application>:
\brief    This function will called from the synchronisation ISR 
            or from the mainloop if no synchronisation is supported
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
	IN_GENERIC0x6000.IN_GEN_INT1 = OUT_GENERIC0x7000.OUT_GEN_UINT1;
   204a4:	d0a0018b 	ldhu	r2,-32762(gp)
   204a8:	d0a0038d 	sth	r2,-32754(gp)
	//DeviceID0x6008.DeviceID = (UINT16) OUT_GENERIC0x7000.OUT_GEN_UINT1;
}
   204ac:	f800283a 	ret

000204b0 <APPL_GetDeviceID>:
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GetDeviceID()
{
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    return 0x5;
}
   204b0:	00800144 	movi	r2,5
   204b4:	f800283a 	ret

000204b8 <main_initial>:
#endif

void main_initial(void) {
   204b8:	deffff04 	addi	sp,sp,-4
   204bc:	dfc00015 	stw	ra,0(sp)
    /* initialize the Hardware and the EtherCAT Slave Controller */
    HW_Init();
   204c0:	00208300 	call	20830 <HW_Init>
    MainInit();
   204c4:	00211100 	call	21110 <MainInit>

    bRunApplication = TRUE;
   204c8:	00800044 	movi	r2,1
   204cc:	d0a14905 	stb	r2,-31452(gp)
    do {
        MainLoop();
   204d0:	00215540 	call	21554 <MainLoop>
    } while (bRunApplication == TRUE);
   204d4:	d0a14903 	ldbu	r2,-31452(gp)
   204d8:	10800060 	cmpeqi	r2,r2,1
   204dc:	103ffc1e 	bne	r2,zero,204d0 <main_initial+0x18>

    HW_Release();
}
   204e0:	dfc00017 	ldw	ra,0(sp)
   204e4:	dec00104 	addi	sp,sp,4
    HW_Release();
   204e8:	00207481 	jmpi	20748 <HW_Release>

000204ec <HW_SPI_Read>:
 * @param pBuf
 * @param Addr
 * @param ByteLen
 */

static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   204ec:	defff504 	addi	sp,sp,-44
   204f0:	ddc00915 	stw	r23,36(sp)
   204f4:	dd000615 	stw	r20,24(sp)

        /* Set dummy byte */
        spiTxBuf[DataOffset] = 0xff;

        /* Set read terminal byte */
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   204f8:	05c000f4 	movhi	r23,3
        spiTxBuf[0] = ptr[1];
   204fc:	050000f4 	movhi	r20,3
static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   20500:	dd400715 	stw	r21,28(sp)
   20504:	dc800415 	stw	r18,16(sp)
   20508:	dc400315 	stw	r17,12(sp)
   2050c:	dc000215 	stw	r16,8(sp)
   20510:	dfc00a15 	stw	ra,40(sp)
   20514:	dd800815 	stw	r22,32(sp)
   20518:	dcc00515 	stw	r19,20(sp)
   2051c:	2023883a 	mov	r17,r4
   20520:	2825883a 	mov	r18,r5
   20524:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   20528:	a521a004 	addi	r20,r20,-31104
        spiTxBuf[DataOffset] = 0xff;
   2052c:	057fffc4 	movi	r21,-1
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20530:	bde1a0c4 	addi	r23,r23,-31101
    while (ByteLen) {
   20534:	80bfffcc 	andi	r2,r16,65535
   20538:	10000b1e 	bne	r2,zero,20568 <HW_SPI_Read+0x7c>
        /* Next section */
        Addr += XferLen;
        pBuf += XferLen;
        ByteLen -= XferLen;
    }
}
   2053c:	dfc00a17 	ldw	ra,40(sp)
   20540:	ddc00917 	ldw	r23,36(sp)
   20544:	dd800817 	ldw	r22,32(sp)
   20548:	dd400717 	ldw	r21,28(sp)
   2054c:	dd000617 	ldw	r20,24(sp)
   20550:	dcc00517 	ldw	r19,20(sp)
   20554:	dc800417 	ldw	r18,16(sp)
   20558:	dc400317 	ldw	r17,12(sp)
   2055c:	dc000217 	ldw	r16,8(sp)
   20560:	dec00b04 	addi	sp,sp,44
   20564:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   20568:	10800270 	cmpltui	r2,r2,9
   2056c:	802d883a 	mov	r22,r16
   20570:	1000011e 	bne	r2,zero,20578 <HW_SPI_Read+0x8c>
   20574:	05800204 	movi	r22,8
        AddrTmp = AddrTmp << 3;
   20578:	900490fa 	slli	r2,r18,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2057c:	b4ffffcc 	andi	r19,r22,65535
        spiTxBuf[0] = ptr[1];
   20580:	010000f4 	movhi	r4,3
   20584:	10ffffcc 	andi	r3,r2,65535
   20588:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   2058c:	108000d4 	ori	r2,r2,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20590:	980d883a 	mov	r6,r19
        spiTxBuf[0] = ptr[1];
   20594:	20e1a005 	stb	r3,-31104(r4)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20598:	000b883a 	mov	r5,zero
   2059c:	b809883a 	mov	r4,r23
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   205a0:	a0800045 	stb	r2,1(r20)
        spiTxBuf[DataOffset] = 0xff;
   205a4:	a5400085 	stb	r21,2(r20)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   205a8:	0026f0c0 	call	26f0c <memset>
        spiTxBuf[DataOffset + XferLen] = 0xff;
   205ac:	008000f4 	movhi	r2,3
   205b0:	9885883a 	add	r2,r19,r2
   205b4:	1561a085 	stb	r21,-31102(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   205b8:	00800134 	movhi	r2,4
   205bc:	10041435 	stwio	zero,4176(r2)
													DataOffset + XferLen, 0);
   205c0:	988000c4 	addi	r2,r19,3
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   205c4:	01c000f4 	movhi	r7,3
   205c8:	018000f4 	movhi	r6,3
   205cc:	01000134 	movhi	r4,4
   205d0:	d8000115 	stw	zero,4(sp)
   205d4:	d8800015 	stw	r2,0(sp)
   205d8:	39e19d04 	addi	r7,r7,-31116
   205dc:	31a1a004 	addi	r6,r6,-31104
   205e0:	000b883a 	mov	r5,zero
   205e4:	21040004 	addi	r4,r4,4096
   205e8:	00268280 	call	26828 <spi_transmit_receive>
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   205ec:	00c00044 	movi	r3,1
   205f0:	00800134 	movhi	r2,4
   205f4:	10c41435 	stwio	r3,4176(r2)
        for (i = 0; i < XferLen; i++) {
   205f8:	008000f4 	movhi	r2,3
   205fc:	10a19d04 	addi	r2,r2,-31116
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   20600:	0007883a 	mov	r3,zero
            pBuf[i] = spiRxBuf[DataOffset + i];
   20604:	114000c3 	ldbu	r5,3(r2)
   20608:	88c9883a 	add	r4,r17,r3
        for (i = 0; i < XferLen; i++) {
   2060c:	18c00044 	addi	r3,r3,1
            pBuf[i] = spiRxBuf[DataOffset + i];
   20610:	21400005 	stb	r5,0(r4)
        for (i = 0; i < XferLen; i++) {
   20614:	193fffcc 	andi	r4,r3,65535
   20618:	10800044 	addi	r2,r2,1
   2061c:	24fff936 	bltu	r4,r19,20604 <HW_SPI_Read+0x118>
        Addr += XferLen;
   20620:	b4a5883a 	add	r18,r22,r18
        pBuf += XferLen;
   20624:	8ce3883a 	add	r17,r17,r19
        ByteLen -= XferLen;
   20628:	85a1c83a 	sub	r16,r16,r22
   2062c:	003fc106 	br	20534 <HW_SPI_Read+0x48>

00020630 <HW_SPI_Write>:
 *
 * @param pData
 * @param Addr
 * @param ByteLen
 */
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   20630:	defff604 	addi	sp,sp,-40
   20634:	dd400715 	stw	r21,28(sp)
   20638:	dd000615 	stw	r20,24(sp)
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
        DataOffset = 2;
#endif

        /* Set transmit data bytes */
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   2063c:	054000f4 	movhi	r21,3
        spiTxBuf[0] = ptr[1];
   20640:	050000f4 	movhi	r20,3
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   20644:	dcc00515 	stw	r19,20(sp)
   20648:	dc800415 	stw	r18,16(sp)
   2064c:	dc000215 	stw	r16,8(sp)
   20650:	dfc00915 	stw	ra,36(sp)
   20654:	dd800815 	stw	r22,32(sp)
   20658:	dc400315 	stw	r17,12(sp)
   2065c:	2025883a 	mov	r18,r4
   20660:	2827883a 	mov	r19,r5
   20664:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   20668:	a521a004 	addi	r20,r20,-31104
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   2066c:	ad61a084 	addi	r21,r21,-31102
    while (ByteLen) {
   20670:	80bfffcc 	andi	r2,r16,65535
   20674:	10000a1e 	bne	r2,zero,206a0 <HW_SPI_Write+0x70>

        Addr += XferLen;
        pData += XferLen;
        ByteLen -= XferLen;
    }
}
   20678:	dfc00917 	ldw	ra,36(sp)
   2067c:	dd800817 	ldw	r22,32(sp)
   20680:	dd400717 	ldw	r21,28(sp)
   20684:	dd000617 	ldw	r20,24(sp)
   20688:	dcc00517 	ldw	r19,20(sp)
   2068c:	dc800417 	ldw	r18,16(sp)
   20690:	dc400317 	ldw	r17,12(sp)
   20694:	dc000217 	ldw	r16,8(sp)
   20698:	dec00a04 	addi	sp,sp,40
   2069c:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   206a0:	10c00268 	cmpgeui	r3,r2,9
   206a4:	1800241e 	bne	r3,zero,20738 <HW_SPI_Write+0x108>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   206a8:	108000e0 	cmpeqi	r2,r2,3
   206ac:	1000241e 	bne	r2,zero,20740 <HW_SPI_Write+0x110>
   206b0:	8023883a 	mov	r17,r16
        AddrTmp = AddrTmp << 3;
   206b4:	980490fa 	slli	r2,r19,3
        spiTxBuf[0] = ptr[1];
   206b8:	010000f4 	movhi	r4,3
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   206bc:	8dbfffcc 	andi	r22,r17,65535
        spiTxBuf[0] = ptr[1];
   206c0:	10ffffcc 	andi	r3,r2,65535
   206c4:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   206c8:	10800114 	ori	r2,r2,4
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   206cc:	b00d883a 	mov	r6,r22
        spiTxBuf[0] = ptr[1];
   206d0:	20e1a005 	stb	r3,-31104(r4)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   206d4:	900b883a 	mov	r5,r18
   206d8:	a809883a 	mov	r4,r21
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   206dc:	a0800045 	stb	r2,1(r20)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   206e0:	0026ee40 	call	26ee4 <memcpy>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   206e4:	00800134 	movhi	r2,4
   206e8:	10041435 	stwio	zero,4176(r2)
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   206ec:	88800084 	addi	r2,r17,2
   206f0:	10bfffcc 	andi	r2,r2,65535
   206f4:	01c000f4 	movhi	r7,3
   206f8:	018000f4 	movhi	r6,3
   206fc:	01000134 	movhi	r4,4
   20700:	d8000115 	stw	zero,4(sp)
   20704:	d8800015 	stw	r2,0(sp)
   20708:	39e19d04 	addi	r7,r7,-31116
   2070c:	31a1a004 	addi	r6,r6,-31104
   20710:	000b883a 	mov	r5,zero
   20714:	21040004 	addi	r4,r4,4096
   20718:	00268280 	call	26828 <spi_transmit_receive>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   2071c:	00c00044 	movi	r3,1
   20720:	00800134 	movhi	r2,4
   20724:	10c41435 	stwio	r3,4176(r2)
        Addr += XferLen;
   20728:	9c67883a 	add	r19,r19,r17
        pData += XferLen;
   2072c:	95a5883a 	add	r18,r18,r22
        ByteLen -= XferLen;
   20730:	8461c83a 	sub	r16,r16,r17
   20734:	003fce06 	br	20670 <HW_SPI_Write+0x40>
            XferLen = HW_SPI_MAX_DATA_FRAGMENT_SIZE;
   20738:	04400204 	movi	r17,8
   2073c:	003fdd06 	br	206b4 <HW_SPI_Write+0x84>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   20740:	04400084 	movi	r17,2
   20744:	003fdb06 	br	206b4 <HW_SPI_Write+0x84>

00020748 <HW_Release>:
 * @brief  This function shall be implemented if hardware resources need to be
 * release when the sample application stops.
 * @param  None
 * @retval None
 */
void HW_Release(void) {}
   20748:	f800283a 	ret

0002074c <HW_GetALEventRegister_Isr>:
 * interrupts service routines. The behaviour is equal to
 * "HW_GetALEventRegister()"
 * @param  None
 * @retval First two Bytes of ALEvent register (0x220)
 */
uint16_t HW_GetALEventRegister_Isr(void) {
   2074c:	deffff04 	addi	sp,sp,-4
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscReadIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20750:	01800084 	movi	r6,2
   20754:	01408804 	movi	r5,544
   20758:	d1213984 	addi	r4,gp,-31514
uint16_t HW_GetALEventRegister_Isr(void) {
   2075c:	dfc00015 	stw	ra,0(sp)
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20760:	00204ec0 	call	204ec <HW_SPI_Read>
}
   20764:	d0a1398b 	ldhu	r2,-31514(gp)
   20768:	dfc00017 	ldw	ra,0(sp)
   2076c:	dec00104 	addi	sp,sp,4
   20770:	f800283a 	ret

00020774 <HW_EscRead>:
void HW_EscRead(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   20774:	deffff04 	addi	sp,sp,-4
   20778:	dfc00015 	stw	ra,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   2077c:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20780:	00ffff84 	movi	r3,-2
   20784:	10c4703a 	and	r2,r2,r3
   20788:	1001703a 	wrctl	status,r2
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   2078c:	31bfffcc 	andi	r6,r6,65535
   20790:	297fffcc 	andi	r5,r5,65535
   20794:	00204ec0 	call	204ec <HW_SPI_Read>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   20798:	00800044 	movi	r2,1
   2079c:	1001703a 	wrctl	status,r2
}
   207a0:	dfc00017 	ldw	ra,0(sp)
   207a4:	dec00104 	addi	sp,sp,4
   207a8:	f800283a 	ret

000207ac <HW_GetALEventRegister>:
uint16_t HW_GetALEventRegister(void) {
   207ac:	deffff04 	addi	sp,sp,-4
   207b0:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   207b4:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   207b8:	00ffff84 	movi	r3,-2
   207bc:	10c4703a 	and	r2,r2,r3
   207c0:	1001703a 	wrctl	status,r2
    HW_EscRead((MEM_ADDR*)EscALEvent.Byte, ESC_AL_EVENT_OFFSET, 2);
   207c4:	01800084 	movi	r6,2
   207c8:	01408804 	movi	r5,544
   207cc:	d1213984 	addi	r4,gp,-31514
   207d0:	00207740 	call	20774 <HW_EscRead>
  NIOS2_WRITE_STATUS (context);
   207d4:	00800044 	movi	r2,1
   207d8:	1001703a 	wrctl	status,r2
}
   207dc:	d0a1398b 	ldhu	r2,-31514(gp)
   207e0:	dfc00017 	ldw	ra,0(sp)
   207e4:	dec00104 	addi	sp,sp,4
   207e8:	f800283a 	ret

000207ec <HW_EscReadIsr>:
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   207ec:	31bfffcc 	andi	r6,r6,65535
   207f0:	297fffcc 	andi	r5,r5,65535
   207f4:	00204ec1 	jmpi	204ec <HW_SPI_Read>

000207f8 <HW_EscWrite>:
 * @param  Address     EtherCAT ASIC address ( upper limit is 0x1FFF ) for
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWrite(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   207f8:	deffff04 	addi	sp,sp,-4
   207fc:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   20800:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20804:	00ffff84 	movi	r3,-2
   20808:	10c4703a 	and	r2,r2,r3
   2080c:	1001703a 	wrctl	status,r2

#if AL_EVENT_ENABLED
    DISABLE_AL_EVENT_INT;
#endif
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   20810:	31bfffcc 	andi	r6,r6,65535
   20814:	297fffcc 	andi	r5,r5,65535
   20818:	00206300 	call	20630 <HW_SPI_Write>
  NIOS2_WRITE_STATUS (context);
   2081c:	00800044 	movi	r2,1
   20820:	1001703a 	wrctl	status,r2
#if AL_EVENT_ENABLED
    ENABLE_AL_EVENT_INT;
#endif
}
   20824:	dfc00017 	ldw	ra,0(sp)
   20828:	dec00104 	addi	sp,sp,4
   2082c:	f800283a 	ret

00020830 <HW_Init>:
uint8_t HW_Init(void) {
   20830:	defffd04 	addi	sp,sp,-12
   20834:	dc000115 	stw	r16,4(sp)
   20838:	dfc00215 	stw	ra,8(sp)
        intMask = 0x93;
   2083c:	040024c4 	movi	r16,147
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20840:	01800104 	movi	r6,4
   20844:	01408104 	movi	r5,516
   20848:	d809883a 	mov	r4,sp
        intMask = 0x93;
   2084c:	dc000015 	stw	r16,0(sp)
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20850:	00207f80 	call	207f8 <HW_EscWrite>
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20854:	01800104 	movi	r6,4
   20858:	01408104 	movi	r5,516
   2085c:	d809883a 	mov	r4,sp
        intMask = 0;
   20860:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20864:	00207740 	call	20774 <HW_EscRead>
    } while (intMask != 0x93);
   20868:	d8800017 	ldw	r2,0(sp)
   2086c:	108024d8 	cmpnei	r2,r2,147
   20870:	103ff31e 	bne	r2,zero,20840 <HW_Init+0x10>
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20874:	01800104 	movi	r6,4
   20878:	01408104 	movi	r5,516
   2087c:	d809883a 	mov	r4,sp
    intMask = 0x00;
   20880:	d8000015 	stw	zero,0(sp)
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20884:	00207f80 	call	207f8 <HW_EscWrite>
	init_exti0_it();
   20888:	002664c0 	call	2664c <init_exti0_it>
   2088c:	00800044 	movi	r2,1
   20890:	1001703a 	wrctl	status,r2
    if (bootSwitchID) {
   20894:	d0a1390b 	ldhu	r2,-31516(gp)
   20898:	10000426 	beq	r2,zero,208ac <HW_Init+0x7c>
        HW_EscWriteWord(bootSwitchID, ESC_ALIAS_ADDRESS_OFFSET);
   2089c:	01800084 	movi	r6,2
   208a0:	01400484 	movi	r5,18
   208a4:	d1213904 	addi	r4,gp,-31516
   208a8:	00207f80 	call	207f8 <HW_EscWrite>
}
   208ac:	0005883a 	mov	r2,zero
   208b0:	dfc00217 	ldw	ra,8(sp)
   208b4:	dc000117 	ldw	r16,4(sp)
   208b8:	dec00304 	addi	sp,sp,12
   208bc:	f800283a 	ret

000208c0 <HW_EscWriteIsr>:
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWriteIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   208c0:	31bfffcc 	andi	r6,r6,65535
   208c4:	297fffcc 	andi	r5,r5,65535
   208c8:	00206301 	jmpi	20630 <HW_SPI_Write>

000208cc <HW_SYNC0_IRQHandler>:
/**
 * @brief  Interrupt service routine for SYNC0/SYNC1
 * @param  None
 * @retval None
 */
void HW_SYNC0_IRQHandler(void) {
   208cc:	f800283a 	ret

000208d0 <HW_SYNC1_IRQHandler>:
 * @brief  Interrupt service routine for SYNC0/SYNC1
 * @param  None
 * @retval None
 */

void HW_SYNC1_IRQHandler(void) {
   208d0:	f800283a 	ret

000208d4 <HW_TIMETASK_IRQHandler>:
	if ((__HAL_TIM_GET_IT_SOURCE(&HW_TIMETASK_INSTANCE_H, TIM_IT_UPDATE) ==
		 SET) &&
		(__HAL_TIM_GET_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE) != 0)) {
		__HAL_TIM_CLEAR_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE);
		*/
		ECAT_CheckTimer();
   208d4:	0020de81 	jmpi	20de8 <ECAT_CheckTimer>

000208d8 <COE_SyncTimeStamp>:
          Called from the Timer handler 
*////////////////////////////////////////////////////////////////////////////////////////
void COE_SyncTimeStamp(void)
{

    if (b32BitDc)
   208d8:	d0a15583 	ldbu	r2,-31402(gp)
{
   208dc:	defffe04 	addi	sp,sp,-8
   208e0:	dfc00115 	stw	ra,4(sp)
    if (b32BitDc)
   208e4:	10001226 	beq	r2,zero,20930 <COE_SyncTimeStamp+0x58>
    {
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   208e8:	d0a13e17 	ldw	r2,-31496(gp)


        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   208ec:	d809883a 	mov	r4,sp
   208f0:	01800104 	movi	r6,4
   208f4:	01424404 	movi	r5,2320
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   208f8:	d8800015 	stw	r2,0(sp)
        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   208fc:	00207740 	call	20774 <HW_EscRead>

        /*update the lower 32Bit*/
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   20900:	d8800017 	ldw	r2,0(sp)

        if (DcTime < u32LastDc32Value)
   20904:	d1213d17 	ldw	r4,-31500(gp)
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   20908:	d0e13f17 	ldw	r3,-31492(gp)
   2090c:	d0a13e15 	stw	r2,-31496(gp)
        if (DcTime < u32LastDc32Value)
   20910:	1100022e 	bgeu	r2,r4,2091c <COE_SyncTimeStamp+0x44>
        {
            /*32Bit overrun*/
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
   20914:	18c00044 	addi	r3,r3,1
   20918:	d0e13f15 	stw	r3,-31492(gp)
        }
        
        u32LastDc32Value = DcTime;
   2091c:	d0a13d15 	stw	r2,-31500(gp)
        /*The DC unit supports 64Bit => update the complete object*/
        
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
    }

    u32CheckForDcOverrunCnt = 0;
   20920:	d0213c15 	stw	zero,-31504(gp)

}
   20924:	dfc00117 	ldw	ra,4(sp)
   20928:	dec00204 	addi	sp,sp,8
   2092c:	f800283a 	ret
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
   20930:	01800204 	movi	r6,8
   20934:	01424404 	movi	r5,2320
   20938:	d1213e04 	addi	r4,gp,-31496
   2093c:	00207740 	call	20774 <HW_EscRead>
   20940:	003ff706 	br	20920 <COE_SyncTimeStamp+0x48>

00020944 <Read0x10F8>:
{
   20944:	defffc04 	addi	sp,sp,-16
    if (index != 0x10F8)
   20948:	20bfffcc 	andi	r2,r4,65535
{
   2094c:	dfc00315 	stw	ra,12(sp)
   20950:	dc800215 	stw	r18,8(sp)
   20954:	dc400115 	stw	r17,4(sp)
   20958:	dc000015 	stw	r16,0(sp)
    if (index != 0x10F8)
   2095c:	10843e18 	cmpnei	r2,r2,4344
{
   20960:	d8c00403 	ldbu	r3,16(sp)
    if (index != 0x10F8)
   20964:	1000151e 	bne	r2,zero,209bc <Read0x10F8+0x78>
    if (bCompleteAccess)
   20968:	18c03fcc 	andi	r3,r3,255
   2096c:	1800151e 	bne	r3,zero,209c4 <Read0x10F8+0x80>
   20970:	2821883a 	mov	r16,r5
    if (subindex > 0)
   20974:	29403fcc 	andi	r5,r5,255
   20978:	2800141e 	bne	r5,zero,209cc <Read0x10F8+0x88>
    if (dataSize > 8)
   2097c:	30800268 	cmpgeui	r2,r6,9
   20980:	3023883a 	mov	r17,r6
   20984:	1000131e 	bne	r2,zero,209d4 <Read0x10F8+0x90>
   20988:	3825883a 	mov	r18,r7
    COE_SyncTimeStamp();
   2098c:	00208d80 	call	208d8 <COE_SyncTimeStamp>
    MEMCPY(pData, &u64Timestamp, dataSize);
   20990:	880d883a 	mov	r6,r17
   20994:	d1613e04 	addi	r5,gp,-31496
   20998:	9009883a 	mov	r4,r18
   2099c:	0026ee40 	call	26ee4 <memcpy>
}
   209a0:	8005883a 	mov	r2,r16
   209a4:	dfc00317 	ldw	ra,12(sp)
   209a8:	dc800217 	ldw	r18,8(sp)
   209ac:	dc400117 	ldw	r17,4(sp)
   209b0:	dc000017 	ldw	r16,0(sp)
   209b4:	dec00404 	addi	sp,sp,16
   209b8:	f800283a 	ret
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
   209bc:	040002c4 	movi	r16,11
   209c0:	003ff706 	br	209a0 <Read0x10F8+0x5c>
        return ABORTIDX_UNSUPPORTED_ACCESS;
   209c4:	04000144 	movi	r16,5
   209c8:	003ff506 	br	209a0 <Read0x10F8+0x5c>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   209cc:	04000444 	movi	r16,17
   209d0:	003ff306 	br	209a0 <Read0x10F8+0x5c>
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
   209d4:	040003c4 	movi	r16,15
   209d8:	003ff106 	br	209a0 <Read0x10F8+0x5c>

000209dc <COE_GetObjectDictionary>:
 \brief    returns the pointer to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
OBJCONST TOBJECT OBJMEM * COE_GetObjectDictionary(void)
{
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
}
   209dc:	d0a13a17 	ldw	r2,-31512(gp)
   209e0:	f800283a 	ret

000209e4 <COE_UpdateSyncErrorStatus>:
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   209e4:	00c000f4 	movhi	r3,3
   209e8:	18e1eb04 	addi	r3,r3,-30804
   209ec:	18800a8b 	ldhu	r2,42(r3)
   209f0:	10000f1e 	bne	r2,zero,20a30 <COE_UpdateSyncErrorStatus+0x4c>
   209f4:	008000f4 	movhi	r2,3
   209f8:	19000a0b 	ldhu	r4,40(r3)
   209fc:	10a0060b 	ldhu	r2,-32744(r2)
   20a00:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManOutPar.u8SyncError = 1;
   20a04:	18801005 	stb	r2,64(r3)
    {
        sSyncManOutPar.u8SyncError = 0;
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   20a08:	00c000f4 	movhi	r3,3
   20a0c:	18e1da04 	addi	r3,r3,-30872
   20a10:	18800a8b 	ldhu	r2,42(r3)
   20a14:	1000081e 	bne	r2,zero,20a38 <COE_UpdateSyncErrorStatus+0x54>
   20a18:	008000f4 	movhi	r2,3
   20a1c:	19000a0b 	ldhu	r4,40(r3)
   20a20:	10a0060b 	ldhu	r2,-32744(r2)
   20a24:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManInPar.u8SyncError = 1;
   20a28:	18801005 	stb	r2,64(r3)
    else
    {
        sSyncManInPar.u8SyncError = 0;
    }

}
   20a2c:	f800283a 	ret
   20a30:	00800044 	movi	r2,1
   20a34:	003ff306 	br	20a04 <COE_UpdateSyncErrorStatus+0x20>
   20a38:	00800044 	movi	r2,1
   20a3c:	003ffa06 	br	20a28 <COE_UpdateSyncErrorStatus+0x44>

00020a40 <COE_AddObjectToDic>:

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
    if(pNewObjEntry != NULL)
   20a40:	20002026 	beq	r4,zero,20ac4 <COE_AddObjectToDic+0x84>
    {
        if(ObjDicList == NULL)
   20a44:	d0a13a17 	ldw	r2,-31512(gp)
   20a48:	1000051e 	bne	r2,zero,20a60 <COE_AddObjectToDic+0x20>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
   20a4c:	d1213a15 	stw	r4,-31512(gp)
            ObjDicList->pNext = NULL;
   20a50:	20000115 	stw	zero,4(r4)
            ObjDicList->pPrev = NULL;
   20a54:	20000015 	stw	zero,0(r4)
            return 0;
   20a58:	0005883a 	mov	r2,zero
   20a5c:	f800283a 	ret
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
   20a60:	1140020b 	ldhu	r5,8(r2)
   20a64:	20c0020b 	ldhu	r3,8(r4)
   20a68:	1940142e 	bgeu	r3,r5,20abc <COE_AddObjectToDic+0x7c>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
   20a6c:	20000015 	stw	zero,0(r4)
            pNewObjEntry->pNext = ObjDicList;
   20a70:	20800115 	stw	r2,4(r4)
            ObjDicList->pPrev = pNewObjEntry;
   20a74:	11000015 	stw	r4,0(r2)
            ObjDicList = pNewObjEntry;
   20a78:	d1213a15 	stw	r4,-31512(gp)
            return 0;
   20a7c:	003ff606 	br	20a58 <COE_AddObjectToDic+0x18>
                if(pDicEntry->Index == pNewObjEntry->Index)
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
   20a80:	1940072e 	bgeu	r3,r5,20aa0 <COE_AddObjectToDic+0x60>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20a84:	10c00017 	ldw	r3,0(r2)
                    pNewObjEntry->pNext = pDicEntry;
   20a88:	20800115 	stw	r2,4(r4)
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20a8c:	20c00015 	stw	r3,0(r4)

                    if(pDicEntry->pPrev != NULL)
   20a90:	18000126 	beq	r3,zero,20a98 <COE_AddObjectToDic+0x58>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
   20a94:	19000115 	stw	r4,4(r3)

                    pDicEntry->pPrev = pNewObjEntry;
   20a98:	11000015 	stw	r4,0(r2)

                    return 0;
   20a9c:	003fee06 	br	20a58 <COE_AddObjectToDic+0x18>
                }
                else if(pDicEntry->pNext == NULL)
   20aa0:	11400117 	ldw	r5,4(r2)
   20aa4:	2800041e 	bne	r5,zero,20ab8 <COE_AddObjectToDic+0x78>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
   20aa8:	11000115 	stw	r4,4(r2)
                    pNewObjEntry->pPrev = pDicEntry;
   20aac:	20800015 	stw	r2,0(r4)
                    pNewObjEntry->pNext = NULL;
   20ab0:	20000115 	stw	zero,4(r4)
                    return 0;
   20ab4:	003fe806 	br	20a58 <COE_AddObjectToDic+0x18>
   20ab8:	2805883a 	mov	r2,r5
                if(pDicEntry->Index == pNewObjEntry->Index)
   20abc:	1140020b 	ldhu	r5,8(r2)
   20ac0:	197fef1e 	bne	r3,r5,20a80 <COE_AddObjectToDic+0x40>
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
   20ac4:	00800044 	movi	r2,1
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
}
   20ac8:	f800283a 	ret

00020acc <COE_RemoveDicEntry>:

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20acc:	d1613a17 	ldw	r5,-31512(gp)

    while(pDicEntry != NULL)
    {
        if(pDicEntry->Index == index)
   20ad0:	213fffcc 	andi	r4,r4,65535
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20ad4:	2805883a 	mov	r2,r5
    while(pDicEntry != NULL)
   20ad8:	1000011e 	bne	r2,zero,20ae0 <COE_RemoveDicEntry+0x14>
            return;
        }

        pDicEntry = pDicEntry->pNext;
    }
}
   20adc:	f800283a 	ret
        if(pDicEntry->Index == index)
   20ae0:	1180020b 	ldhu	r6,8(r2)
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20ae4:	10c00117 	ldw	r3,4(r2)
        if(pDicEntry->Index == index)
   20ae8:	31000b1e 	bne	r6,r4,20b18 <COE_RemoveDicEntry+0x4c>
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
   20aec:	11000017 	ldw	r4,0(r2)
            if(pPrevEntry != NULL)
   20af0:	20000126 	beq	r4,zero,20af8 <COE_RemoveDicEntry+0x2c>
                pPrevEntry->pNext = pNextEntry;
   20af4:	20c00115 	stw	r3,4(r4)
            if(pNextEntry != NULL)
   20af8:	18000126 	beq	r3,zero,20b00 <COE_RemoveDicEntry+0x34>
                pNextEntry->pPrev = pPrevEntry;
   20afc:	19000015 	stw	r4,0(r3)
            pDicEntry->pPrev = NULL;
   20b00:	10000015 	stw	zero,0(r2)
            pDicEntry->pNext = NULL;
   20b04:	10000115 	stw	zero,4(r2)
            if(pDicEntry->Index == ObjDicList->Index)
   20b08:	2880020b 	ldhu	r2,8(r5)
   20b0c:	30bff31e 	bne	r6,r2,20adc <COE_RemoveDicEntry+0x10>
                ObjDicList = pNextEntry;
   20b10:	d0e13a15 	stw	r3,-31512(gp)
   20b14:	f800283a 	ret
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20b18:	1805883a 	mov	r2,r3
   20b1c:	003fee06 	br	20ad8 <COE_RemoveDicEntry+0xc>

00020b20 <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
   20b20:	defffe04 	addi	sp,sp,-8
   20b24:	dc000015 	stw	r16,0(sp)
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
   20b28:	d4213a17 	ldw	r16,-31512(gp)
{
   20b2c:	dfc00115 	stw	ra,4(sp)
    UINT16 Index = 0;

    while(pObjEntry != NULL)
   20b30:	8000051e 	bne	r16,zero,20b48 <COE_ClearObjDictionary+0x28>
        Index = pObjEntry->Index;
        pObjEntry = pObjEntry->pNext;

        COE_RemoveDicEntry(Index);
    }
    ObjDicList = NULL;
   20b34:	d0213a15 	stw	zero,-31512(gp)
}
   20b38:	dfc00117 	ldw	ra,4(sp)
   20b3c:	dc000017 	ldw	r16,0(sp)
   20b40:	dec00204 	addi	sp,sp,8
   20b44:	f800283a 	ret
        Index = pObjEntry->Index;
   20b48:	8100020b 	ldhu	r4,8(r16)
        pObjEntry = pObjEntry->pNext;
   20b4c:	84000117 	ldw	r16,4(r16)
        COE_RemoveDicEntry(Index);
   20b50:	213fffcc 	andi	r4,r4,65535
   20b54:	0020acc0 	call	20acc <COE_RemoveDicEntry>
   20b58:	003ff506 	br	20b30 <COE_ClearObjDictionary+0x10>

00020b5c <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
   20b5c:	defffd04 	addi	sp,sp,-12
   20b60:	dc400115 	stw	r17,4(sp)
   20b64:	dc000015 	stw	r16,0(sp)
   20b68:	dfc00215 	stw	ra,8(sp)
   20b6c:	2021883a 	mov	r16,r4
    UINT16 result = 0;
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;

    while(pEntry->Index != 0xFFFF)
   20b70:	047fffd4 	movui	r17,65535
   20b74:	8080020b 	ldhu	r2,8(r16)
   20b78:	1440061e 	bne	r2,r17,20b94 <AddObjectsToObjDictionary+0x38>
        }

        pEntry++;
    }

    return result;
   20b7c:	0005883a 	mov	r2,zero

}
   20b80:	dfc00217 	ldw	ra,8(sp)
   20b84:	dc400117 	ldw	r17,4(sp)
   20b88:	dc000017 	ldw	r16,0(sp)
   20b8c:	dec00304 	addi	sp,sp,12
   20b90:	f800283a 	ret
        result = COE_AddObjectToDic(pEntry);
   20b94:	8009883a 	mov	r4,r16
   20b98:	0020a400 	call	20a40 <COE_AddObjectToDic>
        if(result != 0)
   20b9c:	10ffffcc 	andi	r3,r2,65535
   20ba0:	183ff71e 	bne	r3,zero,20b80 <AddObjectsToObjDictionary+0x24>
        pEntry++;
   20ba4:	84000a04 	addi	r16,r16,40
   20ba8:	003ff206 	br	20b74 <AddObjectsToObjDictionary+0x18>

00020bac <COE_ObjDictionaryInit>:
    UINT16 result = 0;

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20bac:	010000b4 	movhi	r4,2
{
   20bb0:	deffff04 	addi	sp,sp,-4
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20bb4:	211f2504 	addi	r4,r4,31892
{
   20bb8:	dfc00015 	stw	ra,0(sp)
    ObjDicList = NULL;
   20bbc:	d0213a15 	stw	zero,-31512(gp)
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20bc0:	0020b5c0 	call	20b5c <AddObjectsToObjDictionary>

    if(result != 0)
   20bc4:	10ffffcc 	andi	r3,r2,65535
   20bc8:	1800051e 	bne	r3,zero,20be0 <COE_ObjDictionaryInit+0x34>
        return result;
    }
    
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20bcc:	010000b4 	movhi	r4,2
   20bd0:	211fa604 	addi	r4,r4,32408
    }



    return result;
}
   20bd4:	dfc00017 	ldw	ra,0(sp)
   20bd8:	dec00104 	addi	sp,sp,4
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20bdc:	0020b5c1 	jmpi	20b5c <AddObjectsToObjDictionary>
}
   20be0:	dfc00017 	ldw	ra,0(sp)
   20be4:	dec00104 	addi	sp,sp,4
   20be8:	f800283a 	ret

00020bec <COE_ObjInit>:
    sSyncManOutPar.subindex0         = 32;
   20bec:	01400804 	movi	r5,32
   20bf0:	00c000f4 	movhi	r3,3
   20bf4:	1961eb15 	stw	r5,-30804(r3)
    sSyncManOutPar.u32CycleTime     = 0;
   20bf8:	00c000f4 	movhi	r3,3
{
   20bfc:	defffe04 	addi	sp,sp,-8
    sSyncManOutPar.u32CycleTime     = 0;
   20c00:	1821ec15 	stw	zero,-30800(r3)
    sSyncManOutPar.subindex0         = 32;
   20c04:	008000f4 	movhi	r2,3
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20c08:	00c000b4 	movhi	r3,2
{
   20c0c:	dfc00115 	stw	ra,4(sp)
    sSyncManOutPar.subindex0         = 32;
   20c10:	10a1eb04 	addi	r2,r2,-30804
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20c14:	011007c4 	movi	r4,16415
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20c18:	18e1a804 	addi	r3,r3,-31072
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20c1c:	1100030d 	sth	r4,12(r2)
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20c20:	10c00415 	stw	r3,16(r2)
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   20c24:	008000f4 	movhi	r2,3
   20c28:	1021f015 	stw	zero,-30784(r2)
    sSyncManOutPar.u16GetCycleTime = 0;
   20c2c:	008000f4 	movhi	r2,3
   20c30:	1021f20d 	sth	zero,-30776(r2)
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
   20c34:	008000f4 	movhi	r2,3
   20c38:	1021f315 	stw	zero,-30772(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   20c3c:	008000f4 	movhi	r2,3
   20c40:	1021f515 	stw	zero,-30764(r2)
    sSyncManOutPar.u8SyncError = 0;
   20c44:	008000f4 	movhi	r2,3
   20c48:	1021fb05 	stb	zero,-30740(r2)
    sSyncManInPar.subindex0         = 32;
   20c4c:	008000f4 	movhi	r2,3
   20c50:	10a1da04 	addi	r2,r2,-30872
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
   20c54:	1100030d 	sth	r4,12(r2)
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20c58:	10c00415 	stw	r3,16(r2)
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   20c5c:	008000f4 	movhi	r2,3
   20c60:	1021df15 	stw	zero,-30852(r2)
    sSyncManInPar.u16GetCycleTime = 0;
   20c64:	008000f4 	movhi	r2,3
   20c68:	1021e10d 	sth	zero,-30844(r2)
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20c6c:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20c70:	018000f4 	movhi	r6,3
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20c74:	1021e215 	stw	zero,-30840(r2)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20c78:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20c7c:	3161da15 	stw	r5,-30872(r6)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20c80:	1021e415 	stw	zero,-30832(r2)
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20c84:	014000f4 	movhi	r5,3
    sSyncManInPar.u8SyncError = 0;
   20c88:	008000f4 	movhi	r2,3
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20c8c:	2821db15 	stw	zero,-30868(r5)
    sSyncManInPar.u8SyncError = 0;
   20c90:	1021ea05 	stb	zero,-30808(r2)
    bSyncSetByUser = FALSE;
   20c94:	d0216785 	stb	zero,-31330(gp)
    UINT16 result = COE_ObjDictionaryInit();
   20c98:	0020bac0 	call	20bac <COE_ObjDictionaryInit>
    if(result != 0)
   20c9c:	10bfffcc 	andi	r2,r2,65535
   20ca0:	10000126 	beq	r2,zero,20ca8 <COE_ObjInit+0xbc>
        COE_ClearObjDictionary();
   20ca4:	0020b200 	call	20b20 <COE_ClearObjDictionary>
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20ca8:	01800104 	movi	r6,4
   20cac:	01400204 	movi	r5,8
   20cb0:	d809883a 	mov	r4,sp
    u8PendingSdo = 0;
   20cb4:	d0217605 	stb	zero,-31272(gp)
    bStoreCompleteAccess = FALSE;
   20cb8:	d02175c5 	stb	zero,-31273(gp)
    u16StoreIndex   =   0;
   20cbc:	d021750d 	sth	zero,-31276(gp)
    u8StoreSubindex = 0;
   20cc0:	d0217585 	stb	zero,-31274(gp)
    u32StoreDataSize = 0;
   20cc4:	d0217415 	stw	zero,-31280(gp)
    pStoreData = NULL;
   20cc8:	d0217315 	stw	zero,-31284(gp)
    pSdoPendFunc    = NULL;
   20ccc:	d0217215 	stw	zero,-31288(gp)
    pSdoSegData = NULL;
   20cd0:	d0217115 	stw	zero,-31292(gp)
        UINT32 EscFeature = 0;
   20cd4:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20cd8:	00207740 	call	20774 <HW_EscRead>
        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
   20cdc:	d8800017 	ldw	r2,0(sp)
   20ce0:	1080020c 	andi	r2,r2,8
   20ce4:	10000626 	beq	r2,zero,20d00 <COE_ObjInit+0x114>
            b32BitDc = FALSE;
   20ce8:	d0215585 	stb	zero,-31402(gp)
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20cec:	0083e804 	movi	r2,4000
   20cf0:	d0a13c15 	stw	r2,-31504(gp)
}
   20cf4:	dfc00117 	ldw	ra,4(sp)
   20cf8:	dec00204 	addi	sp,sp,8
   20cfc:	f800283a 	ret
            b32BitDc = TRUE;
   20d00:	00800044 	movi	r2,1
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20d04:	01800104 	movi	r6,4
   20d08:	01424404 	movi	r5,2320
   20d0c:	d1213d04 	addi	r4,gp,-31500
            b32BitDc = TRUE;
   20d10:	d0a15585 	stb	r2,-31402(gp)
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20d14:	00207740 	call	20774 <HW_EscRead>
   20d18:	003ff406 	br	20cec <COE_ObjInit+0x100>

00020d1c <COE_Main>:

void COE_Main(void)
{
     UINT8 abort = 0;
     
    if(pSdoPendFunc != NULL)
   20d1c:	d0a17217 	ldw	r2,-31288(gp)
   20d20:	10003026 	beq	r2,zero,20de4 <COE_Main+0xc8>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20d24:	d0e175c3 	ldbu	r3,-31273(gp)
   20d28:	d1e17317 	ldw	r7,-31284(gp)
   20d2c:	d1a17417 	ldw	r6,-31280(gp)
   20d30:	d1617583 	ldbu	r5,-31274(gp)
   20d34:	d121750b 	ldhu	r4,-31276(gp)
{
   20d38:	defffd04 	addi	sp,sp,-12
   20d3c:	dc000115 	stw	r16,4(sp)
   20d40:	dfc00215 	stw	ra,8(sp)
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20d44:	d8c00015 	stw	r3,0(sp)
   20d48:	103ee83a 	callr	r2

        if(abort != ABORTIDX_WORKING)
   20d4c:	14003fcc 	andi	r16,r2,255
   20d50:	80803fe0 	cmpeqi	r2,r16,255
   20d54:	10000f1e 	bne	r2,zero,20d94 <COE_Main+0x78>
        {
            switch(u8PendingSdo)
   20d58:	d0e17603 	ldbu	r3,-31272(gp)
   20d5c:	18803fcc 	andi	r2,r3,255
   20d60:	110000a0 	cmpeqi	r4,r2,2
   20d64:	2000161e 	bne	r4,zero,20dc0 <COE_Main+0xa4>
   20d68:	110000e8 	cmpgeui	r4,r2,3
   20d6c:	20000d1e 	bne	r4,zero,20da4 <COE_Main+0x88>
   20d70:	10800060 	cmpeqi	r2,r2,1
   20d74:	1000161e 	bne	r2,zero,20dd0 <COE_Main+0xb4>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
                    break;

            }

            u8PendingSdo = 0;
   20d78:	d0217605 	stb	zero,-31272(gp)
            u16StoreIndex = 0;
   20d7c:	d021750d 	sth	zero,-31276(gp)
            u8StoreSubindex = 0;
   20d80:	d0217585 	stb	zero,-31274(gp)
            u32StoreDataSize = 0;
   20d84:	d0217415 	stw	zero,-31280(gp)
            pStoreData = NULL;
   20d88:	d0217315 	stw	zero,-31284(gp)
            bStoreCompleteAccess = 0;
   20d8c:	d02175c5 	stb	zero,-31273(gp)
            pSdoPendFunc = NULL;
   20d90:	d0217215 	stw	zero,-31288(gp)
        }
    }
}
   20d94:	dfc00217 	ldw	ra,8(sp)
   20d98:	dc000117 	ldw	r16,4(sp)
   20d9c:	dec00304 	addi	sp,sp,12
   20da0:	f800283a 	ret
            switch(u8PendingSdo)
   20da4:	18ffff44 	addi	r3,r3,-3
   20da8:	18c03fcc 	andi	r3,r3,255
   20dac:	18c000a8 	cmpgeui	r3,r3,2
   20db0:	183ff11e 	bne	r3,zero,20d78 <COE_Main+0x5c>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20db4:	d1a17317 	ldw	r6,-31284(gp)
   20db8:	d1617417 	ldw	r5,-31280(gp)
   20dbc:	00000606 	br	20dd8 <COE_Main+0xbc>
                    if(pSdoSegData)
   20dc0:	d1217117 	ldw	r4,-31292(gp)
   20dc4:	20000226 	beq	r4,zero,20dd0 <COE_Main+0xb4>
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
   20dc8:	0026bec0 	call	26bec <free>
                        pSdoSegData = NULL;
   20dcc:	d0217115 	stw	zero,-31292(gp)
                    SDOS_SdoRes(abort, 0, NULL);
   20dd0:	000d883a 	mov	r6,zero
   20dd4:	000b883a 	mov	r5,zero
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20dd8:	8009883a 	mov	r4,r16
   20ddc:	00260c40 	call	260c4 <SDOS_SdoRes>
                    break;
   20de0:	003fe506 	br	20d78 <COE_Main+0x5c>
   20de4:	f800283a 	ret

00020de8 <ECAT_CheckTimer>:

void ECAT_CheckTimer(void)
{

    /*decrement the state transition timeout counter*/
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20de8:	d0a15383 	ldbu	r2,-31410(gp)
{
   20dec:	deffff04 	addi	sp,sp,-4
   20df0:	dfc00015 	stw	ra,0(sp)
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20df4:	10000726 	beq	r2,zero,20e14 <ECAT_CheckTimer+0x2c>
   20df8:	d0a15c0b 	ldhu	r2,-31376(gp)
   20dfc:	10ffffcc 	andi	r3,r2,65535
   20e00:	18e0001c 	xori	r3,r3,32768
   20e04:	18e00004 	addi	r3,r3,-32768
   20e08:	00c0020e 	bge	zero,r3,20e14 <ECAT_CheckTimer+0x2c>
    {
        EsmTimeoutCounter--;
   20e0c:	10bfffc4 	addi	r2,r2,-1
   20e10:	d0a15c0d 	sth	r2,-31376(gp)
    }



    DC_CheckWatchdog();
   20e14:	00231f40 	call	231f4 <DC_CheckWatchdog>



/*ECATCHANGE_START(V5.13) */
    /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
   20e18:	d0a15583 	ldbu	r2,-31402(gp)
   20e1c:	10000426 	beq	r2,zero,20e30 <ECAT_CheckTimer+0x48>
   20e20:	d0e13e17 	ldw	r3,-31496(gp)
   20e24:	00bff8b4 	movhi	r2,65506
   20e28:	10bed004 	addi	r2,r2,-1216
   20e2c:	10c00f36 	bltu	r2,r3,20e6c <ECAT_CheckTimer+0x84>
/*ECATCHANGE_END(V5.13) */
    {

        /* the timestamp is stored in ns */
        u64Timestamp = u64Timestamp + 1000000;
   20e30:	d0a13e17 	ldw	r2,-31496(gp)
   20e34:	00c003f4 	movhi	r3,15
   20e38:	d1213f17 	ldw	r4,-31492(gp)
   20e3c:	18d09004 	addi	r3,r3,16960
   20e40:	10c7883a 	add	r3,r2,r3
   20e44:	1885803a 	cmpltu	r2,r3,r2
   20e48:	1105883a 	add	r2,r2,r4
   20e4c:	d0e13e15 	stw	r3,-31496(gp)
   20e50:	d0a13f15 	stw	r2,-31492(gp)
    {
        /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
    }

    u32CheckForDcOverrunCnt++;
   20e54:	d0a13c17 	ldw	r2,-31504(gp)
   20e58:	10800044 	addi	r2,r2,1
   20e5c:	d0a13c15 	stw	r2,-31504(gp)


}
   20e60:	dfc00017 	ldw	ra,0(sp)
   20e64:	dec00104 	addi	sp,sp,4
   20e68:	f800283a 	ret
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20e6c:	0083e804 	movi	r2,4000
   20e70:	d0a13c15 	stw	r2,-31504(gp)
   20e74:	003ff706 	br	20e54 <ECAT_CheckTimer+0x6c>

00020e78 <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
   20e78:	defffd04 	addi	sp,sp,-12
   20e7c:	dc000115 	stw	r16,4(sp)
   UINT32 u32CurValue = 0;
   UINT32 u32Delta = 0;

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e80:	01800104 	movi	r6,4
{
   20e84:	2021883a 	mov	r16,r4
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e88:	01424404 	movi	r5,2320
   20e8c:	d809883a 	mov	r4,sp
{
   20e90:	dfc00215 	stw	ra,8(sp)
   UINT32 u32CurValue = 0;
   20e94:	d8000015 	stw	zero,0(sp)
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e98:	00207ec0 	call	207ec <HW_EscReadIsr>

   if (u32CurValue > 0)
   20e9c:	d8800017 	ldw	r2,0(sp)
   20ea0:	10000626 	beq	r2,zero,20ebc <GetSystemTimeDelay+0x44>
   {
      if (u32StartTime <= u32CurValue)
   20ea4:	14000936 	bltu	r2,r16,20ecc <GetSystemTimeDelay+0x54>
      {
         u32Delta = u32CurValue - u32StartTime;
   20ea8:	1405c83a 	sub	r2,r2,r16
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
      }
   }// current value successfully read out

   if (u32StartTime > 0)
   20eac:	80000326 	beq	r16,zero,20ebc <GetSystemTimeDelay+0x44>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
   20eb0:	d0e14317 	ldw	r3,-31476(gp)
   20eb4:	1880082e 	bgeu	r3,r2,20ed8 <GetSystemTimeDelay+0x60>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
   20eb8:	10c5c83a 	sub	r2,r2,r3
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
       }
   }
   return u32Delta;
}
   20ebc:	dfc00217 	ldw	ra,8(sp)
   20ec0:	dc000117 	ldw	r16,4(sp)
   20ec4:	dec00304 	addi	sp,sp,12
   20ec8:	f800283a 	ret
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
   20ecc:	10bfffc4 	addi	r2,r2,-1
   20ed0:	1405c83a 	sub	r2,r2,r16
   if (u32StartTime > 0)
   20ed4:	003ff606 	br	20eb0 <GetSystemTimeDelay+0x38>
   UINT32 u32Delta = 0;
   20ed8:	0005883a 	mov	r2,zero
   return u32Delta;
   20edc:	003ff706 	br	20ebc <GetSystemTimeDelay+0x44>

00020ee0 <PDO_InputMapping>:
{
   20ee0:	defffc04 	addi	sp,sp,-16
   20ee4:	dc800215 	stw	r18,8(sp)
   20ee8:	dc000015 	stw	r16,0(sp)
    if (MEASUREMENT_ACTIVE)
   20eec:	048000f4 	movhi	r18,3
   20ef0:	040000f4 	movhi	r16,3
{
   20ef4:	dfc00315 	stw	ra,12(sp)
   20ef8:	dc400115 	stw	r17,4(sp)
    if (MEASUREMENT_ACTIVE)
   20efc:	94a1eb04 	addi	r18,r18,-30804
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
   20f00:	002074c0 	call	2074c <HW_GetALEventRegister_Isr>
    if (MEASUREMENT_ACTIVE)
   20f04:	8421da04 	addi	r16,r16,-30872
   20f08:	9080070b 	ldhu	r2,28(r18)
   20f0c:	80c0070b 	ldhu	r3,28(r16)
   20f10:	10c4b03a 	or	r2,r2,r3
   20f14:	1080004c 	andi	r2,r2,1
   20f18:	10001b26 	beq	r2,zero,20f88 <PDO_InputMapping+0xa8>
        u32TimeValue = GetSystemTimeDelay(0);
   20f1c:	0009883a 	mov	r4,zero
   20f20:	0020e780 	call	20e78 <GetSystemTimeDelay>
   20f24:	1023883a 	mov	r17,r2
    APPL_InputMapping((UINT16*)aPdInputData);
   20f28:	010000f4 	movhi	r4,3
   20f2c:	2121a304 	addi	r4,r4,-31092
   20f30:	00203f00 	call	203f0 <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
   20f34:	d1a1528b 	ldhu	r6,-31414(gp)
   20f38:	d1614f0b 	ldhu	r5,-31428(gp)
   20f3c:	010000f4 	movhi	r4,3
   20f40:	2121a304 	addi	r4,r4,-31092
   20f44:	00208c00 	call	208c0 <HW_EscWriteIsr>
    if (MEASUREMENT_ACTIVE)
   20f48:	90c0070b 	ldhu	r3,28(r18)
   20f4c:	8080070b 	ldhu	r2,28(r16)
   20f50:	1886b03a 	or	r3,r3,r2
   20f54:	18c0004c 	andi	r3,r3,1
   20f58:	18000526 	beq	r3,zero,20f70 <PDO_InputMapping+0x90>
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20f5c:	8809883a 	mov	r4,r17
   20f60:	0020e780 	call	20e78 <GetSystemTimeDelay>
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
   20f64:	80c00517 	ldw	r3,20(r16)
   20f68:	1880012e 	bgeu	r3,r2,20f70 <PDO_InputMapping+0x90>
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
   20f6c:	80800515 	stw	r2,20(r16)
}
   20f70:	dfc00317 	ldw	ra,12(sp)
   20f74:	dc800217 	ldw	r18,8(sp)
   20f78:	dc400117 	ldw	r17,4(sp)
   20f7c:	dc000017 	ldw	r16,0(sp)
   20f80:	dec00404 	addi	sp,sp,16
   20f84:	f800283a 	ret
    UINT32 u32TimeValue = 0;
   20f88:	0023883a 	mov	r17,zero
   20f8c:	003fe606 	br	20f28 <PDO_InputMapping+0x48>

00020f90 <HandleCycleTimeMeasurement>:
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
   20f90:	d0a15c83 	ldbu	r2,-31374(gp)
   20f94:	1000181e 	bne	r2,zero,20ff8 <HandleCycleTimeMeasurement+0x68>
        if (u32CycleTimeStartValue > 0)
   20f98:	d1214517 	ldw	r4,-31468(gp)
{
   20f9c:	deffff04 	addi	sp,sp,-4
   20fa0:	dfc00015 	stw	ra,0(sp)
        if (u32CycleTimeStartValue > 0)
   20fa4:	20000e26 	beq	r4,zero,20fe0 <HandleCycleTimeMeasurement+0x50>
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20fa8:	0020e780 	call	20e78 <GetSystemTimeDelay>
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20fac:	00c000f4 	movhi	r3,3
   20fb0:	18e1eb04 	addi	r3,r3,-30804
   20fb4:	19000117 	ldw	r4,4(r3)
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20fb8:	d0a14515 	stw	r2,-31468(gp)
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20fbc:	20000126 	beq	r4,zero,20fc4 <HandleCycleTimeMeasurement+0x34>
   20fc0:	1100012e 	bgeu	r2,r4,20fc8 <HandleCycleTimeMeasurement+0x38>
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
   20fc4:	18800115 	stw	r2,4(r3)
            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
   20fc8:	00c000f4 	movhi	r3,3
   20fcc:	18e1da04 	addi	r3,r3,-30872
   20fd0:	19000117 	ldw	r4,4(r3)
   20fd4:	20000126 	beq	r4,zero,20fdc <HandleCycleTimeMeasurement+0x4c>
   20fd8:	1100012e 	bgeu	r2,r4,20fe0 <HandleCycleTimeMeasurement+0x50>
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
   20fdc:	18800115 	stw	r2,4(r3)
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
   20fe0:	0009883a 	mov	r4,zero
   20fe4:	0020e780 	call	20e78 <GetSystemTimeDelay>
   20fe8:	d0a14515 	stw	r2,-31468(gp)
}
   20fec:	dfc00017 	ldw	ra,0(sp)
   20ff0:	dec00104 	addi	sp,sp,4
   20ff4:	f800283a 	ret
   20ff8:	f800283a 	ret

00020ffc <PDO_OutputMapping>:
{
   20ffc:	defffc04 	addi	sp,sp,-16
   21000:	dc800215 	stw	r18,8(sp)
   21004:	dc000015 	stw	r16,0(sp)
   if (MEASUREMENT_ACTIVE)
   21008:	048000f4 	movhi	r18,3
   2100c:	040000f4 	movhi	r16,3
   21010:	8421eb04 	addi	r16,r16,-30804
   21014:	94a1da04 	addi	r18,r18,-30872
   21018:	8080070b 	ldhu	r2,28(r16)
   2101c:	90c0070b 	ldhu	r3,28(r18)
{
   21020:	dfc00315 	stw	ra,12(sp)
   21024:	dc400115 	stw	r17,4(sp)
   if (MEASUREMENT_ACTIVE)
   21028:	10c4b03a 	or	r2,r2,r3
   2102c:	1080004c 	andi	r2,r2,1
   21030:	10002026 	beq	r2,zero,210b4 <PDO_OutputMapping+0xb8>
      u32TimeValue = GetSystemTimeDelay(0);
   21034:	0009883a 	mov	r4,zero
   21038:	0020e780 	call	20e78 <GetSystemTimeDelay>
   2103c:	1023883a 	mov	r17,r2
      u32MinCycleTimeStartValue = u32TimeValue;
   21040:	d0a14415 	stw	r2,-31472(gp)
      bMinCycleTimeMeasurementStarted = TRUE;
   21044:	00800044 	movi	r2,1
   21048:	d0a14205 	stb	r2,-31480(gp)
      u32MinCycleTimeValue = 0;
   2104c:	d0214115 	stw	zero,-31484(gp)
      HandleCycleTimeMeasurement();
   21050:	0020f900 	call	20f90 <HandleCycleTimeMeasurement>
    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
   21054:	d1a1520b 	ldhu	r6,-31416(gp)
   21058:	d1614f8b 	ldhu	r5,-31426(gp)
   2105c:	010000f4 	movhi	r4,3
   21060:	2121bd04 	addi	r4,r4,-30988
   21064:	00207ec0 	call	207ec <HW_EscReadIsr>
    APPL_OutputMapping((UINT16*) aPdOutputData);
   21068:	010000f4 	movhi	r4,3
   2106c:	2121bd04 	addi	r4,r4,-30988
   21070:	00204580 	call	20458 <APPL_OutputMapping>
    if (MEASUREMENT_ACTIVE)
   21074:	8080070b 	ldhu	r2,28(r16)
   21078:	90c0070b 	ldhu	r3,28(r18)
   2107c:	10c4b03a 	or	r2,r2,r3
   21080:	1080004c 	andi	r2,r2,1
   21084:	10000526 	beq	r2,zero,2109c <PDO_OutputMapping+0xa0>
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   21088:	8809883a 	mov	r4,r17
   2108c:	0020e780 	call	20e78 <GetSystemTimeDelay>
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
   21090:	80c00517 	ldw	r3,20(r16)
   21094:	1880012e 	bgeu	r3,r2,2109c <PDO_OutputMapping+0xa0>
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
   21098:	80800515 	stw	r2,20(r16)
}
   2109c:	dfc00317 	ldw	ra,12(sp)
   210a0:	dc800217 	ldw	r18,8(sp)
   210a4:	dc400117 	ldw	r17,4(sp)
   210a8:	dc000017 	ldw	r16,0(sp)
   210ac:	dec00404 	addi	sp,sp,16
   210b0:	f800283a 	ret
   UINT32 u32TimeValue = 0;
   210b4:	0023883a 	mov	r17,zero
   210b8:	003fe606 	br	21054 <PDO_OutputMapping+0x58>

000210bc <Sync1_Isr>:
void Sync1_Isr(void)
{
    Sync1WdCounter = 0;

    /*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   210bc:	d0a15d43 	ldbu	r2,-31371(gp)
    Sync1WdCounter = 0;
   210c0:	d021578d 	sth	zero,-31394(gp)
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   210c4:	10800058 	cmpnei	r2,r2,1
   210c8:	10000f1e 	bne	r2,zero,21108 <Sync1_Isr+0x4c>
   210cc:	d0a1528b 	ldhu	r2,-31414(gp)
   210d0:	10000d26 	beq	r2,zero,21108 <Sync1_Isr+0x4c>
/*ECATCHANGE_END(V5.13) ECAT 5*/
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
   210d4:	008000f4 	movhi	r2,3
   210d8:	10a1da8b 	ldhu	r2,-30870(r2)
   210dc:	108000d8 	cmpnei	r2,r2,3
   210e0:	1000091e 	bne	r2,zero,21108 <Sync1_Isr+0x4c>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
   210e4:	d0a1568b 	ldhu	r2,-31398(gp)
   210e8:	1000071e 	bne	r2,zero,21108 <Sync1_Isr+0x4c>
{
   210ec:	deffff04 	addi	sp,sp,-4
   210f0:	dfc00015 	stw	ra,0(sp)
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
   210f4:	0020ee00 	call	20ee0 <PDO_InputMapping>
        }

        /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
        LatchInputSync0Counter = 0;
   210f8:	d021560d 	sth	zero,-31400(gp)
}
   210fc:	dfc00017 	ldw	ra,0(sp)
   21100:	dec00104 	addi	sp,sp,4
   21104:	f800283a 	ret
        LatchInputSync0Counter = 0;
   21108:	d021560d 	sth	zero,-31400(gp)
   2110c:	f800283a 	ret

00021110 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
   21110:	defffc04 	addi	sp,sp,-16
   21114:	dfc00315 	stw	ra,12(sp)
   21118:	dc000215 	stw	r16,8(sp)




    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
   2111c:	d0214815 	stw	zero,-31456(gp)
    pAPPL_CoeWriteInd = NULL;
   21120:	d0214715 	stw	zero,-31460(gp)
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
   21124:	d0214615 	stw	zero,-31464(gp)

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
   21128:	00235700 	call	23570 <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
   2112c:	0020bec0 	call	20bec <COE_ObjInit>

    /*Reset PDI Access*/
    {
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values

    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21130:	01800084 	movi	r6,2
   21134:	01414004 	movi	r5,1280
   21138:	d9000104 	addi	r4,sp,4
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values
   2113c:	d800010d 	sth	zero,4(sp)
    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21140:	00207740 	call	20774 <HW_EscRead>
    eepromConfigControl = SWAPWORD(eepromConfigControl);
   21144:	d880010b 	ldhu	r2,4(sp)

    if((eepromConfigControl & ESC_EEPROM_ASSIGN_TO_PDI_MASK) > 0)
   21148:	10c0004c 	andi	r3,r2,1
   2114c:	18000626 	beq	r3,zero,21168 <MainInit+0x58>
    {
        /*Clear access register(0x0501.1)*/
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21150:	10bfbfcc 	andi	r2,r2,65279

        eepromConfigControl = SWAPWORD(eepromConfigControl);
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21154:	01800084 	movi	r6,2
   21158:	01414004 	movi	r5,1280
   2115c:	d9000104 	addi	r4,sp,4
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21160:	d880010d 	sth	r2,4(sp)
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21164:	00207f80 	call	207f8 <HW_EscWrite>
    }
    }
    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
   21168:	00800044 	movi	r2,1
   2116c:	d0a14005 	stb	r2,-31488(gp)


    bMinCycleTimeMeasurementStarted = FALSE;
   21170:	d0214205 	stb	zero,-31480(gp)
    u32CycleTimeStartValue = 0;
   21174:	d0214515 	stw	zero,-31468(gp)
    u32MinCycleTimeStartValue = 0;
   21178:	d0214415 	stw	zero,-31472(gp)

    u32SystemTimeReadFailure = 0;
   2117c:	d0214315 	stw	zero,-31476(gp)

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
   21180:	d8000015 	stw	zero,0(sp)
       UINT32 u32Cnt = 0;
       UINT32 u32Delta = 0;
   21184:	d8000115 	stw	zero,4(sp)
   21188:	0400fa04 	movi	r16,1000

       while (u32Cnt < 1000)
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
   2118c:	01800104 	movi	r6,4
   21190:	01424404 	movi	r5,2320
   21194:	d809883a 	mov	r4,sp
   21198:	00207ec0 	call	207ec <HW_EscReadIsr>
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
   2119c:	01800104 	movi	r6,4
   211a0:	01424404 	movi	r5,2320
   211a4:	d9000104 	addi	r4,sp,4
   211a8:	00207ec0 	call	207ec <HW_EscReadIsr>

            if (u32TimeValue <= u32Delta)
   211ac:	d8800017 	ldw	r2,0(sp)
   211b0:	d8c00117 	ldw	r3,4(sp)
   211b4:	18800636 	bltu	r3,r2,211d0 <MainInit+0xc0>
                    u32Delta = u32Delta - u32TimeValue;
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   211b8:	1885c83a 	sub	r2,r3,r2
            }


            if (u32SystemTimeReadFailure == 0)
   211bc:	d0e14317 	ldw	r3,-31476(gp)
                    u32Delta = u32Delta - u32TimeValue;
   211c0:	d8800115 	stw	r2,4(sp)
            if (u32SystemTimeReadFailure == 0)
   211c4:	1800041e 	bne	r3,zero,211d8 <MainInit+0xc8>
            {
                u32SystemTimeReadFailure = u32Delta;
            }
            else if (u32SystemTimeReadFailure > u32Delta)
            {
                u32SystemTimeReadFailure = u32Delta;
   211c8:	d0a14315 	stw	r2,-31476(gp)
   211cc:	00000306 	br	211dc <MainInit+0xcc>
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   211d0:	18ffffc4 	addi	r3,r3,-1
   211d4:	003ff806 	br	211b8 <MainInit+0xa8>
            else if (u32SystemTimeReadFailure > u32Delta)
   211d8:	10fffb36 	bltu	r2,r3,211c8 <MainInit+0xb8>
       while (u32Cnt < 1000)
   211dc:	843fffc4 	addi	r16,r16,-1
   211e0:	803fea1e 	bne	r16,zero,2118c <MainInit+0x7c>



/*Application Init need to be called from the application layer*/
     return Error;
}
   211e4:	0005883a 	mov	r2,zero
   211e8:	dfc00317 	ldw	ra,12(sp)
   211ec:	dc000217 	ldw	r16,8(sp)
   211f0:	dec00404 	addi	sp,sp,16
   211f4:	f800283a 	ret

000211f8 <ECAT_Application>:
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
   211f8:	008000f4 	movhi	r2,3
   211fc:	00c000f4 	movhi	r3,3
   21200:	10a1f20b 	ldhu	r2,-30776(r2)
   21204:	18e1e10b 	ldhu	r3,-30844(r3)
   21208:	10c4b03a 	or	r2,r2,r3
   2120c:	1080004c 	andi	r2,r2,1
   21210:	10000726 	beq	r2,zero,21230 <ECAT_Application+0x38>
    {
        if (nPdOutputSize == 0)
   21214:	d0a1520b 	ldhu	r2,-31416(gp)
   21218:	1000051e 	bne	r2,zero,21230 <ECAT_Application+0x38>
{
   2121c:	deffff04 	addi	sp,sp,-4
   21220:	dfc00015 	stw	ra,0(sp)
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
   21224:	0020f900 	call	20f90 <HandleCycleTimeMeasurement>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
   21228:	dfc00017 	ldw	ra,0(sp)
   2122c:	dec00104 	addi	sp,sp,4
    APPL_Application();
   21230:	00204a41 	jmpi	204a4 <APPL_Application>

00021234 <Sync0_Isr>:
    if(bDcSyncActive)
   21234:	d0a15c83 	ldbu	r2,-31374(gp)
     Sync0WdCounter = 0;
   21238:	d021588d 	sth	zero,-31390(gp)
    if(bDcSyncActive)
   2123c:	10000d26 	beq	r2,zero,21274 <Sync0_Isr+0x40>
{
   21240:	defffe04 	addi	sp,sp,-8
   21244:	dc000015 	stw	r16,0(sp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   21248:	d4215d43 	ldbu	r16,-31371(gp)
{
   2124c:	dfc00115 	stw	ra,4(sp)
   21250:	d0a15a8b 	ldhu	r2,-31382(gp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   21254:	80c03fcc 	andi	r3,r16,255
   21258:	18c00060 	cmpeqi	r3,r3,1
   2125c:	1800061e 	bne	r3,zero,21278 <Sync0_Isr+0x44>
        if(u16SmSync0Value > 0)
   21260:	1000181e 	bne	r2,zero,212c4 <Sync0_Isr+0x90>
        ECAT_Application();
   21264:	00211f80 	call	211f8 <ECAT_Application>
}
   21268:	dfc00117 	ldw	ra,4(sp)
   2126c:	dc000017 	ldw	r16,0(sp)
   21270:	dec00204 	addi	sp,sp,8
    COE_UpdateSyncErrorStatus();
   21274:	00209e41 	jmpi	209e4 <COE_UpdateSyncErrorStatus>
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   21278:	d121568b 	ldhu	r4,-31398(gp)
   2127c:	203ff826 	beq	r4,zero,21260 <Sync0_Isr+0x2c>
   21280:	d0e1528b 	ldhu	r3,-31414(gp)
   21284:	183ff626 	beq	r3,zero,21260 <Sync0_Isr+0x2c>
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
   21288:	d0e1560b 	ldhu	r3,-31400(gp)
   2128c:	197fffcc 	andi	r5,r3,65535
   21290:	2900022e 	bgeu	r5,r4,2129c <Sync0_Isr+0x68>
                LatchInputSync0Counter++;
   21294:	18c00044 	addi	r3,r3,1
   21298:	d0e1560d 	sth	r3,-31400(gp)
            if (LatchInputSync0Value == LatchInputSync0Counter)
   2129c:	d0e1560b 	ldhu	r3,-31400(gp)
   212a0:	20ffef1e 	bne	r4,r3,21260 <Sync0_Isr+0x2c>
        if(u16SmSync0Value > 0)
   212a4:	1000081e 	bne	r2,zero,212c8 <Sync0_Isr+0x94>
        ECAT_Application();
   212a8:	00211f80 	call	211f8 <ECAT_Application>
            PDO_InputMapping();
   212ac:	0020ee00 	call	20ee0 <PDO_InputMapping>
            if(LatchInputSync0Value == 1)
   212b0:	d0a1568b 	ldhu	r2,-31398(gp)
   212b4:	10800058 	cmpnei	r2,r2,1
   212b8:	103feb1e 	bne	r2,zero,21268 <Sync0_Isr+0x34>
                LatchInputSync0Counter = 0;
   212bc:	d021560d 	sth	zero,-31400(gp)
   212c0:	003fe906 	br	21268 <Sync0_Isr+0x34>
        BOOL bCallInputMapping = FALSE;
   212c4:	0021883a 	mov	r16,zero
           if (u16SmSync0Counter > u16SmSync0Value)
   212c8:	d0e15b0b 	ldhu	r3,-31380(gp)
   212cc:	d121520b 	ldhu	r4,-31416(gp)
   212d0:	197fffcc 	andi	r5,r3,65535
   212d4:	11400a36 	bltu	r2,r5,21300 <Sync0_Isr+0xcc>
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   212d8:	20002b1e 	bne	r4,zero,21388 <Sync0_Isr+0x154>
   212dc:	d0a1528b 	ldhu	r2,-31414(gp)
   212e0:	10002926 	beq	r2,zero,21388 <Sync0_Isr+0x154>
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
   212e4:	002074c0 	call	2074c <HW_GetALEventRegister_Isr>
              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
   212e8:	1082000c 	andi	r2,r2,2048
   212ec:	10001f26 	beq	r2,zero,2136c <Sync0_Isr+0x138>
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   212f0:	008000f4 	movhi	r2,3
                 u16SmSync0Counter = 0;
   212f4:	d0215b0d 	sth	zero,-31380(gp)
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   212f8:	1021e40d 	sth	zero,-30832(r2)
   212fc:	00001606 	br	21358 <Sync0_Isr+0x124>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   21300:	20000c1e 	bne	r4,zero,21334 <Sync0_Isr+0x100>
               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   21304:	d0a1528b 	ldhu	r2,-31414(gp)
   21308:	10001326 	beq	r2,zero,21358 <Sync0_Isr+0x124>
   2130c:	008000f4 	movhi	r2,3
   21310:	10a1da04 	addi	r2,r2,-30872
   21314:	10c00a0b 	ldhu	r3,40(r2)
   21318:	014000f4 	movhi	r5,3
   2131c:	2960060b 	ldhu	r5,-32744(r5)
   21320:	193fffcc 	andi	r4,r3,65535
   21324:	293fef36 	bltu	r5,r4,212e4 <Sync0_Isr+0xb0>
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
   21328:	18c000c4 	addi	r3,r3,3
   2132c:	10c00a0d 	sth	r3,40(r2)
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   21330:	003fec06 	br	212e4 <Sync0_Isr+0xb0>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   21334:	008000f4 	movhi	r2,3
   21338:	10a1eb04 	addi	r2,r2,-30804
   2133c:	010000f4 	movhi	r4,3
   21340:	10c00a0b 	ldhu	r3,40(r2)
   21344:	2160060b 	ldhu	r5,-32744(r4)
   21348:	193fffcc 	andi	r4,r3,65535
   2134c:	29000236 	bltu	r5,r4,21358 <Sync0_Isr+0x124>
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
   21350:	18c000c4 	addi	r3,r3,3
   21354:	10c00a0d 	sth	r3,40(r2)
        if (bCallInputMapping == TRUE)
   21358:	84003fcc 	andi	r16,r16,255
   2135c:	84000058 	cmpnei	r16,r16,1
        ECAT_Application();
   21360:	00211f80 	call	211f8 <ECAT_Application>
        if (bCallInputMapping == TRUE)
   21364:	803fd126 	beq	r16,zero,212ac <Sync0_Isr+0x78>
   21368:	003fbf06 	br	21268 <Sync0_Isr+0x34>
                if (u16SmSync0Counter <= u16SmSync0Value)
   2136c:	d0a15b0b 	ldhu	r2,-31380(gp)
   21370:	d1215a8b 	ldhu	r4,-31382(gp)
   21374:	10ffffcc 	andi	r3,r2,65535
   21378:	20fff736 	bltu	r4,r3,21358 <Sync0_Isr+0x124>
                    u16SmSync0Counter++;
   2137c:	10800044 	addi	r2,r2,1
   21380:	d0a15b0d 	sth	r2,-31380(gp)
   21384:	003ff406 	br	21358 <Sync0_Isr+0x124>
               u16SmSync0Counter++;
   21388:	18c00044 	addi	r3,r3,1
   2138c:	d0e15b0d 	sth	r3,-31380(gp)
   21390:	003ff106 	br	21358 <Sync0_Isr+0x124>

00021394 <PDI_Isr>:
{
   21394:	defffb04 	addi	sp,sp,-20
   21398:	dc000115 	stw	r16,4(sp)
   2139c:	dfc00415 	stw	ra,16(sp)
   213a0:	dc800315 	stw	r18,12(sp)
   213a4:	dc400215 	stw	r17,8(sp)
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
   213a8:	002074c0 	call	2074c <HW_GetALEventRegister_Isr>
   213ac:	1021883a 	mov	r16,r2
    if (ALEvent & SYNC1_EVENT)
   213b0:	8080020c 	andi	r2,r16,8
   213b4:	10000b1e 	bne	r2,zero,213e4 <PDI_Isr+0x50>
    if(bEscIntEnabled)
   213b8:	d0a15543 	ldbu	r2,-31403(gp)
   213bc:	10000f1e 	bne	r2,zero,213fc <PDI_Isr+0x68>
    if (ALEvent & SYNC0_EVENT)
   213c0:	8400010c 	andi	r16,r16,4
   213c4:	80004d26 	beq	r16,zero,214fc <PDI_Isr+0x168>
        Sync0_Isr();
   213c8:	00212340 	call	21234 <Sync0_Isr>
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   213cc:	01800104 	movi	r6,4
   213d0:	01426304 	movi	r5,2444
   213d4:	d809883a 	mov	r4,sp
        volatile UINT32 SyncState = 0;
   213d8:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   213dc:	00207740 	call	20774 <HW_EscRead>
   213e0:	00004606 	br	214fc <PDI_Isr+0x168>
        Sync1_Isr();
   213e4:	00210bc0 	call	210bc <Sync1_Isr>
    if(bEscIntEnabled)
   213e8:	d0a15543 	ldbu	r2,-31403(gp)
   213ec:	10004a1e 	bne	r2,zero,21518 <PDI_Isr+0x184>
    if (ALEvent & SYNC0_EVENT)
   213f0:	8400010c 	andi	r16,r16,4
   213f4:	803ff526 	beq	r16,zero,213cc <PDI_Isr+0x38>
   213f8:	003ff306 	br	213c8 <PDI_Isr+0x34>
    BOOL SyncAcknowledgePending = FALSE;
   213fc:	0025883a 	mov	r18,zero
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21400:	044000f4 	movhi	r17,3
   21404:	8401000c 	andi	r16,r16,1024
   21408:	8c61eb04 	addi	r17,r17,-30804
   2140c:	80001226 	beq	r16,zero,21458 <PDI_Isr+0xc4>
            if(bDcRunning && bDcSyncActive)
   21410:	d0a15b83 	ldbu	r2,-31378(gp)
   21414:	10000326 	beq	r2,zero,21424 <PDI_Isr+0x90>
   21418:	d0a15c83 	ldbu	r2,-31374(gp)
   2141c:	10000126 	beq	r2,zero,21424 <PDI_Isr+0x90>
                u16SmSync0Counter = 0;
   21420:	d0215b0d 	sth	zero,-31380(gp)
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
   21424:	88800a0b 	ldhu	r2,40(r17)
   21428:	10ffffcc 	andi	r3,r2,65535
   2142c:	18000226 	beq	r3,zero,21438 <PDI_Isr+0xa4>
                sSyncManOutPar.u16SmEventMissedCounter--;
   21430:	10bfffc4 	addi	r2,r2,-1
   21434:	88800a0d 	sth	r2,40(r17)
            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
   21438:	88c00a0b 	ldhu	r3,40(r17)
   2143c:	008000f4 	movhi	r2,3
   21440:	10e1e40d 	sth	r3,-30832(r2)
        bEcatFirstOutputsReceived = TRUE;
   21444:	00800044 	movi	r2,1
   21448:	d0a15d05 	stb	r2,-31372(gp)
        if ( bEcatOutputUpdateRunning )
   2144c:	d0a15d83 	ldbu	r2,-31370(gp)
   21450:	10003326 	beq	r2,zero,21520 <PDI_Isr+0x18c>
            PDO_OutputMapping();
   21454:	0020ffc0 	call	20ffc <PDO_OutputMapping>
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
   21458:	8880008b 	ldhu	r2,2(r17)
   2145c:	10800058 	cmpnei	r2,r2,1
   21460:	1000011e 	bne	r2,zero,21468 <PDI_Isr+0xd4>
            ECAT_Application();
   21464:	00211f80 	call	211f8 <ECAT_Application>
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21468:	d0a15d43 	ldbu	r2,-31371(gp)
   2146c:	10800058 	cmpnei	r2,r2,1
   21470:	1000091e 	bne	r2,zero,21498 <PDI_Isr+0x104>
   21474:	d0a1528b 	ldhu	r2,-31414(gp)
   21478:	10000726 	beq	r2,zero,21498 <PDI_Isr+0x104>
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
   2147c:	008000f4 	movhi	r2,3
   21480:	10a1da8b 	ldhu	r2,-30870(r2)
   21484:	10c00060 	cmpeqi	r3,r2,1
   21488:	1800021e 	bne	r3,zero,21494 <PDI_Isr+0x100>
   2148c:	10800898 	cmpnei	r2,r2,34
   21490:	1000011e 	bne	r2,zero,21498 <PDI_Isr+0x104>
        PDO_InputMapping();
   21494:	0020ee00 	call	20ee0 <PDO_InputMapping>
    ALEvent = HW_GetALEventRegister_Isr();
   21498:	002074c0 	call	2074c <HW_GetALEventRegister_Isr>
   2149c:	1021883a 	mov	r16,r2
    if ( ALEvent & PROCESS_OUTPUT_EVENT )
   214a0:	8081000c 	andi	r2,r16,1024
   214a4:	10001126 	beq	r2,zero,214ec <PDI_Isr+0x158>
        sSyncManOutPar.u16CycleExceededCounter++;
   214a8:	88800a8b 	ldhu	r2,42(r17)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   214ac:	d1614f8b 	ldhu	r5,-31426(gp)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   214b0:	00c000f4 	movhi	r3,3
        sSyncManOutPar.u16CycleExceededCounter++;
   214b4:	10800044 	addi	r2,r2,1
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   214b8:	01800044 	movi	r6,1
   214bc:	d1214dc4 	addi	r4,gp,-31433
        sSyncManOutPar.u16CycleExceededCounter++;
   214c0:	88800a8d 	sth	r2,42(r17)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   214c4:	18a1e48d 	sth	r2,-30830(r3)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   214c8:	00207ec0 	call	207ec <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   214cc:	d1614f8b 	ldhu	r5,-31426(gp)
   214d0:	d0a1520b 	ldhu	r2,-31416(gp)
   214d4:	01800044 	movi	r6,1
   214d8:	d1214dc4 	addi	r4,gp,-31433
   214dc:	288b883a 	add	r5,r5,r2
   214e0:	297fffc4 	addi	r5,r5,-1
   214e4:	297fffcc 	andi	r5,r5,65535
   214e8:	00207ec0 	call	207ec <HW_EscReadIsr>
    if (ALEvent & SYNC0_EVENT)
   214ec:	8400010c 	andi	r16,r16,4
   214f0:	803fb51e 	bne	r16,zero,213c8 <PDI_Isr+0x34>
    if (SyncAcknowledgePending)
   214f4:	94803fcc 	andi	r18,r18,255
   214f8:	903fb41e 	bne	r18,zero,213cc <PDI_Isr+0x38>
    COE_UpdateSyncErrorStatus();
   214fc:	00209e40 	call	209e4 <COE_UpdateSyncErrorStatus>
}
   21500:	dfc00417 	ldw	ra,16(sp)
   21504:	dc800317 	ldw	r18,12(sp)
   21508:	dc400217 	ldw	r17,8(sp)
   2150c:	dc000117 	ldw	r16,4(sp)
   21510:	dec00504 	addi	sp,sp,20
   21514:	f800283a 	ret
        SyncAcknowledgePending = TRUE;
   21518:	04800044 	movi	r18,1
   2151c:	003fb806 	br	21400 <PDI_Isr+0x6c>
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21520:	d1614f8b 	ldhu	r5,-31426(gp)
   21524:	01800044 	movi	r6,1
   21528:	d1214dc4 	addi	r4,gp,-31433
   2152c:	00207ec0 	call	207ec <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   21530:	d0a1520b 	ldhu	r2,-31416(gp)
   21534:	d1614f8b 	ldhu	r5,-31426(gp)
   21538:	01800044 	movi	r6,1
   2153c:	d1214dc4 	addi	r4,gp,-31433
   21540:	288b883a 	add	r5,r5,r2
   21544:	297fffc4 	addi	r5,r5,-1
   21548:	297fffcc 	andi	r5,r5,65535
   2154c:	00207ec0 	call	207ec <HW_EscReadIsr>
   21550:	003fc106 	br	21458 <PDI_Isr+0xc4>

00021554 <MainLoop>:
    if(bInitFinished == FALSE)
   21554:	d0a14003 	ldbu	r2,-31488(gp)
   21558:	10003226 	beq	r2,zero,21624 <MainLoop+0xd0>
        if (
   2155c:	d0a15543 	ldbu	r2,-31403(gp)
{
   21560:	deffff04 	addi	sp,sp,-4
   21564:	dfc00015 	stw	ra,0(sp)
          && !bDcSyncActive                                               /* DC-Synchronous */
   21568:	d0e15c83 	ldbu	r3,-31374(gp)
        if (
   2156c:	10000e1e 	bne	r2,zero,215a8 <MainLoop+0x54>
          && !bDcSyncActive                                               /* DC-Synchronous */
   21570:	18c03fcc 	andi	r3,r3,255
   21574:	18001826 	beq	r3,zero,215d8 <MainLoop+0x84>
        if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
   21578:	d0a13c17 	ldw	r2,-31504(gp)
   2157c:	1083e830 	cmpltui	r2,r2,4000
   21580:	1000011e 	bne	r2,zero,21588 <MainLoop+0x34>
            COE_SyncTimeStamp();
   21584:	00208d80 	call	208d8 <COE_SyncTimeStamp>
        ECAT_Main();
   21588:	00236500 	call	23650 <ECAT_Main>
       COE_Main();
   2158c:	0020d1c0 	call	20d1c <COE_Main>
       CheckIfEcatError();
   21590:	00232b40 	call	232b4 <CheckIfEcatError>
    if (pAPPL_MainLoop != NULL)
   21594:	d0a14617 	ldw	r2,-31464(gp)
   21598:	10001f26 	beq	r2,zero,21618 <MainLoop+0xc4>
}
   2159c:	dfc00017 	ldw	ra,0(sp)
   215a0:	dec00104 	addi	sp,sp,4
        pAPPL_MainLoop();
   215a4:	1000683a 	jmp	r2
          && !bDcSyncActive                                               /* DC-Synchronous */
   215a8:	d0a15d03 	ldbu	r2,-31372(gp)
   215ac:	10c4b03a 	or	r2,r2,r3
   215b0:	10803fcc 	andi	r2,r2,255
   215b4:	103ff01e 	bne	r2,zero,21578 <MainLoop+0x24>
             ECAT_Application();
   215b8:	00211f80 	call	211f8 <ECAT_Application>
             if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
   215bc:	d0a15d43 	ldbu	r2,-31371(gp)
   215c0:	10800058 	cmpnei	r2,r2,1
   215c4:	103fec1e 	bne	r2,zero,21578 <MainLoop+0x24>
   215c8:	d0a1528b 	ldhu	r2,-31414(gp)
   215cc:	103fea26 	beq	r2,zero,21578 <MainLoop+0x24>
                PDO_InputMapping();
   215d0:	0020ee00 	call	20ee0 <PDO_InputMapping>
   215d4:	003fe806 	br	21578 <MainLoop+0x24>
                UINT16 ALEvent = HW_GetALEventRegister();
   215d8:	00207ac0 	call	207ac <HW_GetALEventRegister>
                if ( ALEvent & PROCESS_OUTPUT_EVENT )
   215dc:	10c1000c 	andi	r3,r2,1024
   215e0:	18000626 	beq	r3,zero,215fc <MainLoop+0xa8>
                    bEcatFirstOutputsReceived = TRUE;
   215e4:	00800044 	movi	r2,1
   215e8:	d0a15d05 	stb	r2,-31372(gp)
                    if ( bEcatOutputUpdateRunning )
   215ec:	d0a15d83 	ldbu	r2,-31370(gp)
   215f0:	103ff126 	beq	r2,zero,215b8 <MainLoop+0x64>
                        PDO_OutputMapping();
   215f4:	0020ffc0 	call	20ffc <PDO_OutputMapping>
   215f8:	003fef06 	br	215b8 <MainLoop+0x64>
                else if ( nPdOutputSize == 0 )
   215fc:	d0e1520b 	ldhu	r3,-31416(gp)
   21600:	183fed1e 	bne	r3,zero,215b8 <MainLoop+0x64>
                    if ( ALEvent & PROCESS_INPUT_EVENT )
   21604:	1082000c 	andi	r2,r2,2048
   21608:	103feb26 	beq	r2,zero,215b8 <MainLoop+0x64>
                        bEcatFirstOutputsReceived = TRUE;
   2160c:	00800044 	movi	r2,1
   21610:	d0a15d05 	stb	r2,-31372(gp)
   21614:	003fe806 	br	215b8 <MainLoop+0x64>
}
   21618:	dfc00017 	ldw	ra,0(sp)
   2161c:	dec00104 	addi	sp,sp,4
   21620:	f800283a 	ret
   21624:	f800283a 	ret

00021628 <ESC_EepromAccess>:
 \brief        Controller (switch BIG_ENDIAN_FORMAT set) the data has to be swapped outside
 \brief        of this function)
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access)
{
   21628:	defff404 	addi	sp,sp,-48
   2162c:	dd000615 	stw	r20,24(sp)
   21630:	dcc00515 	stw	r19,20(sp)
   21634:	d9000015 	stw	r4,0(sp)
   21638:	3029883a 	mov	r20,r6
    UINT8 RetryCnt = MAX_CMD_RETIRES; //Maximum number of retries (evaluated in case of an Acknowledge Error)

    UINT16 nConfig;
    VARVOLATILE UINT16 nControl;

    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   2163c:	d9000104 	addi	r4,sp,4
   21640:	01800084 	movi	r6,2
{
   21644:	2827883a 	mov	r19,r5
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21648:	01414004 	movi	r5,1280
{
   2164c:	dfc00b15 	stw	ra,44(sp)
   21650:	dd800815 	stw	r22,32(sp)
   21654:	dc000215 	stw	r16,8(sp)
   21658:	382d883a 	mov	r22,r7
   2165c:	3821883a 	mov	r16,r7
   21660:	df000a15 	stw	fp,40(sp)
   21664:	ddc00915 	stw	r23,36(sp)
   21668:	dd400715 	stw	r21,28(sp)
   2166c:	dc800415 	stw	r18,16(sp)
   21670:	dc400315 	stw	r17,12(sp)
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21674:	00207740 	call	20774 <HW_EscRead>
    HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21678:	01800084 	movi	r6,2
   2167c:	01414084 	movi	r5,1282
   21680:	d9000184 	addi	r4,sp,6
   21684:	00207740 	call	20774 <HW_EscRead>



    if ( nConfig & ESC_EEPROM_ASSIGN_TO_PDI_MASK )
   21688:	d880010b 	ldhu	r2,4(sp)
   2168c:	1080004c 	andi	r2,r2,1
   21690:	10006a26 	beq	r2,zero,2183c <ESC_EepromAccess+0x214>
    {
        /* register 0x500.0 is set (should be written by the master before sending
        the state transition request to PREOP),we have access to the EEPROM */
        UINT16 step = 1; /* we write always only 1 word with one write access */

        if ( access == ESC_RD )
   21694:	84003fcc 	andi	r16,r16,255
   21698:	84000098 	cmpnei	r16,r16,2
   2169c:	1023883a 	mov	r17,r2
   216a0:	8000041e 	bne	r16,zero,216b4 <ESC_EepromAccess+0x8c>
        {
            /* read access requested, we have to check if we read 2 (register 0x502.6=0)
            or 4 words (register 0x502.6=1) with one access */
            if ( nControl & ESC_EEPROM_SUPPORTED_READBYTES_MASK )
   216a4:	d880018b 	ldhu	r2,6(sp)
   216a8:	1080100c 	andi	r2,r2,64
   216ac:	10002126 	beq	r2,zero,21734 <ESC_EepromAccess+0x10c>
            {
                step = 4; /* we get 4 words with one read access */
   216b0:	04400104 	movi	r17,4
            }
            else
            {
                if ( access == ESC_RD )
                {
                    UINT16 u16BytesToCopy = (step << 1);
   216b4:	882e907a 	slli	r23,r17,1
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   216b8:	00804004 	movi	r2,256
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   216bc:	01800084 	movi	r6,2
   216c0:	01414004 	movi	r5,1280
   216c4:	d9000104 	addi	r4,sp,4
            if ( access == ESC_RD )
   216c8:	b5803fcc 	andi	r22,r22,255
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   216cc:	d880010d 	sth	r2,4(sp)
        for (i = 0; i < wordsize;)
   216d0:	0025883a 	mov	r18,zero
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   216d4:	00207f80 	call	207f8 <HW_EscWrite>
        for (i = 0; i < wordsize;)
   216d8:	9d7fffcc 	andi	r21,r19,65535
                if ( access == ESC_RD )
   216dc:	b7000098 	cmpnei	fp,r22,2
        for (i = 0; i < wordsize;)
   216e0:	943fffcc 	andi	r16,r18,65535
   216e4:	85401536 	bltu	r16,r21,2173c <ESC_EepromAccess+0x114>
    UINT16 u16RetErr = 0;
   216e8:	0021883a 	mov	r16,zero
    }

    /* clear EEPROM control register 0x500 */
    nConfig = 0;

    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   216ec:	01800084 	movi	r6,2
   216f0:	01414004 	movi	r5,1280
   216f4:	d9000104 	addi	r4,sp,4
    nConfig = 0;
   216f8:	d800010d 	sth	zero,4(sp)
    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   216fc:	00207f80 	call	207f8 <HW_EscWrite>
    return u16RetErr;
}
   21700:	8005883a 	mov	r2,r16
   21704:	dfc00b17 	ldw	ra,44(sp)
   21708:	df000a17 	ldw	fp,40(sp)
   2170c:	ddc00917 	ldw	r23,36(sp)
   21710:	dd800817 	ldw	r22,32(sp)
   21714:	dd400717 	ldw	r21,28(sp)
   21718:	dd000617 	ldw	r20,24(sp)
   2171c:	dcc00517 	ldw	r19,20(sp)
   21720:	dc800417 	ldw	r18,16(sp)
   21724:	dc400317 	ldw	r17,12(sp)
   21728:	dc000217 	ldw	r16,8(sp)
   2172c:	dec00c04 	addi	sp,sp,48
   21730:	f800283a 	ret
                step = 2; /* we get 2 words with one read access */
   21734:	04400084 	movi	r17,2
   21738:	003fde06 	br	216b4 <ESC_EepromAccess+0x8c>
            HW_EscWrite((MEM_ADDR *) &wordaddress, ESC_EEPROM_ADDRESS_OFFSET, 4);
   2173c:	01800104 	movi	r6,4
   21740:	01414104 	movi	r5,1284
   21744:	d809883a 	mov	r4,sp
   21748:	00207f80 	call	207f8 <HW_EscWrite>
            if ( access == ESC_RD )
   2174c:	b0800098 	cmpnei	r2,r22,2
   21750:	10001b1e 	bne	r2,zero,217c0 <ESC_EepromAccess+0x198>
                nControl = ESC_EEPROM_CMD_READ_MASK;
   21754:	00804004 	movi	r2,256
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21758:	01800084 	movi	r6,2
   2175c:	01414084 	movi	r5,1282
   21760:	d9000184 	addi	r4,sp,6
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   21764:	d880018d 	sth	r2,6(sp)
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21768:	00207f80 	call	207f8 <HW_EscWrite>
                HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   2176c:	01800084 	movi	r6,2
   21770:	01414084 	movi	r5,1282
   21774:	d9000184 	addi	r4,sp,6
   21778:	00207740 	call	20774 <HW_EscRead>
            while ( nControl & (ESC_EEPROM_BUSY_MASK));
   2177c:	d880018b 	ldhu	r2,6(sp)
   21780:	10bfffcc 	andi	r2,r2,65535
   21784:	10a0001c 	xori	r2,r2,32768
   21788:	10a00004 	addi	r2,r2,-32768
   2178c:	103ff716 	blt	r2,zero,2176c <ESC_EepromAccess+0x144>
            HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21790:	01800084 	movi	r6,2
   21794:	01414084 	movi	r5,1282
   21798:	d9000184 	addi	r4,sp,6
   2179c:	00207740 	call	20774 <HW_EscRead>
            if ( nControl & ESC_EEPROM_ERROR_MASK )
   217a0:	d880018b 	ldhu	r2,6(sp)
   217a4:	109e000c 	andi	r2,r2,30720
   217a8:	10000c26 	beq	r2,zero,217dc <ESC_EepromAccess+0x1b4>
                if(!(nControl & ESC_EEPROM_ERROR_CMD_ACK) && (RetryCnt != 0))
   217ac:	d880018b 	ldhu	r2,6(sp)
   217b0:	1088000c 	andi	r2,r2,8192
   217b4:	1000151e 	bne	r2,zero,2180c <ESC_EepromAccess+0x1e4>
                    u16RetErr =  ALSTATUSCODE_EE_ERROR;
   217b8:	04001444 	movi	r16,81
   217bc:	003fcb06 	br	216ec <ESC_EepromAccess+0xc4>
                HW_EscWriteWord(pData[i],ESC_EEPROM_DATA_OFFSET);
   217c0:	8008907a 	slli	r4,r16,1
   217c4:	01800084 	movi	r6,2
   217c8:	01414204 	movi	r5,1288
   217cc:	a109883a 	add	r4,r20,r4
   217d0:	00207f80 	call	207f8 <HW_EscWrite>
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   217d4:	00808004 	movi	r2,512
   217d8:	003fdf06 	br	21758 <ESC_EepromAccess+0x130>
                if ( access == ESC_RD )
   217dc:	e0000b1e 	bne	fp,zero,2180c <ESC_EepromAccess+0x1e4>
                    if((u16WordOffset + step) > wordsize)
   217e0:	88bfffcc 	andi	r2,r17,65535
   217e4:	8085883a 	add	r2,r16,r2
   217e8:	a880110e 	bge	r21,r2,21830 <ESC_EepromAccess+0x208>
                        u16BytesToCopy = (wordsize - u16WordOffset) << 1;
   217ec:	91bfffa4 	muli	r6,r18,-2
   217f0:	9804907a 	slli	r2,r19,1
   217f4:	308d883a 	add	r6,r6,r2
                    HW_EscRead((MEM_ADDR *) &pData[i], ESC_EEPROM_DATA_OFFSET, u16BytesToCopy);
   217f8:	8008907a 	slli	r4,r16,1
   217fc:	31bfffcc 	andi	r6,r6,65535
   21800:	01414204 	movi	r5,1288
   21804:	a109883a 	add	r4,r20,r4
   21808:	00207740 	call	20774 <HW_EscRead>
            if(!(nControl & ESC_EEPROM_ERROR_MASK))
   2180c:	d880018b 	ldhu	r2,6(sp)
   21810:	109e000c 	andi	r2,r2,30720
   21814:	1000081e 	bne	r2,zero,21838 <ESC_EepromAccess+0x210>
                wordaddress += step;
   21818:	d8800017 	ldw	r2,0(sp)
   2181c:	88ffffcc 	andi	r3,r17,65535
                u16WordOffset +=step;
   21820:	9465883a 	add	r18,r18,r17
                wordaddress += step;
   21824:	10c5883a 	add	r2,r2,r3
   21828:	d8800015 	stw	r2,0(sp)
                i += step;
   2182c:	003fac06 	br	216e0 <ESC_EepromAccess+0xb8>
                    UINT16 u16BytesToCopy = (step << 1);
   21830:	b80d883a 	mov	r6,r23
   21834:	003ff006 	br	217f8 <ESC_EepromAccess+0x1d0>
                    while(i32TimeoutTicks > 0)
   21838:	003fff06 	br	21838 <ESC_EepromAccess+0x210>
        u16RetErr = ALSTATUSCODE_EE_NOACCESS;
   2183c:	04001404 	movi	r16,80
   21840:	003faa06 	br	216ec <ESC_EepromAccess+0xc4>

00021844 <ESC_EepromWriteCRC>:

 \brief        This function recalculates the EEPROM CRC and writes the updated value to EEPROM.
            After writing the ESC Config Area a device restart is required!
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 ESC_EepromWriteCRC(void)
{
   21844:	defffa04 	addi	sp,sp,-24
    UINT16 u16Return = ALSTATUSCODE_UNSPECIFIEDERROR;
    UINT16 EscCfgData[8];
    UINT16 u16Crc = 0x00FF;
   21848:	00803fc4 	movi	r2,255
    UINT16 i,j;

    
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   2184c:	01c00084 	movi	r7,2
   21850:	d9800104 	addi	r6,sp,4
   21854:	014001c4 	movi	r5,7
   21858:	0009883a 	mov	r4,zero
{
   2185c:	dfc00515 	stw	ra,20(sp)
    UINT16 u16Crc = 0x00FF;
   21860:	d880008d 	sth	r2,2(sp)
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   21864:	00216280 	call	21628 <ESC_EepromAccess>
    if(u16Return == 0)
   21868:	10ffffcc 	andi	r3,r2,65535
   2186c:	18001c1e 	bne	r3,zero,218e0 <ESC_EepromWriteCRC+0x9c>
   21870:	d880008b 	ldhu	r2,2(sp)
    {
        UINT8 *pData = (UINT8 *)EscCfgData;

        for(i = 0; i < 14; i++ )
        {
            u16Crc ^= pData[i];
   21874:	d9000104 	addi	r4,sp,4
   21878:	20c9883a 	add	r4,r4,r3
   2187c:	21000003 	ldbu	r4,0(r4)
   21880:	01400204 	movi	r5,8
   21884:	2084f03a 	xor	r2,r4,r2

            for(j=0; j<8; j++ )
            {
                if( u16Crc & 0x80 )
   21888:	1100200c 	andi	r4,r2,128
   2188c:	20001726 	beq	r4,zero,218ec <ESC_EepromWriteCRC+0xa8>
   21890:	10bfffcc 	andi	r2,r2,65535
                {
                    u16Crc = (u16Crc<<1) ^ 0x07;
   21894:	1004907a 	slli	r2,r2,1
   21898:	108001dc 	xori	r2,r2,7
            for(j=0; j<8; j++ )
   2189c:	293fffc4 	addi	r4,r5,-1
   218a0:	200b883a 	mov	r5,r4
   218a4:	213fffcc 	andi	r4,r4,65535
   218a8:	203ff71e 	bne	r4,zero,21888 <ESC_EepromWriteCRC+0x44>
        for(i = 0; i < 14; i++ )
   218ac:	18c00044 	addi	r3,r3,1
   218b0:	19000398 	cmpnei	r4,r3,14
   218b4:	203fef1e 	bne	r4,zero,21874 <ESC_EepromWriteCRC+0x30>
                }
            }
        }

        /*only low Byte shall be written*/
        u16Crc &= 0x00FF;
   218b8:	10803fcc 	andi	r2,r2,255

        /*write new calculated Crc to Esc Config area*/
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   218bc:	01c00104 	movi	r7,4
   218c0:	d9800084 	addi	r6,sp,2
   218c4:	01400044 	movi	r5,1
   218c8:	010001c4 	movi	r4,7
        u16Crc &= 0x00FF;
   218cc:	d880008d 	sth	r2,2(sp)
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   218d0:	00216280 	call	21628 <ESC_EepromAccess>
        if(u16Return == 0)
   218d4:	10ffffcc 	andi	r3,r2,65535
   218d8:	1800011e 	bne	r3,zero,218e0 <ESC_EepromWriteCRC+0x9c>
        {
            u16Return =  ALSTATUSCODE_WAITFORCOLDSTART;
   218dc:	00800804 	movi	r2,32
        }
    }

    return u16Return;
}
   218e0:	dfc00517 	ldw	ra,20(sp)
   218e4:	dec00604 	addi	sp,sp,24
   218e8:	f800283a 	ret
                    u16Crc <<= 1;
   218ec:	1004907a 	slli	r2,r2,1
   218f0:	003fea06 	br	2189c <ESC_EepromWriteCRC+0x58>

000218f4 <COE_Init>:
 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
    pCoeSendStored = 0;
   218f4:	d0214a15 	stw	zero,-31448(gp)
    nSdoInfoFragmentsLeft = 0;
   218f8:	d021708d 	sth	zero,-31294(gp)
}
   218fc:	f800283a 	ret

00021900 <COE_ServiceInd>:

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
    UINT8 result = 0;

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
   21900:	2080018b 	ldhu	r2,6(r4)
   21904:	1004d33a 	srli	r2,r2,12
   21908:	10c00228 	cmpgeui	r3,r2,8
   2190c:	1800081e 	bne	r3,zero,21930 <COE_ServiceInd+0x30>
   21910:	10c000e8 	cmpgeui	r3,r2,3
   21914:	18000a1e 	bne	r3,zero,21940 <COE_ServiceInd+0x40>
   21918:	10c00060 	cmpeqi	r3,r2,1
   2191c:	1800081e 	bne	r3,zero,21940 <COE_ServiceInd+0x40>
   21920:	108000a0 	cmpeqi	r2,r2,2
   21924:	1000051e 	bne	r2,zero,2193c <COE_ServiceInd+0x3c>
   21928:	00800144 	movi	r2,5
   2192c:	f800283a 	ret
   21930:	10800220 	cmpeqi	r2,r2,8
   21934:	103ffc26 	beq	r2,zero,21928 <COE_ServiceInd+0x28>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
        break;

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
   21938:	002624c1 	jmpi	2624c <SDOS_SdoInfoInd>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
   2193c:	00257d01 	jmpi	257d0 <SDOS_SdoInd>
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
   21940:	00800104 	movi	r2,4
    default:
        result = MBXERR_INVALIDHEADER;
        break;
    }
    return result;
}
   21944:	f800283a 	ret

00021948 <COE_ContinueInd>:
 \brief  be put in the send mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if (pCoeSendStored)
   21948:	d1214a17 	ldw	r4,-31448(gp)
{
   2194c:	deffff04 	addi	sp,sp,-4
   21950:	dfc00015 	stw	ra,0(sp)
    if (pCoeSendStored)
   21954:	20000926 	beq	r4,zero,2197c <COE_ContinueInd+0x34>
    {
        /* send the stored CoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) COE8*/
        if (MBX_MailboxSendReq(pCoeSendStored, COE_SERVICE) == 0)
   21958:	01400084 	movi	r5,2
   2195c:	0023d8c0 	call	23d8c <MBX_MailboxSendReq>
   21960:	10803fcc 	andi	r2,r2,255
   21964:	1000011e 	bne	r2,zero,2196c <COE_ContinueInd+0x24>
        {
            pCoeSendStored = 0;
   21968:	d0214a15 	stw	zero,-31448(gp)
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
        }
    }

    return 0;
   2196c:	0005883a 	mov	r2,zero
}
   21970:	dfc00017 	ldw	ra,0(sp)
   21974:	dec00104 	addi	sp,sp,4
   21978:	f800283a 	ret
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
   2197c:	01002004 	movi	r4,128
   21980:	0026bdc0 	call	26bdc <malloc>
   21984:	1009883a 	mov	r4,r2
        if (pMbx == NULL)
   21988:	10000726 	beq	r2,zero,219a8 <COE_ContinueInd+0x60>
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
   2198c:	014000f4 	movhi	r5,3
   21990:	01800384 	movi	r6,14
   21994:	2961fc04 	addi	r5,r5,-30736
   21998:	0026ee40 	call	26ee4 <memcpy>
   2199c:	1009883a 	mov	r4,r2
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
   219a0:	002624c0 	call	2624c <SDOS_SdoInfoInd>
   219a4:	003ff106 	br	2196c <COE_ContinueInd+0x24>
            return MBXERR_NOMOREMEMORY;
   219a8:	008001c4 	movi	r2,7
   219ac:	003ff006 	br	21970 <COE_ContinueInd+0x28>

000219b0 <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
   219b0:	defffd04 	addi	sp,sp,-12
   219b4:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219b8:	01800084 	movi	r6,2
{
   219bc:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219c0:	01408104 	movi	r5,516
   219c4:	d9000084 	addi	r4,sp,2
{
   219c8:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219cc:	00207740 	call	20774 <HW_EscRead>
    
    mask &= intMask;
   219d0:	d880008b 	ldhu	r2,2(sp)


    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219d4:	01800084 	movi	r6,2
   219d8:	01408104 	movi	r5,516
    mask &= intMask;
   219dc:	80a0703a 	and	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219e0:	d9000084 	addi	r4,sp,2
    mask &= intMask;
   219e4:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219e8:	00207f80 	call	207f8 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   219ec:	dfc00217 	ldw	ra,8(sp)
   219f0:	dc000117 	ldw	r16,4(sp)
   219f4:	dec00304 	addi	sp,sp,12
   219f8:	f800283a 	ret

000219fc <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
   219fc:	defffd04 	addi	sp,sp,-12
   21a00:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21a04:	01800084 	movi	r6,2
{
   21a08:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21a0c:	01408104 	movi	r5,516
   21a10:	d9000084 	addi	r4,sp,2
{
   21a14:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21a18:	00207740 	call	20774 <HW_EscRead>
    

    mask |= intMask;
   21a1c:	d880008b 	ldhu	r2,2(sp)

    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21a20:	01800084 	movi	r6,2
   21a24:	01408104 	movi	r5,516
    mask |= intMask;
   21a28:	80a0b03a 	or	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21a2c:	d9000084 	addi	r4,sp,2
    mask |= intMask;
   21a30:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21a34:	00207f80 	call	207f8 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   21a38:	dfc00217 	ldw	ra,8(sp)
   21a3c:	dc000117 	ldw	r16,4(sp)
   21a40:	dec00304 	addi	sp,sp,12
   21a44:	f800283a 	ret

00021a48 <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
   21a48:	defffe04 	addi	sp,sp,-8
    UINT16 TmpVar = 0;
    //read EEPROM loaded information
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21a4c:	01800084 	movi	r6,2
   21a50:	01414084 	movi	r5,1282
   21a54:	d9000084 	addi	r4,sp,2
{
   21a58:	dfc00115 	stw	ra,4(sp)
    UINT16 TmpVar = 0;
   21a5c:	d800008d 	sth	zero,2(sp)
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21a60:	00207740 	call	20774 <HW_EscRead>
    TmpVar = SWAPWORD(TmpVar);


    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
   21a64:	d880008b 	ldhu	r2,2(sp)
   21a68:	1086000c 	andi	r2,r2,6144
   21a6c:	1005003a 	cmpeq	r2,r2,zero
   21a70:	d0a14b05 	stb	r2,-31444(gp)
    }
    else
    {
        EepromLoaded = TRUE;
    }
}
   21a74:	dfc00117 	ldw	ra,4(sp)
   21a78:	dec00204 	addi	sp,sp,8
   21a7c:	f800283a 	ret

00021a80 <GetSyncMan>:
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a80:	21403fcc 	andi	r5,r4,255
   21a84:	29404004 	addi	r5,r5,256
   21a88:	280a90fa 	slli	r5,r5,3
{
   21a8c:	deffff04 	addi	sp,sp,-4
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a90:	01800204 	movi	r6,8
   21a94:	d1214b84 	addi	r4,gp,-31442
{
   21a98:	dfc00015 	stw	ra,0(sp)
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a9c:	00207740 	call	20774 <HW_EscRead>



    return &SyncManInfo;
}
   21aa0:	d0a14b84 	addi	r2,gp,-31442
   21aa4:	dfc00017 	ldw	ra,0(sp)
   21aa8:	dec00104 	addi	sp,sp,4
   21aac:	f800283a 	ret

00021ab0 <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
   21ab0:	defffd04 	addi	sp,sp,-12
   21ab4:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21ab8:	24003fcc 	andi	r16,r4,255
   21abc:	802090fa 	slli	r16,r16,3
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21ac0:	00800044 	movi	r2,1

    HW_EscWriteByte(smStatus,Offset);
   21ac4:	01800044 	movi	r6,1
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21ac8:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21acc:	843fffcc 	andi	r16,r16,65535
   21ad0:	800b883a 	mov	r5,r16
   21ad4:	d90000c4 	addi	r4,sp,3
{
   21ad8:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21adc:	d88000c5 	stb	r2,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21ae0:	00207f80 	call	207f8 <HW_EscWrite>
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadByte(smStatus, Offset);
   21ae4:	01800044 	movi	r6,1
   21ae8:	800b883a 	mov	r5,r16
   21aec:	d90000c4 	addi	r4,sp,3
   21af0:	00207740 	call	20774 <HW_EscRead>
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
   21af4:	d88000c3 	ldbu	r2,3(sp)
   21af8:	1080004c 	andi	r2,r2,1
   21afc:	103ff926 	beq	r2,zero,21ae4 <DisableSyncManChannel+0x34>
}
   21b00:	dfc00217 	ldw	ra,8(sp)
   21b04:	dc000117 	ldw	r16,4(sp)
   21b08:	dec00304 	addi	sp,sp,12
   21b0c:	f800283a 	ret

00021b10 <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
   21b10:	defffd04 	addi	sp,sp,-12
   21b14:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = 0x00;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21b18:	24003fcc 	andi	r16,r4,255
   21b1c:	802090fa 	slli	r16,r16,3

    HW_EscWriteByte(smStatus,Offset);
   21b20:	01800044 	movi	r6,1
   21b24:	d90000c4 	addi	r4,sp,3
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21b28:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21b2c:	843fffcc 	andi	r16,r16,65535
   21b30:	800b883a 	mov	r5,r16
{
   21b34:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = 0x00;
   21b38:	d80000c5 	stb	zero,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21b3c:	00207f80 	call	207f8 <HW_EscWrite>
    
    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadByte(smStatus,Offset);
   21b40:	01800044 	movi	r6,1
   21b44:	800b883a 	mov	r5,r16
   21b48:	d90000c4 	addi	r4,sp,3
   21b4c:	00207740 	call	20774 <HW_EscRead>
    }while((smStatus & SM_SETTING_PDI_DISABLE));
   21b50:	d88000c3 	ldbu	r2,3(sp)
   21b54:	1080004c 	andi	r2,r2,1
   21b58:	103ff91e 	bne	r2,zero,21b40 <EnableSyncManChannel+0x30>
}
   21b5c:	dfc00217 	ldw	ra,8(sp)
   21b60:	dc000117 	ldw	r16,4(sp)
   21b64:	dec00304 	addi	sp,sp,12
   21b68:	f800283a 	ret

00021b6c <CheckSmSettings>:
    UINT16 SMLength = 0;
    UINT16 SMAddress = 0;


        //Check if max address defines are within the available ESC address range
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21b6c:	d0a1510b 	ldhu	r2,-31420(gp)
{
   21b70:	defffc04 	addi	sp,sp,-16
   21b74:	dfc00315 	stw	ra,12(sp)
   21b78:	dc800215 	stw	r18,8(sp)
   21b7c:	dc400115 	stw	r17,4(sp)
   21b80:	dc000015 	stw	r16,0(sp)
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21b84:	108bfff0 	cmpltui	r2,r2,12287
   21b88:	1000921e 	bne	r2,zero,21dd4 <CheckSmSettings+0x268>
   21b8c:	2025883a 	mov	r18,r4
   21b90:	2023883a 	mov	r17,r4

                return ALSTATUSCODE_NOVALIDFIRMWARE;
        }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
   21b94:	0009883a 	mov	r4,zero
   21b98:	0021a800 	call	21a80 <GetSyncMan>
    SMLength = pSyncMan->Length;
    SMAddress = pSyncMan->PhysicalStartAddress;



    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b9c:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21ba0:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21ba4:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21ba8:	2940004c 	andi	r5,r5,1
   21bac:	2800081e 	bne	r5,zero,21bd0 <CheckSmSettings+0x64>
            result = SYNCMANCHSIZE + 1;
        }

        if ( result != 0 )
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21bb0:	04000584 	movi	r16,22
            pSyncMan = GetSyncMan(i);
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
        }
    }
    return result;
}
   21bb4:	8005883a 	mov	r2,r16
   21bb8:	dfc00317 	ldw	ra,12(sp)
   21bbc:	dc800217 	ldw	r18,8(sp)
   21bc0:	dc400117 	ldw	r17,4(sp)
   21bc4:	dc000017 	ldw	r16,0(sp)
   21bc8:	dec00404 	addi	sp,sp,16
   21bcc:	f800283a 	ret
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
   21bd0:	10800103 	ldbu	r2,4(r2)
   21bd4:	1140030c 	andi	r5,r2,12
   21bd8:	29400118 	cmpnei	r5,r5,4
   21bdc:	283ff41e 	bne	r5,zero,21bb0 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21be0:	1080008c 	andi	r2,r2,2
   21be4:	103ff226 	beq	r2,zero,21bb0 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21be8:	20bff704 	addi	r2,r4,-36
   21bec:	10bfffcc 	andi	r2,r2,65535
   21bf0:	10801768 	cmpgeui	r2,r2,93
   21bf4:	103fee1e 	bne	r2,zero,21bb0 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
   21bf8:	18bc0004 	addi	r2,r3,-4096
   21bfc:	10bfffcc 	andi	r2,r2,65535
   21c00:	10880028 	cmpgeui	r2,r2,8192
   21c04:	103fea1e 	bne	r2,zero,21bb0 <CheckSmSettings+0x44>
        pSyncMan = GetSyncMan(MAILBOX_READ);
   21c08:	01000044 	movi	r4,1
   21c0c:	0021a800 	call	21a80 <GetSyncMan>
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21c10:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21c14:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21c18:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21c1c:	2940004c 	andi	r5,r5,1
   21c20:	283fe326 	beq	r5,zero,21bb0 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
   21c24:	10800103 	ldbu	r2,4(r2)
   21c28:	1140030c 	andi	r5,r2,12
   21c2c:	2821883a 	mov	r16,r5
   21c30:	283fdf1e 	bne	r5,zero,21bb0 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21c34:	1080008c 	andi	r2,r2,2
   21c38:	103fdd26 	beq	r2,zero,21bb0 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21c3c:	20bff704 	addi	r2,r4,-36
   21c40:	10bfffcc 	andi	r2,r2,65535
   21c44:	10801768 	cmpgeui	r2,r2,93
   21c48:	103fd91e 	bne	r2,zero,21bb0 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_READ_ADDRESS)
   21c4c:	18bc0004 	addi	r2,r3,-4096
   21c50:	10bfffcc 	andi	r2,r2,65535
   21c54:	10880028 	cmpgeui	r2,r2,8192
   21c58:	103fd51e 	bne	r2,zero,21bb0 <CheckSmSettings+0x44>
    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
   21c5c:	94803fcc 	andi	r18,r18,255
   21c60:	90800130 	cmpltui	r2,r18,4
   21c64:	1000421e 	bne	r2,zero,21d70 <CheckSmSettings+0x204>
        b3BufferMode = TRUE;
   21c68:	00800044 	movi	r2,1
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21c6c:	010000c4 	movi	r4,3
        b3BufferMode = TRUE;
   21c70:	d0a15505 	stb	r2,-31404(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21c74:	0021a800 	call	21a80 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21c78:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21c7c:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21c80:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21c84:	2940004c 	andi	r5,r5,1
   21c88:	28003426 	beq	r5,zero,21d5c <CheckSmSettings+0x1f0>
   21c8c:	217fffc4 	addi	r5,r4,-1
   21c90:	297fffcc 	andi	r5,r5,65535
   21c94:	29401a28 	cmpgeui	r5,r5,104
   21c98:	28000d1e 	bne	r5,zero,21cd0 <CheckSmSettings+0x164>
                if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
   21c9c:	d161528b 	ldhu	r5,-31414(gp)
   21ca0:	213fffcc 	andi	r4,r4,65535
   21ca4:	21400a1e 	bne	r4,r5,21cd0 <CheckSmSettings+0x164>
                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
   21ca8:	10800103 	ldbu	r2,4(r2)
   21cac:	1100030c 	andi	r4,r2,12
   21cb0:	2000071e 	bne	r4,zero,21cd0 <CheckSmSettings+0x164>
                        if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
   21cb4:	d12150c3 	ldbu	r4,-31421(gp)
   21cb8:	21000098 	cmpnei	r4,r4,2
   21cbc:	2000061e 	bne	r4,zero,21cd8 <CheckSmSettings+0x16c>
   21cc0:	18fc0004 	addi	r3,r3,-4096
   21cc4:	18ffffcc 	andi	r3,r3,65535
   21cc8:	18c80030 	cmpltui	r3,r3,8192
   21ccc:	1800051e 	bne	r3,zero,21ce4 <CheckSmSettings+0x178>
            result = ALSTATUSCODE_INVALIDSMINCFG;
   21cd0:	04000784 	movi	r16,30
   21cd4:	003fb706 	br	21bb4 <CheckSmSettings+0x48>
                            || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
   21cd8:	d1214f0b 	ldhu	r4,-31428(gp)
   21cdc:	18ffffcc 	andi	r3,r3,65535
   21ce0:	193ffb1e 	bne	r3,r4,21cd0 <CheckSmSettings+0x164>
                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21ce4:	1080008c 	andi	r2,r2,2
   21ce8:	10000126 	beq	r2,zero,21cf0 <CheckSmSettings+0x184>
                                    b3BufferMode = FALSE;
   21cec:	d0215505 	stb	zero,-31404(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21cf0:	01000084 	movi	r4,2
   21cf4:	0021a800 	call	21a80 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21cf8:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21cfc:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21d00:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21d04:	2940004c 	andi	r5,r5,1
   21d08:	28002d26 	beq	r5,zero,21dc0 <CheckSmSettings+0x254>
   21d0c:	217fffc4 	addi	r5,r4,-1
   21d10:	297fffcc 	andi	r5,r5,65535
   21d14:	29400328 	cmpgeui	r5,r5,12
   21d18:	28000e1e 	bne	r5,zero,21d54 <CheckSmSettings+0x1e8>
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
   21d1c:	d161520b 	ldhu	r5,-31416(gp)
   21d20:	213fffcc 	andi	r4,r4,65535
   21d24:	21400b1e 	bne	r4,r5,21d54 <CheckSmSettings+0x1e8>
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
   21d28:	10800103 	ldbu	r2,4(r2)
   21d2c:	1100030c 	andi	r4,r2,12
   21d30:	21000118 	cmpnei	r4,r4,4
   21d34:	2000071e 	bne	r4,zero,21d54 <CheckSmSettings+0x1e8>
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
   21d38:	d12150c3 	ldbu	r4,-31421(gp)
   21d3c:	21000098 	cmpnei	r4,r4,2
   21d40:	2000151e 	bne	r4,zero,21d98 <CheckSmSettings+0x22c>
   21d44:	18fc0004 	addi	r3,r3,-4096
   21d48:	18ffffcc 	andi	r3,r3,65535
   21d4c:	18c80030 	cmpltui	r3,r3,8192
   21d50:	1800141e 	bne	r3,zero,21da4 <CheckSmSettings+0x238>
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21d54:	04000744 	movi	r16,29
   21d58:	003f9606 	br	21bb4 <CheckSmSettings+0x48>
        else if (SMLength != 0 || nPdInputSize != 0)
   21d5c:	d0a1528b 	ldhu	r2,-31414(gp)
   21d60:	1104b03a 	or	r2,r2,r4
   21d64:	10bfffcc 	andi	r2,r2,65535
   21d68:	103fe126 	beq	r2,zero,21cf0 <CheckSmSettings+0x184>
   21d6c:	003fd806 	br	21cd0 <CheckSmSettings+0x164>
    if (result == 0 && maxChannel > PROCESS_DATA_OUT)
   21d70:	948000e0 	cmpeqi	r18,r18,3
   21d74:	903fde1e 	bne	r18,zero,21cf0 <CheckSmSettings+0x184>
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d78:	d0a15183 	ldbu	r2,-31418(gp)
   21d7c:	89003fcc 	andi	r4,r17,255
   21d80:	20bf8c2e 	bgeu	r4,r2,21bb4 <CheckSmSettings+0x48>
            pSyncMan = GetSyncMan(i);
   21d84:	0021a800 	call	21a80 <GetSyncMan>
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21d88:	10800183 	ldbu	r2,6(r2)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d8c:	8c400044 	addi	r17,r17,1
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21d90:	d0a14d85 	stb	r2,-31434(gp)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d94:	003ff806 	br	21d78 <CheckSmSettings+0x20c>
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
   21d98:	d1214f8b 	ldhu	r4,-31426(gp)
   21d9c:	18ffffcc 	andi	r3,r3,65535
   21da0:	193fec1e 	bne	r3,r4,21d54 <CheckSmSettings+0x1e8>
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   21da4:	1006d1ba 	srli	r3,r2,6
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21da8:	1080008c 	andi	r2,r2,2
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   21dac:	18c0004c 	andi	r3,r3,1
                                bWdTrigger = TRUE;
   21db0:	d0e15cc5 	stb	r3,-31373(gp)
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21db4:	103ff026 	beq	r2,zero,21d78 <CheckSmSettings+0x20c>
                                b3BufferMode = FALSE;
   21db8:	d0215505 	stb	zero,-31404(gp)
   21dbc:	003fee06 	br	21d78 <CheckSmSettings+0x20c>
        else if (SMLength != 0 || nPdOutputSize != 0)
   21dc0:	d0a1520b 	ldhu	r2,-31416(gp)
   21dc4:	1104b03a 	or	r2,r2,r4
   21dc8:	10bfffcc 	andi	r2,r2,65535
   21dcc:	103fea26 	beq	r2,zero,21d78 <CheckSmSettings+0x20c>
   21dd0:	003fe006 	br	21d54 <CheckSmSettings+0x1e8>
                return ALSTATUSCODE_NOVALIDFIRMWARE;
   21dd4:	04000504 	movi	r16,20
   21dd8:	003f7606 	br	21bb4 <CheckSmSettings+0x48>

00021ddc <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
   21ddc:	defff604 	addi	sp,sp,-40
   21de0:	dc400515 	stw	r17,20(sp)
   21de4:	dc000415 	stw	r16,16(sp)
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21de8:	044000f4 	movhi	r17,3
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   21dec:	040000f4 	movhi	r16,3
   21df0:	8421eb04 	addi	r16,r16,-30804
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21df4:	8c61da04 	addi	r17,r17,-30872
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21df8:	01000084 	movi	r4,2
{
   21dfc:	dcc00715 	stw	r19,28(sp)
   21e00:	dc800615 	stw	r18,24(sp)
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21e04:	8cc0030b 	ldhu	r19,12(r17)
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   21e08:	8480030b 	ldhu	r18,12(r16)
{
   21e0c:	dfc00915 	stw	ra,36(sp)
   21e10:	dd000815 	stw	r20,32(sp)
    UINT16     wdiv = 0;
   21e14:	d800010d 	sth	zero,4(sp)
    UINT16     wd = 0;
   21e18:	d800018d 	sth	zero,6(sp)
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
   21e1c:	d8000215 	stw	zero,8(sp)
    UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
   21e20:	d8000315 	stw	zero,12(sp)
    u16ALEventMask = 0;
   21e24:	d0214e8d 	sth	zero,-31430(gp)
    bEcatFirstOutputsReceived = FALSE;
   21e28:	d0215d05 	stb	zero,-31372(gp)
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21e2c:	0021a800 	call	21a80 <GetSyncMan>
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   21e30:	10c0000b 	ldhu	r3,0(r2)
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e34:	10800103 	ldbu	r2,4(r2)
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   21e38:	d0e14f8d 	sth	r3,-31426(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e3c:	1080008c 	andi	r2,r2,2
   21e40:	1000461e 	bne	r2,zero,21f5c <StartInputHandler+0x180>
    UINT16    nPdOutputBuffer = 3;
   21e44:	050000c4 	movi	r20,3
       nPdOutputBuffer = 1;
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21e48:	010000c4 	movi	r4,3
   21e4c:	0021a800 	call	21a80 <GetSyncMan>
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   21e50:	1100000b 	ldhu	r4,0(r2)


    /* get the number of input buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e54:	10c00103 	ldbu	r3,4(r2)
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   21e58:	d1214f0d 	sth	r4,-31428(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e5c:	18c0008c 	andi	r3,r3,2
   21e60:	1800401e 	bne	r3,zero,21f64 <StartInputHandler+0x188>
    UINT16    nPdInputBuffer = 3;
   21e64:	00c000c4 	movi	r3,3
        nPdInputBuffer = 1;
    }
    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e68:	d221528b 	ldhu	r8,-31414(gp)
   21e6c:	18ffffcc 	andi	r3,r3,65535
   21e70:	d1a1640b 	ldhu	r6,-31344(gp)
   21e74:	1a07383a 	mul	r3,r3,r8
   21e78:	20bfffcc 	andi	r2,r4,65535
   21e7c:	1887883a 	add	r3,r3,r2
   21e80:	30c0030e 	bge	r6,r3,21e90 <StartInputHandler+0xb4>
   21e84:	d121658b 	ldhu	r4,-31338(gp)
   21e88:	2189883a 	add	r4,r4,r6
   21e8c:	11019d16 	blt	r2,r4,22504 <StartInputHandler+0x728>
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   21e90:	d161648b 	ldhu	r5,-31342(gp)
   21e94:	28c0030e 	bge	r5,r3,21ea4 <StartInputHandler+0xc8>
   21e98:	d0e1650b 	ldhu	r3,-31340(gp)
   21e9c:	1947883a 	add	r3,r3,r5
   21ea0:	10c19816 	blt	r2,r3,22504 <StartInputHandler+0x728>
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21ea4:	d0e1520b 	ldhu	r3,-31416(gp)
   21ea8:	a53fffcc 	andi	r20,r20,65535
   21eac:	d1214f8b 	ldhu	r4,-31426(gp)
   21eb0:	1d07383a 	mul	r3,r3,r20
   21eb4:	1907883a 	add	r3,r3,r4
    if (
   21eb8:	30c0030e 	bge	r6,r3,21ec8 <StartInputHandler+0xec>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21ebc:	d1e1658b 	ldhu	r7,-31338(gp)
   21ec0:	398d883a 	add	r6,r7,r6
   21ec4:	21819116 	blt	r4,r6,2250c <StartInputHandler+0x730>
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   21ec8:	28c0030e 	bge	r5,r3,21ed8 <StartInputHandler+0xfc>
   21ecc:	d1a1650b 	ldhu	r6,-31340(gp)
   21ed0:	314b883a 	add	r5,r6,r5
   21ed4:	21418d16 	blt	r4,r5,2250c <StartInputHandler+0x730>
        ||
   21ed8:	10c0020e 	bge	r2,r3,21ee4 <StartInputHandler+0x108>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
   21edc:	1205883a 	add	r2,r2,r8
   21ee0:	20818a16 	blt	r4,r2,2250c <StartInputHandler+0x730>
        --- Check configured synchronization ---
    */

    /* Get the DC Control/Activation register value*/
    /*Read register 0x981 (corresponding masks are adapted)*/
    HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
   21ee4:	01800044 	movi	r6,1
   21ee8:	01426044 	movi	r5,2433
   21eec:	d9000084 	addi	r4,sp,2
   21ef0:	00207740 	call	20774 <HW_EscRead>

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
   21ef4:	01800104 	movi	r6,4
   21ef8:	01426804 	movi	r5,2464
   21efc:	d9000204 	addi	r4,sp,8
   21f00:	00207740 	call	20774 <HW_EscRead>
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);

    // Cycle time for Sync1
        HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
   21f04:	01800104 	movi	r6,4
   21f08:	01426904 	movi	r5,2468
   21f0c:	d9000304 	addi	r4,sp,12
   21f10:	00207740 	call	20774 <HW_EscRead>
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   21f14:	d9400083 	ldbu	r5,2(sp)
        shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
   21f18:	dd000317 	ldw	r20,12(sp)
    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
   21f1c:	80c0008b 	ldhu	r3,2(r16)
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
   21f20:	2980024c 	andi	r6,r5,9
   21f24:	8880008b 	ldhu	r2,2(r17)
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   21f28:	3000101e 	bne	r6,zero,21f6c <StartInputHandler+0x190>


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
   21f2c:	d1216783 	ldbu	r4,-31330(gp)
   21f30:	21403fcc 	andi	r5,r4,255
   21f34:	28003f1e 	bne	r5,zero,22034 <StartInputHandler+0x258>
            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
                
                if (nPdInputSize > 0)
   21f38:	d0a1528b 	ldhu	r2,-31414(gp)
            if (nPdOutputSize > 0)
   21f3c:	d161520b 	ldhu	r5,-31416(gp)
   21f40:	10ffffcc 	andi	r3,r2,65535
   21f44:	28005826 	beq	r5,zero,220a8 <StartInputHandler+0x2cc>
                if (nPdInputSize > 0)
   21f48:	1800be1e 	bne	r3,zero,22244 <StartInputHandler+0x468>
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
   21f4c:	d0e15503 	ldbu	r3,-31404(gp)
   21f50:	1800a426 	beq	r3,zero,221e4 <StartInputHandler+0x408>
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
   21f54:	00c00044 	movi	r3,1
   21f58:	00007d06 	br	22150 <StartInputHandler+0x374>
       nPdOutputBuffer = 1;
   21f5c:	05000044 	movi	r20,1
   21f60:	003fb906 	br	21e48 <StartInputHandler+0x6c>
        nPdInputBuffer = 1;
   21f64:	00c00044 	movi	r3,1
   21f68:	003fbf06 	br	21e68 <StartInputHandler+0x8c>
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
   21f6c:	2900008c 	andi	r4,r5,2
   21f70:	20004926 	beq	r4,zero,22098 <StartInputHandler+0x2bc>
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21f74:	94e4703a 	and	r18,r18,r19
        if(u16MinSuppSyncType != 0)
   21f78:	913fffcc 	andi	r4,r18,65535
   21f7c:	20000626 	beq	r4,zero,21f98 <StartInputHandler+0x1bc>
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
   21f80:	9100010c 	andi	r4,r18,4
   21f84:	20004426 	beq	r4,zero,22098 <StartInputHandler+0x2bc>
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
   21f88:	9100020c 	andi	r4,r18,8
   21f8c:	2000021e 	bne	r4,zero,21f98 <StartInputHandler+0x1bc>
   21f90:	2900010c 	andi	r4,r5,4
   21f94:	2000401e 	bne	r4,zero,22098 <StartInputHandler+0x2bc>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21f98:	d9c00217 	ldw	r7,8(sp)
            curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
   21f9c:	81800417 	ldw	r6,16(r16)
   21fa0:	2900018c 	andi	r4,r5,6
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21fa4:	3800131e 	bne	r7,zero,21ff4 <StartInputHandler+0x218>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   21fa8:	21000198 	cmpnei	r4,r4,6
   21fac:	2000011e 	bne	r4,zero,21fb4 <StartInputHandler+0x1d8>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   21fb0:	a000171e 	bne	r20,zero,22010 <StartInputHandler+0x234>
    if(bSyncSetByUser)
   21fb4:	d1216783 	ldbu	r4,-31330(gp)
   21fb8:	2000391e 	bne	r4,zero,220a0 <StartInputHandler+0x2c4>
            if (nPdOutputSize > 0)
   21fbc:	d0a1520b 	ldhu	r2,-31416(gp)
   21fc0:	1000701e 	bne	r2,zero,22184 <StartInputHandler+0x3a8>
   21fc4:	0009883a 	mov	r4,zero
            if (nPdInputSize > 0)
   21fc8:	d0e1528b 	ldhu	r3,-31414(gp)
   21fcc:	d0a15503 	ldbu	r2,-31404(gp)
   21fd0:	18003726 	beq	r3,zero,220b0 <StartInputHandler+0x2d4>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   21fd4:	2940010c 	andi	r5,r5,4
   21fd8:	28008d1e 	bne	r5,zero,22210 <StartInputHandler+0x434>
    if ( !b3BufferMode )
   21fdc:	10008126 	beq	r2,zero,221e4 <StartInputHandler+0x408>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   21fe0:	00800084 	movi	r2,2

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
   21fe4:	00c00044 	movi	r3,1
   21fe8:	d0e15545 	stb	r3,-31403(gp)
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
   21fec:	0007883a 	mov	r3,zero
   21ff0:	00005906 	br	22158 <StartInputHandler+0x37c>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21ff4:	39814736 	bltu	r7,r6,22514 <StartInputHandler+0x738>
   21ff8:	01b0d434 	movhi	r6,50000
   21ffc:	31c14536 	bltu	r6,r7,22514 <StartInputHandler+0x738>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   22000:	210001a0 	cmpeqi	r4,r4,6
   22004:	203feb26 	beq	r4,zero,21fb4 <StartInputHandler+0x1d8>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   22008:	a03fea26 	beq	r20,zero,21fb4 <StartInputHandler+0x1d8>
   2200c:	a1ffe936 	bltu	r20,r7,21fb4 <StartInputHandler+0x1d8>
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
   22010:	9480040c 	andi	r18,r18,16
   22014:	90002026 	beq	r18,zero,22098 <StartInputHandler+0x2bc>
    if(bSyncSetByUser)
   22018:	d1216783 	ldbu	r4,-31330(gp)
   2201c:	2000151e 	bne	r4,zero,22074 <StartInputHandler+0x298>
            if (nPdOutputSize > 0)
   22020:	d0e1520b 	ldhu	r3,-31416(gp)
                if (nPdInputSize > 0)
   22024:	d0a1528b 	ldhu	r2,-31414(gp)
            if (nPdOutputSize > 0)
   22028:	18003c1e 	bne	r3,zero,2211c <StartInputHandler+0x340>
                bSubordinatedCycles = TRUE;
   2202c:	01000044 	movi	r4,1
   22030:	003fe506 	br	21fc8 <StartInputHandler+0x1ec>
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22034:	193fff84 	addi	r4,r3,-2
   22038:	213fffcc 	andi	r4,r4,65535
   2203c:	210000b0 	cmpltui	r4,r4,2
   22040:	2000151e 	bne	r4,zero,22098 <StartInputHandler+0x2bc>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
   22044:	113fff84 	addi	r4,r2,-2
   22048:	213fffcc 	andi	r4,r4,65535
   2204c:	210000b0 	cmpltui	r4,r4,2
   22050:	2000111e 	bne	r4,zero,22098 <StartInputHandler+0x2bc>
   22054:	3009883a 	mov	r4,r6
    if ( !b3BufferMode )
   22058:	d1a15503 	ldbu	r6,-31404(gp)
   2205c:	197fffcc 	andi	r5,r3,65535
   22060:	3000721e 	bne	r6,zero,2222c <StartInputHandler+0x450>
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
   22064:	28005f26 	beq	r5,zero,221e4 <StartInputHandler+0x408>
   22068:	117fffcc 	andi	r5,r2,65535
   2206c:	2800381e 	bne	r5,zero,22150 <StartInputHandler+0x374>
   22070:	00005c06 	br	221e4 <StartInputHandler+0x408>
                bSubordinatedCycles = TRUE;
   22074:	01000044 	movi	r4,1
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
   22078:	2940010c 	andi	r5,r5,4
   2207c:	19bfffcc 	andi	r6,r3,65535
   22080:	2800491e 	bne	r5,zero,221a8 <StartInputHandler+0x3cc>
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
   22084:	314000e0 	cmpeqi	r5,r6,3
   22088:	2800031e 	bne	r5,zero,22098 <StartInputHandler+0x2bc>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
   2208c:	117fffcc 	andi	r5,r2,65535
   22090:	294000e0 	cmpeqi	r5,r5,3
   22094:	28004626 	beq	r5,zero,221b0 <StartInputHandler+0x3d4>
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
   22098:	00800c04 	movi	r2,48
   2209c:	00005206 	br	221e8 <StartInputHandler+0x40c>
    BOOL bSubordinatedCycles = FALSE;
   220a0:	0009883a 	mov	r4,zero
   220a4:	003ff406 	br	22078 <StartInputHandler+0x29c>
            else if (nPdInputSize > 0)
   220a8:	d0a15503 	ldbu	r2,-31404(gp)
   220ac:	18004c1e 	bne	r3,zero,221e0 <StartInputHandler+0x404>
    if ( !b3BufferMode )
   220b0:	10004c26 	beq	r2,zero,221e4 <StartInputHandler+0x408>
        if(bEscIntEnabled)
   220b4:	d0a15543 	ldbu	r2,-31403(gp)
   220b8:	1000641e 	bne	r2,zero,2224c <StartInputHandler+0x470>
   220bc:	0007883a 	mov	r3,zero
            }
        }



    sSyncManOutPar.u16SyncType = SyncType0x1C32;
   220c0:	80c0008d 	sth	r3,2(r16)
    LatchInputSync0Counter = 0;
    u16SmSync0Value = 0;
    u16SmSync0Counter = 0;


    if(bSubordinatedCycles == TRUE)
   220c4:	24003fcc 	andi	r16,r4,255
    sSyncManInPar.u16SyncType = SyncType0x1C33;
   220c8:	8880008d 	sth	r2,2(r17)
    LatchInputSync0Value = 0;
   220cc:	d021568d 	sth	zero,-31398(gp)
    LatchInputSync0Counter = 0;
   220d0:	d021560d 	sth	zero,-31400(gp)
    u16SmSync0Value = 0;
   220d4:	d0215a8d 	sth	zero,-31382(gp)
    u16SmSync0Counter = 0;
   220d8:	d0215b0d 	sth	zero,-31380(gp)
    if(bSubordinatedCycles == TRUE)
   220dc:	81000058 	cmpnei	r4,r16,1
   220e0:	2000cf1e 	bne	r4,zero,22420 <StartInputHandler+0x644>
    {
        
        UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
   220e4:	dc800217 	ldw	r18,8(sp)
   220e8:	a4a7883a 	add	r19,r20,r18

        /* get the number of Sync0 event within on SM cycle */
        if(shiftTimeSync1 >= cycleTimeSync0)
        {

            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   220ec:	900b883a 	mov	r5,r18
   220f0:	9809883a 	mov	r4,r19
   220f4:	0026b1c0 	call	26b1c <__udivsi3>
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   220f8:	900b883a 	mov	r5,r18
   220fc:	9809883a 	mov	r4,r19
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   22100:	1023883a 	mov	r17,r2
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   22104:	0026b800 	call	26b80 <__umodsi3>
        if(shiftTimeSync1 >= cycleTimeSync0)
   22108:	a480c236 	bltu	r20,r18,22414 <StartInputHandler+0x638>
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   2210c:	10006826 	beq	r2,zero,222b0 <StartInputHandler+0x4d4>
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   22110:	d4615a8d 	sth	r17,-31382(gp)
        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);

        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
        {
            LatchInputSync0Value++;
   22114:	8c400044 	addi	r17,r17,1
   22118:	00006706 	br	222b8 <StartInputHandler+0x4dc>
            if (nPdInputSize > 0)
   2211c:	10ffffcc 	andi	r3,r2,65535
   22120:	18000326 	beq	r3,zero,22130 <StartInputHandler+0x354>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22124:	2940010c 	andi	r5,r5,4
   22128:	28002b26 	beq	r5,zero,221d8 <StartInputHandler+0x3fc>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   2212c:	008000c4 	movi	r2,3
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22130:	01000044 	movi	r4,1
    if ( !b3BufferMode )
   22134:	d0e15503 	ldbu	r3,-31404(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22138:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   2213c:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22140:	89c00915 	stw	r7,36(r17)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22144:	89c00115 	stw	r7,4(r17)
    if ( !b3BufferMode )
   22148:	18003426 	beq	r3,zero,2221c <StartInputHandler+0x440>
   2214c:	00c000c4 	movi	r3,3
        bEscIntEnabled = TRUE;
   22150:	01400044 	movi	r5,1
   22154:	d1615545 	stb	r5,-31403(gp)
            if(nPdOutputSize > 0)
   22158:	d1a1520b 	ldhu	r6,-31416(gp)
   2215c:	197fff84 	addi	r5,r3,-2
   22160:	30003c26 	beq	r6,zero,22254 <StartInputHandler+0x478>
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   22164:	01810004 	movi	r6,1024
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22168:	297fffcc 	andi	r5,r5,65535
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   2216c:	d1a14e8d 	sth	r6,-31430(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22170:	294000a8 	cmpgeui	r5,r5,2
   22174:	2800421e 	bne	r5,zero,22280 <StartInputHandler+0x4a4>
            bDcSyncActive = TRUE;
   22178:	01400044 	movi	r5,1
   2217c:	d1615c85 	stb	r5,-31374(gp)
            if (nPdOutputSize == 0)
   22180:	003fcf06 	br	220c0 <StartInputHandler+0x2e4>
            if (nPdInputSize > 0)
   22184:	d0a1528b 	ldhu	r2,-31414(gp)
   22188:	10ffffcc 	andi	r3,r2,65535
   2218c:	18000426 	beq	r3,zero,221a0 <StartInputHandler+0x3c4>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22190:	2940010c 	andi	r5,r5,4
   22194:	2809883a 	mov	r4,r5
   22198:	28001b26 	beq	r5,zero,22208 <StartInputHandler+0x42c>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   2219c:	008000c4 	movi	r2,3
            if (nPdInputSize > 0)
   221a0:	0009883a 	mov	r4,zero
   221a4:	00000406 	br	221b8 <StartInputHandler+0x3dc>
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   221a8:	314000d8 	cmpnei	r5,r6,3
   221ac:	283fe126 	beq	r5,zero,22134 <StartInputHandler+0x358>
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   221b0:	31800098 	cmpnei	r6,r6,2
   221b4:	303fa81e 	bne	r6,zero,22058 <StartInputHandler+0x27c>
    if ( !b3BufferMode )
   221b8:	d0e15503 	ldbu	r3,-31404(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   221bc:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   221c0:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   221c4:	89c00915 	stw	r7,36(r17)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   221c8:	89c00115 	stw	r7,4(r17)
    if ( !b3BufferMode )
   221cc:	18001526 	beq	r3,zero,22224 <StartInputHandler+0x448>
   221d0:	00c00084 	movi	r3,2
   221d4:	003fde06 	br	22150 <StartInputHandler+0x374>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   221d8:	00800084 	movi	r2,2
   221dc:	003fd406 	br	22130 <StartInputHandler+0x354>
    if ( !b3BufferMode )
   221e0:	1000161e 	bne	r2,zero,2223c <StartInputHandler+0x460>
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
   221e4:	00800a44 	movi	r2,41

    /*write initial input data*/
    PDO_InputMapping();

    return ALSTATUSCODE_NOERROR;
}
   221e8:	dfc00917 	ldw	ra,36(sp)
   221ec:	dd000817 	ldw	r20,32(sp)
   221f0:	dcc00717 	ldw	r19,28(sp)
   221f4:	dc800617 	ldw	r18,24(sp)
   221f8:	dc400517 	ldw	r17,20(sp)
   221fc:	dc000417 	ldw	r16,16(sp)
   22200:	dec00a04 	addi	sp,sp,40
   22204:	f800283a 	ret
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   22208:	00800084 	movi	r2,2
   2220c:	003fea06 	br	221b8 <StartInputHandler+0x3dc>
    if ( !b3BufferMode )
   22210:	103ff426 	beq	r2,zero,221e4 <StartInputHandler+0x408>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   22214:	008000c4 	movi	r2,3
   22218:	003f7206 	br	21fe4 <StartInputHandler+0x208>
    if ( !b3BufferMode )
   2221c:	00c000c4 	movi	r3,3
   22220:	003f9106 	br	22068 <StartInputHandler+0x28c>
   22224:	00c00084 	movi	r3,2
   22228:	003f8f06 	br	22068 <StartInputHandler+0x28c>
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
   2222c:	283fc81e 	bne	r5,zero,22150 <StartInputHandler+0x374>
   22230:	10ffffcc 	andi	r3,r2,65535
   22234:	183f9f26 	beq	r3,zero,220b4 <StartInputHandler+0x2d8>
   22238:	003f6a06 	br	21fe4 <StartInputHandler+0x208>
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
   2223c:	00800044 	movi	r2,1
   22240:	003f6806 	br	21fe4 <StartInputHandler+0x208>
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
   22244:	00800884 	movi	r2,34
   22248:	003f4206 	br	21f54 <StartInputHandler+0x178>
        if(bEscIntEnabled)
   2224c:	0005883a 	mov	r2,zero
   22250:	003f6606 	br	21fec <StartInputHandler+0x210>
            else if(nPdInputSize > 0)
   22254:	d1a1528b 	ldhu	r6,-31414(gp)
   22258:	30000226 	beq	r6,zero,22264 <StartInputHandler+0x488>
                u16ALEventMask = PROCESS_INPUT_EVENT;
   2225c:	01820004 	movi	r6,2048
   22260:	d1a14e8d 	sth	r6,-31430(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22264:	297fffcc 	andi	r5,r5,65535
   22268:	294000b0 	cmpltui	r5,r5,2
   2226c:	28000a26 	beq	r5,zero,22298 <StartInputHandler+0x4bc>
            bDcSyncActive = TRUE;
   22270:	01400044 	movi	r5,1
   22274:	d1615c85 	stb	r5,-31374(gp)
               u16ALEventMask = 0;
   22278:	d0214e8d 	sth	zero,-31430(gp)
   2227c:	003f9006 	br	220c0 <StartInputHandler+0x2e4>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
   22280:	117fffcc 	andi	r5,r2,65535
   22284:	29800098 	cmpnei	r6,r5,2
   22288:	303fbb26 	beq	r6,zero,22178 <StartInputHandler+0x39c>
   2228c:	294000d8 	cmpnei	r5,r5,3
   22290:	283fb926 	beq	r5,zero,22178 <StartInputHandler+0x39c>
   22294:	003f8a06 	br	220c0 <StartInputHandler+0x2e4>
   22298:	117fffcc 	andi	r5,r2,65535
   2229c:	298000a0 	cmpeqi	r6,r5,2
   222a0:	303ff31e 	bne	r6,zero,22270 <StartInputHandler+0x494>
   222a4:	294000d8 	cmpnei	r5,r5,3
   222a8:	283ff126 	beq	r5,zero,22270 <StartInputHandler+0x494>
   222ac:	003f8406 	br	220c0 <StartInputHandler+0x2e4>
                u16SmSync0Value ++;
   222b0:	88800044 	addi	r2,r17,1
   222b4:	d0a15a8d 	sth	r2,-31382(gp)
            LatchInputSync0Value++;
   222b8:	d461568d 	sth	r17,-31398(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   222bc:	01800084 	movi	r6,2
   222c0:	01410804 	movi	r5,1056
   222c4:	d9000184 	addi	r4,sp,6
    sCycleDiag.syncFailedCounter = 0;
   222c8:	d021670d 	sth	zero,-31332(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   222cc:	00207740 	call	20774 <HW_EscRead>
    if (nPdOutputSize > 0 &&  wd != 0 )
   222d0:	d0e1520b 	ldhu	r3,-31416(gp)
    wd = SWAPWORD(wd);
   222d4:	d880018b 	ldhu	r2,6(sp)
    if (nPdOutputSize > 0 &&  wd != 0 )
   222d8:	18005f26 	beq	r3,zero,22458 <StartInputHandler+0x67c>
   222dc:	10bfffcc 	andi	r2,r2,65535
   222e0:	10005d26 	beq	r2,zero,22458 <StartInputHandler+0x67c>
    HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
   222e4:	01800084 	movi	r6,2
   222e8:	01410004 	movi	r5,1024
   222ec:	d9000104 	addi	r4,sp,4
   222f0:	00207740 	call	20774 <HW_EscRead>
        if ( wdiv != 0 )
   222f4:	d880010b 	ldhu	r2,4(sp)
   222f8:	10005426 	beq	r2,zero,2244c <StartInputHandler+0x670>
            d *= wd;
   222fc:	d900018b 	ldhu	r4,6(sp)
            UINT32 d = wdiv+2;
   22300:	10800084 	addi	r2,r2,2
            d /= 25000;
   22304:	01586a04 	movi	r5,25000
            d *= wd;
   22308:	2089383a 	mul	r4,r4,r2
            d /= 25000;
   2230c:	211869c4 	addi	r4,r4,24999
   22310:	0026b1c0 	call	26b1c <__udivsi3>
            EcatWdValue = (UINT16) d;
   22314:	d0a1500d 	sth	r2,-31424(gp)
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   22318:	10bfffcc 	andi	r2,r2,65535
   2231c:	d0e15cc3 	ldbu	r3,-31373(gp)
   22320:	10004f1e 	bne	r2,zero,22460 <StartInputHandler+0x684>
   22324:	d0a15cc3 	ldbu	r2,-31373(gp)
   22328:	10004f1e 	bne	r2,zero,22468 <StartInputHandler+0x68c>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   2232c:	d0a15543 	ldbu	r2,-31403(gp)
   22330:	10004f1e 	bne	r2,zero,22470 <StartInputHandler+0x694>
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   22334:	01800044 	movi	r6,1
   22338:	01405444 	movi	r5,337
   2233c:	d90000c4 	addi	r4,sp,3
    Sync0WdValue = 0;
   22340:	d021580d 	sth	zero,-31392(gp)
    Sync0WdCounter = 0;
   22344:	d021588d 	sth	zero,-31390(gp)
    Sync1WdCounter = 0;
   22348:	d021578d 	sth	zero,-31394(gp)
    Sync1WdValue = 0;
   2234c:	d021570d 	sth	zero,-31396(gp)
    bDcRunning = FALSE;
   22350:	d0215b85 	stb	zero,-31378(gp)
    bSmSyncSequenceValid = FALSE;
   22354:	d0215a05 	stb	zero,-31384(gp)
    i16WaitForPllRunningTimeout = 0;
   22358:	d021598d 	sth	zero,-31386(gp)
        UINT8 u8TmpVar = 0;
   2235c:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   22360:	00207740 	call	20774 <HW_EscRead>
        if ((u8TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
   22364:	d88000c3 	ldbu	r2,3(sp)
   22368:	10c0020c 	andi	r3,r2,8
   2236c:	18000326 	beq	r3,zero,2237c <StartInputHandler+0x5a0>
            u16ALEventMask |= SYNC0_EVENT;
   22370:	d0e14e8b 	ldhu	r3,-31430(gp)
   22374:	18c00114 	ori	r3,r3,4
   22378:	d0e14e8d 	sth	r3,-31430(gp)
        if ((u8TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
   2237c:	10803fcc 	andi	r2,r2,255
   22380:	1080201c 	xori	r2,r2,128
   22384:	10bfe004 	addi	r2,r2,-128
   22388:	1000030e 	bge	r2,zero,22398 <StartInputHandler+0x5bc>
            u16ALEventMask |= SYNC1_EVENT;
   2238c:	d0a14e8b 	ldhu	r2,-31430(gp)
   22390:	10800214 	ori	r2,r2,8
   22394:	d0a14e8d 	sth	r2,-31430(gp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22398:	008000f4 	movhi	r2,3
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   2239c:	dc400083 	ldbu	r17,2(sp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   223a0:	1021e415 	stw	zero,-30832(r2)
    sSyncManInPar.u8SyncError = 0;
   223a4:	008000f4 	movhi	r2,3
   223a8:	1021ea05 	stb	zero,-30808(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   223ac:	008000f4 	movhi	r2,3
   223b0:	1021f515 	stw	zero,-30764(r2)
    sSyncManOutPar.u8SyncError = 0;
   223b4:	008000f4 	movhi	r2,3
   223b8:	1021fb05 	stb	zero,-30740(r2)
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   223bc:	8880008c 	andi	r2,r17,2
   223c0:	10004126 	beq	r2,zero,224c8 <StartInputHandler+0x6ec>
        if(cycleTimeSync0 == 0)
   223c4:	dc000217 	ldw	r16,8(sp)
   223c8:	8c40010c 	andi	r17,r17,4
   223cc:	80002e1e 	bne	r16,zero,22488 <StartInputHandler+0x6ac>
            Sync0WdValue = 0;
   223d0:	d021580d 	sth	zero,-31392(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   223d4:	88003c26 	beq	r17,zero,224c8 <StartInputHandler+0x6ec>
            if(shiftTimeSync1 < cycleTimeSync0)
   223d8:	d8c00317 	ldw	r3,12(sp)
                if(Sync1Cycle < 5)
   223dc:	00800234 	movhi	r2,8
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   223e0:	80c9883a 	add	r4,r16,r3
                if(Sync1Cycle < 5)
   223e4:	10a847c4 	addi	r2,r2,-24289
   223e8:	1100442e 	bgeu	r2,r4,224fc <StartInputHandler+0x720>
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   223ec:	014000b4 	movhi	r5,2
   223f0:	2961a804 	addi	r5,r5,-31072
   223f4:	0026b1c0 	call	26b1c <__udivsi3>
                    Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
   223f8:	1008907a 	slli	r4,r2,1
   223fc:	01400284 	movi	r5,10
   22400:	0026b1c0 	call	26b1c <__udivsi3>
                Sync1WdValue += Sync0WdValue/2;
   22404:	d0e1580b 	ldhu	r3,-31392(gp)
   22408:	1806d07a 	srli	r3,r3,1
   2240c:	1885883a 	add	r2,r3,r2
   22410:	00002c06 	br	224c4 <StartInputHandler+0x6e8>
            u16SmSync0Value = 1;
   22414:	d4215a8d 	sth	r16,-31382(gp)
        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
   22418:	103f3e1e 	bne	r2,zero,22114 <StartInputHandler+0x338>
   2241c:	003fa606 	br	222b8 <StartInputHandler+0x4dc>
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   22420:	18ffffcc 	andi	r3,r3,65535
   22424:	18c00098 	cmpnei	r3,r3,2
   22428:	1800021e 	bne	r3,zero,22434 <StartInputHandler+0x658>
            u16SmSync0Value = 1;
   2242c:	00c00044 	movi	r3,1
   22430:	d0e15a8d 	sth	r3,-31382(gp)
        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
   22434:	10bfffcc 	andi	r2,r2,65535
   22438:	108000e0 	cmpeqi	r2,r2,3
   2243c:	103f9f1e 	bne	r2,zero,222bc <StartInputHandler+0x4e0>
            LatchInputSync0Value = 1;
   22440:	00800044 	movi	r2,1
   22444:	d0a1568d 	sth	r2,-31398(gp)
   22448:	003f9c06 	br	222bc <StartInputHandler+0x4e0>
            wd = 0;
   2244c:	d800018d 	sth	zero,6(sp)
        EcatWdValue = 0;
   22450:	d021500d 	sth	zero,-31424(gp)
   22454:	003fb306 	br	22324 <StartInputHandler+0x548>
        wdiv = 0;
   22458:	d800010d 	sth	zero,4(sp)
   2245c:	003ffc06 	br	22450 <StartInputHandler+0x674>
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   22460:	18803fcc 	andi	r2,r3,255
   22464:	103fb11e 	bne	r2,zero,2232c <StartInputHandler+0x550>
        return ALSTATUSCODE_INVALIDWDCFG;
   22468:	008007c4 	movi	r2,31
   2246c:	003f5e06 	br	221e8 <StartInputHandler+0x40c>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   22470:	d0a1520b 	ldhu	r2,-31416(gp)
   22474:	103faf26 	beq	r2,zero,22334 <StartInputHandler+0x558>
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
   22478:	d0a14e8b 	ldhu	r2,-31430(gp)
   2247c:	10810014 	ori	r2,r2,1024
   22480:	d0a14e8d 	sth	r2,-31430(gp)
   22484:	003fab06 	br	22334 <StartInputHandler+0x558>
            if(Sync0Cycle < 5)
   22488:	00800234 	movhi	r2,8
   2248c:	10a847c4 	addi	r2,r2,-24289
   22490:	1400182e 	bgeu	r2,r16,224f4 <StartInputHandler+0x718>
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
   22494:	014000b4 	movhi	r5,2
   22498:	2961a804 	addi	r5,r5,-31072
   2249c:	8009883a 	mov	r4,r16
   224a0:	0026b1c0 	call	26b1c <__udivsi3>
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
   224a4:	1008907a 	slli	r4,r2,1
   224a8:	01400284 	movi	r5,10
   224ac:	213fff8c 	andi	r4,r4,65534
   224b0:	0026b1c0 	call	26b1c <__udivsi3>
   224b4:	d0a1580d 	sth	r2,-31392(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   224b8:	88000326 	beq	r17,zero,224c8 <StartInputHandler+0x6ec>
            if(shiftTimeSync1 < cycleTimeSync0)
   224bc:	d8c00317 	ldw	r3,12(sp)
   224c0:	1c3fc62e 	bgeu	r3,r16,223dc <StartInputHandler+0x600>
                Sync1WdValue += Sync0WdValue/2;
   224c4:	d0a1570d 	sth	r2,-31396(gp)
    if(nPdOutputSize > 0)
   224c8:	d0a1520b 	ldhu	r2,-31416(gp)
   224cc:	10000226 	beq	r2,zero,224d8 <StartInputHandler+0x6fc>
        EnableSyncManChannel(PROCESS_DATA_OUT);
   224d0:	01000084 	movi	r4,2
   224d4:	0021b100 	call	21b10 <EnableSyncManChannel>
    if(nPdInputSize > 0)
   224d8:	d0a1528b 	ldhu	r2,-31414(gp)
   224dc:	10000226 	beq	r2,zero,224e8 <StartInputHandler+0x70c>
        EnableSyncManChannel(PROCESS_DATA_IN);
   224e0:	010000c4 	movi	r4,3
   224e4:	0021b100 	call	21b10 <EnableSyncManChannel>
    PDO_InputMapping();
   224e8:	0020ee00 	call	20ee0 <PDO_InputMapping>
    return ALSTATUSCODE_NOERROR;
   224ec:	0005883a 	mov	r2,zero
   224f0:	003f3d06 	br	221e8 <StartInputHandler+0x40c>
   224f4:	00800044 	movi	r2,1
   224f8:	003fee06 	br	224b4 <StartInputHandler+0x6d8>
   224fc:	00800044 	movi	r2,1
   22500:	003fc006 	br	22404 <StartInputHandler+0x628>
        return ALSTATUSCODE_INVALIDSMINCFG;
   22504:	00800784 	movi	r2,30
   22508:	003f3706 	br	221e8 <StartInputHandler+0x40c>
        return ALSTATUSCODE_INVALIDSMOUTCFG;
   2250c:	00800744 	movi	r2,29
   22510:	003f3506 	br	221e8 <StartInputHandler+0x40c>
                    return ALSTATUSCODE_DCSYNC0CYCLETIME;
   22514:	00800d84 	movi	r2,54
   22518:	003f3306 	br	221e8 <StartInputHandler+0x40c>

0002251c <StartOutputHandler>:
    /* by default the SO transition should be completed in AlControlRes().
       required to support also masters which starts to send process data after the SO transition was triggered
       (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
    UINT16 result = NOERROR_INWORK;
    /*ECATCHANGE_START(V5.13) ESM1*/
    if(STATE_VALID(u8LocalErrorState))
   2251c:	d0e15403 	ldbu	r3,-31408(gp)
   22520:	00804584 	movi	r2,278
   22524:	18c003cc 	andi	r3,r3,15
   22528:	10c4d83a 	srl	r2,r2,r3
   2252c:	1080004c 	andi	r2,r2,1
   22530:	10000226 	beq	r2,zero,2253c <StartOutputHandler+0x20>
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
        return u16LocalErrorCode;
   22534:	d0a1548b 	ldhu	r2,-31406(gp)
   22538:	f800283a 	ret
    }
/*The application ESM function is separated from this function to handle pending transitions*/


    /*DC synchronisation is active wait until pll is valid*/
    if(bDcSyncActive)
   2253c:	d0a15c83 	ldbu	r2,-31374(gp)
   22540:	10000326 	beq	r2,zero,22550 <StartOutputHandler+0x34>
    {
        i16WaitForPllRunningTimeout = 200;
   22544:	00803204 	movi	r2,200
   22548:	d0a1598d 	sth	r2,-31386(gp)

        i16WaitForPllRunningCnt = 0;
   2254c:	d021590d 	sth	zero,-31388(gp)
    }



    sSyncManOutPar.u16SmEventMissedCounter = 0;
   22550:	008000f4 	movhi	r2,3
   22554:	1021f50d 	sth	zero,-30764(r2)
    sSyncManOutPar.u8SyncError = 0;
   22558:	008000f4 	movhi	r2,3
   2255c:	1021fb05 	stb	zero,-30740(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   22560:	008000f4 	movhi	r2,3
   22564:	1021e40d 	sth	zero,-30832(r2)
    sSyncManInPar.u8SyncError = 0;
   22568:	008000f4 	movhi	r2,3
   2256c:	1021ea05 	stb	zero,-30808(r2)
   22570:	00803fc4 	movi	r2,255


    return result;
}
   22574:	f800283a 	ret

00022578 <StopOutputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

void StopOutputHandler(void)
{
    /* reset the flags that outputs were received and that the slave is in OP */
    bEcatFirstOutputsReceived = FALSE;
   22578:	d0215d05 	stb	zero,-31372(gp)
    bEcatOutputUpdateRunning = FALSE;
   2257c:	d0215d85 	stb	zero,-31370(gp)
}
   22580:	f800283a 	ret

00022584 <StopInputHandler>:

*////////////////////////////////////////////////////////////////////////////////////////

void StopInputHandler(void)
{
    if(nPdOutputSize > 0)
   22584:	d0a1520b 	ldhu	r2,-31416(gp)
{
   22588:	deffff04 	addi	sp,sp,-4
   2258c:	dfc00015 	stw	ra,0(sp)
    if(nPdOutputSize > 0)
   22590:	10000226 	beq	r2,zero,2259c <StopInputHandler+0x18>
    {
        /* disable the Sync Manager Channel 2 (outputs) */
        DisableSyncManChannel(PROCESS_DATA_OUT);
   22594:	01000084 	movi	r4,2
   22598:	0021ab00 	call	21ab0 <DisableSyncManChannel>
    }

    if(nPdInputSize > 0)
   2259c:	d0a1528b 	ldhu	r2,-31414(gp)
   225a0:	10000226 	beq	r2,zero,225ac <StopInputHandler+0x28>
    {
        /*disable Sync Manager 3 (inputs) if no outputs available*/
        DisableSyncManChannel(PROCESS_DATA_IN);
   225a4:	010000c4 	movi	r4,3
   225a8:	0021ab00 	call	21ab0 <DisableSyncManChannel>
    {
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
        ResetMask |= PROCESS_OUTPUT_EVENT;
        ResetMask |= PROCESS_INPUT_EVENT;

    ResetALEventMask( ~(ResetMask) );
   225ac:	013cfcd4 	movui	r4,62451
   225b0:	00219b00 	call	219b0 <ResetALEventMask>
    Sync1WdValue = 0;
    LatchInputSync0Value = 0;
    LatchInputSync0Counter = 0;


    sSyncManOutPar.u16SmEventMissedCounter = 0;
   225b4:	008000f4 	movhi	r2,3
   225b8:	1021f515 	stw	zero,-30764(r2)
    sSyncManOutPar.u16CycleExceededCounter = 0;
    sSyncManOutPar.u8SyncError = 0;
   225bc:	008000f4 	movhi	r2,3
   225c0:	1021fb05 	stb	zero,-30740(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   225c4:	008000f4 	movhi	r2,3
   225c8:	1021e415 	stw	zero,-30832(r2)
    sSyncManInPar.u16CycleExceededCounter = 0;
    sSyncManInPar.u8SyncError = 0;
   225cc:	008000f4 	movhi	r2,3
    bEcatFirstOutputsReceived = FALSE;
   225d0:	d0215d05 	stb	zero,-31372(gp)
    bEscIntEnabled = FALSE;
   225d4:	d0215545 	stb	zero,-31403(gp)
    bDcSyncActive = FALSE;
   225d8:	d0215c85 	stb	zero,-31374(gp)
    bDcRunning = FALSE;
   225dc:	d0215b85 	stb	zero,-31378(gp)
    bSmSyncSequenceValid = FALSE;
   225e0:	d0215a05 	stb	zero,-31384(gp)
    u16SmSync0Value = 0;
   225e4:	d0215a8d 	sth	zero,-31382(gp)
    u16SmSync0Counter = 0;
   225e8:	d0215b0d 	sth	zero,-31380(gp)
    Sync0WdValue = 0;
   225ec:	d021580d 	sth	zero,-31392(gp)
    Sync0WdCounter = 0;
   225f0:	d021588d 	sth	zero,-31390(gp)
    Sync1WdCounter = 0;
   225f4:	d021578d 	sth	zero,-31394(gp)
    Sync1WdValue = 0;
   225f8:	d021570d 	sth	zero,-31396(gp)
    LatchInputSync0Value = 0;
   225fc:	d021568d 	sth	zero,-31398(gp)
    LatchInputSync0Counter = 0;
   22600:	d021560d 	sth	zero,-31400(gp)
    sSyncManInPar.u8SyncError = 0;
   22604:	1021ea05 	stb	zero,-30808(r2)

    i16WaitForPllRunningTimeout = 0;
   22608:	d021598d 	sth	zero,-31386(gp)

    bWdTrigger = FALSE;
   2260c:	d0215cc5 	stb	zero,-31373(gp)
    bEcatInputUpdateRunning = FALSE;
   22610:	d0215d45 	stb	zero,-31371(gp)

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
   22614:	d0216785 	stb	zero,-31330(gp)
}
   22618:	dfc00017 	ldw	ra,0(sp)
   2261c:	dec00104 	addi	sp,sp,4
   22620:	f800283a 	ret

00022624 <BackToInitTransition>:
*////////////////////////////////////////////////////////////////////////////////////////

void BackToInitTransition(void)
{
    /* Reset indication that the user has written a sync mode*/
    bSyncSetByUser = FALSE;
   22624:	d0216785 	stb	zero,-31330(gp)
}
   22628:	f800283a 	ret

0002262c <SetALStatus>:
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
    UINT16 Value = alStatusCode;

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
   2262c:	d0e150c3 	ldbu	r3,-31421(gp)
{
   22630:	defffe04 	addi	sp,sp,-8
   22634:	dfc00115 	stw	ra,4(sp)
    UINT16 Value = alStatusCode;
   22638:	d940008d 	sth	r5,2(sp)
    if(nAlStatus != alStatus)
   2263c:	20803fcc 	andi	r2,r4,255
   22640:	18800126 	beq	r3,r2,22648 <SetALStatus+0x1c>
    {
        nAlStatus = alStatus;
   22644:	d12150c5 	stb	r4,-31421(gp)
    }

    /*Handle Explicit Device ID is requested*/
    if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
   22648:	d0e15083 	ldbu	r3,-31422(gp)
   2264c:	d0a150c3 	ldbu	r2,-31421(gp)
   22650:	297fffcc 	andi	r5,r5,65535
   22654:	18001126 	beq	r3,zero,2269c <SetALStatus+0x70>
   22658:	10c0040c 	andi	r3,r2,16
   2265c:	18000f1e 	bne	r3,zero,2269c <SetALStatus+0x70>
   22660:	28000e1e 	bne	r5,zero,2269c <SetALStatus+0x70>
   22664:	10c003cc 	andi	r3,r2,15
   22668:	18c000e0 	cmpeqi	r3,r3,3
   2266c:	1800091e 	bne	r3,zero,22694 <SetALStatus+0x68>
    {
/*ECATCHANGE_START(V5.13) ECAT2*/
        Value = u16IdValue;
   22670:	d0e14e0b 	ldhu	r3,-31432(gp)
/*ECATCHANGE_END(V5.13) ECAT2*/
        nAlStatus |= STATE_DEVID;
   22674:	10800814 	ori	r2,r2,32
        Value = u16IdValue;
   22678:	d8c0008d 	sth	r3,2(sp)
    }
    else
    {
        nAlStatus &= ~STATE_DEVID;
   2267c:	d0a150c5 	stb	r2,-31421(gp)

    if (alStatusCode != 0xFFFF)
    {
        Value = SWAPWORD(Value);

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
   22680:	01800084 	movi	r6,2
   22684:	01404d04 	movi	r5,308
   22688:	d9000084 	addi	r4,sp,2
   2268c:	00207f80 	call	207f8 <HW_EscWrite>
   22690:	00000606 	br	226ac <SetALStatus+0x80>
        nAlStatus &= ~STATE_DEVID;
   22694:	108037cc 	andi	r2,r2,223
   22698:	003ff806 	br	2267c <SetALStatus+0x50>
   2269c:	108037cc 	andi	r2,r2,223
   226a0:	d0a150c5 	stb	r2,-31421(gp)
    if (alStatusCode != 0xFFFF)
   226a4:	00bfffd4 	movui	r2,65535
   226a8:	28bff51e 	bne	r5,r2,22680 <SetALStatus+0x54>
    }

    Value = nAlStatus;
   226ac:	d0a150c3 	ldbu	r2,-31421(gp)
    Value = SWAPWORD(Value);
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   226b0:	01800084 	movi	r6,2
   226b4:	01404c04 	movi	r5,304
   226b8:	d9000084 	addi	r4,sp,2
    Value = nAlStatus;
   226bc:	d880008d 	sth	r2,2(sp)
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   226c0:	00207f80 	call	207f8 <HW_EscWrite>

}
   226c4:	dfc00117 	ldw	ra,4(sp)
   226c8:	dec00204 	addi	sp,sp,8
   226cc:	f800283a 	ret

000226d0 <AL_ControlInd>:
{
    UINT16        result = 0;
    UINT8            bErrAck = 0;
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
   226d0:	00bfffc4 	movi	r2,-1
{
   226d4:	defff704 	addi	sp,sp,-36
    EsmTimeoutCounter = -1;
   226d8:	d0a15c0d 	sth	r2,-31376(gp)
    bApplEsmPending = TRUE;
   226dc:	00800044 	movi	r2,1
{
   226e0:	dd800615 	stw	r22,24(sp)
   226e4:	dd400515 	stw	r21,20(sp)
   226e8:	dd000415 	stw	r20,16(sp)
   226ec:	dcc00315 	stw	r19,12(sp)
   226f0:	dc400115 	stw	r17,4(sp)
    bApplEsmPending = TRUE;
   226f4:	d0a153c5 	stb	r2,-31409(gp)
   226f8:	24c003cc 	andi	r19,r4,15
{
   226fc:	dfc00815 	stw	ra,32(sp)
   22700:	ddc00715 	stw	r23,28(sp)
   22704:	dc800215 	stw	r18,8(sp)
   22708:	dc000015 	stw	r16,0(sp)
   2270c:	2080040c 	andi	r2,r4,16

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
    {
        bErrAck = 1;
        nAlStatus &= ~STATE_CHANGE;
   22710:	d46150c3 	ldbu	r17,-31421(gp)
{
   22714:	2829883a 	mov	r20,r5
   22718:	282d883a 	mov	r22,r5
   2271c:	982b883a 	mov	r21,r19
    if ( alControl & STATE_CHANGE )
   22720:	10005126 	beq	r2,zero,22868 <AL_ControlInd+0x198>
        nAlStatus &= ~STATE_CHANGE;
   22724:	00bffbc4 	movi	r2,-17
   22728:	1462703a 	and	r17,r2,r17
        bErrAck = 1;
   2272c:	05c00044 	movi	r23,1
        nAlStatus &= ~STATE_CHANGE;
   22730:	d46150c5 	stb	r17,-31421(gp)

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
    stateTrans = nAlStatus;
    stateTrans <<= 4;
   22734:	8822913a 	slli	r17,r17,4
    stateTrans += alControl;
   22738:	9c63883a 	add	r17,r19,r17

    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
   2273c:	8c803fcc 	andi	r18,r17,255
   22740:	908010a0 	cmpeqi	r2,r18,66
   22744:	1000931e 	bne	r2,zero,22994 <AL_ControlInd+0x2c4>
   22748:	908010e8 	cmpgeui	r2,r18,67
   2274c:	1000551e 	bne	r2,zero,228a4 <AL_ControlInd+0x1d4>
   22750:	90800920 	cmpeqi	r2,r18,36
   22754:	1000ae1e 	bne	r2,zero,22a10 <AL_ControlInd+0x340>
   22758:	90800970 	cmpltui	r2,r18,37
   2275c:	1000491e 	bne	r2,zero,22884 <AL_ControlInd+0x1b4>
    }

    if ( result == 0 )
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
   22760:	d021530d 	sth	zero,-31412(gp)
        switch ( stateTrans )
   22764:	8c7ffbc4 	addi	r17,r17,-17
   22768:	8c403fcc 	andi	r17,r17,255
   2276c:	88800e28 	cmpgeui	r2,r17,56
   22770:	10005b1e 	bne	r2,zero,228e0 <AL_ControlInd+0x210>
   22774:	882290ba 	slli	r17,r17,2
   22778:	008000b4 	movhi	r2,2
   2277c:	8885883a 	add	r2,r17,r2
   22780:	1089e217 	ldw	r2,10120(r2)
   22784:	1000683a 	jmp	r2
   22788:	00022d20 	cmpeqi	zero,zero,2228
   2278c:	00022a64 	muli	zero,zero,2217
   22790:	00022a50 	cmplti	zero,zero,2217
   22794:	00022e18 	cmpnei	zero,zero,2232
   22798:	000228e0 	cmpeqi	zero,zero,2211
   2279c:	000228e0 	cmpeqi	zero,zero,2211
   227a0:	000228e0 	cmpeqi	zero,zero,2211
   227a4:	00022e18 	cmpnei	zero,zero,2232
   227a8:	000228e0 	cmpeqi	zero,zero,2211
   227ac:	000228e0 	cmpeqi	zero,zero,2211
   227b0:	000228e0 	cmpeqi	zero,zero,2211
   227b4:	000228e0 	cmpeqi	zero,zero,2211
   227b8:	000228e0 	cmpeqi	zero,zero,2211
   227bc:	000228e0 	cmpeqi	zero,zero,2211
   227c0:	000228e0 	cmpeqi	zero,zero,2211
   227c4:	000228e0 	cmpeqi	zero,zero,2211
   227c8:	00022cf4 	movhi	zero,2227
   227cc:	00022d24 	muli	zero,zero,2228
   227d0:	00022e18 	cmpnei	zero,zero,2232
   227d4:	00022b78 	rdprs	zero,zero,2221
   227d8:	000228e0 	cmpeqi	zero,zero,2211
   227dc:	000228e0 	cmpeqi	zero,zero,2211
   227e0:	000228e0 	cmpeqi	zero,zero,2211
   227e4:	00022e18 	cmpnei	zero,zero,2232
   227e8:	000228e0 	cmpeqi	zero,zero,2211
   227ec:	000228e0 	cmpeqi	zero,zero,2211
   227f0:	000228e0 	cmpeqi	zero,zero,2211
   227f4:	000228e0 	cmpeqi	zero,zero,2211
   227f8:	000228e0 	cmpeqi	zero,zero,2211
   227fc:	000228e0 	cmpeqi	zero,zero,2211
   22800:	000228e0 	cmpeqi	zero,zero,2211
   22804:	000228e0 	cmpeqi	zero,zero,2211
   22808:	00022a4c 	andi	zero,zero,2217
   2280c:	00022e18 	cmpnei	zero,zero,2232
   22810:	000228e0 	cmpeqi	zero,zero,2211
   22814:	00022e18 	cmpnei	zero,zero,2232
   22818:	000228e0 	cmpeqi	zero,zero,2211
   2281c:	000228e0 	cmpeqi	zero,zero,2211
   22820:	000228e0 	cmpeqi	zero,zero,2211
   22824:	00022e18 	cmpnei	zero,zero,2232
   22828:	000228e0 	cmpeqi	zero,zero,2211
   2282c:	000228e0 	cmpeqi	zero,zero,2211
   22830:	000228e0 	cmpeqi	zero,zero,2211
   22834:	000228e0 	cmpeqi	zero,zero,2211
   22838:	000228e0 	cmpeqi	zero,zero,2211
   2283c:	000228e0 	cmpeqi	zero,zero,2211
   22840:	000228e0 	cmpeqi	zero,zero,2211
   22844:	000228e0 	cmpeqi	zero,zero,2211
   22848:	00022cc4 	movi	zero,2227
   2284c:	000228e0 	cmpeqi	zero,zero,2211
   22850:	00022e18 	cmpnei	zero,zero,2232
   22854:	00022d24 	muli	zero,zero,2228
   22858:	000228e0 	cmpeqi	zero,zero,2211
   2285c:	000228e0 	cmpeqi	zero,zero,2211
   22860:	000228e0 	cmpeqi	zero,zero,2211
   22864:	00022bf0 	cmpltui	zero,zero,2223
   22868:	102f883a 	mov	r23,r2
    else if ((nAlStatus & STATE_CHANGE)
   2286c:	8880040c 	andi	r2,r17,16
   22870:	10000226 	beq	r2,zero,2287c <AL_ControlInd+0x1ac>
        && (alControl & STATE_MASK) != STATE_INIT)
   22874:	98800058 	cmpnei	r2,r19,1
   22878:	1000a11e 	bne	r2,zero,22b00 <AL_ControlInd+0x430>
        nAlStatus &= STATE_MASK;
   2287c:	8c4003cc 	andi	r17,r17,15
   22880:	003fab06 	br	22730 <AL_ControlInd+0x60>
    switch ( stateTrans )
   22884:	908004a0 	cmpeqi	r2,r18,18
   22888:	10004b1e 	bne	r2,zero,229b8 <AL_ControlInd+0x2e8>
   2288c:	908008a0 	cmpeqi	r2,r18,34
   22890:	1000491e 	bne	r2,zero,229b8 <AL_ControlInd+0x2e8>
        nEcatStateTrans = 0;
   22894:	d021530d 	sth	zero,-31412(gp)
        switch ( stateTrans )
   22898:	90800468 	cmpgeui	r2,r18,17
   2289c:	10001026 	beq	r2,zero,228e0 <AL_ControlInd+0x210>
   228a0:	003fb006 	br	22764 <AL_ControlInd+0x94>
    switch ( stateTrans )
   228a4:	908020a0 	cmpeqi	r2,r18,130
   228a8:	1000281e 	bne	r2,zero,2294c <AL_ControlInd+0x27c>
   228ac:	908020e8 	cmpgeui	r2,r18,131
   228b0:	1000101e 	bne	r2,zero,228f4 <AL_ControlInd+0x224>
   228b4:	90801120 	cmpeqi	r2,r18,68
   228b8:	10005b1e 	bne	r2,zero,22a28 <AL_ControlInd+0x358>
   228bc:	90801220 	cmpeqi	r2,r18,72
   228c0:	1000591e 	bne	r2,zero,22a28 <AL_ControlInd+0x358>
        nEcatStateTrans = 0;
   228c4:	d021530d 	sth	zero,-31412(gp)
        switch ( stateTrans )
   228c8:	90801270 	cmpltui	r2,r18,73
   228cc:	103fa51e 	bne	r2,zero,22764 <AL_ControlInd+0x94>
   228d0:	8c401fc4 	addi	r17,r17,127
   228d4:	8c403fcc 	andi	r17,r17,255
   228d8:	8c400228 	cmpgeui	r17,r17,8
   228dc:	8800eb26 	beq	r17,zero,22c8c <AL_ControlInd+0x5bc>
                break;
        }
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
   228e0:	d12150c3 	ldbu	r4,-31421(gp)
   228e4:	208003cc 	andi	r2,r4,15
   228e8:	98806426 	beq	r19,r2,22a7c <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
   228ec:	04000484 	movi	r16,18
   228f0:	00009506 	br	22b48 <AL_ControlInd+0x478>
    switch ( stateTrans )
   228f4:	90802120 	cmpeqi	r2,r18,132
   228f8:	10004b1e 	bne	r2,zero,22a28 <AL_ControlInd+0x358>
   228fc:	90802220 	cmpeqi	r2,r18,136
   22900:	1000491e 	bne	r2,zero,22a28 <AL_ControlInd+0x358>
        nEcatStateTrans = 0;
   22904:	d021530d 	sth	zero,-31412(gp)
        switch ( stateTrans )
   22908:	8c401fc4 	addi	r17,r17,127
   2290c:	8c403fcc 	andi	r17,r17,255
   22910:	88800228 	cmpgeui	r2,r17,8
   22914:	103ff21e 	bne	r2,zero,228e0 <AL_ControlInd+0x210>
   22918:	882290ba 	slli	r17,r17,2
   2291c:	008000b4 	movhi	r2,2
   22920:	8885883a 	add	r2,r17,r2
   22924:	108a4b17 	ldw	r2,10540(r2)
   22928:	1000683a 	jmp	r2
   2292c:	00022c8c 	andi	zero,zero,2226
   22930:	00022964 	muli	zero,zero,2213
   22934:	00022e18 	cmpnei	zero,zero,2232
   22938:	00022c7c 	xorhi	zero,zero,2225
   2293c:	000228e0 	cmpeqi	zero,zero,2211
   22940:	000228e0 	cmpeqi	zero,zero,2211
   22944:	000228e0 	cmpeqi	zero,zero,2211
   22948:	00022d24 	muli	zero,zero,2228
        result = CheckSmSettings(MAILBOX_READ+1);
   2294c:	01000084 	movi	r4,2
   22950:	0021b6c0 	call	21b6c <CheckSmSettings>
   22954:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22958:	10803fcc 	andi	r2,r2,255
   2295c:	10001b1e 	bne	r2,zero,229cc <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   22960:	d021530d 	sth	zero,-31412(gp)
            result = APPL_StopOutputHandler();
   22964:	00202280 	call	20228 <APPL_StopOutputHandler>
   22968:	1021883a 	mov	r16,r2
            StopOutputHandler();
   2296c:	00225780 	call	22578 <StopOutputHandler>
            if (result != 0)
   22970:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22974:	d02153c5 	stb	zero,-31409(gp)
            if (result != 0)
   22978:	10000c26 	beq	r2,zero,229ac <AL_ControlInd+0x2dc>
    if ( result == NOERROR_INWORK )
   2297c:	10803fd8 	cmpnei	r2,r2,255
   22980:	10006e1e 	bne	r2,zero,22b3c <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22984:	00800044 	movi	r2,1
   22988:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   2298c:	00802084 	movi	r2,130
   22990:	0000c906 	br	22cb8 <AL_ControlInd+0x5e8>
        result = CheckSmSettings(MAILBOX_READ+1);
   22994:	01000084 	movi	r4,2
   22998:	0021b6c0 	call	21b6c <CheckSmSettings>
   2299c:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   229a0:	10803fcc 	andi	r2,r2,255
   229a4:	1000091e 	bne	r2,zero,229cc <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   229a8:	d021530d 	sth	zero,-31412(gp)
            APPL_StopInputHandler();
   229ac:	00202180 	call	20218 <APPL_StopInputHandler>
            StopInputHandler();
   229b0:	00225840 	call	22584 <StopInputHandler>
   229b4:	0000b306 	br	22c84 <AL_ControlInd+0x5b4>
        result = CheckSmSettings(MAILBOX_READ+1);
   229b8:	01000084 	movi	r4,2
   229bc:	0021b6c0 	call	21b6c <CheckSmSettings>
   229c0:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   229c4:	10803fcc 	andi	r2,r2,255
   229c8:	103fb226 	beq	r2,zero,22894 <AL_ControlInd+0x1c4>
        switch (nAlStatus)
   229cc:	d12150c3 	ldbu	r4,-31421(gp)
   229d0:	85ffffcc 	andi	r23,r16,65535
   229d4:	20803fcc 	andi	r2,r4,255
   229d8:	10c00120 	cmpeqi	r3,r2,4
   229dc:	1800e81e 	bne	r3,zero,22d80 <AL_ControlInd+0x6b0>
   229e0:	10c00220 	cmpeqi	r3,r2,8
   229e4:	1800e41e 	bne	r3,zero,22d78 <AL_ControlInd+0x6a8>
   229e8:	10c000a0 	cmpeqi	r3,r2,2
   229ec:	1800e61e 	bne	r3,zero,22d88 <AL_ControlInd+0x6b8>
    if ( result == NOERROR_INWORK )
   229f0:	bdc03fe0 	cmpeqi	r23,r23,255
   229f4:	b800fa1e 	bne	r23,zero,22de0 <AL_ControlInd+0x710>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   229f8:	20c003cc 	andi	r3,r4,15
   229fc:	98c0521e 	bne	r19,r3,22b48 <AL_ControlInd+0x478>
   22a00:	1009883a 	mov	r4,r2
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
   22a04:	d0215385 	stb	zero,-31410(gp)

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
   22a08:	000b883a 	mov	r5,zero
   22a0c:	00011a06 	br	22e78 <AL_ControlInd+0x7a8>
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
   22a10:	d1615204 	addi	r5,gp,-31416
   22a14:	d1215284 	addi	r4,gp,-31414
   22a18:	00202300 	call	20230 <APPL_GenerateMapping>
   22a1c:	1021883a 	mov	r16,r2
            if (result != 0)
   22a20:	10bfffcc 	andi	r2,r2,65535
   22a24:	103fe91e 	bne	r2,zero,229cc <AL_ControlInd+0x2fc>
        result = CheckSmSettings(nMaxSyncMan);
   22a28:	d1215183 	ldbu	r4,-31418(gp)
   22a2c:	0021b6c0 	call	21b6c <CheckSmSettings>
   22a30:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22a34:	10803fcc 	andi	r2,r2,255
   22a38:	103fe41e 	bne	r2,zero,229cc <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   22a3c:	d021530d 	sth	zero,-31412(gp)
        switch ( stateTrans )
   22a40:	90801268 	cmpgeui	r2,r18,73
   22a44:	103f9426 	beq	r2,zero,22898 <AL_ControlInd+0x1c8>
   22a48:	003faf06 	br	22908 <AL_ControlInd+0x238>
    bSyncSetByUser = FALSE;
   22a4c:	d0216785 	stb	zero,-31330(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a50:	d12150c3 	ldbu	r4,-31421(gp)
   22a54:	208003cc 	andi	r2,r4,15
   22a58:	98800826 	beq	r19,r2,22a7c <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_BOOTNOTSUPP;
   22a5c:	040004c4 	movi	r16,19
   22a60:	00003906 	br	22b48 <AL_ControlInd+0x478>
           UpdateEEPROMLoadedState();
   22a64:	0021a480 	call	21a48 <UpdateEEPROMLoadedState>
            if (EepromLoaded == FALSE)
   22a68:	d0a14b03 	ldbu	r2,-31444(gp)
   22a6c:	1000051e 	bne	r2,zero,22a84 <AL_ControlInd+0x3b4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a70:	d12150c3 	ldbu	r4,-31421(gp)
   22a74:	208003cc 	andi	r2,r4,15
   22a78:	9880f11e 	bne	r19,r2,22e40 <AL_ControlInd+0x770>
   22a7c:	21003fcc 	andi	r4,r4,255
   22a80:	003fe006 	br	22a04 <AL_ControlInd+0x334>
            result = MBX_StartMailboxHandler();
   22a84:	002393c0 	call	2393c <MBX_StartMailboxHandler>
   22a88:	1021883a 	mov	r16,r2
            if (result == 0)
   22a8c:	10bfffcc 	andi	r2,r2,65535
   22a90:	10000e1e 	bne	r2,zero,22acc <AL_ControlInd+0x3fc>
                bApplEsmPending = FALSE;
   22a94:	d02153c5 	stb	zero,-31409(gp)
                result = APPL_StartMailboxHandler();
   22a98:	00202000 	call	20200 <APPL_StartMailboxHandler>
   22a9c:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22aa0:	10bfffcc 	andi	r2,r2,65535
   22aa4:	1000091e 	bne	r2,zero,22acc <AL_ControlInd+0x3fc>
                    bMbxRunning = TRUE;
   22aa8:	00800044 	movi	r2,1
   22aac:	d0a16645 	stb	r2,-31335(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22ab0:	d12150c3 	ldbu	r4,-31421(gp)
   22ab4:	208003cc 	andi	r2,r4,15
   22ab8:	98bff026 	beq	r19,r2,22a7c <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22abc:	a0bfffcc 	andi	r2,r20,65535
   22ac0:	1000e51e 	bne	r2,zero,22e58 <AL_ControlInd+0x788>
   22ac4:	002d883a 	mov	r22,zero
            nAlStatus = alControl;
   22ac8:	0000e706 	br	22e68 <AL_ControlInd+0x798>
            if(result != 0 && result != NOERROR_INWORK)
   22acc:	80bfffcc 	andi	r2,r16,65535
   22ad0:	10803fd8 	cmpnei	r2,r2,255
   22ad4:	1000151e 	bne	r2,zero,22b2c <AL_ControlInd+0x45c>
        bEcatWaitForAlControlRes = TRUE;
   22ad8:	00800044 	movi	r2,1
   22adc:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22ae0:	00800484 	movi	r2,18
   22ae4:	d0a1530d 	sth	r2,-31412(gp)
            break;
   22ae8:	0401f404 	movi	r16,2000
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
   22aec:	813fffcc 	andi	r4,r16,65535
   22af0:	01400284 	movi	r5,10
   22af4:	0026b1c0 	call	26b1c <__udivsi3>
   22af8:	80a1c83a 	sub	r16,r16,r2
   22afc:	d4215c0d 	sth	r16,-31376(gp)
    }
    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 state machine from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/

}
   22b00:	dfc00817 	ldw	ra,32(sp)
   22b04:	ddc00717 	ldw	r23,28(sp)
   22b08:	dd800617 	ldw	r22,24(sp)
   22b0c:	dd400517 	ldw	r21,20(sp)
   22b10:	dd000417 	ldw	r20,16(sp)
   22b14:	dcc00317 	ldw	r19,12(sp)
   22b18:	dc800217 	ldw	r18,8(sp)
   22b1c:	dc400117 	ldw	r17,4(sp)
   22b20:	dc000017 	ldw	r16,0(sp)
   22b24:	dec00904 	addi	sp,sp,36
   22b28:	f800283a 	ret
                    if (!bApplEsmPending)
   22b2c:	d0a153c3 	ldbu	r2,-31409(gp)
   22b30:	1000011e 	bne	r2,zero,22b38 <AL_ControlInd+0x468>
                        APPL_StopMailboxHandler();
   22b34:	00202080 	call	20208 <APPL_StopMailboxHandler>
                 MBX_StopMailboxHandler();
   22b38:	0023a100 	call	23a10 <MBX_StopMailboxHandler>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22b3c:	d12150c3 	ldbu	r4,-31421(gp)
   22b40:	208003cc 	andi	r2,r4,15
   22b44:	98bfcd26 	beq	r19,r2,22a7c <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22b48:	9908b03a 	or	r4,r19,r4
   22b4c:	2100020c 	andi	r4,r4,8
   22b50:	2000d51e 	bne	r4,zero,22ea8 <AL_ControlInd+0x7d8>
                if (nAlStatus == STATE_OP)
   22b54:	d0a150c3 	ldbu	r2,-31421(gp)
   22b58:	10800218 	cmpnei	r2,r2,8
   22b5c:	1000021e 	bne	r2,zero,22b68 <AL_ControlInd+0x498>
                    nAlStatus = STATE_SAFEOP;
   22b60:	00800104 	movi	r2,4
   22b64:	d0a150c5 	stb	r2,-31421(gp)
            nAlStatus |= STATE_CHANGE;
   22b68:	d56150c3 	ldbu	r21,-31421(gp)
   22b6c:	802d883a 	mov	r22,r16
   22b70:	ad400414 	ori	r21,r21,16
   22b74:	0000bc06 	br	22e68 <AL_ControlInd+0x798>
            result = StartInputHandler();
   22b78:	0021ddc0 	call	21ddc <StartInputHandler>
   22b7c:	1021883a 	mov	r16,r2
            if ( result == 0 )
   22b80:	10bfffcc 	andi	r2,r2,65535
   22b84:	10000b1e 	bne	r2,zero,22bb4 <AL_ControlInd+0x4e4>
                result = APPL_StartInputHandler(&u16ALEventMask);
   22b88:	d1214e84 	addi	r4,gp,-31430
                bApplEsmPending = FALSE;
   22b8c:	d02153c5 	stb	zero,-31409(gp)
                result = APPL_StartInputHandler(&u16ALEventMask);
   22b90:	00202100 	call	20210 <APPL_StartInputHandler>
   22b94:	1021883a 	mov	r16,r2
                if(result == 0)
   22b98:	10bfffcc 	andi	r2,r2,65535
   22b9c:	1000051e 	bne	r2,zero,22bb4 <AL_ControlInd+0x4e4>
                    SetALEventMask( u16ALEventMask );
   22ba0:	d1214e8b 	ldhu	r4,-31430(gp)
   22ba4:	00219fc0 	call	219fc <SetALEventMask>
                    bEcatInputUpdateRunning = TRUE;
   22ba8:	00800044 	movi	r2,1
   22bac:	d0a15d45 	stb	r2,-31371(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22bb0:	003fbf06 	br	22ab0 <AL_ControlInd+0x3e0>
            if(result != 0 && result != NOERROR_INWORK)
   22bb4:	80bfffcc 	andi	r2,r16,65535
   22bb8:	10803fd8 	cmpnei	r2,r2,255
   22bbc:	1000061e 	bne	r2,zero,22bd8 <AL_ControlInd+0x508>
        bEcatWaitForAlControlRes = TRUE;
   22bc0:	00800044 	movi	r2,1
   22bc4:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22bc8:	00800904 	movi	r2,36
   22bcc:	d0a1530d 	sth	r2,-31412(gp)
                break;
   22bd0:	0408ca04 	movi	r16,9000
   22bd4:	003fc506 	br	22aec <AL_ControlInd+0x41c>
                if(!bApplEsmPending)
   22bd8:	d0a153c3 	ldbu	r2,-31409(gp)
   22bdc:	10000226 	beq	r2,zero,22be8 <AL_ControlInd+0x518>
                StopInputHandler();
   22be0:	00225840 	call	22584 <StopInputHandler>
   22be4:	003fd506 	br	22b3c <AL_ControlInd+0x46c>
                    APPL_StopInputHandler();
   22be8:	00202180 	call	20218 <APPL_StopInputHandler>
   22bec:	003ffc06 	br	22be0 <AL_ControlInd+0x510>
            if (bErrAck)
   22bf0:	bdc03fcc 	andi	r23,r23,255
   22bf4:	b8000426 	beq	r23,zero,22c08 <AL_ControlInd+0x538>
                if (nPdOutputSize > 0)
   22bf8:	d0a1520b 	ldhu	r2,-31416(gp)
   22bfc:	10000e26 	beq	r2,zero,22c38 <AL_ControlInd+0x568>
                    EnableSyncManChannel(PROCESS_DATA_OUT);
   22c00:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22c04:	0021b100 	call	21b10 <EnableSyncManChannel>
            result = StartOutputHandler();
   22c08:	002251c0 	call	2251c <StartOutputHandler>
   22c0c:	1021883a 	mov	r16,r2
            if(result == 0)
   22c10:	10bfffcc 	andi	r2,r2,65535
   22c14:	10000c1e 	bne	r2,zero,22c48 <AL_ControlInd+0x578>
                bApplEsmPending = FALSE;
   22c18:	d02153c5 	stb	zero,-31409(gp)
                result = APPL_StartOutputHandler();
   22c1c:	00202200 	call	20220 <APPL_StartOutputHandler>
   22c20:	1021883a 	mov	r16,r2
                if(result == 0)
   22c24:	10bfffcc 	andi	r2,r2,65535
   22c28:	1000071e 	bne	r2,zero,22c48 <AL_ControlInd+0x578>
                    bEcatOutputUpdateRunning = TRUE;
   22c2c:	00800044 	movi	r2,1
   22c30:	d0a15d85 	stb	r2,-31370(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22c34:	003f9e06 	br	22ab0 <AL_ControlInd+0x3e0>
                    if (nPdInputSize > 0)
   22c38:	d0a1528b 	ldhu	r2,-31414(gp)
   22c3c:	103ff226 	beq	r2,zero,22c08 <AL_ControlInd+0x538>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22c40:	010000c4 	movi	r4,3
   22c44:	003fef06 	br	22c04 <AL_ControlInd+0x534>
            if ( result != 0 && result != NOERROR_INWORK)
   22c48:	80bfffcc 	andi	r2,r16,65535
   22c4c:	10803fd8 	cmpnei	r2,r2,255
   22c50:	1000041e 	bne	r2,zero,22c64 <AL_ControlInd+0x594>
        bEcatWaitForAlControlRes = TRUE;
   22c54:	00800044 	movi	r2,1
   22c58:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22c5c:	00801204 	movi	r2,72
   22c60:	003fda06 	br	22bcc <AL_ControlInd+0x4fc>
                    if (!bApplEsmPending)
   22c64:	d0a153c3 	ldbu	r2,-31409(gp)
   22c68:	10000226 	beq	r2,zero,22c74 <AL_ControlInd+0x5a4>
                StopOutputHandler();
   22c6c:	00225780 	call	22578 <StopOutputHandler>
    if ( result == NOERROR_INWORK )
   22c70:	003fb206 	br	22b3c <AL_ControlInd+0x46c>
                        APPL_StopOutputHandler();
   22c74:	00202280 	call	20228 <APPL_StopOutputHandler>
   22c78:	003ffc06 	br	22c6c <AL_ControlInd+0x59c>
            APPL_StopOutputHandler();
   22c7c:	00202280 	call	20228 <APPL_StopOutputHandler>
            StopOutputHandler();
   22c80:	00225780 	call	22578 <StopOutputHandler>
            bApplEsmPending = FALSE;
   22c84:	d02153c5 	stb	zero,-31409(gp)
   22c88:	003f8906 	br	22ab0 <AL_ControlInd+0x3e0>
            result = APPL_StopOutputHandler();
   22c8c:	00202280 	call	20228 <APPL_StopOutputHandler>
   22c90:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22c94:	00225780 	call	22578 <StopOutputHandler>
            if (result != 0)
   22c98:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22c9c:	d02153c5 	stb	zero,-31409(gp)
            if (result != 0)
   22ca0:	10000826 	beq	r2,zero,22cc4 <AL_ControlInd+0x5f4>
    if ( result == NOERROR_INWORK )
   22ca4:	10803fd8 	cmpnei	r2,r2,255
   22ca8:	103fa41e 	bne	r2,zero,22b3c <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22cac:	00800044 	movi	r2,1
   22cb0:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22cb4:	00802044 	movi	r2,129
   22cb8:	d0a1530d 	sth	r2,-31412(gp)
                break;
   22cbc:	04003204 	movi	r16,200
   22cc0:	003f8a06 	br	22aec <AL_ControlInd+0x41c>
            result = APPL_StopInputHandler();
   22cc4:	00202180 	call	20218 <APPL_StopInputHandler>
   22cc8:	1021883a 	mov	r16,r2
            StopInputHandler();
   22ccc:	00225840 	call	22584 <StopInputHandler>
            if (result != 0)
   22cd0:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22cd4:	d02153c5 	stb	zero,-31409(gp)
            if (result != 0)
   22cd8:	10000626 	beq	r2,zero,22cf4 <AL_ControlInd+0x624>
    if ( result == NOERROR_INWORK )
   22cdc:	10803fd8 	cmpnei	r2,r2,255
   22ce0:	103f961e 	bne	r2,zero,22b3c <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22ce4:	00800044 	movi	r2,1
   22ce8:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22cec:	00801044 	movi	r2,65
   22cf0:	003ff106 	br	22cb8 <AL_ControlInd+0x5e8>
            MBX_StopMailboxHandler();
   22cf4:	0023a100 	call	23a10 <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
   22cf8:	00202080 	call	20208 <APPL_StopMailboxHandler>
   22cfc:	1021883a 	mov	r16,r2
    if ( result == NOERROR_INWORK )
   22d00:	10bfffcc 	andi	r2,r2,65535
    bSyncSetByUser = FALSE;
   22d04:	d0216785 	stb	zero,-31330(gp)
    if ( result == NOERROR_INWORK )
   22d08:	10c03fe0 	cmpeqi	r3,r2,255
   22d0c:	18004726 	beq	r3,zero,22e2c <AL_ControlInd+0x75c>
        bEcatWaitForAlControlRes = TRUE;
   22d10:	00800044 	movi	r2,1
   22d14:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22d18:	00800844 	movi	r2,33
   22d1c:	003fe606 	br	22cb8 <AL_ControlInd+0x5e8>
    bSyncSetByUser = FALSE;
   22d20:	d0216785 	stb	zero,-31330(gp)
            if(bErrAck)
   22d24:	bdc03fcc 	andi	r23,r23,255
   22d28:	b8000226 	beq	r23,zero,22d34 <AL_ControlInd+0x664>
                APPL_AckErrorInd(stateTrans);
   22d2c:	9009883a 	mov	r4,r18
   22d30:	00201fc0 	call	201fc <APPL_AckErrorInd>
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
   22d34:	d12150c3 	ldbu	r4,-31421(gp)
   22d38:	9c003fcc 	andi	r16,r19,255
   22d3c:	2080030c 	andi	r2,r4,12
   22d40:	10000526 	beq	r2,zero,22d58 <AL_ControlInd+0x688>
                    if(nPdOutputSize > 0)
   22d44:	d0a1520b 	ldhu	r2,-31416(gp)
   22d48:	10000726 	beq	r2,zero,22d68 <AL_ControlInd+0x698>
                        EnableSyncManChannel(PROCESS_DATA_OUT);
   22d4c:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22d50:	0021b100 	call	21b10 <EnableSyncManChannel>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d54:	d12150c3 	ldbu	r4,-31421(gp)
   22d58:	208003cc 	andi	r2,r4,15
   22d5c:	80bf4726 	beq	r16,r2,22a7c <AL_ControlInd+0x3ac>
            result = NOERROR_NOSTATECHANGE;
   22d60:	04003f84 	movi	r16,254
   22d64:	003f7806 	br	22b48 <AL_ControlInd+0x478>
                    if(nPdInputSize > 0)
   22d68:	d0a1528b 	ldhu	r2,-31414(gp)
   22d6c:	103ffa26 	beq	r2,zero,22d58 <AL_ControlInd+0x688>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22d70:	010000c4 	movi	r4,3
   22d74:	003ff606 	br	22d50 <AL_ControlInd+0x680>
            APPL_StopOutputHandler();
   22d78:	00202280 	call	20228 <APPL_StopOutputHandler>
            StopOutputHandler();
   22d7c:	00225780 	call	22578 <StopOutputHandler>
            APPL_StopInputHandler();
   22d80:	00202180 	call	20218 <APPL_StopInputHandler>
            StopInputHandler();
   22d84:	00225840 	call	22584 <StopInputHandler>
            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
   22d88:	b8800598 	cmpnei	r2,r23,22
   22d8c:	10000c1e 	bne	r2,zero,22dc0 <AL_ControlInd+0x6f0>
                MBX_StopMailboxHandler();
   22d90:	0023a100 	call	23a10 <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
   22d94:	00202080 	call	20208 <APPL_StopMailboxHandler>
                DisableSyncManChannel(MAILBOX_WRITE);
   22d98:	0009883a 	mov	r4,zero
   22d9c:	0021ab00 	call	21ab0 <DisableSyncManChannel>
                DisableSyncManChannel(MAILBOX_READ);
   22da0:	01000044 	movi	r4,1
   22da4:	0021ab00 	call	21ab0 <DisableSyncManChannel>
                nAlStatus = STATE_INIT;
   22da8:	00800044 	movi	r2,1
   22dac:	d0a150c5 	stb	r2,-31421(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22db0:	98800058 	cmpnei	r2,r19,1
   22db4:	1000241e 	bne	r2,zero,22e48 <AL_ControlInd+0x778>
   22db8:	01000044 	movi	r4,1
   22dbc:	003f1106 	br	22a04 <AL_ControlInd+0x334>
                nAlStatus = STATE_PREOP;
   22dc0:	00800084 	movi	r2,2
   22dc4:	d0a150c5 	stb	r2,-31421(gp)
    if ( result == NOERROR_INWORK )
   22dc8:	bdc03fe0 	cmpeqi	r23,r23,255
   22dcc:	b800041e 	bne	r23,zero,22de0 <AL_ControlInd+0x710>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22dd0:	98800098 	cmpnei	r2,r19,2
   22dd4:	10001e1e 	bne	r2,zero,22e50 <AL_ControlInd+0x780>
   22dd8:	01000084 	movi	r4,2
   22ddc:	003f0906 	br	22a04 <AL_ControlInd+0x334>
        bEcatWaitForAlControlRes = TRUE;
   22de0:	00800044 	movi	r2,1
        nEcatStateTrans = stateTrans;
   22de4:	8c403fcc 	andi	r17,r17,255
        bEcatWaitForAlControlRes = TRUE;
   22de8:	d0a15385 	stb	r2,-31410(gp)
        nEcatStateTrans = stateTrans;
   22dec:	d461530d 	sth	r17,-31412(gp)
        switch(nEcatStateTrans)
   22df0:	90800528 	cmpgeui	r2,r18,20
   22df4:	1000031e 	bne	r2,zero,22e04 <AL_ControlInd+0x734>
   22df8:	948004a8 	cmpgeui	r18,r18,18
   22dfc:	903f3a1e 	bne	r18,zero,22ae8 <AL_ControlInd+0x418>
   22e00:	003fae06 	br	22cbc <AL_ControlInd+0x5ec>
   22e04:	90800920 	cmpeqi	r2,r18,36
   22e08:	103f711e 	bne	r2,zero,22bd0 <AL_ControlInd+0x500>
   22e0c:	94801220 	cmpeqi	r18,r18,72
   22e10:	903f6f1e 	bne	r18,zero,22bd0 <AL_ControlInd+0x500>
   22e14:	003fa906 	br	22cbc <AL_ControlInd+0x5ec>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22e18:	d12150c3 	ldbu	r4,-31421(gp)
   22e1c:	208003cc 	andi	r2,r4,15
   22e20:	98bf1626 	beq	r19,r2,22a7c <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_INVALIDALCONTROL;
   22e24:	04000444 	movi	r16,17
   22e28:	003f4706 	br	22b48 <AL_ControlInd+0x478>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22e2c:	d12150c3 	ldbu	r4,-31421(gp)
   22e30:	20c003cc 	andi	r3,r4,15
   22e34:	98ff1126 	beq	r19,r3,22a7c <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22e38:	103f2026 	beq	r2,zero,22abc <AL_ControlInd+0x3ec>
   22e3c:	003f4206 	br	22b48 <AL_ControlInd+0x478>
                result = ALSTATUSCODE_EE_ERROR;
   22e40:	04001444 	movi	r16,81
   22e44:	003f4006 	br	22b48 <AL_ControlInd+0x478>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22e48:	01000044 	movi	r4,1
   22e4c:	003f3e06 	br	22b48 <AL_ControlInd+0x478>
   22e50:	01000084 	movi	r4,2
   22e54:	003f3c06 	br	22b48 <AL_ControlInd+0x478>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22e58:	9908b03a 	or	r4,r19,r4
   22e5c:	2100020c 	andi	r4,r4,8
   22e60:	2000101e 	bne	r4,zero,22ea4 <AL_ControlInd+0x7d4>
                alControl |= STATE_CHANGE;
   22e64:	9d400414 	ori	r21,r19,16
            nAlStatus |= STATE_CHANGE;
   22e68:	d56150c5 	stb	r21,-31421(gp)
        bEcatWaitForAlControlRes = FALSE;
   22e6c:	d0215385 	stb	zero,-31410(gp)
        SetALStatus(nAlStatus, result);
   22e70:	b17fffcc 	andi	r5,r22,65535
   22e74:	a9003fcc 	andi	r4,r21,255
}
   22e78:	dfc00817 	ldw	ra,32(sp)
   22e7c:	ddc00717 	ldw	r23,28(sp)
   22e80:	dd800617 	ldw	r22,24(sp)
   22e84:	dd400517 	ldw	r21,20(sp)
   22e88:	dd000417 	ldw	r20,16(sp)
   22e8c:	dcc00317 	ldw	r19,12(sp)
   22e90:	dc800217 	ldw	r18,8(sp)
   22e94:	dc400117 	ldw	r17,4(sp)
   22e98:	dc000017 	ldw	r16,0(sp)
   22e9c:	dec00904 	addi	sp,sp,36
        SetALStatus(nAlStatus, 0);
   22ea0:	002262c1 	jmpi	2262c <SetALStatus>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22ea4:	0021883a 	mov	r16,zero
            if(bEcatOutputUpdateRunning)
   22ea8:	d0a15d83 	ldbu	r2,-31370(gp)
   22eac:	10000226 	beq	r2,zero,22eb8 <AL_ControlInd+0x7e8>
                APPL_StopOutputHandler();
   22eb0:	00202280 	call	20228 <APPL_StopOutputHandler>
                StopOutputHandler();
   22eb4:	00225780 	call	22578 <StopOutputHandler>
            if(nPdOutputSize > 0)
   22eb8:	d0a1520b 	ldhu	r2,-31416(gp)
   22ebc:	10000726 	beq	r2,zero,22edc <AL_ControlInd+0x80c>
                DisableSyncManChannel(PROCESS_DATA_OUT);
   22ec0:	01000084 	movi	r4,2
                DisableSyncManChannel(PROCESS_DATA_IN);
   22ec4:	0021ab00 	call	21ab0 <DisableSyncManChannel>
        if ( result != 0 )
   22ec8:	80bfffcc 	andi	r2,r16,65535
   22ecc:	103f211e 	bne	r2,zero,22b54 <AL_ControlInd+0x484>
            if ( alStatusCode != 0 )
   22ed0:	a53fffcc 	andi	r20,r20,65535
   22ed4:	a03fe31e 	bne	r20,zero,22e64 <AL_ControlInd+0x794>
   22ed8:	003efa06 	br	22ac4 <AL_ControlInd+0x3f4>
                if(nPdInputSize > 0)
   22edc:	d0a1528b 	ldhu	r2,-31414(gp)
   22ee0:	103ff926 	beq	r2,zero,22ec8 <AL_ControlInd+0x7f8>
                DisableSyncManChannel(PROCESS_DATA_IN);
   22ee4:	010000c4 	movi	r4,3
   22ee8:	003ff606 	br	22ec4 <AL_ControlInd+0x7f4>

00022eec <AL_ControlRes>:
 \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the application specific state transition function is called.
 \brief    If the pending state transition is triggered by the application the transition need to be completed by the application (ECAT_StateChange())
  *////////////////////////////////////////////////////////////////////////////////////////
void AL_ControlRes(void)
{
    if(bEcatWaitForAlControlRes)
   22eec:	d0a15383 	ldbu	r2,-31410(gp)
   22ef0:	1000bf26 	beq	r2,zero,231f0 <AL_ControlRes+0x304>
        UINT8 Status = 0;
        UINT16 StatusCode = 0;

        if(EsmTimeoutCounter == 0)
        {
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22ef4:	d0a1530b 	ldhu	r2,-31412(gp)
        if(EsmTimeoutCounter == 0)
   22ef8:	d1215c0f 	ldh	r4,-31376(gp)
{
   22efc:	defffc04 	addi	sp,sp,-16
   22f00:	dfc00315 	stw	ra,12(sp)
   22f04:	dc800215 	stw	r18,8(sp)
   22f08:	dc400115 	stw	r17,4(sp)
   22f0c:	dc000015 	stw	r16,0(sp)
   22f10:	10ffffcc 	andi	r3,r2,65535
        if(EsmTimeoutCounter == 0)
   22f14:	2000551e 	bne	r4,zero,2306c <AL_ControlRes+0x180>
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22f18:	1822d13a 	srli	r17,r3,4

            /* ESM timeout expired*/
            switch(nEcatStateTrans)
   22f1c:	19000920 	cmpeqi	r4,r3,36
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22f20:	8825883a 	mov	r18,r17
            switch(nEcatStateTrans)
   22f24:	2000331e 	bne	r4,zero,22ff4 <AL_ControlRes+0x108>
   22f28:	19000968 	cmpgeui	r4,r3,37
   22f2c:	2000091e 	bne	r4,zero,22f54 <AL_ControlRes+0x68>
   22f30:	10bffb84 	addi	r2,r2,-18
   22f34:	10bfffcc 	andi	r2,r2,65535
   22f38:	108000a8 	cmpgeui	r2,r2,2
   22f3c:	10001e26 	beq	r2,zero,22fb8 <AL_ControlRes+0xcc>
                    }             
                break;
            }//Switch - transition
        }

        if(Status != 0)
   22f40:	8c403fcc 	andi	r17,r17,255
   22f44:	88005126 	beq	r17,zero,2308c <AL_ControlRes+0x1a0>
        {
            /*Pending state transition finished => write AL Status and AL Status Code*/
            bEcatWaitForAlControlRes = FALSE;
   22f48:	d0215385 	stb	zero,-31410(gp)
        UINT16 StatusCode = 0;
   22f4c:	0021883a 	mov	r16,zero
   22f50:	00001106 	br	22f98 <AL_ControlRes+0xac>
            switch(nEcatStateTrans)
   22f54:	18c01220 	cmpeqi	r3,r3,72
   22f58:	183ff926 	beq	r3,zero,22f40 <AL_ControlRes+0x54>
                    if(bDcSyncActive)
   22f5c:	d0a15c83 	ldbu	r2,-31374(gp)
   22f60:	10002c26 	beq	r2,zero,23014 <AL_ControlRes+0x128>
                        if(!bDcRunning)
   22f64:	d0a15b83 	ldbu	r2,-31378(gp)
   22f68:	10003a26 	beq	r2,zero,23054 <AL_ControlRes+0x168>
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
   22f6c:	d0a15d03 	ldbu	r2,-31372(gp)
   22f70:	1000021e 	bne	r2,zero,22f7c <AL_ControlRes+0x90>
   22f74:	d0a1520b 	ldhu	r2,-31416(gp)
   22f78:	1000381e 	bne	r2,zero,2305c <AL_ControlRes+0x170>
                        else if (!bSmSyncSequenceValid)
   22f7c:	d0a15a03 	ldbu	r2,-31384(gp)
   22f80:	10003826 	beq	r2,zero,23064 <AL_ControlRes+0x178>
                            bEcatOutputUpdateRunning = TRUE;
   22f84:	00800044 	movi	r2,1
   22f88:	d0a15d85 	stb	r2,-31370(gp)
            bEcatWaitForAlControlRes = FALSE;
   22f8c:	d0215385 	stb	zero,-31410(gp)
                            StatusCode = 0;
   22f90:	0021883a 	mov	r16,zero
                            Status = STATE_OP;
   22f94:	04800204 	movi	r18,8
            if (StatusCode != 0)
            {
                Status |= STATE_CHANGE;
            }

            SetALStatus(Status,StatusCode);
   22f98:	817fffcc 	andi	r5,r16,65535
   22f9c:	91003fcc 	andi	r4,r18,255
        }
    }// Pending state transition (bEcatWaitForAlControlRes == true)
}
   22fa0:	dfc00317 	ldw	ra,12(sp)
   22fa4:	dc800217 	ldw	r18,8(sp)
   22fa8:	dc400117 	ldw	r17,4(sp)
   22fac:	dc000017 	ldw	r16,0(sp)
   22fb0:	dec00404 	addi	sp,sp,16
            SetALStatus(Status,StatusCode);
   22fb4:	002262c1 	jmpi	2262c <SetALStatus>
                        if (!bApplEsmPending)
   22fb8:	d0a153c3 	ldbu	r2,-31409(gp)
   22fbc:	1000011e 	bne	r2,zero,22fc4 <AL_ControlRes+0xd8>
                            APPL_StopMailboxHandler();
   22fc0:	00202080 	call	20208 <APPL_StopMailboxHandler>
                    MBX_StopMailboxHandler();
   22fc4:	0023a100 	call	23a10 <MBX_StopMailboxHandler>
                    if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
   22fc8:	d0a15403 	ldbu	r2,-31408(gp)
   22fcc:	108003cc 	andi	r2,r2,15
   22fd0:	10800058 	cmpnei	r2,r2,1
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   22fd4:	1000811e 	bne	r2,zero,231dc <AL_ControlRes+0x2f0>
        if(Status != 0)
   22fd8:	88803fcc 	andi	r2,r17,255
                        StatusCode = u16LocalErrorCode;
   22fdc:	d421548b 	ldhu	r16,-31406(gp)
        if(Status != 0)
   22fe0:	10002a26 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   22fe4:	d0215385 	stb	zero,-31410(gp)
            if (StatusCode != 0)
   22fe8:	80bfffcc 	andi	r2,r16,65535
   22fec:	1000171e 	bne	r2,zero,2304c <AL_ControlRes+0x160>
   22ff0:	003fe906 	br	22f98 <AL_ControlRes+0xac>
                        if (!bApplEsmPending)
   22ff4:	d0a153c3 	ldbu	r2,-31409(gp)
   22ff8:	1000011e 	bne	r2,zero,23000 <AL_ControlRes+0x114>
                            APPL_StopInputHandler();
   22ffc:	00202180 	call	20218 <APPL_StopInputHandler>
                    StopInputHandler();
   23000:	00225840 	call	22584 <StopInputHandler>
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   23004:	d0a15403 	ldbu	r2,-31408(gp)
   23008:	108003cc 	andi	r2,r2,15
   2300c:	10800098 	cmpnei	r2,r2,2
   23010:	003ff006 	br	22fd4 <AL_ControlRes+0xe8>
                            if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
   23014:	d0a15403 	ldbu	r2,-31408(gp)
   23018:	108003cc 	andi	r2,r2,15
   2301c:	10800118 	cmpnei	r2,r2,4
   23020:	103fd81e 	bne	r2,zero,22f84 <AL_ControlRes+0x98>
                                StatusCode = u16LocalErrorCode;
   23024:	d421548b 	ldhu	r16,-31406(gp)
                    if(StatusCode != 0)
   23028:	80bfffcc 	andi	r2,r16,65535
   2302c:	103fc426 	beq	r2,zero,22f40 <AL_ControlRes+0x54>
                            if (!bApplEsmPending)
   23030:	d0a153c3 	ldbu	r2,-31409(gp)
   23034:	1000011e 	bne	r2,zero,2303c <AL_ControlRes+0x150>
                                APPL_StopOutputHandler();
   23038:	00202280 	call	20228 <APPL_StopOutputHandler>
                        StopOutputHandler();
   2303c:	00225780 	call	22578 <StopOutputHandler>
        if(Status != 0)
   23040:	88803fcc 	andi	r2,r17,255
   23044:	10001126 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   23048:	d0215385 	stb	zero,-31410(gp)
                Status |= STATE_CHANGE;
   2304c:	8c800414 	ori	r18,r17,16
   23050:	003fd106 	br	22f98 <AL_ControlRes+0xac>
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
   23054:	04000b44 	movi	r16,45
   23058:	003ff506 	br	23030 <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
   2305c:	040006c4 	movi	r16,27
   23060:	003ff306 	br	23030 <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SYNCERROR;
   23064:	04000684 	movi	r16,26
   23068:	003ff106 	br	23030 <AL_ControlRes+0x144>
            switch(nEcatStateTrans)
   2306c:	19000920 	cmpeqi	r4,r3,36
   23070:	20003d1e 	bne	r4,zero,23168 <AL_ControlRes+0x27c>
   23074:	19000968 	cmpgeui	r4,r3,37
   23078:	20000a1e 	bne	r4,zero,230a4 <AL_ControlRes+0x1b8>
   2307c:	10bffb84 	addi	r2,r2,-18
   23080:	10bfffcc 	andi	r2,r2,65535
   23084:	108000a8 	cmpgeui	r2,r2,2
   23088:	10001f26 	beq	r2,zero,23108 <AL_ControlRes+0x21c>
}
   2308c:	dfc00317 	ldw	ra,12(sp)
   23090:	dc800217 	ldw	r18,8(sp)
   23094:	dc400117 	ldw	r17,4(sp)
   23098:	dc000017 	ldw	r16,0(sp)
   2309c:	dec00404 	addi	sp,sp,16
   230a0:	f800283a 	ret
            switch(nEcatStateTrans)
   230a4:	18c01220 	cmpeqi	r3,r3,72
   230a8:	183ff826 	beq	r3,zero,2308c <AL_ControlRes+0x1a0>
                   if(bApplEsmPending)
   230ac:	d0a153c3 	ldbu	r2,-31409(gp)
   230b0:	103ff626 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
                        if(bDcSyncActive)
   230b4:	d0a15c83 	ldbu	r2,-31374(gp)
   230b8:	10004126 	beq	r2,zero,231c0 <AL_ControlRes+0x2d4>
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
   230bc:	d0a1598f 	ldh	r2,-31386(gp)
   230c0:	00bff20e 	bge	zero,r2,2308c <AL_ControlRes+0x1a0>
   230c4:	d0e1590f 	ldh	r3,-31388(gp)
   230c8:	18bff016 	blt	r3,r2,2308c <AL_ControlRes+0x1a0>
                                i16WaitForPllRunningTimeout = 0;
   230cc:	d021598d 	sth	zero,-31386(gp)
                                i16WaitForPllRunningCnt = 0;
   230d0:	d021590d 	sth	zero,-31388(gp)
                                bApplEsmPending = FALSE;
   230d4:	d02153c5 	stb	zero,-31409(gp)
                                result = APPL_StartOutputHandler();
   230d8:	00202200 	call	20220 <APPL_StartOutputHandler>
                                if(result == 0)
   230dc:	10bfffcc 	andi	r2,r2,65535
   230e0:	103fa826 	beq	r2,zero,22f84 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   230e4:	10803fe0 	cmpeqi	r2,r2,255
   230e8:	103fe81e 	bne	r2,zero,2308c <AL_ControlRes+0x1a0>
                                        APPL_StopOutputHandler();
   230ec:	00202280 	call	20228 <APPL_StopOutputHandler>
}
   230f0:	dfc00317 	ldw	ra,12(sp)
   230f4:	dc800217 	ldw	r18,8(sp)
   230f8:	dc400117 	ldw	r17,4(sp)
   230fc:	dc000017 	ldw	r16,0(sp)
   23100:	dec00404 	addi	sp,sp,16
                                        StopOutputHandler();
   23104:	00225781 	jmpi	22578 <StopOutputHandler>
                    if(bApplEsmPending)
   23108:	d0a153c3 	ldbu	r2,-31409(gp)
   2310c:	103fdf26 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
                        bApplEsmPending = FALSE;
   23110:	d02153c5 	stb	zero,-31409(gp)
                        result = APPL_StartMailboxHandler();
   23114:	00202000 	call	20200 <APPL_StartMailboxHandler>
   23118:	1021883a 	mov	r16,r2
                        if(result == 0)
   2311c:	10bfffcc 	andi	r2,r2,65535
   23120:	1000081e 	bne	r2,zero,23144 <AL_ControlRes+0x258>
                            bMbxRunning = TRUE;
   23124:	00800044 	movi	r2,1
   23128:	d0a16645 	stb	r2,-31335(gp)
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   2312c:	d0a15303 	ldbu	r2,-31412(gp)
   23130:	108003cc 	andi	r2,r2,15
   23134:	1025883a 	mov	r18,r2
        if(Status != 0)
   23138:	103fd426 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   2313c:	d0215385 	stb	zero,-31410(gp)
            if (StatusCode != 0)
   23140:	003f9506 	br	22f98 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   23144:	10803fe0 	cmpeqi	r2,r2,255
   23148:	103fd01e 	bne	r2,zero,2308c <AL_ControlRes+0x1a0>
                                APPL_StopMailboxHandler();
   2314c:	00202080 	call	20208 <APPL_StopMailboxHandler>
}
   23150:	dfc00317 	ldw	ra,12(sp)
   23154:	dc800217 	ldw	r18,8(sp)
   23158:	dc400117 	ldw	r17,4(sp)
   2315c:	dc000017 	ldw	r16,0(sp)
   23160:	dec00404 	addi	sp,sp,16
                                MBX_StopMailboxHandler();
   23164:	0023a101 	jmpi	23a10 <MBX_StopMailboxHandler>
                    if(bApplEsmPending)
   23168:	d0a153c3 	ldbu	r2,-31409(gp)
   2316c:	103fc726 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23170:	d1214e84 	addi	r4,gp,-31430
                        bApplEsmPending = FALSE;
   23174:	d02153c5 	stb	zero,-31409(gp)
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23178:	00202100 	call	20210 <APPL_StartInputHandler>
   2317c:	1021883a 	mov	r16,r2
                        if(result == 0)
   23180:	10bfffcc 	andi	r2,r2,65535
   23184:	1000051e 	bne	r2,zero,2319c <AL_ControlRes+0x2b0>
                            bEcatInputUpdateRunning = TRUE;
   23188:	00800044 	movi	r2,1
   2318c:	d0a15d45 	stb	r2,-31371(gp)
            bEcatWaitForAlControlRes = FALSE;
   23190:	d0215385 	stb	zero,-31410(gp)
                            Status = STATE_SAFEOP;
   23194:	04800104 	movi	r18,4
   23198:	003f7f06 	br	22f98 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   2319c:	10803fe0 	cmpeqi	r2,r2,255
   231a0:	103fba1e 	bne	r2,zero,2308c <AL_ControlRes+0x1a0>
                                APPL_StopInputHandler();
   231a4:	00202180 	call	20218 <APPL_StopInputHandler>
}
   231a8:	dfc00317 	ldw	ra,12(sp)
   231ac:	dc800217 	ldw	r18,8(sp)
   231b0:	dc400117 	ldw	r17,4(sp)
   231b4:	dc000017 	ldw	r16,0(sp)
   231b8:	dec00404 	addi	sp,sp,16
                                StopInputHandler();
   231bc:	00225841 	jmpi	22584 <StopInputHandler>
                                bApplEsmPending = FALSE;  
   231c0:	d02153c5 	stb	zero,-31409(gp)
                                result = APPL_StartOutputHandler();
   231c4:	00202200 	call	20220 <APPL_StartOutputHandler>
                                if(result == 0)
   231c8:	10bfffcc 	andi	r2,r2,65535
   231cc:	103f6d26 	beq	r2,zero,22f84 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   231d0:	10803fd8 	cmpnei	r2,r2,255
   231d4:	103fad26 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
   231d8:	003fc406 	br	230ec <AL_ControlRes+0x200>
        if(Status != 0)
   231dc:	88803fcc 	andi	r2,r17,255
   231e0:	103faa26 	beq	r2,zero,2308c <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   231e4:	d0215385 	stb	zero,-31410(gp)
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
   231e8:	04000044 	movi	r16,1
   231ec:	003f9706 	br	2304c <AL_ControlRes+0x160>
   231f0:	f800283a 	ret

000231f4 <DC_CheckWatchdog>:

*////////////////////////////////////////////////////////////////////////////////////////
void DC_CheckWatchdog(void)
{

    if(bDcSyncActive && bEcatInputUpdateRunning)
   231f4:	d0a15c83 	ldbu	r2,-31374(gp)
   231f8:	10002d26 	beq	r2,zero,232b0 <DC_CheckWatchdog+0xbc>
   231fc:	d0a15d43 	ldbu	r2,-31371(gp)
   23200:	10002b26 	beq	r2,zero,232b0 <DC_CheckWatchdog+0xbc>
    {
        /*If Sync0 watchdog is enabled and expired*/
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
   23204:	d0e1580b 	ldhu	r3,-31392(gp)
   23208:	18000926 	beq	r3,zero,23230 <DC_CheckWatchdog+0x3c>
   2320c:	d0a1588b 	ldhu	r2,-31390(gp)
   23210:	113fffcc 	andi	r4,r2,65535
   23214:	20c00436 	bltu	r4,r3,23228 <DC_CheckWatchdog+0x34>
                {
                    i16WaitForPllRunningCnt = 0;
                }
            }
        }
        else if(bSmSyncSequenceValid)
   23218:	d0a15a03 	ldbu	r2,-31384(gp)
                bDcRunning = FALSE;        
   2321c:	d0215b85 	stb	zero,-31378(gp)
        else if(bSmSyncSequenceValid)
   23220:	1000211e 	bne	r2,zero,232a8 <DC_CheckWatchdog+0xb4>
   23224:	f800283a 	ret
                Sync0WdCounter ++;
   23228:	10800044 	addi	r2,r2,1
   2322c:	d0a1588d 	sth	r2,-31390(gp)
            if(Sync1WdValue > 0)
   23230:	d0e1570b 	ldhu	r3,-31396(gp)
            bDcRunning = TRUE;
   23234:	00800044 	movi	r2,1
   23238:	d0a15b85 	stb	r2,-31378(gp)
            if(Sync1WdValue > 0)
   2323c:	18000526 	beq	r3,zero,23254 <DC_CheckWatchdog+0x60>
                if(Sync1WdCounter < Sync1WdValue)
   23240:	d0a1578b 	ldhu	r2,-31394(gp)
   23244:	113fffcc 	andi	r4,r2,65535
   23248:	20fff32e 	bgeu	r4,r3,23218 <DC_CheckWatchdog+0x24>
                    Sync1WdCounter ++;
   2324c:	10800044 	addi	r2,r2,1
   23250:	d0a1578d 	sth	r2,-31394(gp)
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
   23254:	008000f4 	movhi	r2,3
   23258:	10a0060b 	ldhu	r2,-32744(r2)
   2325c:	10000326 	beq	r2,zero,2326c <DC_CheckWatchdog+0x78>
   23260:	00c000f4 	movhi	r3,3
   23264:	18e1f50b 	ldhu	r3,-30764(r3)
   23268:	1880082e 	bgeu	r3,r2,2328c <DC_CheckWatchdog+0x98>
                bSmSyncSequenceValid = TRUE;
   2326c:	00800044 	movi	r2,1
   23270:	d0a15a05 	stb	r2,-31384(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23274:	d0a1598f 	ldh	r2,-31386(gp)
   23278:	00800d0e 	bge	zero,r2,232b0 <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt++;
   2327c:	d0a1590b 	ldhu	r2,-31388(gp)
   23280:	10800044 	addi	r2,r2,1
   23284:	d0a1590d 	sth	r2,-31388(gp)
   23288:	f800283a 	ret
            else if (bSmSyncSequenceValid)
   2328c:	d0a15a03 	ldbu	r2,-31384(gp)
   23290:	10000726 	beq	r2,zero,232b0 <DC_CheckWatchdog+0xbc>
                if (i16WaitForPllRunningTimeout > 0)
   23294:	d0a1598f 	ldh	r2,-31386(gp)
                    bSmSyncSequenceValid = FALSE;
   23298:	d0215a05 	stb	zero,-31384(gp)
                if (i16WaitForPllRunningTimeout > 0)
   2329c:	0080040e 	bge	zero,r2,232b0 <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt = 0;
   232a0:	d021590d 	sth	zero,-31388(gp)
   232a4:	f800283a 	ret
        {
           bSmSyncSequenceValid = FALSE;
   232a8:	d0215a05 	stb	zero,-31384(gp)
        }
    }
}
   232ac:	f800283a 	ret
   232b0:	f800283a 	ret

000232b4 <CheckIfEcatError>:
*////////////////////////////////////////////////////////////////////////////////////////
void CheckIfEcatError(void)
{
   /*if the watchdog is enabled check the process data watchdog in the ESC
   and set the AL status code 0x1B if the watchdog expired*/
   if (EcatWdValue != 0)
   232b4:	d0a1500b 	ldhu	r2,-31424(gp)
   232b8:	10002626 	beq	r2,zero,23354 <CheckIfEcatError+0xa0>
{
   232bc:	defffe04 	addi	sp,sp,-8
   {
      /*watchdog time is set => watchdog is active*/
      UINT16 WdStatusOK = 0;

      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   232c0:	01800084 	movi	r6,2
   232c4:	01411004 	movi	r5,1088
   232c8:	d9000084 	addi	r4,sp,2
{
   232cc:	dfc00115 	stw	ra,4(sp)
      UINT16 WdStatusOK = 0;
   232d0:	d800008d 	sth	zero,2(sp)
      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   232d4:	00207740 	call	20774 <HW_EscRead>
      WdStatusOK = SWAPWORD(WdStatusOK);

      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
   232d8:	d880008b 	ldhu	r2,2(sp)
   232dc:	1080004c 	andi	r2,r2,1
   232e0:	10000d1e 	bne	r2,zero,23318 <CheckIfEcatError+0x64>
   232e4:	d0a1520b 	ldhu	r2,-31416(gp)
   232e8:	10000b26 	beq	r2,zero,23318 <CheckIfEcatError+0x64>
      {
         /*The device is in OP state*/

         if (bEcatOutputUpdateRunning
   232ec:	d0a15d83 	ldbu	r2,-31370(gp)
   232f0:	10000826 	beq	r2,zero,23314 <CheckIfEcatError+0x60>
            && bEcatFirstOutputsReceived
   232f4:	d0a15d03 	ldbu	r2,-31372(gp)
   232f8:	10000626 	beq	r2,zero,23314 <CheckIfEcatError+0x60>
            )
         {
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
   232fc:	014006c4 	movi	r5,27
   23300:	01000104 	movi	r4,4
   23304:	00226d00 	call	226d0 <AL_ControlInd>
               return;
           }
        
       }
   }
}
   23308:	dfc00117 	ldw	ra,4(sp)
   2330c:	dec00204 	addi	sp,sp,8
   23310:	f800283a 	ret
            bEcatFirstOutputsReceived = FALSE;
   23314:	d0215d05 	stb	zero,-31372(gp)
   if(bDcSyncActive)
   23318:	d0a15c83 	ldbu	r2,-31374(gp)
   2331c:	103ffa26 	beq	r2,zero,23308 <CheckIfEcatError+0x54>
       if(bEcatOutputUpdateRunning)
   23320:	d0a15d83 	ldbu	r2,-31370(gp)
   23324:	103ff826 	beq	r2,zero,23308 <CheckIfEcatError+0x54>
           if(!bDcRunning)
   23328:	d0a15b83 	ldbu	r2,-31378(gp)
   2332c:	1000051e 	bne	r2,zero,23344 <CheckIfEcatError+0x90>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   23330:	01400b04 	movi	r5,44
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   23334:	01000104 	movi	r4,4
}
   23338:	dfc00117 	ldw	ra,4(sp)
   2333c:	dec00204 	addi	sp,sp,8
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   23340:	00226d01 	jmpi	226d0 <AL_ControlInd>
           else if(!bSmSyncSequenceValid)
   23344:	d0a15a03 	ldbu	r2,-31384(gp)
   23348:	103fef1e 	bne	r2,zero,23308 <CheckIfEcatError+0x54>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   2334c:	01400684 	movi	r5,26
   23350:	003ff806 	br	23334 <CheckIfEcatError+0x80>
   if(bDcSyncActive)
   23354:	d0a15c83 	ldbu	r2,-31374(gp)
   23358:	10000b26 	beq	r2,zero,23388 <CheckIfEcatError+0xd4>
       if(bEcatOutputUpdateRunning)
   2335c:	d0a15d83 	ldbu	r2,-31370(gp)
   23360:	10000926 	beq	r2,zero,23388 <CheckIfEcatError+0xd4>
           if(!bDcRunning)
   23364:	d0a15b83 	ldbu	r2,-31378(gp)
   23368:	1000031e 	bne	r2,zero,23378 <CheckIfEcatError+0xc4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   2336c:	01400b04 	movi	r5,44
   23370:	01000104 	movi	r4,4
   23374:	003ff206 	br	23340 <CheckIfEcatError+0x8c>
           else if(!bSmSyncSequenceValid)
   23378:	d0a15a03 	ldbu	r2,-31384(gp)
   2337c:	1000021e 	bne	r2,zero,23388 <CheckIfEcatError+0xd4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   23380:	01400684 	movi	r5,26
   23384:	003ffa06 	br	23370 <CheckIfEcatError+0xbc>
   23388:	f800283a 	ret

0002338c <ECAT_StateChange>:
 \brief    This function changes the state of the EtherCAT slave if the requested state
             is lower than the actual state, otherwise the error condition will be reset.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
{
   2338c:	defffe04 	addi	sp,sp,-8
   23390:	dc000015 	stw	r16,0(sp)
   23394:	dfc00115 	stw	ra,4(sp)
    UINT8 Status = alStatus;

    /*ECATCHANGE_START(V5.13) ESM1*/
    /*return in case of invalid parameters*/
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23398:	2c3fffcc 	andi	r16,r5,65535
   2339c:	8000201e 	bne	r16,zero,23420 <ECAT_StateChange+0x94>
    {
        return;
    }

    /* call the application requested state transition only once*/
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   233a0:	d0a15383 	ldbu	r2,-31410(gp)
   233a4:	10000a1e 	bne	r2,zero,233d0 <ECAT_StateChange+0x44>
   233a8:	d0a15403 	ldbu	r2,-31408(gp)
   233ac:	21003fcc 	andi	r4,r4,255
   233b0:	2080021e 	bne	r4,r2,233bc <ECAT_StateChange+0x30>
   233b4:	d0a1548b 	ldhu	r2,-31406(gp)
   233b8:	10002526 	beq	r2,zero,23450 <ECAT_StateChange+0xc4>
               /* no error pending and the target state is lower than the current one*/
                AL_ControlInd(alStatus, alStatusCode);
            }
        }
        /*ECATCHANGE_START(V5.13) ESM1*/
        else if (u8LocalErrorState != 0)
   233bc:	d0a15403 	ldbu	r2,-31408(gp)
   233c0:	10002326 	beq	r2,zero,23450 <ECAT_StateChange+0xc4>
                u8LocalErrorState = 0;
   233c4:	d0215405 	stb	zero,-31408(gp)
                u16LocalErrorCode = alStatusCode;
   233c8:	d021548d 	sth	zero,-31406(gp)
   233cc:	00002006 	br	23450 <ECAT_StateChange+0xc4>
        if(bApplEsmPending)
   233d0:	d0a153c3 	ldbu	r2,-31409(gp)
   233d4:	103ffb1e 	bne	r2,zero,233c4 <ECAT_StateChange+0x38>
                switch(nEcatStateTrans)
   233d8:	d0a1530b 	ldhu	r2,-31412(gp)
   233dc:	10ffffcc 	andi	r3,r2,65535
   233e0:	19000920 	cmpeqi	r4,r3,36
   233e4:	20004b1e 	bne	r4,zero,23514 <ECAT_StateChange+0x188>
   233e8:	19000968 	cmpgeui	r4,r3,37
   233ec:	2000411e 	bne	r4,zero,234f4 <ECAT_StateChange+0x168>
   233f0:	10bffb84 	addi	r2,r2,-18
   233f4:	10bfffcc 	andi	r2,r2,65535
   233f8:	108000a8 	cmpgeui	r2,r2,2
   233fc:	10004226 	beq	r2,zero,23508 <ECAT_StateChange+0x17c>
                else if (u8LocalErrorState != 0)
   23400:	d0a15403 	ldbu	r2,-31408(gp)
                bEcatWaitForAlControlRes = FALSE;
   23404:	d0215385 	stb	zero,-31410(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   23408:	d121530b 	ldhu	r4,-31412(gp)
                else if (u8LocalErrorState != 0)
   2340c:	10000226 	beq	r2,zero,23418 <ECAT_StateChange+0x8c>
                    u8LocalErrorState = 0;
   23410:	d0215405 	stb	zero,-31408(gp)
                    u16LocalErrorCode = 0x00;
   23414:	d021548d 	sth	zero,-31406(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   23418:	210003cc 	andi	r4,r4,15
   2341c:	00002406 	br	234b0 <ECAT_StateChange+0x124>
   23420:	208003cc 	andi	r2,r4,15
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23424:	00c04584 	movi	r3,278
   23428:	1886d83a 	srl	r3,r3,r2
   2342c:	18c0004c 	andi	r3,r3,1
   23430:	18000726 	beq	r3,zero,23450 <ECAT_StateChange+0xc4>
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   23434:	d0e15383 	ldbu	r3,-31410(gp)
   23438:	1800091e 	bne	r3,zero,23460 <ECAT_StateChange+0xd4>
   2343c:	d0e15403 	ldbu	r3,-31408(gp)
   23440:	21003fcc 	andi	r4,r4,255
   23444:	1900381e 	bne	r3,r4,23528 <ECAT_StateChange+0x19c>
   23448:	d0e1548b 	ldhu	r3,-31406(gp)
   2344c:	80c0361e 	bne	r16,r3,23528 <ECAT_StateChange+0x19c>
            u8LocalErrorState = 0;
            u16LocalErrorCode = 0x00;
        }
        /*ECATCHANGE_END(V5.13) ESM1*/
    }
}
   23450:	dfc00117 	ldw	ra,4(sp)
   23454:	dc000017 	ldw	r16,0(sp)
   23458:	dec00204 	addi	sp,sp,8
   2345c:	f800283a 	ret
        if(bApplEsmPending)
   23460:	d0e153c3 	ldbu	r3,-31409(gp)
                u8LocalErrorState = (alStatus & STATE_MASK);
   23464:	d0a15405 	stb	r2,-31408(gp)
                u16LocalErrorCode = alStatusCode;
   23468:	d161548d 	sth	r5,-31406(gp)
        if(bApplEsmPending)
   2346c:	18000226 	beq	r3,zero,23478 <ECAT_StateChange+0xec>
                EsmTimeoutCounter = 0;
   23470:	d0215c0d 	sth	zero,-31376(gp)
   23474:	003ff606 	br	23450 <ECAT_StateChange+0xc4>
                switch(nEcatStateTrans)
   23478:	d0a1530b 	ldhu	r2,-31412(gp)
   2347c:	10ffffcc 	andi	r3,r2,65535
   23480:	19000920 	cmpeqi	r4,r3,36
   23484:	2000181e 	bne	r4,zero,234e8 <ECAT_StateChange+0x15c>
   23488:	19000968 	cmpgeui	r4,r3,37
   2348c:	20000e1e 	bne	r4,zero,234c8 <ECAT_StateChange+0x13c>
   23490:	10bffb84 	addi	r2,r2,-18
   23494:	10bfffcc 	andi	r2,r2,65535
   23498:	108000a8 	cmpgeui	r2,r2,2
   2349c:	10000f26 	beq	r2,zero,234dc <ECAT_StateChange+0x150>
                Status =  (UINT8)(nEcatStateTrans >> 4);
   234a0:	d121530b 	ldhu	r4,-31412(gp)
                bEcatWaitForAlControlRes = FALSE;
   234a4:	d0215385 	stb	zero,-31410(gp)
                Status =  (UINT8)(nEcatStateTrans >> 4);
   234a8:	2008d13a 	srli	r4,r4,4
                    Status |= STATE_CHANGE;
   234ac:	21000414 	ori	r4,r4,16
                SetALStatus(Status,alStatusCode);
   234b0:	800b883a 	mov	r5,r16
   234b4:	21003fcc 	andi	r4,r4,255
}
   234b8:	dfc00117 	ldw	ra,4(sp)
   234bc:	dc000017 	ldw	r16,0(sp)
   234c0:	dec00204 	addi	sp,sp,8
                SetALStatus(Status,alStatusCode);
   234c4:	002262c1 	jmpi	2262c <SetALStatus>
                switch(nEcatStateTrans)
   234c8:	18c01220 	cmpeqi	r3,r3,72
   234cc:	183ff426 	beq	r3,zero,234a0 <ECAT_StateChange+0x114>
                          APPL_StopOutputHandler();
   234d0:	00202280 	call	20228 <APPL_StopOutputHandler>
                          StopOutputHandler();
   234d4:	00225780 	call	22578 <StopOutputHandler>
                    break;
   234d8:	003ff106 	br	234a0 <ECAT_StateChange+0x114>
                          APPL_StopMailboxHandler();
   234dc:	00202080 	call	20208 <APPL_StopMailboxHandler>
                          MBX_StopMailboxHandler();
   234e0:	0023a100 	call	23a10 <MBX_StopMailboxHandler>
                    break;
   234e4:	003fee06 	br	234a0 <ECAT_StateChange+0x114>
                          APPL_StopInputHandler();
   234e8:	00202180 	call	20218 <APPL_StopInputHandler>
                          StopInputHandler();
   234ec:	00225840 	call	22584 <StopInputHandler>
                    break;
   234f0:	003feb06 	br	234a0 <ECAT_StateChange+0x114>
                switch(nEcatStateTrans)
   234f4:	18c01220 	cmpeqi	r3,r3,72
   234f8:	183fc126 	beq	r3,zero,23400 <ECAT_StateChange+0x74>
                          bEcatOutputUpdateRunning = TRUE;
   234fc:	00800044 	movi	r2,1
   23500:	d0a15d85 	stb	r2,-31370(gp)
                    break;
   23504:	003fbe06 	br	23400 <ECAT_StateChange+0x74>
                        bMbxRunning = TRUE;
   23508:	00800044 	movi	r2,1
   2350c:	d0a16645 	stb	r2,-31335(gp)
                    break;
   23510:	003fbb06 	br	23400 <ECAT_StateChange+0x74>
                        SetALEventMask(u16ALEventMask);
   23514:	d1214e8b 	ldhu	r4,-31430(gp)
   23518:	00219fc0 	call	219fc <SetALEventMask>
                        bEcatInputUpdateRunning = TRUE;
   2351c:	00800044 	movi	r2,1
   23520:	d0a15d45 	stb	r2,-31371(gp)
                    break;
   23524:	003fb606 	br	23400 <ECAT_StateChange+0x74>
        if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
   23528:	10c00220 	cmpeqi	r3,r2,8
   2352c:	11803fcc 	andi	r6,r2,255
   23530:	183fa21e 	bne	r3,zero,233bc <ECAT_StateChange+0x30>
   23534:	00c00584 	movi	r3,22
   23538:	1986d83a 	srl	r3,r3,r6
   2353c:	18c0004c 	andi	r3,r3,1
   23540:	183f9e26 	beq	r3,zero,233bc <ECAT_StateChange+0x30>
            u8LocalErrorState = (alStatus & STATE_MASK);
   23544:	d0a15405 	stb	r2,-31408(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   23548:	d0a150c3 	ldbu	r2,-31421(gp)
            u16LocalErrorCode = alStatusCode;
   2354c:	d161548d 	sth	r5,-31406(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   23550:	108003cc 	andi	r2,r2,15
   23554:	10800218 	cmpnei	r2,r2,8
   23558:	103fbd1e 	bne	r2,zero,23450 <ECAT_StateChange+0xc4>
                AL_ControlInd(alStatus, alStatusCode);
   2355c:	800b883a 	mov	r5,r16
}
   23560:	dfc00117 	ldw	ra,4(sp)
   23564:	dc000017 	ldw	r16,0(sp)
   23568:	dec00204 	addi	sp,sp,8
                AL_ControlInd(alStatus, alStatusCode);
   2356c:	00226d01 	jmpi	226d0 <AL_ControlInd>

00023570 <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
   23570:	defffe04 	addi	sp,sp,-8
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23574:	01800044 	movi	r6,1
   23578:	01400144 	movi	r5,5
   2357c:	d1215184 	addi	r4,gp,-31418
{
   23580:	dfc00115 	stw	ra,4(sp)
   23584:	dc000015 	stw	r16,0(sp)
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23588:	00207740 	call	20774 <HW_EscRead>

    HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
   2358c:	01800084 	movi	r6,2
   23590:	01400184 	movi	r5,6
   23594:	d1215104 	addi	r4,gp,-31420
   23598:	00207740 	call	20774 <HW_EscRead>
    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   2359c:	d0a1510b 	ldhu	r2,-31420(gp)

/*ECATCHANGE_START(V5.13) ECAT2*/
    u16IdValue = 0;
   235a0:	d0214e0d 	sth	zero,-31432(gp)

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
   235a4:	0021883a 	mov	r16,zero
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   235a8:	100492ba 	slli	r2,r2,10
   235ac:	1083ffc4 	addi	r2,r2,4095
   235b0:	d0a1510d 	sth	r2,-31420(gp)
    UpdateEEPROMLoadedState();
   235b4:	0021a480 	call	21a48 <UpdateEEPROMLoadedState>
    for (i = 0; i < nMaxSyncMan; i++)
   235b8:	d0a15183 	ldbu	r2,-31418(gp)
   235bc:	81003fcc 	andi	r4,r16,255
   235c0:	20802036 	bltu	r4,r2,23644 <ECAT_Init+0xd4>
    {
        DisableSyncManChannel(i);
    }

    /* initialize the mailbox handler */
    MBX_Init();
   235c4:	002388c0 	call	2388c <MBX_Init>
    u16ALEventMask = 0;
    nPdOutputSize = 0;
    nPdInputSize = 0;

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
   235c8:	00800044 	movi	r2,1
    SetALStatus(nAlStatus, 0);
   235cc:	000b883a 	mov	r5,zero
   235d0:	01000044 	movi	r4,1
    nAlStatus    = STATE_INIT;
   235d4:	d0a150c5 	stb	r2,-31421(gp)
    bApplEsmPending = FALSE;
   235d8:	d02153c5 	stb	zero,-31409(gp)
    bEcatWaitForAlControlRes = FALSE;
   235dc:	d0215385 	stb	zero,-31410(gp)
    bEcatFirstOutputsReceived = FALSE;
   235e0:	d0215d05 	stb	zero,-31372(gp)
     bEcatOutputUpdateRunning = FALSE;
   235e4:	d0215d85 	stb	zero,-31370(gp)
     bEcatInputUpdateRunning = FALSE;
   235e8:	d0215d45 	stb	zero,-31371(gp)
     bExplicitDevIdRequested = FALSE;
   235ec:	d0215085 	stb	zero,-31422(gp)
    bWdTrigger = FALSE;
   235f0:	d0215cc5 	stb	zero,-31373(gp)
    EcatWdValue = 0;
   235f4:	d021500d 	sth	zero,-31424(gp)
    Sync0WdCounter = 0;
   235f8:	d021588d 	sth	zero,-31390(gp)
    Sync0WdValue = 0;
   235fc:	d021580d 	sth	zero,-31392(gp)
    Sync1WdCounter = 0;
   23600:	d021578d 	sth	zero,-31394(gp)
    Sync1WdValue = 0;
   23604:	d021570d 	sth	zero,-31396(gp)
    bDcSyncActive = FALSE;
   23608:	d0215c85 	stb	zero,-31374(gp)
    u8LocalErrorState = 0;
   2360c:	d0215405 	stb	zero,-31408(gp)
    u16LocalErrorCode = 0x00;
   23610:	d021548d 	sth	zero,-31406(gp)
    u16ALEventMask = 0;
   23614:	d0214e8d 	sth	zero,-31430(gp)
    nPdOutputSize = 0;
   23618:	d021520d 	sth	zero,-31416(gp)
    nPdInputSize = 0;
   2361c:	d021528d 	sth	zero,-31414(gp)
    SetALStatus(nAlStatus, 0);
   23620:	002262c0 	call	2262c <SetALStatus>
    nEcatStateTrans = 0;
   23624:	d021530d 	sth	zero,-31412(gp)

    bEscIntEnabled = FALSE;
   23628:	d0215545 	stb	zero,-31403(gp)

    /* initialize the COE part */
    COE_Init();
   2362c:	00218f40 	call	218f4 <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
   23630:	0009883a 	mov	r4,zero
}
   23634:	dfc00117 	ldw	ra,4(sp)
   23638:	dc000017 	ldw	r16,0(sp)
   2363c:	dec00204 	addi	sp,sp,8
    ResetALEventMask(0);
   23640:	00219b01 	jmpi	219b0 <ResetALEventMask>
        DisableSyncManChannel(i);
   23644:	0021ab00 	call	21ab0 <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
   23648:	84000044 	addi	r16,r16,1
   2364c:	003fda06 	br	235b8 <ECAT_Init+0x48>

00023650 <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
   23650:	defffc04 	addi	sp,sp,-16
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
/*ECATCHANGE_START(V5.13) MBX1*/
    UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
   23654:	00800044 	movi	r2,1
   23658:	d8800005 	stb	r2,0(sp)
{
   2365c:	dfc00315 	stw	ra,12(sp)
   23660:	dc400215 	stw	r17,8(sp)
   23664:	dc000115 	stw	r16,4(sp)
    UINT16 EscAlControl = 0x0000;
   23668:	d800008d 	sth	zero,2(sp)
    UINT8 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
   2366c:	d8000045 	stb	zero,1(sp)
/*ECATCHANGE_END(V5.13) MBX1*/


    /* check if services are stored in the mailbox */
    MBX_Main();
   23670:	00240800 	call	24080 <MBX_Main>


    if ( bMbxRunning )
   23674:	d0a16643 	ldbu	r2,-31335(gp)
   23678:	10000826 	beq	r2,zero,2369c <ECAT_Main+0x4c>
    {
        /* Slave is at least in PREOP, Mailbox is running */

/*ECATCHANGE_START(V5.13) MBX1*/
        /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
        HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
   2367c:	01800044 	movi	r6,1
   23680:	01420384 	movi	r5,2062
   23684:	d809883a 	mov	r4,sp
   23688:	00207740 	call	20774 <HW_EscRead>

        HW_EscReadByte(sm1Status, (ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   2368c:	01800044 	movi	r6,1
   23690:	01420344 	movi	r5,2061
   23694:	d9000044 	addi	r4,sp,1
   23698:	00207740 	call	20774 <HW_EscRead>
/*ECATCHANGE_END(V5.13) MBX1*/
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
   2369c:	00207ac0 	call	207ac <HW_GetALEventRegister>
   236a0:	1021883a 	mov	r16,r2
    ALEventReg = SWAPWORD(ALEventReg);


    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
   236a4:	8080004c 	andi	r2,r16,1
   236a8:	10001526 	beq	r2,zero,23700 <ECAT_Main+0xb0>
   236ac:	d4615383 	ldbu	r17,-31410(gp)
   236b0:	88803fcc 	andi	r2,r17,255
   236b4:	1000121e 	bne	r2,zero,23700 <ECAT_Main+0xb0>
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */

        HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
   236b8:	01800044 	movi	r6,1
   236bc:	01404804 	movi	r5,288
   236c0:	d9000084 	addi	r4,sp,2
   236c4:	00207740 	call	20774 <HW_EscRead>
        EscAlControl = SWAPWORD(EscAlControl);


            /*ECATCHANGE_START(V5.13) ECAT2*/
                /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
            if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
   236c8:	d880008b 	ldhu	r2,2(sp)
   236cc:	1080080c 	andi	r2,r2,32
   236d0:	10000526 	beq	r2,zero,236e8 <ECAT_Main+0x98>
            {
                if (bExplicitDevIdRequested == FALSE)
   236d4:	d0a15083 	ldbu	r2,-31422(gp)
   236d8:	1000021e 	bne	r2,zero,236e4 <ECAT_Main+0x94>
                {
                    u16IdValue = APPL_GetDeviceID();
   236dc:	00204b00 	call	204b0 <APPL_GetDeviceID>
   236e0:	d0a14e0d 	sth	r2,-31432(gp)
                }

                bExplicitDevIdRequested = TRUE;
   236e4:	04400044 	movi	r17,1

        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));

            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   236e8:	d9000083 	ldbu	r4,2(sp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   236ec:	00bffb84 	movi	r2,-18
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   236f0:	000b883a 	mov	r5,zero
                bExplicitDevIdRequested = TRUE;
   236f4:	d4615085 	stb	r17,-31422(gp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   236f8:	1420703a 	and	r16,r2,r16
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   236fc:	00226d00 	call	226d0 <AL_ControlInd>

            /* SM-Change-Event was handled too */

    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   23700:	8400040c 	andi	r16,r16,16
   23704:	d0a15383 	ldbu	r2,-31410(gp)
   23708:	80002e26 	beq	r16,zero,237c4 <ECAT_Main+0x174>
   2370c:	10803fcc 	andi	r2,r2,255
   23710:	10002326 	beq	r2,zero,237a0 <ECAT_Main+0x150>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
    }

    if(bEcatWaitForAlControlRes)
    {
        AL_ControlRes();
   23714:	0022eec0 	call	22eec <AL_ControlRes>
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
   23718:	d0a16643 	ldbu	r2,-31335(gp)
   2371c:	10001b26 	beq	r2,zero,2378c <ECAT_Main+0x13c>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
            if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
   23720:	d8800003 	ldbu	r2,0(sp)
   23724:	1080004c 	andi	r2,r2,1
   23728:	1000041e 	bne	r2,zero,2373c <ECAT_Main+0xec>
            {
                AL_ControlInd(nAlStatus & STATE_MASK, 0);
   2372c:	d12150c3 	ldbu	r4,-31421(gp)
   23730:	000b883a 	mov	r5,zero
   23734:	210003cc 	andi	r4,r4,15
   23738:	00226d00 	call	226d0 <AL_ControlInd>
            }

/*ECATCHANGE_START(V5.13) MBX1*/
        if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
   2373c:	d8800043 	ldbu	r2,1(sp)
   23740:	1080020c 	andi	r2,r2,8
   23744:	1000081e 	bne	r2,zero,23768 <ECAT_Main+0x118>
            && bSendMbxIsFull) 
   23748:	d0a16683 	ldbu	r2,-31334(gp)
   2374c:	10000626 	beq	r2,zero,23768 <ECAT_Main+0x118>
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u8dummy = 0;
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   23750:	d161640b 	ldhu	r5,-31344(gp)
   23754:	01800044 	movi	r6,1
   23758:	d1214dc4 	addi	r4,gp,-31433
            u8dummy = 0;
   2375c:	d0214dc5 	stb	zero,-31433(gp)
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   23760:	00207f80 	call	207f8 <HW_EscWrite>

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
            MBX_MailboxReadInd();
   23764:	0023c840 	call	23c84 <MBX_MailboxReadInd>
        }

            /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

            if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
   23768:	d8800003 	ldbu	r2,0(sp)
   2376c:	d0e16603 	ldbu	r3,-31336(gp)
   23770:	1080008c 	andi	r2,r2,2
   23774:	10001626 	beq	r2,zero,237d0 <ECAT_Main+0x180>
   23778:	18001626 	beq	r3,zero,237d4 <ECAT_Main+0x184>
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
            }


        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
   2377c:	00207ac0 	call	207ac <HW_GetALEventRegister>
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
   23780:	1080400c 	andi	r2,r2,256
   23784:	10000126 	beq	r2,zero,2378c <ECAT_Main+0x13c>
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
            MBX_CheckAndCopyMailbox();
   23788:	0023f4c0 	call	23f4c <MBX_CheckAndCopyMailbox>

        }
    }
}
   2378c:	dfc00317 	ldw	ra,12(sp)
   23790:	dc400217 	ldw	r17,8(sp)
   23794:	dc000117 	ldw	r16,4(sp)
   23798:	dec00404 	addi	sp,sp,16
   2379c:	f800283a 	ret
    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   237a0:	d12150c3 	ldbu	r4,-31421(gp)
   237a4:	2080040c 	andi	r2,r4,16
   237a8:	103fdb1e 	bne	r2,zero,23718 <ECAT_Main+0xc8>
   237ac:	20803bcc 	andi	r2,r4,239
   237b0:	10800060 	cmpeqi	r2,r2,1
   237b4:	103fd81e 	bne	r2,zero,23718 <ECAT_Main+0xc8>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
   237b8:	000b883a 	mov	r5,zero
   237bc:	210003cc 	andi	r4,r4,15
   237c0:	00226d00 	call	226d0 <AL_ControlInd>
    if(bEcatWaitForAlControlRes)
   237c4:	d0a15383 	ldbu	r2,-31410(gp)
   237c8:	103fd326 	beq	r2,zero,23718 <ECAT_Main+0xc8>
   237cc:	003fd106 	br	23714 <ECAT_Main+0xc4>
                || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
   237d0:	183fea26 	beq	r3,zero,2377c <ECAT_Main+0x12c>
                MBX_MailboxRepeatReq();
   237d4:	0023d240 	call	23d24 <MBX_MailboxRepeatReq>
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   237d8:	d8800003 	ldbu	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   237dc:	01800044 	movi	r6,1
   237e0:	014203c4 	movi	r5,2063
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   237e4:	1080008c 	andi	r2,r2,2
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   237e8:	d809883a 	mov	r4,sp
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   237ec:	d8800005 	stb	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   237f0:	00207f80 	call	207f8 <HW_EscWrite>
   237f4:	003fe106 	br	2377c <ECAT_Main+0x12c>

000237f8 <PutInMbxQueue>:
{
    UINT16 lastInQueue;
    ENTER_MBX_CRITICAL;


    lastInQueue = pQueue->lastInQueue+1;
   237f8:	2880008b 	ldhu	r2,2(r5)
    if (lastInQueue == pQueue->maxQueueSize)
   237fc:	29c0010b 	ldhu	r7,4(r5)
    lastInQueue = pQueue->lastInQueue+1;
   23800:	10c00044 	addi	r3,r2,1
   23804:	180d883a 	mov	r6,r3
    if (lastInQueue == pQueue->maxQueueSize)
   23808:	18ffffcc 	andi	r3,r3,65535
   2380c:	38c0011e 	bne	r7,r3,23814 <PutInMbxQueue+0x1c>
    {
        // Umbruch der Queue
        lastInQueue = 0;
   23810:	000d883a 	mov	r6,zero
    }

    if (pQueue->firstInQueue == lastInQueue)
   23814:	29c0000b 	ldhu	r7,0(r5)
   23818:	30ffffcc 	andi	r3,r6,65535
   2381c:	38c00826 	beq	r7,r3,23840 <PutInMbxQueue+0x48>
        // Ueberlauf der Queue -> letztes Element wieder herausnehmen
        LEAVE_MBX_CRITICAL;
        return MBXERR_NOMOREMEMORY;
    }

    pQueue->queue[pQueue->lastInQueue] = pMbx;
   23820:	10bfffcc 	andi	r2,r2,65535
   23824:	10800084 	addi	r2,r2,2
   23828:	100490ba 	slli	r2,r2,2
   2382c:	2885883a 	add	r2,r5,r2
   23830:	11000015 	stw	r4,0(r2)
    pQueue->lastInQueue = lastInQueue;
   23834:	2980008d 	sth	r6,2(r5)

    LEAVE_MBX_CRITICAL;

    return 0;
   23838:	0005883a 	mov	r2,zero
   2383c:	f800283a 	ret
        return MBXERR_NOMOREMEMORY;
   23840:	008001c4 	movi	r2,7
}
   23844:	f800283a 	ret

00023848 <GetOutOfMbxQueue>:
TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
   23848:	20c0000b 	ldhu	r3,0(r4)
   2384c:	2140008b 	ldhu	r5,2(r4)
   23850:	18bfffcc 	andi	r2,r3,65535
   23854:	11400b26 	beq	r2,r5,23884 <GetOutOfMbxQueue+0x3c>
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
        pMbx = pQueue->queue[firstInQueue];
   23858:	10800084 	addi	r2,r2,2
   2385c:	100490ba 	slli	r2,r2,2
        firstInQueue++;
        pQueue->firstInQueue = firstInQueue;
        
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23860:	2140010b 	ldhu	r5,4(r4)
        firstInQueue++;
   23864:	18c00044 	addi	r3,r3,1
        pMbx = pQueue->queue[firstInQueue];
   23868:	2085883a 	add	r2,r4,r2
   2386c:	10800017 	ldw	r2,0(r2)
        pQueue->firstInQueue = firstInQueue;
   23870:	20c0000d 	sth	r3,0(r4)
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23874:	18ffffcc 	andi	r3,r3,65535
   23878:	28c0031e 	bne	r5,r3,23888 <GetOutOfMbxQueue+0x40>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
   2387c:	2000000d 	sth	zero,0(r4)
   23880:	f800283a 	ret
        }
    }
    else
    {
        pMbx = 0;
   23884:	0005883a 	mov	r2,zero


    LEAVE_MBX_CRITICAL;

    return pMbx;
}
   23888:	f800283a 	ret

0002388c <MBX_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
   2388c:	00800904 	movi	r2,36
   23890:	d0a1650d 	sth	r2,-31340(gp)
    u16SendMbxSize = MAX_MBX_SIZE;
   23894:	00802004 	movi	r2,128
   23898:	d0a1658d 	sth	r2,-31338(gp)
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
   2389c:	00840004 	movi	r2,4096
   238a0:	d0a1648d 	sth	r2,-31342(gp)
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
   238a4:	d0a1640d 	sth	r2,-31344(gp)

    sMbxReceiveQueue.firstInQueue    = 0;
   238a8:	008000f4 	movhi	r2,3
   238ac:	1021c015 	stw	zero,-30976(r2)
    sMbxReceiveQueue.lastInQueue     = 0;
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   238b0:	00c000f4 	movhi	r3,3
   238b4:	00800284 	movi	r2,10
{
   238b8:	defffe04 	addi	sp,sp,-8
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   238bc:	18a1c10d 	sth	r2,-30972(r3)
    sMbxSendQueue.firstInQueue        = 0;
   238c0:	00c000f4 	movhi	r3,3

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238c4:	d90000c4 	addi	r4,sp,3
    sMbxSendQueue.firstInQueue        = 0;
   238c8:	1821cd15 	stw	zero,-30924(r3)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238cc:	01800044 	movi	r6,1
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   238d0:	00c000f4 	movhi	r3,3
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238d4:	014203c4 	movi	r5,2063
{
   238d8:	dfc00115 	stw	ra,4(sp)
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   238dc:	18a1ce0d 	sth	r2,-30920(r3)
        UINT8 sm1Activate = 0;
   238e0:	d80000c5 	stb	zero,3(sp)
    psWriteMbx  = NULL;
   238e4:	d0216215 	stw	zero,-31352(gp)
    psRepeatMbx = NULL;
   238e8:	d0216015 	stw	zero,-31360(gp)
    psReadMbx    = NULL;
   238ec:	d0216115 	stw	zero,-31356(gp)
    psStoreMbx    = NULL;
   238f0:	d0215f15 	stw	zero,-31364(gp)
    bMbxRepeatToggle    = FALSE;
   238f4:	d0216605 	stb	zero,-31336(gp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238f8:	00207740 	call	20774 <HW_EscRead>
        sm1Activate &= ~0x02;
   238fc:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23900:	01800044 	movi	r6,1
   23904:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23908:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   2390c:	d90000c4 	addi	r4,sp,3
        sm1Activate &= ~0x02;
   23910:	d88000c5 	stb	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23914:	00207f80 	call	207f8 <HW_EscWrite>
    }
    bMbxRunning = FALSE;
   23918:	d0216645 	stb	zero,-31335(gp)
    bSendMbxIsFull = FALSE;
   2391c:	d0216685 	stb	zero,-31334(gp)
    bReceiveMbxIsLocked = FALSE;
   23920:	d02166c5 	stb	zero,-31333(gp)
    u8MailboxSendReqStored    = 0;
   23924:	d0216305 	stb	zero,-31348(gp)
    u8MbxWriteCounter = 0;
   23928:	d0216385 	stb	zero,-31346(gp)
    u8MbxReadCounter    = 0;
   2392c:	d0216345 	stb	zero,-31347(gp)
}
   23930:	dfc00117 	ldw	ra,4(sp)
   23934:	dec00204 	addi	sp,sp,8
   23938:	f800283a 	ret

0002393c <MBX_StartMailboxHandler>:
 \brief     it is checked if the mailbox areas overlaps each other
 \brief     and the Sync Manager channels 0 and 1 are enabled.
 \brief     This function shall only be called if mailbox is supported.
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 MBX_StartMailboxHandler(void)
{
   2393c:	defffe04 	addi	sp,sp,-8
    UINT16 result = 0;
    
    /* get address of the receive mailbox sync manager (SM0) */
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   23940:	0009883a 	mov	r4,zero
{
   23944:	dfc00115 	stw	ra,4(sp)
   23948:	dc000015 	stw	r16,0(sp)
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   2394c:	0021a800 	call	21a80 <GetSyncMan>

    /* store size of the receive mailbox */
    u16ReceiveMbxSize     = pSyncMan->Length;
   23950:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the receive mailbox */
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23954:	1080000b 	ldhu	r2,0(r2)

    /* get address of the send mailbox sync manager (SM1) */
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23958:	01000044 	movi	r4,1
    u16ReceiveMbxSize     = pSyncMan->Length;
   2395c:	d0e1650d 	sth	r3,-31340(gp)
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23960:	d0a1648d 	sth	r2,-31342(gp)
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23964:	0021a800 	call	21a80 <GetSyncMan>

    /* store the size of the send mailbox */
    u16SendMbxSize = pSyncMan->Length;
   23968:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the send mailbox */
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;

    // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   2396c:	d161648b 	ldhu	r5,-31342(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23970:	1080000b 	ldhu	r2,0(r2)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23974:	d121650b 	ldhu	r4,-31340(gp)
    u16SendMbxSize = pSyncMan->Length;
   23978:	d0e1658d 	sth	r3,-31338(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   2397c:	d0a1640d 	sth	r2,-31344(gp)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23980:	2149883a 	add	r4,r4,r5
   23984:	10bfffcc 	andi	r2,r2,65535
   23988:	1100030e 	bge	r2,r4,23998 <MBX_StartMailboxHandler+0x5c>
   2398c:	18ffffcc 	andi	r3,r3,65535
   23990:	1887883a 	add	r3,r3,r2
   23994:	28c01c16 	blt	r5,r3,23a08 <MBX_StartMailboxHandler+0xcc>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
    }


    /* enable the receive mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_WRITE);
   23998:	0009883a 	mov	r4,zero
   2399c:	0021b100 	call	21b10 <EnableSyncManChannel>
    /* enable the send mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_READ);
   239a0:	01000044 	movi	r4,1
   239a4:	0021b100 	call	21b10 <EnableSyncManChannel>

        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   239a8:	d121650b 	ldhu	r4,-31340(gp)
   239ac:	0026bdc0 	call	26bdc <malloc>
   239b0:	d0a16215 	stw	r2,-31352(gp)
   239b4:	1009883a 	mov	r4,r2
        if(psWriteMbx == NULL)
   239b8:	10000e1e 	bne	r2,zero,239f4 <MBX_StartMailboxHandler+0xb8>
        {
            bNoMbxMemoryAvailable = TRUE;
   239bc:	00800044 	movi	r2,1

            //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   239c0:	01000284 	movi	r4,10
            bNoMbxMemoryAvailable = TRUE;
   239c4:	d0a15e05 	stb	r2,-31368(gp)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   239c8:	0026bdc0 	call	26bdc <malloc>
            if(psWriteMbx == NULL)
   239cc:	1021003a 	cmpeq	r16,r2,zero
   239d0:	8020907a 	slli	r16,r16,1
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   239d4:	1009883a 	mov	r4,r2
            {
                result = ALSTATUSCODE_NOMEMORY;
            }

            APPL_FreeMailboxBuffer(psWriteMbx);
   239d8:	0026bec0 	call	26bec <free>
            psWriteMbx = NULL;
   239dc:	d0216215 	stw	zero,-31352(gp)
            APPL_FreeMailboxBuffer(psWriteMbx);
            psWriteMbx = NULL;
        }

    return result;
}
   239e0:	8005883a 	mov	r2,r16
   239e4:	dfc00117 	ldw	ra,4(sp)
   239e8:	dc000017 	ldw	r16,0(sp)
   239ec:	dec00204 	addi	sp,sp,8
   239f0:	f800283a 	ret
            bNoMbxMemoryAvailable = FALSE;
   239f4:	d0215e05 	stb	zero,-31368(gp)
    UINT16 result = 0;
   239f8:	0021883a 	mov	r16,zero
            APPL_FreeMailboxBuffer(psWriteMbx);
   239fc:	0026bec0 	call	26bec <free>
            psWriteMbx = NULL;
   23a00:	d0216215 	stw	zero,-31352(gp)
   23a04:	003ff606 	br	239e0 <MBX_StartMailboxHandler+0xa4>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
   23a08:	04000584 	movi	r16,22
   23a0c:	003ff406 	br	239e0 <MBX_StartMailboxHandler+0xa4>

00023a10 <MBX_StopMailboxHandler>:
 \brief  local management service Stop Mailbox Handler
 \brief  the Sync Manager channels 0 and 1 are disabled
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_StopMailboxHandler(void)
{
   23a10:	defffd04 	addi	sp,sp,-12
    TMBX MBXMEM * pMbx;

    /* mailbox handler is stopped */
    bMbxRunning = FALSE;
    /* disable the receive mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_WRITE);
   23a14:	0009883a 	mov	r4,zero
{
   23a18:	dfc00215 	stw	ra,8(sp)
   23a1c:	dc000115 	stw	r16,4(sp)
    bMbxRunning = FALSE;
   23a20:	d0216645 	stb	zero,-31335(gp)
    DisableSyncManChannel(MAILBOX_WRITE);
   23a24:	0021ab00 	call	21ab0 <DisableSyncManChannel>
    /* disable the send mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_READ);
   23a28:	01000044 	movi	r4,1
   23a2c:	0021ab00 	call	21ab0 <DisableSyncManChannel>
    /* initialize variables again */


    if (psRepeatMbx != NULL)
   23a30:	d1216017 	ldw	r4,-31360(gp)
   23a34:	20000126 	beq	r4,zero,23a3c <MBX_StopMailboxHandler+0x2c>
    {
        APPL_FreeMailboxBuffer(psRepeatMbx);
   23a38:	0026bec0 	call	26bec <free>
    }

    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
   23a3c:	d1215f17 	ldw	r4,-31364(gp)
   23a40:	20000326 	beq	r4,zero,23a50 <MBX_StopMailboxHandler+0x40>
   23a44:	d0a16017 	ldw	r2,-31360(gp)
   23a48:	20800126 	beq	r4,r2,23a50 <MBX_StopMailboxHandler+0x40>
    {
        APPL_FreeMailboxBuffer(psStoreMbx);
   23a4c:	0026bec0 	call	26bec <free>
    }

    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
   23a50:	d1216117 	ldw	r4,-31356(gp)
   23a54:	20000526 	beq	r4,zero,23a6c <MBX_StopMailboxHandler+0x5c>
   23a58:	d0a16017 	ldw	r2,-31360(gp)
   23a5c:	20800326 	beq	r4,r2,23a6c <MBX_StopMailboxHandler+0x5c>
   23a60:	d0a15f17 	ldw	r2,-31364(gp)
   23a64:	20800126 	beq	r4,r2,23a6c <MBX_StopMailboxHandler+0x5c>
    {
        APPL_FreeMailboxBuffer(psReadMbx);
   23a68:	0026bec0 	call	26bec <free>
    }


    SDOS_ClearPendingResponse();
   23a6c:	00261d40 	call	261d4 <SDOS_ClearPendingResponse>

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a70:	01800044 	movi	r6,1
   23a74:	014203c4 	movi	r5,2063
   23a78:	d90000c4 	addi	r4,sp,3
    psWriteMbx = NULL;
   23a7c:	d0216215 	stw	zero,-31352(gp)
    psRepeatMbx = NULL;
   23a80:	d0216015 	stw	zero,-31360(gp)
    psReadMbx = NULL;
   23a84:	d0216115 	stw	zero,-31356(gp)
    psStoreMbx = NULL;
   23a88:	d0215f15 	stw	zero,-31364(gp)
    bMbxRepeatToggle    = FALSE;
   23a8c:	d0216605 	stb	zero,-31336(gp)
        UINT8 sm1Activate = 0;
   23a90:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a94:	00207740 	call	20774 <HW_EscRead>
        sm1Activate &= ~0x02;
   23a98:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a9c:	01800044 	movi	r6,1
   23aa0:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23aa4:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23aa8:	d90000c4 	addi	r4,sp,3
    u8MbxWriteCounter         = 0;
    u8MbxReadCounter        = 0;

    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23aac:	040000f4 	movhi	r16,3
        sm1Activate &= ~0x02;
   23ab0:	d88000c5 	stb	r2,3(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23ab4:	8421c004 	addi	r16,r16,-30976
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23ab8:	00207f80 	call	207f8 <HW_EscWrite>
    bSendMbxIsFull         = FALSE;
   23abc:	d0216685 	stb	zero,-31334(gp)
    bReceiveMbxIsLocked = FALSE;
   23ac0:	d02166c5 	stb	zero,-31333(gp)
    u8MailboxSendReqStored    = 0;
   23ac4:	d0216305 	stb	zero,-31348(gp)
    u8MbxWriteCounter         = 0;
   23ac8:	d0216385 	stb	zero,-31346(gp)
    u8MbxReadCounter        = 0;
   23acc:	d0216345 	stb	zero,-31347(gp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23ad0:	8009883a 	mov	r4,r16
   23ad4:	00238480 	call	23848 <GetOutOfMbxQueue>
   23ad8:	1009883a 	mov	r4,r2
        if (pMbx)
   23adc:	1000081e 	bne	r2,zero,23b00 <MBX_StopMailboxHandler+0xf0>
        }
    } while (pMbx != NULL);
    
    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23ae0:	040000f4 	movhi	r16,3
   23ae4:	8421cd04 	addi	r16,r16,-30924
   23ae8:	8009883a 	mov	r4,r16
   23aec:	00238480 	call	23848 <GetOutOfMbxQueue>
   23af0:	1009883a 	mov	r4,r2
        if (pMbx)
   23af4:	10000426 	beq	r2,zero,23b08 <MBX_StopMailboxHandler+0xf8>
        {
            APPL_FreeMailboxBuffer(pMbx);
   23af8:	0026bec0 	call	26bec <free>
        }
    } while (pMbx != NULL);
   23afc:	003ffa06 	br	23ae8 <MBX_StopMailboxHandler+0xd8>
            APPL_FreeMailboxBuffer(pMbx);
   23b00:	0026bec0 	call	26bec <free>
    } while (pMbx != NULL);
   23b04:	003ff206 	br	23ad0 <MBX_StopMailboxHandler+0xc0>

}
   23b08:	dfc00217 	ldw	ra,8(sp)
   23b0c:	dc000117 	ldw	r16,4(sp)
   23b10:	dec00304 	addi	sp,sp,12
   23b14:	f800283a 	ret

00023b18 <MailboxServiceInd>:
UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
{
    UINT8 result;


    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
   23b18:	2080010b 	ldhu	r2,4(r4)
   23b1c:	1005d23a 	srai	r2,r2,8
   23b20:	108003cc 	andi	r2,r2,15
   23b24:	108000d8 	cmpnei	r2,r2,3
   23b28:	1000011e 	bne	r2,zero,23b30 <MailboxServiceInd+0x18>
    {
    case MBX_TYPE_COE:
        /* CoE datagram received */
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
   23b2c:	00219001 	jmpi	21900 <COE_ServiceInd>
        result = MBXERR_UNSUPPORTEDPROTOCOL;
        break;
    }

    return result;
}
   23b30:	00800084 	movi	r2,2
   23b34:	f800283a 	ret

00023b38 <MBX_CopyToSendMailbox>:
 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23b38:	d0a150c3 	ldbu	r2,-31421(gp)
{
   23b3c:	defff804 	addi	sp,sp,-32
   23b40:	dfc00715 	stw	ra,28(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23b44:	108003cc 	andi	r2,r2,15
{
   23b48:	dd400615 	stw	r21,24(sp)
   23b4c:	dd000515 	stw	r20,20(sp)
   23b50:	dcc00415 	stw	r19,16(sp)
   23b54:	dc800315 	stw	r18,12(sp)
   23b58:	dc400215 	stw	r17,8(sp)
   23b5c:	dc000115 	stw	r16,4(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23b60:	10800060 	cmpeqi	r2,r2,1
   23b64:	1000431e 	bne	r2,zero,23c74 <MBX_CopyToSendMailbox+0x13c>
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }


    if ( !bMbxRunning )
   23b68:	d0a16643 	ldbu	r2,-31335(gp)
   23b6c:	10004126 	beq	r2,zero,23c74 <MBX_CopyToSendMailbox+0x13c>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }

    if ( bSendMbxIsFull )
   23b70:	d4e16683 	ldbu	r19,-31334(gp)
   23b74:	98803fcc 	andi	r2,r19,255
   23b78:	1000401e 	bne	r2,zero,23c7c <MBX_CopyToSendMailbox+0x144>
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
/*ECATCHANGE_START(V5.13) MBX2*/
        /*Reset the not used mailbox memory*/
        {
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b7c:	d421640b 	ldhu	r16,-31344(gp)
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   23b80:	d521658b 	ldhu	r20,-31338(gp)
        UINT16 mbxSize = pMbx->MbxHeader.Length;
   23b84:	2440000b 	ldhu	r17,0(r4)
   23b88:	2025883a 	mov	r18,r4
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   23b8c:	a429883a 	add	r20,r20,r16
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b90:	84000184 	addi	r16,r16,6
            LastAddrToReset = LastAddrToReset - 1;
   23b94:	a53fffc4 	addi	r20,r20,-1
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b98:	8461883a 	add	r16,r16,r17
            u8dummy = 0;
   23b9c:	d0214dc5 	stb	zero,-31433(gp)

            /*clear all unused bytes*/
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   23ba0:	843fffcc 	andi	r16,r16,65535
   23ba4:	a53fffcc 	andi	r20,r20,65535
            {
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   23ba8:	d5614dc4 	addi	r21,gp,-31433
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   23bac:	80bfffcc 	andi	r2,r16,65535
   23bb0:	15002a36 	bltu	r2,r20,23c5c <MBX_CopyToSendMailbox+0x124>
                LastUsedAddr = LastUsedAddr + 1;
            }
        }
/*ECATCHANGE_END(V5.13) MBX2*/

        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
   23bb4:	d161640b 	ldhu	r5,-31344(gp)
   23bb8:	89800184 	addi	r6,r17,6
   23bbc:	31bfffcc 	andi	r6,r6,65535
   23bc0:	9009883a 	mov	r4,r18
   23bc4:	00207f80 	call	207f8 <HW_EscWrite>


        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT8 smstate = 0x00;
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23bc8:	01800044 	movi	r6,1
   23bcc:	01420344 	movi	r5,2061
   23bd0:	d90000c4 	addi	r4,sp,3
        VARVOLATILE UINT8 smstate = 0x00;
   23bd4:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23bd8:	00207740 	call	20774 <HW_EscRead>

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
   23bdc:	d88000c3 	ldbu	r2,3(sp)
   23be0:	1080020c 	andi	r2,r2,8
   23be4:	10000d1e 	bne	r2,zero,23c1c <MBX_CopyToSendMailbox+0xe4>
        {
            UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
   23be8:	d0a1658b 	ldhu	r2,-31338(gp)
   23bec:	1463c83a 	sub	r17,r2,r17

            /*in case of a slow ESC the buffer status may not indicate 'full' even if the complete buffer was written, trigger an additional write access only if not the complete buffer was written*/
            if (BytesLeft > 0)
   23bf0:	8c7fffcc 	andi	r17,r17,65535
   23bf4:	8c4001a0 	cmpeqi	r17,r17,6
   23bf8:	8800081e 	bne	r17,zero,23c1c <MBX_CopyToSendMailbox+0xe4>
            {
                /*Write last Byte to trigger mailbox full flag*/
            u8dummy = 0;
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   23bfc:	d161640b 	ldhu	r5,-31344(gp)
   23c00:	01800044 	movi	r6,1
   23c04:	d1214dc4 	addi	r4,gp,-31433
   23c08:	288b883a 	add	r5,r5,r2
   23c0c:	297fffc4 	addi	r5,r5,-1
   23c10:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   23c14:	d0214dc5 	stb	zero,-31433(gp)
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   23c18:	00207f80 	call	207f8 <HW_EscWrite>
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
   23c1c:	d0a16117 	ldw	r2,-31356(gp)
   23c20:	10000126 	beq	r2,zero,23c28 <MBX_CopyToSendMailbox+0xf0>
        {
            psWriteMbx = NULL;
   23c24:	d0216215 	stw	zero,-31352(gp)
        }
        psReadMbx = pMbx;

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
   23c28:	00800044 	movi	r2,1
        psReadMbx = pMbx;
   23c2c:	d4a16115 	stw	r18,-31356(gp)
        bSendMbxIsFull = TRUE;
   23c30:	d0a16685 	stb	r2,-31334(gp)


        return 0;
    }
}
   23c34:	9805883a 	mov	r2,r19
   23c38:	dfc00717 	ldw	ra,28(sp)
   23c3c:	dd400617 	ldw	r21,24(sp)
   23c40:	dd000517 	ldw	r20,20(sp)
   23c44:	dcc00417 	ldw	r19,16(sp)
   23c48:	dc800317 	ldw	r18,12(sp)
   23c4c:	dc400217 	ldw	r17,8(sp)
   23c50:	dc000117 	ldw	r16,4(sp)
   23c54:	dec00804 	addi	sp,sp,32
   23c58:	f800283a 	ret
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   23c5c:	800b883a 	mov	r5,r16
   23c60:	01800044 	movi	r6,1
   23c64:	a809883a 	mov	r4,r21
   23c68:	00207f80 	call	207f8 <HW_EscWrite>
                LastUsedAddr = LastUsedAddr + 1;
   23c6c:	84000044 	addi	r16,r16,1
   23c70:	003fce06 	br	23bac <MBX_CopyToSendMailbox+0x74>
        return( ERROR_INVALIDSTATE );
   23c74:	04fffc04 	movi	r19,-16
   23c78:	003fee06 	br	23c34 <MBX_CopyToSendMailbox+0xfc>
        return MBXERR_NOMOREMEMORY;
   23c7c:	04c001c4 	movi	r19,7
   23c80:	003fec06 	br	23c34 <MBX_CopyToSendMailbox+0xfc>

00023c84 <MBX_MailboxReadInd>:
    if (psRepeatMbx && psStoreMbx == NULL)
   23c84:	d1216017 	ldw	r4,-31360(gp)
{
   23c88:	deffff04 	addi	sp,sp,-4
   23c8c:	dfc00015 	stw	ra,0(sp)
    bSendMbxIsFull = FALSE;
   23c90:	d0216685 	stb	zero,-31334(gp)
    if (psRepeatMbx && psStoreMbx == NULL)
   23c94:	20000526 	beq	r4,zero,23cac <MBX_MailboxReadInd+0x28>
   23c98:	d0a15f17 	ldw	r2,-31364(gp)
   23c9c:	1000031e 	bne	r2,zero,23cac <MBX_MailboxReadInd+0x28>
        if (psReadMbx != psRepeatMbx)
   23ca0:	d0a16117 	ldw	r2,-31356(gp)
   23ca4:	20800126 	beq	r4,r2,23cac <MBX_MailboxReadInd+0x28>
            APPL_FreeMailboxBuffer(psRepeatMbx);
   23ca8:	0026bec0 	call	26bec <free>
    psRepeatMbx = psReadMbx;
   23cac:	d0a16117 	ldw	r2,-31356(gp)
      if ( psStoreMbx )
   23cb0:	d1215f17 	ldw	r4,-31364(gp)
    psRepeatMbx = psReadMbx;
   23cb4:	d0a16015 	stw	r2,-31360(gp)
      if ( psStoreMbx )
   23cb8:	20001326 	beq	r4,zero,23d08 <MBX_MailboxReadInd+0x84>
        MBX_CopyToSendMailbox(psStoreMbx);
   23cbc:	0023b380 	call	23b38 <MBX_CopyToSendMailbox>
        psStoreMbx = NULL;
   23cc0:	d0215f15 	stw	zero,-31364(gp)
      if ( u8MailboxSendReqStored )
   23cc4:	d0a16303 	ldbu	r2,-31348(gp)
   23cc8:	10c03fcc 	andi	r3,r2,255
   23ccc:	18000b26 	beq	r3,zero,23cfc <MBX_MailboxReadInd+0x78>
        if ( u8MailboxSendReqStored & COE_SERVICE )
   23cd0:	10c0008c 	andi	r3,r2,2
   23cd4:	18000926 	beq	r3,zero,23cfc <MBX_MailboxReadInd+0x78>
            result = COE_ContinueInd(psWriteMbx);
   23cd8:	d1216217 	ldw	r4,-31352(gp)
            u8MailboxSendReqStored &= ~COE_SERVICE;
   23cdc:	10803f4c 	andi	r2,r2,253
   23ce0:	d0a16305 	stb	r2,-31348(gp)
            result = COE_ContinueInd(psWriteMbx);
   23ce4:	00219480 	call	21948 <COE_ContinueInd>
            if (result != 0)
   23ce8:	10803fcc 	andi	r2,r2,255
   23cec:	10000326 	beq	r2,zero,23cfc <MBX_MailboxReadInd+0x78>
                u8MailboxSendReqStored |= COE_SERVICE;
   23cf0:	d0a16303 	ldbu	r2,-31348(gp)
   23cf4:	10800094 	ori	r2,r2,2
   23cf8:	d0a16305 	stb	r2,-31348(gp)
}
   23cfc:	dfc00017 	ldw	ra,0(sp)
   23d00:	dec00104 	addi	sp,sp,4
   23d04:	f800283a 	ret
        TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23d08:	010000f4 	movhi	r4,3
   23d0c:	2121cd04 	addi	r4,r4,-30924
   23d10:	00238480 	call	23848 <GetOutOfMbxQueue>
   23d14:	1009883a 	mov	r4,r2
        if (pMbx)
   23d18:	103fea26 	beq	r2,zero,23cc4 <MBX_MailboxReadInd+0x40>
            MBX_CopyToSendMailbox(pMbx);
   23d1c:	0023b380 	call	23b38 <MBX_CopyToSendMailbox>
   23d20:	003fe806 	br	23cc4 <MBX_MailboxReadInd+0x40>

00023d24 <MBX_MailboxRepeatReq>:
{
   23d24:	defffe04 	addi	sp,sp,-8
   23d28:	dc000015 	stw	r16,0(sp)
    if (psRepeatMbx)
   23d2c:	d4216017 	ldw	r16,-31360(gp)
{
   23d30:	dfc00115 	stw	ra,4(sp)
    if (psRepeatMbx)
   23d34:	80000e26 	beq	r16,zero,23d70 <MBX_MailboxRepeatReq+0x4c>
       if (bSendMbxIsFull && psStoreMbx == NULL)
   23d38:	d0a16683 	ldbu	r2,-31334(gp)
   23d3c:	10000926 	beq	r2,zero,23d64 <MBX_MailboxRepeatReq+0x40>
   23d40:	d0a15f17 	ldw	r2,-31364(gp)
   23d44:	1000071e 	bne	r2,zero,23d64 <MBX_MailboxRepeatReq+0x40>
            DisableSyncManChannel(MAILBOX_READ);
   23d48:	01000044 	movi	r4,1
   23d4c:	0021ab00 	call	21ab0 <DisableSyncManChannel>
            psStoreMbx = psReadMbx;
   23d50:	d0a16117 	ldw	r2,-31356(gp)
            EnableSyncManChannel(MAILBOX_READ);
   23d54:	01000044 	movi	r4,1
            psStoreMbx = psReadMbx;
   23d58:	d0a15f15 	stw	r2,-31364(gp)
            EnableSyncManChannel(MAILBOX_READ);
   23d5c:	0021b100 	call	21b10 <EnableSyncManChannel>
            bSendMbxIsFull = FALSE;
   23d60:	d0216685 	stb	zero,-31334(gp)
        MBX_CopyToSendMailbox(pMbx);
   23d64:	8009883a 	mov	r4,r16
   23d68:	0023b380 	call	23b38 <MBX_CopyToSendMailbox>
        psRepeatMbx = NULL;
   23d6c:	d0216015 	stw	zero,-31360(gp)
    bMbxRepeatToggle = !bMbxRepeatToggle;
   23d70:	d0a16603 	ldbu	r2,-31336(gp)
   23d74:	1005003a 	cmpeq	r2,r2,zero
   23d78:	d0a16605 	stb	r2,-31336(gp)
}
   23d7c:	dfc00117 	ldw	ra,4(sp)
   23d80:	dc000017 	ldw	r16,0(sp)
   23d84:	dec00204 	addi	sp,sp,8
   23d88:	f800283a 	ret

00023d8c <MBX_MailboxSendReq>:
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
   23d8c:	d0a150c3 	ldbu	r2,-31421(gp)
   23d90:	108003cc 	andi	r2,r2,15
   23d94:	10800060 	cmpeqi	r2,r2,1
   23d98:	1000321e 	bne	r2,zero,23e64 <MBX_MailboxSendReq+0xd8>
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23d9c:	d0e16343 	ldbu	r3,-31347(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   23da0:	2080010b 	ldhu	r2,4(r4)
{
   23da4:	defffc04 	addi	sp,sp,-16
   23da8:	dc800215 	stw	r18,8(sp)
   23dac:	dc400115 	stw	r17,4(sp)
   23db0:	dc000015 	stw	r16,0(sp)
   23db4:	dfc00315 	stw	ra,12(sp)
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23db8:	18c001cc 	andi	r3,r3,7
   23dbc:	2025883a 	mov	r18,r4
   23dc0:	2823883a 	mov	r17,r5
   23dc4:	2821883a 	mov	r16,r5
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   23dc8:	1083ffcc 	andi	r2,r2,4095
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23dcc:	1800021e 	bne	r3,zero,23dd8 <MBX_MailboxSendReq+0x4c>
        u8MbxReadCounter = 1;
   23dd0:	00c00044 	movi	r3,1
   23dd4:	d0e16345 	stb	r3,-31347(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   23dd8:	d0e16343 	ldbu	r3,-31347(gp)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   23ddc:	9009883a 	mov	r4,r18
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   23de0:	1806933a 	slli	r3,r3,12
   23de4:	10c4b03a 	or	r2,r2,r3
   23de8:	9080010d 	sth	r2,4(r18)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   23dec:	0023b380 	call	23b38 <MBX_CopyToSendMailbox>
   23df0:	10803fcc 	andi	r2,r2,255
   23df4:	10000d26 	beq	r2,zero,23e2c <MBX_MailboxSendReq+0xa0>
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
   23df8:	014000f4 	movhi	r5,3
   23dfc:	2961cd04 	addi	r5,r5,-30924
   23e00:	9009883a 	mov	r4,r18
   23e04:	00237f80 	call	237f8 <PutInMbxQueue>
        if (result != 0)
   23e08:	10c03fcc 	andi	r3,r2,255
   23e0c:	18000726 	beq	r3,zero,23e2c <MBX_MailboxSendReq+0xa0>
            flags |= FRAGMENTS_FOLLOW;
   23e10:	043fe004 	movi	r16,-128
   23e14:	8c20b03a 	or	r16,r17,r16
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
   23e18:	d0e16303 	ldbu	r3,-31348(gp)
   23e1c:	84001fcc 	andi	r16,r16,127
   23e20:	80e0b03a 	or	r16,r16,r3
   23e24:	d4216305 	stb	r16,-31348(gp)
   23e28:	00000806 	br	23e4c <MBX_MailboxSendReq+0xc0>
        u8MbxReadCounter++;
   23e2c:	d0a16343 	ldbu	r2,-31347(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   23e30:	8c403fcc 	andi	r17,r17,255
   23e34:	8c40201c 	xori	r17,r17,128
        u8MbxReadCounter++;
   23e38:	10800044 	addi	r2,r2,1
   23e3c:	d0a16345 	stb	r2,-31347(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   23e40:	8c7fe004 	addi	r17,r17,-128
   23e44:	0005883a 	mov	r2,zero
   23e48:	883ff316 	blt	r17,zero,23e18 <MBX_MailboxSendReq+0x8c>
}
   23e4c:	dfc00317 	ldw	ra,12(sp)
   23e50:	dc800217 	ldw	r18,8(sp)
   23e54:	dc400117 	ldw	r17,4(sp)
   23e58:	dc000017 	ldw	r16,0(sp)
   23e5c:	dec00404 	addi	sp,sp,16
   23e60:	f800283a 	ret
        return ERROR_INVALIDSTATE;
   23e64:	00bffc04 	movi	r2,-16
}
   23e68:	f800283a 	ret

00023e6c <MBX_MailboxWriteInd>:
    if(MbxLen > MAX_MBX_SIZE)
   23e6c:	2080000b 	ldhu	r2,0(r4)
{
   23e70:	defffd04 	addi	sp,sp,-12
   23e74:	dc400115 	stw	r17,4(sp)
   23e78:	dc000015 	stw	r16,0(sp)
   23e7c:	dfc00215 	stw	ra,8(sp)
    if(MbxLen > MAX_MBX_SIZE)
   23e80:	10802070 	cmpltui	r2,r2,129
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   23e84:	2440010b 	ldhu	r17,4(r4)
{
   23e88:	2021883a 	mov	r16,r4
    if(MbxLen > MAX_MBX_SIZE)
   23e8c:	10000e1e 	bne	r2,zero,23ec8 <MBX_MailboxWriteInd+0x5c>
        pMbx->MbxHeader.Length     = 4;
   23e90:	00800104 	movi	r2,4
   23e94:	2080000d 	sth	r2,0(r4)
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23e98:	00800044 	movi	r2,1
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23e9c:	8c7c3fcc 	andi	r17,r17,61695
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23ea0:	2080018d 	sth	r2,6(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   23ea4:	00800204 	movi	r2,8
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23ea8:	2440010d 	sth	r17,4(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   23eac:	2080020d 	sth	r2,8(r4)
        MBX_MailboxSendReq(pMbx, 0);
   23eb0:	000b883a 	mov	r5,zero
}
   23eb4:	dfc00217 	ldw	ra,8(sp)
   23eb8:	dc400117 	ldw	r17,4(sp)
   23ebc:	dc000017 	ldw	r16,0(sp)
   23ec0:	dec00304 	addi	sp,sp,12
            MBX_MailboxSendReq(pMbx, 0);
   23ec4:	0023d8c1 	jmpi	23d8c <MBX_MailboxSendReq>
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   23ec8:	88bfffcc 	andi	r2,r17,65535
   23ecc:	1006d33a 	srli	r3,r2,12
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
   23ed0:	18000226 	beq	r3,zero,23edc <MBX_MailboxWriteInd+0x70>
   23ed4:	d0a16383 	ldbu	r2,-31346(gp)
   23ed8:	10c01226 	beq	r2,r3,23f24 <MBX_MailboxWriteInd+0xb8>
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   23edc:	014000f4 	movhi	r5,3
   23ee0:	2961c004 	addi	r5,r5,-30976
   23ee4:	8009883a 	mov	r4,r16
        u8MbxWriteCounter = mbxCounter;
   23ee8:	d0e16385 	stb	r3,-31346(gp)
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   23eec:	00237f80 	call	237f8 <PutInMbxQueue>
        if ( result != 0 )
   23ef0:	10c03fcc 	andi	r3,r2,255
   23ef4:	18001026 	beq	r3,zero,23f38 <MBX_MailboxWriteInd+0xcc>
            pMbx->MbxHeader.Length     = 4;
   23ef8:	00c00104 	movi	r3,4
   23efc:	80c0000d 	sth	r3,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23f00:	8c7c3fcc 	andi	r17,r17,61695
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23f04:	00c00044 	movi	r3,1
            pMbx->Data[1]                        = SWAPWORD(result);
   23f08:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23f0c:	8440010d 	sth	r17,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23f10:	80c0018d 	sth	r3,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   23f14:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   23f18:	000b883a 	mov	r5,zero
   23f1c:	8009883a 	mov	r4,r16
   23f20:	003fe406 	br	23eb4 <MBX_MailboxWriteInd+0x48>
}
   23f24:	dfc00217 	ldw	ra,8(sp)
   23f28:	dc400117 	ldw	r17,4(sp)
   23f2c:	dc000017 	ldw	r16,0(sp)
   23f30:	dec00304 	addi	sp,sp,12
        APPL_FreeMailboxBuffer(pMbx);
   23f34:	0026bec1 	jmpi	26bec <free>
}
   23f38:	dfc00217 	ldw	ra,8(sp)
   23f3c:	dc400117 	ldw	r17,4(sp)
   23f40:	dc000017 	ldw	r16,0(sp)
   23f44:	dec00304 	addi	sp,sp,12
   23f48:	f800283a 	ret

00023f4c <MBX_CheckAndCopyMailbox>:
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f4c:	d161648b 	ldhu	r5,-31342(gp)
{
   23f50:	defffc04 	addi	sp,sp,-16
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f54:	01800084 	movi	r6,2
   23f58:	d9000084 	addi	r4,sp,2
{
   23f5c:	dc400215 	stw	r17,8(sp)
   23f60:	dfc00315 	stw	ra,12(sp)
   23f64:	dc000115 	stw	r16,4(sp)
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f68:	00207740 	call	20774 <HW_EscRead>
    if(bNoMbxMemoryAvailable == TRUE)
   23f6c:	d4615e03 	ldbu	r17,-31368(gp)
   23f70:	88800060 	cmpeqi	r2,r17,1
   23f74:	10001226 	beq	r2,zero,23fc0 <MBX_CheckAndCopyMailbox+0x74>
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23f78:	01000284 	movi	r4,10
   23f7c:	0026bdc0 	call	26bdc <malloc>
   23f80:	1021883a 	mov	r16,r2
        if(pMbx != NULL)
   23f84:	10000e26 	beq	r2,zero,23fc0 <MBX_CheckAndCopyMailbox+0x74>
            HMEMSET(pMbx,0x00,10);
   23f88:	01800204 	movi	r6,8
   23f8c:	000b883a 	mov	r5,zero
   23f90:	11000084 	addi	r4,r2,2
   23f94:	0026f0c0 	call	26f0c <memset>
            pMbx->MbxHeader.Length     = 4;
   23f98:	00800104 	movi	r2,4
   23f9c:	8080000d 	sth	r2,0(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   23fa0:	008001c4 	movi	r2,7
            MBX_MailboxSendReq(pMbx, 0);
   23fa4:	8009883a 	mov	r4,r16
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23fa8:	8440018d 	sth	r17,6(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   23fac:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   23fb0:	000b883a 	mov	r5,zero
   23fb4:	0023d8c0 	call	23d8c <MBX_MailboxSendReq>
            APPL_FreeMailboxBuffer(pMbx);
   23fb8:	8009883a 	mov	r4,r16
   23fbc:	0026bec0 	call	26bec <free>
    mbxLen += MBX_HEADER_SIZE;
   23fc0:	d880008b 	ldhu	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   23fc4:	d0e16683 	ldbu	r3,-31334(gp)
   23fc8:	d1216303 	ldbu	r4,-31348(gp)
    mbxLen += MBX_HEADER_SIZE;
   23fcc:	10800184 	addi	r2,r2,6
   23fd0:	d880008d 	sth	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   23fd4:	1906b03a 	or	r3,r3,r4
   23fd8:	18c03fcc 	andi	r3,r3,255
   23fdc:	18000726 	beq	r3,zero,23ffc <MBX_CheckAndCopyMailbox+0xb0>
            bReceiveMbxIsLocked = TRUE;
   23fe0:	00800044 	movi	r2,1
   23fe4:	d0a166c5 	stb	r2,-31333(gp)
}
   23fe8:	dfc00317 	ldw	ra,12(sp)
   23fec:	dc400217 	ldw	r17,8(sp)
   23ff0:	dc000117 	ldw	r16,4(sp)
   23ff4:	dec00404 	addi	sp,sp,16
   23ff8:	f800283a 	ret
        if (mbxLen > u16ReceiveMbxSize)
   23ffc:	d0e1650b 	ldhu	r3,-31340(gp)
        bReceiveMbxIsLocked = FALSE;
   24000:	d02166c5 	stb	zero,-31333(gp)
        if (mbxLen > u16ReceiveMbxSize)
   24004:	10bfffcc 	andi	r2,r2,65535
   24008:	193fffcc 	andi	r4,r3,65535
   2400c:	2080012e 	bgeu	r4,r2,24014 <MBX_CheckAndCopyMailbox+0xc8>
            mbxLen = u16ReceiveMbxSize;
   24010:	d8c0008d 	sth	r3,2(sp)
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   24014:	0026bdc0 	call	26bdc <malloc>
   24018:	d0a16215 	stw	r2,-31352(gp)
   2401c:	1009883a 	mov	r4,r2
        if (psWriteMbx == NULL)
   24020:	103fef26 	beq	r2,zero,23fe0 <MBX_CheckAndCopyMailbox+0x94>
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
   24024:	d980008b 	ldhu	r6,2(sp)
   24028:	d161648b 	ldhu	r5,-31342(gp)
   2402c:	00207740 	call	20774 <HW_EscRead>
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   24030:	01800044 	movi	r6,1
   24034:	01420144 	movi	r5,2053
   24038:	d9000044 	addi	r4,sp,1
        VARVOLATILE UINT8 smstate = 0x00;
   2403c:	d8000045 	stb	zero,1(sp)
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   24040:	00207740 	call	20774 <HW_EscRead>
        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
   24044:	d8800043 	ldbu	r2,1(sp)
   24048:	1080020c 	andi	r2,r2,8
   2404c:	10000926 	beq	r2,zero,24074 <MBX_CheckAndCopyMailbox+0x128>
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   24050:	d161648b 	ldhu	r5,-31342(gp)
   24054:	d0a1650b 	ldhu	r2,-31340(gp)
   24058:	01800044 	movi	r6,1
   2405c:	d1214dc4 	addi	r4,gp,-31433
   24060:	288b883a 	add	r5,r5,r2
   24064:	297fffc4 	addi	r5,r5,-1
   24068:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   2406c:	d0214dc5 	stb	zero,-31433(gp)
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   24070:	00207740 	call	20774 <HW_EscRead>
        MBX_MailboxWriteInd( psWriteMbx );
   24074:	d1216217 	ldw	r4,-31352(gp)
   24078:	0023e6c0 	call	23e6c <MBX_MailboxWriteInd>
   2407c:	003fda06 	br	23fe8 <MBX_CheckAndCopyMailbox+0x9c>

00024080 <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
   24080:	defffa04 	addi	sp,sp,-24
   24084:	dc400115 	stw	r17,4(sp)

    do
    {
        UINT8 result = 0;

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24088:	044000f4 	movhi	r17,3
{
   2408c:	dd000415 	stw	r20,16(sp)
   24090:	dcc00315 	stw	r19,12(sp)
   24094:	dc800215 	stw	r18,8(sp)
   24098:	dfc00515 	stw	ra,20(sp)
   2409c:	dc000015 	stw	r16,0(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   240a0:	8c61c004 	addi	r17,r17,-30976
        }

        if ( result != 0 )
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
   240a4:	05000104 	movi	r20,4
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   240a8:	04fc3fc4 	movi	r19,-3841
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   240ac:	04800044 	movi	r18,1
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   240b0:	8809883a 	mov	r4,r17
   240b4:	00238480 	call	23848 <GetOutOfMbxQueue>
   240b8:	1021883a 	mov	r16,r2
        if ( pMbx )
   240bc:	10000a1e 	bne	r2,zero,240e8 <MBX_Main+0x68>
        }
    }
    while ( pMbx != NULL );


    if (bReceiveMbxIsLocked)
   240c0:	d0a166c3 	ldbu	r2,-31333(gp)
   240c4:	10001726 	beq	r2,zero,24124 <MBX_Main+0xa4>
    if (u8MailboxSendReqStored)
    {
        /* there are mailbox services stored to be sent */
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   240c8:	dfc00517 	ldw	ra,20(sp)
   240cc:	dd000417 	ldw	r20,16(sp)
   240d0:	dcc00317 	ldw	r19,12(sp)
   240d4:	dc800217 	ldw	r18,8(sp)
   240d8:	dc400117 	ldw	r17,4(sp)
   240dc:	dc000017 	ldw	r16,0(sp)
   240e0:	dec00604 	addi	sp,sp,24
        MBX_CheckAndCopyMailbox();
   240e4:	0023f4c1 	jmpi	23f4c <MBX_CheckAndCopyMailbox>
            result = MailboxServiceInd(pMbx);
   240e8:	1009883a 	mov	r4,r2
   240ec:	0023b180 	call	23b18 <MailboxServiceInd>
        if ( result != 0 )
   240f0:	10c03fcc 	andi	r3,r2,255
   240f4:	183fee26 	beq	r3,zero,240b0 <MBX_Main+0x30>
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   240f8:	80c0010b 	ldhu	r3,4(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   240fc:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Length     = 4;
   24100:	8500000d 	sth	r20,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   24104:	1cc6703a 	and	r3,r3,r19
   24108:	80c0010d 	sth	r3,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   2410c:	8480018d 	sth	r18,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   24110:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   24114:	000b883a 	mov	r5,zero
   24118:	8009883a 	mov	r4,r16
   2411c:	0023d8c0 	call	23d8c <MBX_MailboxSendReq>
   24120:	003fe306 	br	240b0 <MBX_Main+0x30>
}
   24124:	dfc00517 	ldw	ra,20(sp)
   24128:	dd000417 	ldw	r20,16(sp)
   2412c:	dcc00317 	ldw	r19,12(sp)
   24130:	dc800217 	ldw	r18,8(sp)
   24134:	dc400117 	ldw	r17,4(sp)
   24138:	dc000017 	ldw	r16,0(sp)
   2413c:	dec00604 	addi	sp,sp,24
   24140:	f800283a 	ret

00024144 <OBJ_GetObjectHandle>:
             and returns a handle if found.

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
{
   24144:	defffe04 	addi	sp,sp,-8
   24148:	dc000015 	stw	r16,0(sp)
   2414c:	2021883a 	mov	r16,r4
   24150:	dfc00115 	stw	ra,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();

    while (pObjEntry!= NULL)
    {
        
        if (pObjEntry->Index == index)
   24154:	843fffcc 	andi	r16,r16,65535
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24158:	00209dc0 	call	209dc <COE_GetObjectDictionary>
    while (pObjEntry!= NULL)
   2415c:	1000041e 	bne	r2,zero,24170 <OBJ_GetObjectHandle+0x2c>
            return pObjEntry;
        }
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
    }
    return 0;
}
   24160:	dfc00117 	ldw	ra,4(sp)
   24164:	dc000017 	ldw	r16,0(sp)
   24168:	dec00204 	addi	sp,sp,8
   2416c:	f800283a 	ret
        if (pObjEntry->Index == index)
   24170:	10c0020b 	ldhu	r3,8(r2)
   24174:	1c3ffa26 	beq	r3,r16,24160 <OBJ_GetObjectHandle+0x1c>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24178:	10800117 	ldw	r2,4(r2)
   2417c:	003ff706 	br	2415c <OBJ_GetObjectHandle+0x18>

00024180 <OBJ_GetObjectLength>:

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24180:	30c0030b 	ldhu	r3,12(r6)
    
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
    UINT32 size = 0;

    if ( bCompleteAccess )
   24184:	39c03fcc 	andi	r7,r7,255
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24188:	1804d23a 	srli	r2,r3,8
    if ( bCompleteAccess )
   2418c:	108003cc 	andi	r2,r2,15
   24190:	38001c26 	beq	r7,zero,24204 <OBJ_GetObjectLength+0x84>
    {
        if ( objCode == OBJCODE_VAR )
   24194:	110001e0 	cmpeqi	r4,r2,7
   24198:	2000301e 	bne	r4,zero,2425c <OBJ_GetObjectLength+0xdc>
        {
            return 0;
        }
        else if ((objCode == OBJCODE_ARR)
   2419c:	10800218 	cmpnei	r2,r2,8
   241a0:	1000141e 	bne	r2,zero,241f4 <OBJ_GetObjectLength+0x74>
            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   241a4:	30800417 	ldw	r2,16(r6)
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   241a8:	30c00617 	ldw	r3,24(r6)
            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   241ac:	1080020b 	ldhu	r2,8(r2)
   241b0:	18c00003 	ldbu	r3,0(r3)
   241b4:	10c5383a 	mul	r2,r2,r3
            for (i = 1; i <= maxSubindex; i++)
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
   241b8:	108001c4 	addi	r2,r2,7

            if ( subindex == 0 )
   241bc:	29403fcc 	andi	r5,r5,255
            size = BIT2BYTE(size);
   241c0:	1004d0fa 	srli	r2,r2,3
            if ( subindex == 0 )
   241c4:	2800261e 	bne	r5,zero,24260 <OBJ_GetObjectLength+0xe0>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
   241c8:	10800084 	addi	r2,r2,2
   241cc:	f800283a 	ret
                size += pObjEntry->pEntryDesc[i].BitLength;
   241d0:	31c00417 	ldw	r7,16(r6)
   241d4:	220001a4 	muli	r8,r4,6
   241d8:	3a0f883a 	add	r7,r7,r8
   241dc:	39c0008b 	ldhu	r7,2(r7)
   241e0:	11c5883a 	add	r2,r2,r7
            for (i = 1; i <= maxSubindex; i++)
   241e4:	21000044 	addi	r4,r4,1
   241e8:	21ffffcc 	andi	r7,r4,65535
   241ec:	19fff82e 	bgeu	r3,r7,241d0 <OBJ_GetObjectLength+0x50>
   241f0:	003ff106 	br	241b8 <OBJ_GetObjectLength+0x38>
   241f4:	0009883a 	mov	r4,zero
    UINT32 size = 0;
   241f8:	0005883a 	mov	r2,zero
            for (i = 1; i <= maxSubindex; i++)
   241fc:	18c03fcc 	andi	r3,r3,255
   24200:	003ff806 	br	241e4 <OBJ_GetObjectLength+0x64>
            return size;
        }
    }
    else
    {
        if ( objCode == OBJCODE_VAR )
   24204:	110001d8 	cmpnei	r4,r2,7
   24208:	2000031e 	bne	r4,zero,24218 <OBJ_GetObjectLength+0x98>
        {

            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
   2420c:	30800417 	ldw	r2,16(r6)
                    return 0;

                }
                else
                {
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24210:	1080008b 	ldhu	r2,2(r2)
   24214:	00000606 	br	24230 <OBJ_GetObjectLength+0xb0>
        else if ( subindex == 0 )
   24218:	29403fcc 	andi	r5,r5,255
   2421c:	28000d26 	beq	r5,zero,24254 <OBJ_GetObjectLength+0xd4>
        else if((objCode == OBJCODE_ARR)
   24220:	10800218 	cmpnei	r2,r2,8
   24224:	1000051e 	bne	r2,zero,2423c <OBJ_GetObjectLength+0xbc>
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
   24228:	30800417 	ldw	r2,16(r6)
   2422c:	1080020b 	ldhu	r2,8(r2)
   24230:	108001c4 	addi	r2,r2,7
   24234:	1005d0fa 	srai	r2,r2,3
   24238:	f800283a 	ret
                if (maxSubindex < subindex)
   2423c:	18c03fcc 	andi	r3,r3,255
   24240:	19400636 	bltu	r3,r5,2425c <OBJ_GetObjectLength+0xdc>
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24244:	30800417 	ldw	r2,16(r6)
   24248:	294001a4 	muli	r5,r5,6
   2424c:	1145883a 	add	r2,r2,r5
   24250:	003fef06 	br	24210 <OBJ_GetObjectLength+0x90>
            return 1;
   24254:	00800044 	movi	r2,1
   24258:	f800283a 	ret
            return 0;
   2425c:	0005883a 	mov	r2,zero
                }
            }
        }
    }
}
   24260:	f800283a 	ret

00024264 <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
   24264:	defffd04 	addi	sp,sp,-12
   24268:	dc400115 	stw	r17,4(sp)
    UINT8 Modulo;

    pStr[2] = '0';
    pStr[0] += (Number / 100);
   2426c:	2c403fcc 	andi	r17,r5,255
{
   24270:	dc000015 	stw	r16,0(sp)
    pStr[0] += (Number / 100);
   24274:	01401904 	movi	r5,100
{
   24278:	2021883a 	mov	r16,r4
    pStr[0] += (Number / 100);
   2427c:	8809883a 	mov	r4,r17
{
   24280:	dfc00215 	stw	ra,8(sp)
    pStr[0] += (Number / 100);
   24284:	0026b1c0 	call	26b1c <__udivsi3>
   24288:	80c00003 	ldbu	r3,0(r16)
    Modulo = Number % 100;
   2428c:	8809883a 	mov	r4,r17
   24290:	01401904 	movi	r5,100
    pStr[0] += (Number / 100);
   24294:	10c5883a 	add	r2,r2,r3
   24298:	80800005 	stb	r2,0(r16)
    Modulo = Number % 100;
   2429c:	0026b800 	call	26b80 <__umodsi3>
    pStr[1] += (Modulo / 10);
   242a0:	14403fcc 	andi	r17,r2,255
   242a4:	8809883a 	mov	r4,r17
   242a8:	01400284 	movi	r5,10
   242ac:	0026b1c0 	call	26b1c <__udivsi3>
   242b0:	80c00043 	ldbu	r3,1(r16)
    pStr[2] += (Modulo % 10);
   242b4:	01400284 	movi	r5,10
   242b8:	8809883a 	mov	r4,r17
    pStr[1] += (Modulo / 10);
   242bc:	10c5883a 	add	r2,r2,r3
   242c0:	80800045 	stb	r2,1(r16)
    pStr[2] += (Modulo % 10);
   242c4:	0026b800 	call	26b80 <__umodsi3>
   242c8:	10800c04 	addi	r2,r2,48
   242cc:	80800085 	stb	r2,2(r16)
}
   242d0:	dfc00217 	ldw	ra,8(sp)
   242d4:	dc400117 	ldw	r17,4(sp)
   242d8:	dc000017 	ldw	r16,0(sp)
   242dc:	dec00304 	addi	sp,sp,12
   242e0:	f800283a 	ret

000242e4 <OBJ_GetDesc>:
                0xFF                                            <br>
            }
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
{
   242e4:	defff604 	addi	sp,sp,-40
   242e8:	dcc00715 	stw	r19,28(sp)
   242ec:	dc800615 	stw	r18,24(sp)
   242f0:	dc000415 	stw	r16,16(sp)
   242f4:	dfc00915 	stw	ra,36(sp)
   242f8:	dd000815 	stw	r20,32(sp)
   242fc:	dc400515 	stw	r17,20(sp)
/* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;



    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24300:	2cc03fcc 	andi	r19,r5,255
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
   24304:	34000517 	ldw	r16,20(r6)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24308:	3080030b 	ldhu	r2,12(r6)
{
   2430c:	3825883a 	mov	r18,r7
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24310:	98000426 	beq	r19,zero,24324 <OBJ_GetDesc+0x40>
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24314:	1004d23a 	srli	r2,r2,8
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24318:	108003cc 	andi	r2,r2,15
   2431c:	10c001d8 	cmpnei	r3,r2,7
   24320:	1800091e 	bne	r3,zero,24348 <OBJ_GetDesc+0x64>
    {
        // Get object description length
       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
   24324:	8009883a 	mov	r4,r16
   24328:	0026f2c0 	call	26f2c <strlen>
   2432c:	1023883a 	mov	r17,r2

        // If there is a pointer given, copy data:
        if ( pData )
   24330:	90001a26 	beq	r18,zero,2439c <OBJ_GetDesc+0xb8>
        {
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
   24334:	11bfffcc 	andi	r6,r2,65535
                if ( i == tmpSubindex )
                {
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
                    if ( pData && strSize )
                    {
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   24338:	800b883a 	mov	r5,r16
   2433c:	9009883a 	mov	r4,r18
   24340:	0026ee40 	call	26ee4 <memcpy>
            }
            }
            }
        }

        if ( strSize == 0 )
   24344:	00001506 	br	2439c <OBJ_GetDesc+0xb8>
        if ( objCode == OBJCODE_REC )
   24348:	10800258 	cmpnei	r2,r2,9
   2434c:	1000251e 	bne	r2,zero,243e4 <OBJ_GetDesc+0x100>
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24350:	8009883a 	mov	r4,r16
            UINT16 tmpSubindex = subindex;
   24354:	2c403fcc 	andi	r17,r5,255
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24358:	0026f2c0 	call	26f2c <strlen>
   2435c:	10800044 	addi	r2,r2,1
   24360:	80a1883a 	add	r16,r16,r2
            UINT16 i = 1;
   24364:	05000044 	movi	r20,1
                if ( i == tmpSubindex )
   24368:	8c7fffcc 	andi	r17,r17,65535
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   2436c:	80800003 	ldbu	r2,0(r16)
   24370:	10803fb0 	cmpltui	r2,r2,254
   24374:	10001b26 	beq	r2,zero,243e4 <OBJ_GetDesc+0x100>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   24378:	8009883a 	mov	r4,r16
   2437c:	0026f2c0 	call	26f2c <strlen>
                if ( i == tmpSubindex )
   24380:	a0ffffcc 	andi	r3,r20,65535
   24384:	88c0111e 	bne	r17,r3,243cc <OBJ_GetDesc+0xe8>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   24388:	1023883a 	mov	r17,r2
                    if ( pData && strSize )
   2438c:	10ffffcc 	andi	r3,r2,65535
   24390:	90000b1e 	bne	r18,zero,243c0 <OBJ_GetDesc+0xdc>
        if ( strSize == 0 )
   24394:	1800011e 	bne	r3,zero,2439c <OBJ_GetDesc+0xb8>
        {
            // no string found for subindex x -> name is Subindex x
            strSize =    12;
   24398:	04400304 	movi	r17,12
            }
        }
    }

    return strSize;
}
   2439c:	8805883a 	mov	r2,r17
   243a0:	dfc00917 	ldw	ra,36(sp)
   243a4:	dd000817 	ldw	r20,32(sp)
   243a8:	dcc00717 	ldw	r19,28(sp)
   243ac:	dc800617 	ldw	r18,24(sp)
   243b0:	dc400517 	ldw	r17,20(sp)
   243b4:	dc000417 	ldw	r16,16(sp)
   243b8:	dec00a04 	addi	sp,sp,40
   243bc:	f800283a 	ret
                    if ( pData && strSize )
   243c0:	18000926 	beq	r3,zero,243e8 <OBJ_GetDesc+0x104>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   243c4:	11bfffcc 	andi	r6,r2,65535
   243c8:	003fdb06 	br	24338 <OBJ_GetDesc+0x54>
                    i++;
   243cc:	a0c00044 	addi	r3,r20,1
   243d0:	1829883a 	mov	r20,r3
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   243d4:	10800044 	addi	r2,r2,1
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   243d8:	18ffffcc 	andi	r3,r3,65535
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   243dc:	80a1883a 	add	r16,r16,r2
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   243e0:	88ffe22e 	bgeu	r17,r3,2436c <OBJ_GetDesc+0x88>
            if ( pData )
   243e4:	903fec26 	beq	r18,zero,24398 <OBJ_GetDesc+0xb4>
                MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
   243e8:	014000f4 	movhi	r5,3
   243ec:	01800344 	movi	r6,13
   243f0:	d90000c4 	addi	r4,sp,3
   243f4:	29600004 	addi	r5,r5,-32768
   243f8:	0026ee40 	call	26ee4 <memcpy>
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
   243fc:	980b883a 	mov	r5,r19
   24400:	d9000304 	addi	r4,sp,12
   24404:	00242640 	call	24264 <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
   24408:	01800344 	movi	r6,13
   2440c:	d94000c4 	addi	r5,sp,3
   24410:	9009883a 	mov	r4,r18
   24414:	0026ee40 	call	26ee4 <memcpy>
   24418:	003fdf06 	br	24398 <OBJ_GetDesc+0xb4>

0002441c <OBJ_GetEntryDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2441c:	20c0030b 	ldhu	r3,12(r4)
   24420:	20800417 	ldw	r2,16(r4)
   24424:	29403fcc 	andi	r5,r5,255
   24428:	1807d23a 	srai	r3,r3,8

    if ((objCode == OBJCODE_ARR)
   2442c:	18c003cc 	andi	r3,r3,15
   24430:	18c00218 	cmpnei	r3,r3,8
   24434:	1800031e 	bne	r3,zero,24444 <OBJ_GetEntryDesc+0x28>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
   24438:	28000426 	beq	r5,zero,2444c <OBJ_GetEntryDesc+0x30>
            pEntry = &pObjEntry->pEntryDesc[0];
        }
        else
        {
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
   2443c:	10800184 	addi	r2,r2,6
   24440:	f800283a 	ret
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
   24444:	294001a4 	muli	r5,r5,6
   24448:	1145883a 	add	r2,r2,r5
        }
    }

    return pEntry;
}
   2444c:	f800283a 	ret

00024450 <OBJ_GetNoOfObjects>:
{
   24450:	defff904 	addi	sp,sp,-28
   24454:	dd000415 	stw	r20,16(sp)
   24458:	dcc00315 	stw	r19,12(sp)
   2445c:	2029883a 	mov	r20,r4
    UINT16 listFlags = 0x0020 << listType;
   24460:	04c00804 	movi	r19,32
   24464:	21003fcc 	andi	r4,r4,255
{
   24468:	dc800215 	stw	r18,8(sp)
   2446c:	dc000015 	stw	r16,0(sp)
    UINT16 listFlags = 0x0020 << listType;
   24470:	9926983a 	sll	r19,r19,r4
{
   24474:	dfc00615 	stw	ra,24(sp)
   24478:	dd400515 	stw	r21,20(sp)
   2447c:	dc400115 	stw	r17,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24480:	00209dc0 	call	209dc <COE_GetObjectDictionary>
   24484:	1021883a 	mov	r16,r2
    UINT16 n = 0;
   24488:	0025883a 	mov	r18,zero
            if ( t )
   2448c:	a5003fcc 	andi	r20,r20,255
    while (pObjEntry != NULL)
   24490:	80000a1e 	bne	r16,zero,244bc <OBJ_GetNoOfObjects+0x6c>
}
   24494:	9005883a 	mov	r2,r18
   24498:	dfc00617 	ldw	ra,24(sp)
   2449c:	dd400517 	ldw	r21,20(sp)
   244a0:	dd000417 	ldw	r20,16(sp)
   244a4:	dcc00317 	ldw	r19,12(sp)
   244a8:	dc800217 	ldw	r18,8(sp)
   244ac:	dc400117 	ldw	r17,4(sp)
   244b0:	dc000017 	ldw	r16,0(sp)
   244b4:	dec00704 	addi	sp,sp,28
   244b8:	f800283a 	ret
        if ( pObjEntry->Index >= 0x1000 )
   244bc:	8080020b 	ldhu	r2,8(r16)
   244c0:	10840030 	cmpltui	r2,r2,4096
   244c4:	10000c1e 	bne	r2,zero,244f8 <OBJ_GetNoOfObjects+0xa8>
            if ( t )
   244c8:	a0000d26 	beq	r20,zero,24500 <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   244cc:	85400303 	ldbu	r21,12(r16)
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   244d0:	0023883a 	mov	r17,zero
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
   244d4:	880b883a 	mov	r5,r17
   244d8:	8009883a 	mov	r4,r16
   244dc:	002441c0 	call	2441c <OBJ_GetEntryDesc>
   244e0:	1080010b 	ldhu	r2,4(r2)
   244e4:	14c4703a 	and	r2,r2,r19
   244e8:	1000051e 	bne	r2,zero,24500 <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   244ec:	8c400044 	addi	r17,r17,1
   244f0:	88bfffcc 	andi	r2,r17,65535
   244f4:	a8bff72e 	bgeu	r21,r2,244d4 <OBJ_GetNoOfObjects+0x84>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   244f8:	84000117 	ldw	r16,4(r16)
   244fc:	003fe406 	br	24490 <OBJ_GetNoOfObjects+0x40>
                n++;
   24500:	94800044 	addi	r18,r18,1
   24504:	003ffc06 	br	244f8 <OBJ_GetNoOfObjects+0xa8>

00024508 <OBJ_GetObjectList>:
    if ( pIndex[0] == 0x1000 )
   24508:	2880000b 	ldhu	r2,0(r5)
{
   2450c:	defff604 	addi	sp,sp,-40
   24510:	ddc00715 	stw	r23,28(sp)
   24514:	dd800615 	stw	r22,24(sp)
   24518:	dd400515 	stw	r21,20(sp)
   2451c:	dd000415 	stw	r20,16(sp)
   24520:	dcc00315 	stw	r19,12(sp)
   24524:	dc800215 	stw	r18,8(sp)
   24528:	dc400115 	stw	r17,4(sp)
   2452c:	dfc00915 	stw	ra,36(sp)
   24530:	df000815 	stw	fp,32(sp)
   24534:	dc000015 	stw	r16,0(sp)
    if ( pIndex[0] == 0x1000 )
   24538:	10840018 	cmpnei	r2,r2,4096
{
   2453c:	ddc00a17 	ldw	r23,40(sp)
   24540:	2025883a 	mov	r18,r4
   24544:	2827883a 	mov	r19,r5
   24548:	3023883a 	mov	r17,r6
   2454c:	3829883a 	mov	r20,r7
   24550:	202d883a 	mov	r22,r4
   24554:	302b883a 	mov	r21,r6
    if ( pIndex[0] == 0x1000 )
   24558:	10001c1e 	bne	r2,zero,245cc <OBJ_GetObjectList+0xc4>
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   2455c:	00209dc0 	call	209dc <COE_GetObjectDictionary>
   24560:	1021883a 	mov	r16,r2
        if((pObjEntry == NULL) && (pAbort != NULL))
   24564:	10001326 	beq	r2,zero,245b4 <OBJ_GetObjectList+0xac>
        while (pObjEntry != NULL && size > 1 )
   24568:	8c7fffcc 	andi	r17,r17,65535
   2456c:	8c4000a8 	cmpgeui	r17,r17,2
   24570:	8800191e 	bne	r17,zero,245d8 <OBJ_GetObjectList+0xd0>
            pIndex[0] = pObjEntry->Index;
   24574:	8080020b 	ldhu	r2,8(r16)
   24578:	9880000d 	sth	r2,0(r19)
}
   2457c:	a805883a 	mov	r2,r21
    pSdoInfoObjEntry = pObjEntry;
   24580:	d4216f15 	stw	r16,-31300(gp)
}
   24584:	dfc00917 	ldw	ra,36(sp)
   24588:	df000817 	ldw	fp,32(sp)
   2458c:	ddc00717 	ldw	r23,28(sp)
   24590:	dd800617 	ldw	r22,24(sp)
   24594:	dd400517 	ldw	r21,20(sp)
   24598:	dd000417 	ldw	r20,16(sp)
   2459c:	dcc00317 	ldw	r19,12(sp)
   245a0:	dc800217 	ldw	r18,8(sp)
   245a4:	dc400117 	ldw	r17,4(sp)
   245a8:	dc000017 	ldw	r16,0(sp)
   245ac:	dec00a04 	addi	sp,sp,40
   245b0:	f800283a 	ret
        if((pObjEntry == NULL) && (pAbort != NULL))
   245b4:	b8000226 	beq	r23,zero,245c0 <OBJ_GetObjectList+0xb8>
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
   245b8:	008006c4 	movi	r2,27
   245bc:	b8800005 	stb	r2,0(r23)
            pIndex[0] = 0xFFFF;
   245c0:	00bfffc4 	movi	r2,-1
   245c4:	0021883a 	mov	r16,zero
   245c8:	003feb06 	br	24578 <OBJ_GetObjectList+0x70>
        pObjEntry = pSdoInfoObjEntry;
   245cc:	d4216f17 	ldw	r16,-31300(gp)
    if ( pObjEntry != NULL )
   245d0:	803fe51e 	bne	r16,zero,24568 <OBJ_GetObjectList+0x60>
   245d4:	003ffa06 	br	245c0 <OBJ_GetObjectList+0xb8>
    UINT16 listFlags = 0x0020 << listType;
   245d8:	94bfffcc 	andi	r18,r18,65535
   245dc:	00800804 	movi	r2,32
   245e0:	14a4983a 	sll	r18,r2,r18
                if ( t )
   245e4:	b5bfffcc 	andi	r22,r22,65535
            if ( pObjEntry->Index >= 0x1000 )
   245e8:	85c0020b 	ldhu	r23,8(r16)
   245ec:	b8bfffcc 	andi	r2,r23,65535
   245f0:	10840030 	cmpltui	r2,r2,4096
   245f4:	10000c1e 	bne	r2,zero,24628 <OBJ_GetObjectList+0x120>
                if ( t )
   245f8:	b0001126 	beq	r22,zero,24640 <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   245fc:	87000303 	ldbu	fp,12(r16)
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   24600:	0023883a 	mov	r17,zero
                        if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
   24604:	880b883a 	mov	r5,r17
   24608:	8009883a 	mov	r4,r16
   2460c:	002441c0 	call	2441c <OBJ_GetEntryDesc>
   24610:	1080010b 	ldhu	r2,4(r2)
   24614:	1484703a 	and	r2,r2,r18
   24618:	1000091e 	bne	r2,zero,24640 <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   2461c:	8c400044 	addi	r17,r17,1
   24620:	88bfffcc 	andi	r2,r17,65535
   24624:	e0bff72e 	bgeu	fp,r2,24604 <OBJ_GetObjectList+0xfc>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24628:	84000117 	ldw	r16,4(r16)
        while (pObjEntry != NULL && size > 1 )
   2462c:	803fe426 	beq	r16,zero,245c0 <OBJ_GetObjectList+0xb8>
   24630:	a8bfffcc 	andi	r2,r21,65535
   24634:	108000a8 	cmpgeui	r2,r2,2
   24638:	103feb1e 	bne	r2,zero,245e8 <OBJ_GetObjectList+0xe0>
   2463c:	003fcd06 	br	24574 <OBJ_GetObjectList+0x6c>
                    *pData = SWAPWORD(pObjEntry->Index);
   24640:	a5c0000d 	sth	r23,0(r20)
                    size -= 2;
   24644:	ad7fff84 	addi	r21,r21,-2
                    pData++;
   24648:	a5000084 	addi	r20,r20,2
                    size -= 2;
   2464c:	003ff606 	br	24628 <OBJ_GetObjectList+0x120>

00024650 <OBJ_GetObjDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    return &pObjEntry->ObjDesc;
}
   24650:	20800284 	addi	r2,r4,10
   24654:	f800283a 	ret

00024658 <OBJ_GetEntryOffset>:
UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    UINT16 i;
    /* bitOffset will be initialized with the bit offset of subindex 1 */
    UINT16 bitOffset = 0;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24658:	28c0030b 	ldhu	r3,12(r5)
   2465c:	1807d23a 	srai	r3,r3,8
   24660:	18c003cc 	andi	r3,r3,15
   24664:	1811883a 	mov	r8,r3
    {
        /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
        bitOffset +=16;
    }

    if (objCode == OBJCODE_VAR)
   24668:	18c001e0 	cmpeqi	r3,r3,7
   2466c:	1800531e 	bne	r3,zero,247bc <OBJ_GetEntryOffset+0x164>
   24670:	20803fcc 	andi	r2,r4,255
    {
        return 0;
    }

    for (i = 1; i <= subindex; i++)
   24674:	02800044 	movi	r10,1
   24678:	1004c03a 	cmpne	r2,r2,zero
    {
        /* get the entry description */
        if ((objCode == OBJCODE_ARR)
   2467c:	42003fcc 	andi	r8,r8,255
        else
        {
            pEntry = &pObjEntry->pEntryDesc[i];
        }

        switch (pEntry->DataType)
   24680:	02d00074 	movhi	r11,16385
   24684:	03080034 	movhi	r12,8192
    for (i = 1; i <= subindex; i++)
   24688:	21003fcc 	andi	r4,r4,255
   2468c:	51bfffcc 	andi	r6,r10,65535
   24690:	1004913a 	slli	r2,r2,4
   24694:	02400184 	movi	r9,6
        if ((objCode == OBJCODE_ARR)
   24698:	42000218 	cmpnei	r8,r8,8
        case    DEFTYPE_ARRAY_OF_INT :

#if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
            /* the 16-bit variables in the structure are word-aligned,
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
   2469c:	03fffc04 	movi	r15,-16
        case    DEFTYPE_ARRAY_OF_DINT :
        case    DEFTYPE_ARRAY_OF_UDINT:
#if OBJ_DWORD_ALIGN
            /* the 32-bit variables in the structure are dword-aligned,
               align the actual bitOffset to a dword */
            bitOffset = (bitOffset+31) & 0xFFE0;
   246a0:	037ff804 	movi	r13,-32
   246a4:	03800044 	movi	r14,1
        switch (pEntry->DataType)
   246a8:	5ae00004 	addi	r11,r11,-32768
   246ac:	63100004 	addi	r12,r12,16384
    for (i = 1; i <= subindex; i++)
   246b0:	2180462e 	bgeu	r4,r6,247cc <OBJ_GetEntryOffset+0x174>
            break;
        }
    }

    return bitOffset;
}
   246b4:	f800283a 	ret
            pEntry = &pObjEntry->pEntryDesc[i];
   246b8:	3a4f883a 	add	r7,r7,r9
   246bc:	00004906 	br	247e4 <OBJ_GetEntryOffset+0x18c>
        switch (pEntry->DataType)
   246c0:	18fffbc4 	addi	r3,r3,-17
   246c4:	18ffffcc 	andi	r3,r3,65535
   246c8:	70c6983a 	sll	r3,r14,r3
   246cc:	1c01044c 	andi	r16,r3,1041
   246d0:	8000341e 	bne	r16,zero,247a4 <OBJ_GetEntryOffset+0x14c>
   246d4:	1ae0703a 	and	r16,r3,r11
   246d8:	80002b1e 	bne	r16,zero,24788 <OBJ_GetEntryOffset+0x130>
   246dc:	1b06703a 	and	r3,r3,r12
   246e0:	18004a26 	beq	r3,zero,2480c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   246e4:	108003c4 	addi	r2,r2,15
   246e8:	00fffc04 	movi	r3,-16
   246ec:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   246f0:	31003436 	bltu	r6,r4,247c4 <OBJ_GetEntryOffset+0x16c>
    for (i = 1; i <= subindex; i++)
   246f4:	52800044 	addi	r10,r10,1
   246f8:	51bfffcc 	andi	r6,r10,65535
   246fc:	4a400184 	addi	r9,r9,6
   24700:	2180352e 	bgeu	r4,r6,247d8 <OBJ_GetEntryOffset+0x180>
}
   24704:	dfc00117 	ldw	ra,4(sp)
   24708:	dc000017 	ldw	r16,0(sp)
   2470c:	dec00204 	addi	sp,sp,8
   24710:	f800283a 	ret
   24714:	77c6983a 	sll	r3,r14,ra
        switch (pEntry->DataType)
   24718:	1c00640c 	andi	r16,r3,400
   2471c:	80001a1e 	bne	r16,zero,24788 <OBJ_GetEntryOffset+0x130>
   24720:	18c2120c 	andi	r3,r3,2120
   24724:	18003926 	beq	r3,zero,2480c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24728:	108003c4 	addi	r2,r2,15
   2472c:	00fffc04 	movi	r3,-16
   24730:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24734:	313fef2e 	bgeu	r6,r4,246f4 <OBJ_GetEntryOffset+0x9c>
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
   24738:	ffc002d8 	cmpnei	ra,ra,11
   2473c:	f800211e 	bne	ra,zero,247c4 <OBJ_GetEntryOffset+0x16c>
                bitOffset += pEntry->BitLength;
   24740:	38c0008b 	ldhu	r3,2(r7)
   24744:	00000b06 	br	24774 <OBJ_GetEntryOffset+0x11c>
        switch (pEntry->DataType)
   24748:	ffc09820 	cmpeqi	ra,ra,608
   2474c:	f8000b1e 	bne	ra,zero,2477c <OBJ_GetEntryOffset+0x124>
   24750:	18ff6784 	addi	r3,r3,-610
   24754:	18ffffcc 	andi	r3,r3,65535
   24758:	18c000a8 	cmpgeui	r3,r3,2
   2475c:	18002b1e 	bne	r3,zero,2480c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24760:	10c007c4 	addi	r3,r2,31
   24764:	1b46703a 	and	r3,r3,r13
   24768:	1805883a 	mov	r2,r3
            if (i < subindex)
   2476c:	313fe12e 	bgeu	r6,r4,246f4 <OBJ_GetEntryOffset+0x9c>
                    bitOffset += pEntry->BitLength;
   24770:	3880008b 	ldhu	r2,2(r7)
                bitOffset += pEntry->BitLength;
   24774:	1885883a 	add	r2,r3,r2
   24778:	003fde06 	br	246f4 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset+15) & 0xFFF0;
   2477c:	108003c4 	addi	r2,r2,15
   24780:	13c4703a 	and	r2,r2,r15
            if (i < subindex)
   24784:	00002106 	br	2480c <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   24788:	10c007c4 	addi	r3,r2,31
   2478c:	00bff804 	movi	r2,-32
   24790:	1886703a 	and	r3,r3,r2
   24794:	1805883a 	mov	r2,r3
            if (i < subindex)
   24798:	313fd62e 	bgeu	r6,r4,246f4 <OBJ_GetEntryOffset+0x9c>
                   bitOffset += 32;
   2479c:	18800804 	addi	r2,r3,32
   247a0:	003fd406 	br	246f4 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset + 31) & 0xFFE0;
   247a4:	10c007c4 	addi	r3,r2,31
   247a8:	1b46703a 	and	r3,r3,r13
   247ac:	1805883a 	mov	r2,r3
            if (i < subindex)
   247b0:	313fd02e 	bgeu	r6,r4,246f4 <OBJ_GetEntryOffset+0x9c>
                bitOffset += 64;
   247b4:	18801004 	addi	r2,r3,64
   247b8:	003fce06 	br	246f4 <OBJ_GetEntryOffset+0x9c>
        return 0;
   247bc:	0005883a 	mov	r2,zero
   247c0:	f800283a 	ret
                    bitOffset += 16;
   247c4:	10800404 	addi	r2,r2,16
   247c8:	003fca06 	br	246f4 <OBJ_GetEntryOffset+0x9c>
{
   247cc:	defffe04 	addi	sp,sp,-8
   247d0:	dfc00115 	stw	ra,4(sp)
   247d4:	dc000015 	stw	r16,0(sp)
            pEntry = &pObjEntry->pEntryDesc[1];
   247d8:	29c00417 	ldw	r7,16(r5)
        if ((objCode == OBJCODE_ARR)
   247dc:	403fb61e 	bne	r8,zero,246b8 <OBJ_GetEntryOffset+0x60>
            pEntry = &pObjEntry->pEntryDesc[1];
   247e0:	39c00184 	addi	r7,r7,6
        switch (pEntry->DataType)
   247e4:	38c0000b 	ldhu	r3,0(r7)
   247e8:	1fffffcc 	andi	ra,r3,65535
   247ec:	fc000c28 	cmpgeui	r16,ra,48
   247f0:	803fd51e 	bne	r16,zero,24748 <OBJ_GetEntryOffset+0xf0>
   247f4:	fc000468 	cmpgeui	r16,ra,17
   247f8:	803fb11e 	bne	r16,zero,246c0 <OBJ_GetEntryOffset+0x68>
   247fc:	18ffff44 	addi	r3,r3,-3
   24800:	18ffffcc 	andi	r3,r3,65535
   24804:	18c00268 	cmpgeui	r3,r3,9
   24808:	183fc226 	beq	r3,zero,24714 <OBJ_GetEntryOffset+0xbc>
            if (i < subindex)
   2480c:	313fb92e 	bgeu	r6,r4,246f4 <OBJ_GetEntryOffset+0x9c>
   24810:	003fcb06 	br	24740 <OBJ_GetEntryOffset+0xe8>

00024814 <CheckSyncTypeValue>:

 \brief    Checks if the new Sync type value is valid
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
{
    switch (NewSyncType)
   24814:	297fffcc 	andi	r5,r5,65535
   24818:	288000a0 	cmpeqi	r2,r5,2
   2481c:	1000281e 	bne	r2,zero,248c0 <CheckSyncTypeValue+0xac>
   24820:	288000e8 	cmpgeui	r2,r5,3
   24824:	1000031e 	bne	r2,zero,24834 <CheckSyncTypeValue+0x20>
   24828:	2800081e 	bne	r5,zero,2484c <CheckSyncTypeValue+0x38>
    {
    case SYNCTYPE_FREERUN:
        return 0; //free run sync mode is always accepted
   2482c:	0005883a 	mov	r2,zero
   24830:	f800283a 	ret
    switch (NewSyncType)
   24834:	288000e0 	cmpeqi	r2,r5,3
   24838:	10002d1e 	bne	r2,zero,248f0 <CheckSyncTypeValue+0xdc>
   2483c:	294008a0 	cmpeqi	r5,r5,34
   24840:	2800161e 	bne	r5,zero,2489c <CheckSyncTypeValue+0x88>
        {
            return 0;
        }
        break;
    } //switch 
    return ABORTIDX_VALUE_EXCEEDED;
   24844:	00800484 	movi	r2,18

}
   24848:	f800283a 	ret
        if ((index == 0x1C32) 
   2484c:	213fffcc 	andi	r4,r4,65535
   24850:	20870c98 	cmpnei	r2,r4,7218
   24854:	1000071e 	bne	r2,zero,24874 <CheckSyncTypeValue+0x60>
            && (nPdOutputSize > 0) 
   24858:	d0a1520b 	ldhu	r2,-31416(gp)
   2485c:	103ff926 	beq	r2,zero,24844 <CheckSyncTypeValue+0x30>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
   24860:	008000f4 	movhi	r2,3
   24864:	10a1ee0b 	ldhu	r2,-30792(r2)
   24868:	1080008c 	andi	r2,r2,2
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   2486c:	103ff526 	beq	r2,zero,24844 <CheckSyncTypeValue+0x30>
   24870:	003fee06 	br	2482c <CheckSyncTypeValue+0x18>
        if ((index == 0x1C33) 
   24874:	21070cd8 	cmpnei	r4,r4,7219
   24878:	203ff21e 	bne	r4,zero,24844 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   2487c:	008000f4 	movhi	r2,3
   24880:	10a1dd0b 	ldhu	r2,-30860(r2)
   24884:	1080008c 	andi	r2,r2,2
   24888:	103fee26 	beq	r2,zero,24844 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize == 0) 
   2488c:	d0a1520b 	ldhu	r2,-31416(gp)
   24890:	103fec1e 	bne	r2,zero,24844 <CheckSyncTypeValue+0x30>
            && (nPdInputSize > 0))
   24894:	d0a1528b 	ldhu	r2,-31414(gp)
   24898:	003ff406 	br	2486c <CheckSyncTypeValue+0x58>
        if ((index == 0x1C33) 
   2489c:	213fffcc 	andi	r4,r4,65535
   248a0:	21070cd8 	cmpnei	r4,r4,7219
   248a4:	203fe71e 	bne	r4,zero,24844 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   248a8:	008000f4 	movhi	r2,3
   248ac:	10a1dd0b 	ldhu	r2,-30860(r2)
   248b0:	1080008c 	andi	r2,r2,2
   248b4:	103fe326 	beq	r2,zero,24844 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize > 0))
   248b8:	d0a1520b 	ldhu	r2,-31416(gp)
   248bc:	003feb06 	br	2486c <CheckSyncTypeValue+0x58>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   248c0:	213fffcc 	andi	r4,r4,65535
   248c4:	20870c98 	cmpnei	r2,r4,7218
   248c8:	1000041e 	bne	r2,zero,248dc <CheckSyncTypeValue+0xc8>
   248cc:	008000f4 	movhi	r2,3
   248d0:	10a1ee0b 	ldhu	r2,-30792(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   248d4:	1080010c 	andi	r2,r2,4
   248d8:	003fe406 	br	2486c <CheckSyncTypeValue+0x58>
   248dc:	21070cd8 	cmpnei	r4,r4,7219
   248e0:	203fd81e 	bne	r4,zero,24844 <CheckSyncTypeValue+0x30>
   248e4:	008000f4 	movhi	r2,3
   248e8:	10a1dd0b 	ldhu	r2,-30860(r2)
   248ec:	003ff906 	br	248d4 <CheckSyncTypeValue+0xc0>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   248f0:	213fffcc 	andi	r4,r4,65535
   248f4:	20870c98 	cmpnei	r2,r4,7218
   248f8:	1000041e 	bne	r2,zero,2490c <CheckSyncTypeValue+0xf8>
   248fc:	008000f4 	movhi	r2,3
   24900:	10a1ee0b 	ldhu	r2,-30792(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24904:	1080020c 	andi	r2,r2,8
   24908:	003fd806 	br	2486c <CheckSyncTypeValue+0x58>
   2490c:	21070cd8 	cmpnei	r4,r4,7219
   24910:	203fcc1e 	bne	r4,zero,24844 <CheckSyncTypeValue+0x30>
   24914:	008000f4 	movhi	r2,3
   24918:	10a1dd0b 	ldhu	r2,-30860(r2)
   2491c:	003ff906 	br	24904 <CheckSyncTypeValue+0xf0>

00024920 <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
   24920:	defff004 	addi	sp,sp,-64
   24924:	dd400b15 	stw	r21,44(sp)
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24928:	3d40030b 	ldhu	r21,12(r7)
{
   2492c:	df000e15 	stw	fp,56(sp)
   24930:	ddc00d15 	stw	r23,52(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24934:	a804d23a 	srli	r2,r21,8
{
   24938:	dd800c15 	stw	r22,48(sp)
   2493c:	dd000a15 	stw	r20,40(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24940:	108003cc 	andi	r2,r2,15
{
   24944:	dcc00915 	stw	r19,36(sp)
   24948:	dc400715 	stw	r17,28(sp)
   2494c:	dc000615 	stw	r16,24(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24950:	102f883a 	mov	r23,r2
{
   24954:	dfc00f15 	stw	ra,60(sp)
   24958:	dc800815 	stw	r18,32(sp)
   2495c:	d9800115 	stw	r6,4(sp)
   24960:	d900008d 	sth	r4,2(sp)
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24964:	108001e0 	cmpeqi	r2,r2,7
{
   24968:	dd801017 	ldw	r22,64(sp)
   2496c:	dcc01103 	ldbu	r19,68(sp)
   24970:	2023883a 	mov	r17,r4
   24974:	2839883a 	mov	fp,r5
   24978:	3821883a 	mov	r16,r7
    UINT16 i = subindex;
   2497c:	2d003fcc 	andi	r20,r5,255
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   24980:	ad403fcc 	andi	r21,r21,255
    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24984:	1000191e 	bne	r2,zero,249ec <OBJ_Read+0xcc>
   24988:	20bfffcc 	andi	r2,r4,65535
   2498c:	10840030 	cmpltui	r2,r2,4096
   24990:	1000161e 	bne	r2,zero,249ec <OBJ_Read+0xcc>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
   24994:	38800617 	ldw	r2,24(r7)
   24998:	14800003 	ldbu	r18,0(r2)
   2499c:	902b883a 	mov	r21,r18

    }

    if ( bCompleteAccess )
   249a0:	9800211e 	bne	r19,zero,24a28 <OBJ_Read+0x108>

        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
    }
    else
        if ( subindex > maxSubindex )
   249a4:	a0bfffcc 	andi	r2,r20,65535
   249a8:	a93fffcc 	andi	r4,r21,65535
   249ac:	20815c36 	bltu	r4,r2,24f20 <OBJ_Read+0x600>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   249b0:	8009883a 	mov	r4,r16
   249b4:	e1403fcc 	andi	r5,fp,255
   249b8:	002441c0 	call	2441c <OBJ_GetEntryDesc>

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
   249bc:	1100010b 	ldhu	r4,4(r2)
   249c0:	20bfffcc 	andi	r2,r4,65535
   249c4:	10000a26 	beq	r2,zero,249f0 <OBJ_Read+0xd0>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
   249c8:	2004907a 	slli	r2,r4,1
   249cc:	d16150c3 	ldbu	r5,-31421(gp)
   249d0:	1144703a 	and	r2,r2,r5
   249d4:	1080038c 	andi	r2,r2,14
   249d8:	1000191e 	bne	r2,zero,24a40 <OBJ_Read+0x120>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   249dc:	210001cc 	andi	r4,r4,7
   249e0:	2001511e 	bne	r4,zero,24f28 <OBJ_Read+0x608>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
   249e4:	07000184 	movi	fp,6
   249e8:	00000206 	br	249f4 <OBJ_Read+0xd4>
    if ( bCompleteAccess )
   249ec:	983fed26 	beq	r19,zero,249a4 <OBJ_Read+0x84>
            return ABORTIDX_UNSUPPORTED_ACCESS;
   249f0:	07000144 	movi	fp,5
                return result;
            }
        }

    return 0;
}
   249f4:	e005883a 	mov	r2,fp
   249f8:	dfc00f17 	ldw	ra,60(sp)
   249fc:	df000e17 	ldw	fp,56(sp)
   24a00:	ddc00d17 	ldw	r23,52(sp)
   24a04:	dd800c17 	ldw	r22,48(sp)
   24a08:	dd400b17 	ldw	r21,44(sp)
   24a0c:	dd000a17 	ldw	r20,40(sp)
   24a10:	dcc00917 	ldw	r19,36(sp)
   24a14:	dc800817 	ldw	r18,32(sp)
   24a18:	dc400717 	ldw	r17,28(sp)
   24a1c:	dc000617 	ldw	r16,24(sp)
   24a20:	dec01004 	addi	sp,sp,64
   24a24:	f800283a 	ret
        if (pAPPL_CoeReadInd != NULL)
   24a28:	d0a14817 	ldw	r2,-31456(gp)
   24a2c:	1000071e 	bne	r2,zero,24a4c <OBJ_Read+0x12c>
        if ( pObjEntry->Read != NULL )
   24a30:	38800717 	ldw	r2,28(r7)
   24a34:	10000b1e 	bne	r2,zero,24a64 <OBJ_Read+0x144>
    UINT16 i = subindex;
   24a38:	a023883a 	mov	r17,r20
   24a3c:	00002006 	br	24ac0 <OBJ_Read+0x1a0>
        if (pAPPL_CoeReadInd != NULL)
   24a40:	d0a14817 	ldw	r2,-31456(gp)
    UINT16 lastSubindex = subindex;
   24a44:	a025883a 	mov	r18,r20
        if (pAPPL_CoeReadInd != NULL)
   24a48:	10000426 	beq	r2,zero,24a5c <OBJ_Read+0x13c>
            pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
   24a4c:	980d883a 	mov	r6,r19
   24a50:	e1403fcc 	andi	r5,fp,255
   24a54:	893fffcc 	andi	r4,r17,65535
   24a58:	103ee83a 	callr	r2
        if ( pObjEntry->Read != NULL )
   24a5c:	80800717 	ldw	r2,28(r16)
   24a60:	10001126 	beq	r2,zero,24aa8 <OBJ_Read+0x188>
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24a64:	d9800117 	ldw	r6,4(sp)
   24a68:	b00f883a 	mov	r7,r22
   24a6c:	e1403fcc 	andi	r5,fp,255
   24a70:	893fffcc 	andi	r4,r17,65535
   24a74:	dcc01015 	stw	r19,64(sp)
}
   24a78:	dfc00f17 	ldw	ra,60(sp)
   24a7c:	df000e17 	ldw	fp,56(sp)
   24a80:	ddc00d17 	ldw	r23,52(sp)
   24a84:	dd800c17 	ldw	r22,48(sp)
   24a88:	dd400b17 	ldw	r21,44(sp)
   24a8c:	dd000a17 	ldw	r20,40(sp)
   24a90:	dcc00917 	ldw	r19,36(sp)
   24a94:	dc800817 	ldw	r18,32(sp)
   24a98:	dc400717 	ldw	r17,28(sp)
   24a9c:	dc000617 	ldw	r16,24(sp)
   24aa0:	dec01004 	addi	sp,sp,64
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24aa4:	1000683a 	jmp	r2
        else if ( index < 0x1000 && subindex != 0 )
   24aa8:	88ffffcc 	andi	r3,r17,65535
   24aac:	18c40028 	cmpgeui	r3,r3,4096
   24ab0:	183fe11e 	bne	r3,zero,24a38 <OBJ_Read+0x118>
   24ab4:	e7003fcc 	andi	fp,fp,255
   24ab8:	e000111e 	bne	fp,zero,24b00 <OBJ_Read+0x1e0>
            for (i = subindex; i <= lastSubindex; i++)
   24abc:	0023883a 	mov	r17,zero
                else if ( index >= 0x1000 )
   24ac0:	d880008b 	ldhu	r2,2(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24ac4:	bdc03fcc 	andi	r23,r23,255
   24ac8:	8c7fffcc 	andi	r17,r17,65535
                else if ( index >= 0x1000 )
   24acc:	10840030 	cmpltui	r2,r2,4096
   24ad0:	d8800215 	stw	r2,8(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24ad4:	b88001e0 	cmpeqi	r2,r23,7
                            bRead = 1;
   24ad8:	0039883a 	mov	fp,zero
   24adc:	000d883a 	mov	r6,zero
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24ae0:	d8800315 	stw	r2,12(sp)
            for (i = subindex; i <= lastSubindex; i++)
   24ae4:	dc40008d 	sth	r17,2(sp)
   24ae8:	88bfffcc 	andi	r2,r17,65535
   24aec:	90ffffcc 	andi	r3,r18,65535
   24af0:	1880392e 	bgeu	r3,r2,24bd8 <OBJ_Read+0x2b8>
            if(bRead == 0)
   24af4:	30803fcc 	andi	r2,r6,255
   24af8:	1000221e 	bne	r2,zero,24b84 <OBJ_Read+0x264>
   24afc:	003fbd06 	br	249f4 <OBJ_Read+0xd4>
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24b00:	e00b883a 	mov	r5,fp
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   24b04:	84400617 	ldw	r17,24(r16)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24b08:	e03890ba 	slli	fp,fp,2
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24b0c:	8009883a 	mov	r4,r16
   24b10:	002441c0 	call	2441c <OBJ_GetEntryDesc>
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24b14:	8f23883a 	add	r17,r17,fp
            size = BIT2BYTE(pEntry->BitLength);
   24b18:	1180008b 	ldhu	r6,2(r2)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24b1c:	897fff17 	ldw	r5,-4(r17)
            size = BIT2BYTE(pEntry->BitLength);
   24b20:	318001c4 	addi	r6,r6,7
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   24b24:	2880004c 	andi	r2,r5,1
            size = BIT2BYTE(pEntry->BitLength);
   24b28:	300dd0fa 	srai	r6,r6,3
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   24b2c:	10002126 	beq	r2,zero,24bb4 <OBJ_Read+0x294>
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   24b30:	00bfff84 	movi	r2,-2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b34:	3006d07a 	srli	r3,r6,1
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   24b38:	288a703a 	and	r5,r5,r2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b3c:	b009883a 	mov	r4,r22
   24b40:	0011883a 	mov	r8,zero
   24b44:	2d95c83a 	sub	r10,r5,r22
   24b48:	40bfffcc 	andi	r2,r8,65535
   24b4c:	2293883a 	add	r9,r4,r10
   24b50:	18800e1e 	bne	r3,r2,24b8c <OBJ_Read+0x26c>
                if((size % 2) == 1)
   24b54:	3180004c 	andi	r6,r6,1
   24b58:	30000a26 	beq	r6,zero,24b84 <OBJ_Read+0x264>
   24b5c:	1806907a 	slli	r3,r3,1
   24b60:	b0cf883a 	add	r7,r22,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   24b64:	3880000b 	ldhu	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   24b68:	28cb883a 	add	r5,r5,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   24b6c:	10bfc00c 	andi	r2,r2,65280
   24b70:	3880000d 	sth	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   24b74:	28c0000b 	ldhu	r3,0(r5)
   24b78:	1806d23a 	srli	r3,r3,8
   24b7c:	10c4b03a 	or	r2,r2,r3
   24b80:	3880000d 	sth	r2,0(r7)
    return 0;
   24b84:	0039883a 	mov	fp,zero
   24b88:	003f9a06 	br	249f4 <OBJ_Read+0xd4>
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   24b8c:	4880000b 	ldhu	r2,0(r9)
                    pData++;
   24b90:	21000084 	addi	r4,r4,2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b94:	42000044 	addi	r8,r8,1
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   24b98:	1004d23a 	srli	r2,r2,8
   24b9c:	20bfff8d 	sth	r2,-2(r4)
                    pData[0] |= (pVarPtr[1] & 0xFF) << 8;
   24ba0:	4a40008b 	ldhu	r9,2(r9)
   24ba4:	4812923a 	slli	r9,r9,8
   24ba8:	1244b03a 	or	r2,r2,r9
   24bac:	20bfff8d 	sth	r2,-2(r4)
                for(cnt = 0; cnt < (size / 2);cnt++)
   24bb0:	003fe506 	br	24b48 <OBJ_Read+0x228>
            pData[0] = pVarPtr[0];
   24bb4:	2880000b 	ldhu	r2,0(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24bb8:	31bfff04 	addi	r6,r6,-4
   24bbc:	29400104 	addi	r5,r5,4
            pData[0] = pVarPtr[0];
   24bc0:	b080000d 	sth	r2,0(r22)
            pData[1] = pVarPtr[1];
   24bc4:	28bfff8b 	ldhu	r2,-2(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24bc8:	b1000104 	addi	r4,r22,4
            pData[1] = pVarPtr[1];
   24bcc:	b080008d 	sth	r2,2(r22)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24bd0:	0026ee40 	call	26ee4 <memcpy>
   24bd4:	003feb06 	br	24b84 <OBJ_Read+0x264>
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   24bd8:	80c00617 	ldw	r3,24(r16)
   24bdc:	d8c00115 	stw	r3,4(sp)
                if (i == 0)
   24be0:	10002226 	beq	r2,zero,24c6c <OBJ_Read+0x34c>
                else if ( index >= 0x1000 )
   24be4:	d8800217 	ldw	r2,8(sp)
   24be8:	1000221e 	bne	r2,zero,24c74 <OBJ_Read+0x354>
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   24bec:	800b883a 	mov	r5,r16
   24bf0:	8809883a 	mov	r4,r17
   24bf4:	d9800415 	stw	r6,16(sp)
   24bf8:	00246580 	call	24658 <OBJ_GetEntryOffset>
   24bfc:	d9800417 	ldw	r6,16(sp)
   24c00:	1007883a 	mov	r3,r2
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   24c04:	8009883a 	mov	r4,r16
   24c08:	880b883a 	mov	r5,r17
   24c0c:	d8c00515 	stw	r3,20(sp)
   24c10:	d9800415 	stw	r6,16(sp)
   24c14:	002441c0 	call	2441c <OBJ_GetEntryDesc>
   24c18:	102f883a 	mov	r23,r2
                if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
   24c1c:	10800103 	ldbu	r2,4(r2)
   24c20:	d12150c3 	ldbu	r4,-31421(gp)
   24c24:	d9800417 	ldw	r6,16(sp)
   24c28:	1004907a 	slli	r2,r2,1
   24c2c:	d8c00517 	ldw	r3,20(sp)
   24c30:	1104703a 	and	r2,r2,r4
   24c34:	1080038c 	andi	r2,r2,14
   24c38:	10009e26 	beq	r2,zero,24eb4 <OBJ_Read+0x594>
                    if ( i == subindex                                     /* requested entry */
   24c3c:	d880008b 	ldhu	r2,2(sp)
   24c40:	a13fffcc 	andi	r4,r20,65535
   24c44:	11000226 	beq	r2,r4,24c50 <OBJ_Read+0x330>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   24c48:	98000626 	beq	r19,zero,24c64 <OBJ_Read+0x344>
   24c4c:	11000536 	bltu	r2,r4,24c64 <OBJ_Read+0x344>
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24c50:	10000a1e 	bne	r2,zero,24c7c <OBJ_Read+0x35c>
   24c54:	d8800317 	ldw	r2,12(sp)
   24c58:	1000081e 	bne	r2,zero,24c7c <OBJ_Read+0x35c>
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
   24c5c:	b540000d 	sth	r21,0(r22)
                            pData++;
   24c60:	b5800084 	addi	r22,r22,2
            for (i = subindex; i <= lastSubindex; i++)
   24c64:	8c400044 	addi	r17,r17,1
   24c68:	003f9e06 	br	24ae4 <OBJ_Read+0x1c4>
                UINT16 bitOffset = 0;
   24c6c:	8807883a 	mov	r3,r17
   24c70:	003fe406 	br	24c04 <OBJ_Read+0x2e4>
   24c74:	0007883a 	mov	r3,zero
   24c78:	003fe206 	br	24c04 <OBJ_Read+0x2e4>
                pVarPtr += (bitOffset >> 4);
   24c7c:	180ad0fa 	srli	r5,r3,3
   24c80:	d8800117 	ldw	r2,4(sp)
                            UINT16 dataType = pEntry->DataType;
   24c84:	b900000b 	ldhu	r4,0(r23)
                pVarPtr += (bitOffset >> 4);
   24c88:	2947ff8c 	andi	r5,r5,8190
   24c8c:	114b883a 	add	r5,r2,r5
                            if (pEntry->DataType >= 0x700)
   24c90:	20bfffcc 	andi	r2,r4,65535
   24c94:	1181c030 	cmpltui	r6,r2,1792
   24c98:	3000201e 	bne	r6,zero,24d1c <OBJ_Read+0x3fc>
                                if ( pEntry->BitLength <= 8 )
   24c9c:	b900008b 	ldhu	r4,2(r23)
   24ca0:	20bfffcc 	andi	r2,r4,65535
   24ca4:	11800268 	cmpgeui	r6,r2,9
   24ca8:	3000161e 	bne	r6,zero,24d04 <OBJ_Read+0x3e4>
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   24cac:	21000bc4 	addi	r4,r4,47
                            switch (dataType)
   24cb0:	213ff884 	addi	r4,r4,-30
   24cb4:	213fffcc 	andi	r4,r4,65535
   24cb8:	00800044 	movi	r2,1
   24cbc:	1104983a 	sll	r2,r2,r4
   24cc0:	0100ff74 	movhi	r4,1021
   24cc4:	21200044 	addi	r4,r4,-32767
   24cc8:	1108703a 	and	r4,r2,r4
   24ccc:	2000591e 	bne	r4,zero,24e34 <OBJ_Read+0x514>
   24cd0:	010000b4 	movhi	r4,2
   24cd4:	21000104 	addi	r4,r4,4
   24cd8:	1108703a 	and	r4,r2,r4
   24cdc:	20006d1e 	bne	r4,zero,24e94 <OBJ_Read+0x574>
   24ce0:	01000074 	movhi	r4,1
   24ce4:	21000084 	addi	r4,r4,2
   24ce8:	1104703a 	and	r2,r2,r4
   24cec:	10000926 	beq	r2,zero,24d14 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24cf0:	18c003cc 	andi	r3,r3,15
   24cf4:	183f3e1e 	bne	r3,zero,249f0 <OBJ_Read+0xd0>
                                pData[0] = SWAPWORD(pVarPtr[0]);
   24cf8:	2880000b 	ldhu	r2,0(r5)
   24cfc:	b080000d 	sth	r2,0(r22)
   24d00:	00005f06 	br	24e80 <OBJ_Read+0x560>
                                else if ( pEntry->BitLength == 16 )
   24d04:	11000420 	cmpeqi	r4,r2,16
   24d08:	203ff91e 	bne	r4,zero,24cf0 <OBJ_Read+0x3d0>
                                else if ( pEntry->BitLength == 32 )
   24d0c:	10800820 	cmpeqi	r2,r2,32
   24d10:	1000601e 	bne	r2,zero,24e94 <OBJ_Read+0x574>
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   24d14:	07000604 	movi	fp,24
   24d18:	003f3606 	br	249f4 <OBJ_Read+0xd4>
                            switch (dataType)
   24d1c:	11800328 	cmpgeui	r6,r2,12
   24d20:	30000d1e 	bne	r6,zero,24d58 <OBJ_Read+0x438>
   24d24:	110002a8 	cmpgeui	r4,r2,10
   24d28:	2000241e 	bne	r4,zero,24dbc <OBJ_Read+0x49c>
   24d2c:	11000260 	cmpeqi	r4,r2,9
   24d30:	2000221e 	bne	r4,zero,24dbc <OBJ_Read+0x49c>
   24d34:	10003126 	beq	r2,zero,24dfc <OBJ_Read+0x4dc>
   24d38:	01000044 	movi	r4,1
   24d3c:	2084983a 	sll	r2,r4,r2
   24d40:	1100640c 	andi	r4,r2,400
   24d44:	2000531e 	bne	r4,zero,24e94 <OBJ_Read+0x574>
   24d48:	1100098c 	andi	r4,r2,38
   24d4c:	2000391e 	bne	r4,zero,24e34 <OBJ_Read+0x514>
   24d50:	1080120c 	andi	r2,r2,72
   24d54:	003fe506 	br	24cec <OBJ_Read+0x3cc>
   24d58:	11800e28 	cmpgeui	r6,r2,56
   24d5c:	3000131e 	bne	r6,zero,24dac <OBJ_Read+0x48c>
   24d60:	118007a8 	cmpgeui	r6,r2,30
   24d64:	303fd21e 	bne	r6,zero,24cb0 <OBJ_Read+0x390>
   24d68:	213ffecc 	andi	r4,r4,65531
   24d6c:	21000460 	cmpeqi	r4,r4,17
   24d70:	2000021e 	bne	r4,zero,24d7c <OBJ_Read+0x45c>
   24d74:	108006e0 	cmpeqi	r2,r2,27
   24d78:	103fe626 	beq	r2,zero,24d14 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24d7c:	18c003cc 	andi	r3,r3,15
   24d80:	183f1b1e 	bne	r3,zero,249f0 <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   24d84:	2880000b 	ldhu	r2,0(r5)
                                pData += 4;
   24d88:	b5800204 	addi	r22,r22,8
                                pData[0] = pVarPtr[0];
   24d8c:	b0bffe0d 	sth	r2,-8(r22)
                                pData[1] = pVarPtr[1];
   24d90:	2880008b 	ldhu	r2,2(r5)
   24d94:	b0bffe8d 	sth	r2,-6(r22)
                                pData[2] = pVarPtr[2];
   24d98:	2880010b 	ldhu	r2,4(r5)
   24d9c:	b0bfff0d 	sth	r2,-4(r22)
                                pData[3] = pVarPtr[3];
   24da0:	2880018b 	ldhu	r2,6(r5)
   24da4:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   24da8:	00002006 	br	24e2c <OBJ_Read+0x50c>
                            switch (dataType)
   24dac:	213f6804 	addi	r4,r4,-608
   24db0:	213fffcc 	andi	r4,r4,65535
   24db4:	21000128 	cmpgeui	r4,r4,4
   24db8:	203fd61e 	bne	r4,zero,24d14 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24dbc:	18c003cc 	andi	r3,r3,15
   24dc0:	183f0b1e 	bne	r3,zero,249f0 <OBJ_Read+0xd0>
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
   24dc4:	b980008b 	ldhu	r6,2(r23)
   24dc8:	b009883a 	mov	r4,r22
   24dcc:	318001c4 	addi	r6,r6,7
   24dd0:	300cd0fa 	srli	r6,r6,3
   24dd4:	0026ee40 	call	26ee4 <memcpy>
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   24dd8:	b880008b 	ldhu	r2,2(r23)
   24ddc:	10fffc0c 	andi	r3,r2,65520
   24de0:	1806d0fa 	srli	r3,r3,3
                                if((pEntry->BitLength & 0xF) != 0)
   24de4:	108003cc 	andi	r2,r2,15
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   24de8:	b0ed883a 	add	r22,r22,r3
                                if((pEntry->BitLength & 0xF) != 0)
   24dec:	10000f26 	beq	r2,zero,24e2c <OBJ_Read+0x50c>
                                    *pData &= 0xFF;
   24df0:	b0800003 	ldbu	r2,0(r22)
   24df4:	b080000d 	sth	r2,0(r22)
   24df8:	00000c06 	br	24e2c <OBJ_Read+0x50c>
                                if(bCompleteAccess)
   24dfc:	983fc526 	beq	r19,zero,24d14 <OBJ_Read+0x3f4>
                                    if (((pEntry->BitLength & 0xF) > 0)
   24e00:	b880008b 	ldhu	r2,2(r23)
   24e04:	114003cc 	andi	r5,r2,15
   24e08:	113fffcc 	andi	r4,r2,65535
   24e0c:	28000426 	beq	r5,zero,24e20 <OBJ_Read+0x500>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   24e10:	10c5883a 	add	r2,r2,r3
   24e14:	108003cc 	andi	r2,r2,15
   24e18:	1000011e 	bne	r2,zero,24e20 <OBJ_Read+0x500>
                                        pData++;
   24e1c:	b5800084 	addi	r22,r22,2
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
   24e20:	2004d0fa 	srli	r2,r4,3
   24e24:	1080078c 	andi	r2,r2,30
   24e28:	b0ad883a 	add	r22,r22,r2
                            bRead = 1;
   24e2c:	01800044 	movi	r6,1
   24e30:	003f8c06 	br	24c64 <OBJ_Read+0x344>
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   24e34:	b900008b 	ldhu	r4,2(r23)
   24e38:	008000b4 	movhi	r2,2
   24e3c:	198003cc 	andi	r6,r3,15
   24e40:	2008907a 	slli	r4,r4,1
                                    TmpValue = SWAPWORD(pVarPtr[0]);
   24e44:	2940000b 	ldhu	r5,0(r5)
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   24e48:	2085883a 	add	r2,r4,r2
   24e4c:	109efe0b 	ldhu	r2,31736(r2)
   24e50:	1184983a 	sll	r2,r2,r6
                                    if ((bitOffset & 0x0F) == 0) 
   24e54:	3000011e 	bne	r6,zero,24e5c <OBJ_Read+0x53c>
                                        pData[0] = 0;
   24e58:	b000000d 	sth	zero,0(r22)
                                    pData[0] = SWAPWORD(pData[0]);
   24e5c:	b100000b 	ldhu	r4,0(r22)
                                        pData[0] |= TmpValue & bitMask;
   24e60:	1144703a 	and	r2,r2,r5
                                    if (bCompleteAccess) 
   24e64:	98000826 	beq	r19,zero,24e88 <OBJ_Read+0x568>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   24e68:	1104b03a 	or	r2,r2,r4
                                        pData[0] |= TmpValue & bitMask;
   24e6c:	b080000d 	sth	r2,0(r22)
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
   24e70:	b880008b 	ldhu	r2,2(r23)
   24e74:	10c5883a 	add	r2,r2,r3
   24e78:	108003cc 	andi	r2,r2,15
   24e7c:	103feb1e 	bne	r2,zero,24e2c <OBJ_Read+0x50c>
                                pData++;
   24e80:	b5800084 	addi	r22,r22,2
                                break;
   24e84:	003fe906 	br	24e2c <OBJ_Read+0x50c>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   24e88:	10bfffcc 	andi	r2,r2,65535
   24e8c:	1185d83a 	sra	r2,r2,r6
   24e90:	003ff506 	br	24e68 <OBJ_Read+0x548>
                                if(bitOffset & 0xF)
   24e94:	18c003cc 	andi	r3,r3,15
   24e98:	183ed51e 	bne	r3,zero,249f0 <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   24e9c:	2880000b 	ldhu	r2,0(r5)
                                pData += 2;
   24ea0:	b5800104 	addi	r22,r22,4
                                pData[0] = pVarPtr[0];
   24ea4:	b0bfff0d 	sth	r2,-4(r22)
                                pData[1] = pVarPtr[1];
   24ea8:	2880008b 	ldhu	r2,2(r5)
   24eac:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   24eb0:	003fde06 	br	24e2c <OBJ_Read+0x50c>
                    if ((bitOffset & 0x0F) == 0) 
   24eb4:	188003cc 	andi	r2,r3,15
   24eb8:	1000011e 	bne	r2,zero,24ec0 <OBJ_Read+0x5a0>
                        *pData = 0;
   24ebc:	b000000d 	sth	zero,0(r22)
                    if (((pEntry->BitLength & 0xF) > 0)
   24ec0:	b880008b 	ldhu	r2,2(r23)
   24ec4:	110003cc 	andi	r4,r2,15
   24ec8:	20000526 	beq	r4,zero,24ee0 <OBJ_Read+0x5c0>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   24ecc:	10c5883a 	add	r2,r2,r3
   24ed0:	108003cc 	andi	r2,r2,15
   24ed4:	1000021e 	bne	r2,zero,24ee0 <OBJ_Read+0x5c0>
                        *pData = 0;
   24ed8:	b000008d 	sth	zero,2(r22)
                        pData++;
   24edc:	b5800084 	addi	r22,r22,2
   24ee0:	0007883a 	mov	r3,zero
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   24ee4:	b880008b 	ldhu	r2,2(r23)
   24ee8:	1005d13a 	srai	r2,r2,4
   24eec:	108003cc 	andi	r2,r2,15
   24ef0:	18800516 	blt	r3,r2,24f08 <OBJ_Read+0x5e8>
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   24ef4:	b880010b 	ldhu	r2,4(r23)
   24ef8:	108001cc 	andi	r2,r2,7
   24efc:	1000061e 	bne	r2,zero,24f18 <OBJ_Read+0x5f8>
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
   24f00:	07000184 	movi	fp,6
   24f04:	003f5706 	br	24c64 <OBJ_Read+0x344>
                        pData++;
   24f08:	b5800084 	addi	r22,r22,2
                        *pData = 0;
   24f0c:	18c00044 	addi	r3,r3,1
   24f10:	b000000d 	sth	zero,0(r22)
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   24f14:	003ff306 	br	24ee4 <OBJ_Read+0x5c4>
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   24f18:	07000684 	movi	fp,26
   24f1c:	003f5106 	br	24c64 <OBJ_Read+0x344>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
   24f20:	07000444 	movi	fp,17
   24f24:	003eb306 	br	249f4 <OBJ_Read+0xd4>
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   24f28:	07000684 	movi	fp,26
   24f2c:	003eb106 	br	249f4 <OBJ_Read+0xd4>

00024f30 <OBJ_Write>:

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f30:	3880030b 	ldhu	r2,12(r7)
{
   24f34:	deffec04 	addi	sp,sp,-80
   24f38:	ddc01115 	stw	r23,68(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f3c:	1006d23a 	srli	r3,r2,8
    UINT16 maxSubindex = 0;
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   24f40:	10803fcc 	andi	r2,r2,255
{
   24f44:	dd801015 	stw	r22,64(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f48:	18c003cc 	andi	r3,r3,15
{
   24f4c:	dd400f15 	stw	r21,60(sp)
   24f50:	dd000e15 	stw	r20,56(sp)
   24f54:	dc800c15 	stw	r18,48(sp)
   24f58:	dc000a15 	stw	r16,40(sp)
   24f5c:	3825883a 	mov	r18,r7
   24f60:	dfc01315 	stw	ra,76(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f64:	180f883a 	mov	r7,r3
{
   24f68:	df001215 	stw	fp,72(sp)
   24f6c:	dcc00d15 	stw	r19,52(sp)
   24f70:	dc400b15 	stw	r17,44(sp)
   24f74:	d900010d 	sth	r4,4(sp)
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   24f78:	d880038d 	sth	r2,14(sp)
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
   24f7c:	18c001d8 	cmpnei	r3,r3,7
{
   24f80:	dc001417 	ldw	r16,80(sp)
   24f84:	dd001503 	ldbu	r20,84(sp)
   24f88:	202f883a 	mov	r23,r4
   24f8c:	282d883a 	mov	r22,r5
   24f90:	302b883a 	mov	r21,r6
    UINT16 i = subindex;
   24f94:	2a003fcc 	andi	r8,r5,255
    if ( objCode != OBJCODE_VAR )
   24f98:	1800271e 	bne	r3,zero,25038 <OBJ_Write+0x108>
            maxSubindex = maxConfiguredSubindex;
        }
    }


    if ( bCompleteAccess )
   24f9c:	a0007e26 	beq	r20,zero,25198 <OBJ_Write+0x268>
    {
        if ( objCode == OBJCODE_VAR )
        {
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
   24fa0:	07000144 	movi	fp,5
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
    }
    /* ECATCHANGE_END(V5.13) COE4*/

    return 0;
}
   24fa4:	e005883a 	mov	r2,fp
   24fa8:	dfc01317 	ldw	ra,76(sp)
   24fac:	df001217 	ldw	fp,72(sp)
   24fb0:	ddc01117 	ldw	r23,68(sp)
   24fb4:	dd801017 	ldw	r22,64(sp)
   24fb8:	dd400f17 	ldw	r21,60(sp)
   24fbc:	dd000e17 	ldw	r20,56(sp)
   24fc0:	dcc00d17 	ldw	r19,52(sp)
   24fc4:	dc800c17 	ldw	r18,48(sp)
   24fc8:	dc400b17 	ldw	r17,44(sp)
   24fcc:	dc000a17 	ldw	r16,40(sp)
   24fd0:	dec01404 	addi	sp,sp,80
   24fd4:	f800283a 	ret
    if ( bCompleteAccess )
   24fd8:	a001a21e 	bne	r20,zero,25664 <OBJ_Write+0x734>
   24fdc:	d9c00415 	stw	r7,16(sp)
    if (subindex > maxSubindex)
   24fe0:	40bfffcc 	andi	r2,r8,65535
   24fe4:	da000215 	stw	r8,8(sp)
   24fe8:	8c7fffcc 	andi	r17,r17,65535
   24fec:	88819536 	bltu	r17,r2,25644 <OBJ_Write+0x714>
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24ff0:	b4403fcc 	andi	r17,r22,255
   24ff4:	880b883a 	mov	r5,r17
   24ff8:	9009883a 	mov	r4,r18
   24ffc:	002441c0 	call	2441c <OBJ_GetEntryDesc>
        if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25000:	10c0010b 	ldhu	r3,4(r2)
   25004:	d16150c3 	ldbu	r5,-31421(gp)
   25008:	da000217 	ldw	r8,8(sp)
   2500c:	193fffcc 	andi	r4,r3,65535
   25010:	2005d0ba 	srai	r2,r4,2
   25014:	d9c00417 	ldw	r7,16(sp)
   25018:	1144703a 	and	r2,r2,r5
   2501c:	1080038c 	andi	r2,r2,14
   25020:	1000611e 	bne	r2,zero,251a8 <OBJ_Write+0x278>
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
   25024:	18c00e0c 	andi	r3,r3,56
   25028:	1801881e 	bne	r3,zero,2564c <OBJ_Write+0x71c>
                if (pEntry->ObjAccess == 0)
   2502c:	203fdc26 	beq	r4,zero,24fa0 <OBJ_Write+0x70>
                        return ABORTIDX_READ_ONLY_ENTRY;
   25030:	070001c4 	movi	fp,7
   25034:	003fdb06 	br	24fa4 <OBJ_Write+0x74>
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   25038:	90c00617 	ldw	r3,24(r18)
   2503c:	18c00003 	ldbu	r3,0(r3)
   25040:	1823883a 	mov	r17,r3
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   25044:	1800331e 	bne	r3,zero,25114 <OBJ_Write+0x1e4>
   25048:	20f8fc04 	addi	r3,r4,-7184
   2504c:	18ffffcc 	andi	r3,r3,65535
   25050:	18c00830 	cmpltui	r3,r3,32
   25054:	1800081e 	bne	r3,zero,25078 <OBJ_Write+0x148>
   25058:	20fa8004 	addi	r3,r4,-5632
   2505c:	18ffffcc 	andi	r3,r3,65535
   25060:	18c08030 	cmpltui	r3,r3,512
   25064:	1800041e 	bne	r3,zero,25078 <OBJ_Write+0x148>
   25068:	20f98004 	addi	r3,r4,-6656
   2506c:	18ffffcc 	andi	r3,r3,65535
   25070:	18c08028 	cmpgeui	r3,r3,512
   25074:	18001b1e 	bne	r3,zero,250e4 <OBJ_Write+0x1b4>
    if ( bCompleteAccess )
   25078:	a0004926 	beq	r20,zero,251a0 <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   2507c:	b0c03fcc 	andi	r3,r22,255
   25080:	18002726 	beq	r3,zero,25120 <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   25084:	1023883a 	mov	r17,r2
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
   25088:	90800617 	ldw	r2,24(r18)
        if(Subindex0 != 0x00)
   2508c:	14c00003 	ldbu	r19,0(r2)
   25090:	9826c03a 	cmpne	r19,r19,zero
    if ( pObjEntry->Write != NULL )
   25094:	90800817 	ldw	r2,32(r18)
   25098:	10005526 	beq	r2,zero,251f0 <OBJ_Write+0x2c0>
        result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
   2509c:	bdffffcc 	andi	r23,r23,65535
   250a0:	b5803fcc 	andi	r22,r22,255
   250a4:	dd000015 	stw	r20,0(sp)
   250a8:	800f883a 	mov	r7,r16
   250ac:	a80d883a 	mov	r6,r21
   250b0:	b00b883a 	mov	r5,r22
   250b4:	b809883a 	mov	r4,r23
   250b8:	103ee83a 	callr	r2
   250bc:	1039883a 	mov	fp,r2
        if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
   250c0:	10803fcc 	andi	r2,r2,255
   250c4:	103fb71e 	bne	r2,zero,24fa4 <OBJ_Write+0x74>
   250c8:	d0a14717 	ldw	r2,-31460(gp)
   250cc:	10001726 	beq	r2,zero,2512c <OBJ_Write+0x1fc>
            pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   250d0:	a00d883a 	mov	r6,r20
   250d4:	b00b883a 	mov	r5,r22
   250d8:	b809883a 	mov	r4,r23
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   250dc:	103ee83a 	callr	r2
   250e0:	00001206 	br	2512c <OBJ_Write+0x1fc>
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   250e4:	20ffffcc 	andi	r3,r4,65535
   250e8:	013c0c14 	movui	r4,61488
   250ec:	193fba1e 	bne	r3,r4,24fd8 <OBJ_Write+0xa8>
    if ( bCompleteAccess )
   250f0:	a0002b26 	beq	r20,zero,251a0 <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   250f4:	28c03fcc 	andi	r3,r5,255
   250f8:	18000926 	beq	r3,zero,25120 <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   250fc:	1023883a 	mov	r17,r2
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   25100:	b8bfffcc 	andi	r2,r23,65535
   25104:	00fc0c14 	movui	r3,61488
   25108:	10ffdf26 	beq	r2,r3,25088 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   2510c:	0027883a 	mov	r19,zero
   25110:	003fe006 	br	25094 <OBJ_Write+0x164>
    if ( bCompleteAccess )
   25114:	a03fb126 	beq	r20,zero,24fdc <OBJ_Write+0xac>
        if ((subindex == 0) && (dataSize > 0))
   25118:	28803fcc 	andi	r2,r5,255
   2511c:	1000241e 	bne	r2,zero,251b0 <OBJ_Write+0x280>
    if ( pObjEntry->Write != NULL )
   25120:	90800817 	ldw	r2,32(r18)
        if ((subindex == 0) && (dataSize > 0))
   25124:	a800031e 	bne	r21,zero,25134 <OBJ_Write+0x204>
    if ( pObjEntry->Write != NULL )
   25128:	103fdc1e 	bne	r2,zero,2509c <OBJ_Write+0x16c>
           return 0; //no error
   2512c:	0039883a 	mov	fp,zero
   25130:	003f9c06 	br	24fa4 <OBJ_Write+0x74>
    if ( pObjEntry->Write != NULL )
   25134:	103fd91e 	bne	r2,zero,2509c <OBJ_Write+0x16c>
   25138:	84400003 	ldbu	r17,0(r16)
    BOOL bClearSubindex0Required = FALSE;
   2513c:	0027883a 	mov	r19,zero
        for (i = subindex; i <= lastSubindex; i++)
   25140:	88bfffcc 	andi	r2,r17,65535
   25144:	d8800415 	stw	r2,16(sp)
   25148:	40bfffcc 	andi	r2,r8,65535
   2514c:	d8800215 	stw	r2,8(sp)
                    if (i == 0 && objCode != OBJCODE_VAR)
   25150:	38803fcc 	andi	r2,r7,255
   25154:	108001e0 	cmpeqi	r2,r2,7
   25158:	b5403fcc 	andi	r21,r22,255
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
   2515c:	070001c4 	movi	fp,7
        UINT8 bWritten = 0;
   25160:	000d883a 	mov	r6,zero
                    if (i == 0 && objCode != OBJCODE_VAR)
   25164:	d8800515 	stw	r2,20(sp)
        for (i = subindex; i <= lastSubindex; i++)
   25168:	d8800417 	ldw	r2,16(sp)
   2516c:	ab7fffcc 	andi	r13,r21,65535
   25170:	a819883a 	mov	r12,r21
   25174:	1340202e 	bgeu	r2,r13,251f8 <OBJ_Write+0x2c8>
        if (bWritten == 0)
   25178:	31803fcc 	andi	r6,r6,255
   2517c:	303f8926 	beq	r6,zero,24fa4 <OBJ_Write+0x74>
    if (pAPPL_CoeWriteInd != NULL)
   25180:	d0a14717 	ldw	r2,-31460(gp)
   25184:	103fe926 	beq	r2,zero,2512c <OBJ_Write+0x1fc>
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   25188:	a00d883a 	mov	r6,r20
   2518c:	b1403fcc 	andi	r5,r22,255
   25190:	b93fffcc 	andi	r4,r23,65535
   25194:	003fd106 	br	250dc <OBJ_Write+0x1ac>
    UINT16 maxSubindex = 0;
   25198:	0023883a 	mov	r17,zero
   2519c:	003f8f06 	br	24fdc <OBJ_Write+0xac>
            maxSubindex = maxConfiguredSubindex;
   251a0:	1023883a 	mov	r17,r2
   251a4:	003f8d06 	br	24fdc <OBJ_Write+0xac>
    if((subindex > 0) &&
   251a8:	88000e26 	beq	r17,zero,251e4 <OBJ_Write+0x2b4>
    UINT16 lastSubindex = subindex;
   251ac:	4023883a 	mov	r17,r8
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   251b0:	b8b8fc04 	addi	r2,r23,-7184
    if((subindex > 0) &&
   251b4:	10bfffcc 	andi	r2,r2,65535
   251b8:	10800830 	cmpltui	r2,r2,32
   251bc:	103fb21e 	bne	r2,zero,25088 <OBJ_Write+0x158>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   251c0:	b8ba8004 	addi	r2,r23,-5632
   251c4:	10bfffcc 	andi	r2,r2,65535
   251c8:	10808030 	cmpltui	r2,r2,512
   251cc:	103fae1e 	bne	r2,zero,25088 <OBJ_Write+0x158>
   251d0:	b8b98004 	addi	r2,r23,-6656
   251d4:	10bfffcc 	andi	r2,r2,65535
   251d8:	10808030 	cmpltui	r2,r2,512
   251dc:	103fc826 	beq	r2,zero,25100 <OBJ_Write+0x1d0>
   251e0:	003fa906 	br	25088 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   251e4:	b027883a 	mov	r19,r22
    UINT16 lastSubindex = subindex;
   251e8:	0023883a 	mov	r17,zero
   251ec:	003fa906 	br	25094 <OBJ_Write+0x164>
        if (dataSize == 0)
   251f0:	a83fd31e 	bne	r21,zero,25140 <OBJ_Write+0x210>
   251f4:	003fcd06 	br	2512c <OBJ_Write+0x1fc>
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   251f8:	91c00617 	ldw	r7,24(r18)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   251fc:	a80b883a 	mov	r5,r21
   25200:	9009883a 	mov	r4,r18
   25204:	db400915 	stw	r13,36(sp)
   25208:	d9800715 	stw	r6,28(sp)
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   2520c:	db000815 	stw	r12,32(sp)
   25210:	d9c00615 	stw	r7,24(sp)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25214:	002441c0 	call	2441c <OBJ_GetEntryDesc>
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25218:	900b883a 	mov	r5,r18
   2521c:	a809883a 	mov	r4,r21
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25220:	1023883a 	mov	r17,r2
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25224:	00246580 	call	24658 <OBJ_GetEntryOffset>
            if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25228:	8900010b 	ldhu	r4,4(r17)
   2522c:	d16150c3 	ldbu	r5,-31421(gp)
   25230:	d9800717 	ldw	r6,28(sp)
   25234:	2009d0ba 	srai	r4,r4,2
   25238:	db400917 	ldw	r13,36(sp)
   2523c:	2148703a 	and	r4,r4,r5
   25240:	2100038c 	andi	r4,r4,14
   25244:	2000f026 	beq	r4,zero,25608 <OBJ_Write+0x6d8>
                if (i != 0)
   25248:	d9c00617 	ldw	r7,24(sp)
   2524c:	db000817 	ldw	r12,32(sp)
   25250:	68000926 	beq	r13,zero,25278 <OBJ_Write+0x348>
                    pVarPtr += (bitOffset >> 4);
   25254:	1008d0fa 	srli	r4,r2,3
                if ( i == subindex                                     /* requested entry */
   25258:	d8c00217 	ldw	r3,8(sp)
                    pVarPtr += (bitOffset >> 4);
   2525c:	2107ff8c 	andi	r4,r4,8190
   25260:	390f883a 	add	r7,r7,r4
                if ( i == subindex                                     /* requested entry */
   25264:	1b400f26 	beq	r3,r13,252a4 <OBJ_Write+0x374>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25268:	a0000126 	beq	r20,zero,25270 <OBJ_Write+0x340>
   2526c:	68c00d2e 	bgeu	r13,r3,252a4 <OBJ_Write+0x374>
        for (i = subindex; i <= lastSubindex; i++)
   25270:	ad400044 	addi	r21,r21,1
   25274:	003fbc06 	br	25168 <OBJ_Write+0x238>
                if ( i == subindex                                     /* requested entry */
   25278:	d8c00217 	ldw	r3,8(sp)
   2527c:	183ffc1e 	bne	r3,zero,25270 <OBJ_Write+0x340>
                    if (i == 0 && objCode != OBJCODE_VAR)
   25280:	d8c00517 	ldw	r3,20(sp)
   25284:	1800071e 	bne	r3,zero,252a4 <OBJ_Write+0x374>
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   25288:	8100000b 	ldhu	r4,0(r16)
                        if(maxConfiguredSubindex < NewSubindex0)
   2528c:	d880038b 	ldhu	r2,14(sp)
   25290:	21403fcc 	andi	r5,r4,255
   25294:	1140ef36 	bltu	r2,r5,25654 <OBJ_Write+0x724>
                        pVarPtr[0] = SWAPWORD(pData[0]);
   25298:	3900000d 	sth	r4,0(r7)
                            pData++;
   2529c:	84000084 	addi	r16,r16,2
                            break;
   252a0:	00008d06 	br	254d8 <OBJ_Write+0x5a8>
                        UINT16 dataType = pEntry->DataType;
   252a4:	8980000b 	ldhu	r6,0(r17)
                        if (pEntry->DataType >= 0x700)
   252a8:	313fffcc 	andi	r4,r6,65535
   252ac:	2141c030 	cmpltui	r5,r4,1792
   252b0:	2800341e 	bne	r5,zero,25384 <OBJ_Write+0x454>
                            if ( pEntry->BitLength <= 8 )
   252b4:	8980008b 	ldhu	r6,2(r17)
   252b8:	313fffcc 	andi	r4,r6,65535
   252bc:	21400268 	cmpgeui	r5,r4,9
   252c0:	28002a1e 	bne	r5,zero,2536c <OBJ_Write+0x43c>
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   252c4:	31800bc4 	addi	r6,r6,47
                        switch (dataType)
   252c8:	31bff884 	addi	r6,r6,-30
   252cc:	31bfffcc 	andi	r6,r6,65535
   252d0:	01000044 	movi	r4,1
   252d4:	2188983a 	sll	r4,r4,r6
   252d8:	0140ff74 	movhi	r5,1021
   252dc:	29600044 	addi	r5,r5,-32767
   252e0:	214a703a 	and	r5,r4,r5
   252e4:	2800681e 	bne	r5,zero,25488 <OBJ_Write+0x558>
   252e8:	014000b4 	movhi	r5,2
   252ec:	29400104 	addi	r5,r5,4
   252f0:	214a703a 	and	r5,r4,r5
   252f4:	2800b41e 	bne	r5,zero,255c8 <OBJ_Write+0x698>
   252f8:	01400074 	movhi	r5,1
   252fc:	29400084 	addi	r5,r5,2
   25300:	2148703a 	and	r4,r4,r5
   25304:	20001d26 	beq	r4,zero,2537c <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25308:	108003cc 	andi	r2,r2,15
   2530c:	103f241e 	bne	r2,zero,24fa0 <OBJ_Write+0x70>
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25310:	98803fcc 	andi	r2,r19,255
                            UINT16 u16NewData = SWAPWORD(pData[0]);
   25314:	8440000b 	ldhu	r17,0(r16)
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25318:	10000326 	beq	r2,zero,25328 <OBJ_Write+0x3f8>
   2531c:	3900000b 	ldhu	r4,0(r7)
   25320:	88bfffcc 	andi	r2,r17,65535
   25324:	2080cd1e 	bne	r4,r2,2565c <OBJ_Write+0x72c>
                            if(IS_PDO_ASSIGN(index))  //PDO assign
   25328:	d8800117 	ldw	r2,4(sp)
   2532c:	10b8fc04 	addi	r2,r2,-7184
   25330:	10bfffcc 	andi	r2,r2,65535
   25334:	10800828 	cmpgeui	r2,r2,32
   25338:	1000721e 	bne	r2,zero,25504 <OBJ_Write+0x5d4>
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
   2533c:	88ba8004 	addi	r2,r17,-5632
   25340:	10bfffcc 	andi	r2,r2,65535
   25344:	10808030 	cmpltui	r2,r2,512
   25348:	1000821e 	bne	r2,zero,25554 <OBJ_Write+0x624>
   2534c:	88b98004 	addi	r2,r17,-6656
   25350:	10bfffcc 	andi	r2,r2,65535
   25354:	10808030 	cmpltui	r2,r2,512
   25358:	10007e1e 	bne	r2,zero,25554 <OBJ_Write+0x624>
   2535c:	88bfffcc 	andi	r2,r17,65535
   25360:	10007c26 	beq	r2,zero,25554 <OBJ_Write+0x624>
                                    return ABORTIDX_VALUE_EXCEEDED;
   25364:	07000484 	movi	fp,18
   25368:	003f0e06 	br	24fa4 <OBJ_Write+0x74>
                            else if ( pEntry->BitLength == 16 )
   2536c:	21400420 	cmpeqi	r5,r4,16
   25370:	283fe51e 	bne	r5,zero,25308 <OBJ_Write+0x3d8>
                            else if ( pEntry->BitLength == 32 )
   25374:	21000820 	cmpeqi	r4,r4,32
   25378:	2000931e 	bne	r4,zero,255c8 <OBJ_Write+0x698>
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   2537c:	07000604 	movi	fp,24
   25380:	003f0806 	br	24fa4 <OBJ_Write+0x74>
                        switch (dataType)
   25384:	21400328 	cmpgeui	r5,r4,12
   25388:	28000d1e 	bne	r5,zero,253c0 <OBJ_Write+0x490>
   2538c:	214002a8 	cmpgeui	r5,r4,10
   25390:	2800241e 	bne	r5,zero,25424 <OBJ_Write+0x4f4>
   25394:	21400260 	cmpeqi	r5,r4,9
   25398:	2800221e 	bne	r5,zero,25424 <OBJ_Write+0x4f4>
   2539c:	20002d26 	beq	r4,zero,25454 <OBJ_Write+0x524>
   253a0:	01400044 	movi	r5,1
   253a4:	2908983a 	sll	r4,r5,r4
   253a8:	2140640c 	andi	r5,r4,400
   253ac:	2800861e 	bne	r5,zero,255c8 <OBJ_Write+0x698>
   253b0:	2140098c 	andi	r5,r4,38
   253b4:	2800341e 	bne	r5,zero,25488 <OBJ_Write+0x558>
   253b8:	2100120c 	andi	r4,r4,72
   253bc:	003fd106 	br	25304 <OBJ_Write+0x3d4>
   253c0:	21400e28 	cmpgeui	r5,r4,56
   253c4:	2800131e 	bne	r5,zero,25414 <OBJ_Write+0x4e4>
   253c8:	214007a8 	cmpgeui	r5,r4,30
   253cc:	283fbe1e 	bne	r5,zero,252c8 <OBJ_Write+0x398>
   253d0:	31bffecc 	andi	r6,r6,65531
   253d4:	31800460 	cmpeqi	r6,r6,17
   253d8:	3000021e 	bne	r6,zero,253e4 <OBJ_Write+0x4b4>
   253dc:	210006e0 	cmpeqi	r4,r4,27
   253e0:	203fe626 	beq	r4,zero,2537c <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   253e4:	108003cc 	andi	r2,r2,15
   253e8:	103eed1e 	bne	r2,zero,24fa0 <OBJ_Write+0x70>
                            pVarPtr[0] = pData[0];
   253ec:	8080000b 	ldhu	r2,0(r16)
                            pData += 4;
   253f0:	84000204 	addi	r16,r16,8
                            pVarPtr[0] = pData[0];
   253f4:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   253f8:	80bffe8b 	ldhu	r2,-6(r16)
   253fc:	3880008d 	sth	r2,2(r7)
                            pVarPtr[2] = pData[2];
   25400:	80bfff0b 	ldhu	r2,-4(r16)
   25404:	3880010d 	sth	r2,4(r7)
                            pVarPtr[3] = pData[3];
   25408:	80bfff8b 	ldhu	r2,-2(r16)
   2540c:	3880018d 	sth	r2,6(r7)
                            break;
   25410:	00003106 	br	254d8 <OBJ_Write+0x5a8>
                        switch (dataType)
   25414:	31bf6804 	addi	r6,r6,-608
   25418:	31bfffcc 	andi	r6,r6,65535
   2541c:	31800128 	cmpgeui	r6,r6,4
   25420:	303fd61e 	bne	r6,zero,2537c <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25424:	108003cc 	andi	r2,r2,15
   25428:	103edd1e 	bne	r2,zero,24fa0 <OBJ_Write+0x70>
                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
   2542c:	8980008b 	ldhu	r6,2(r17)
   25430:	800b883a 	mov	r5,r16
   25434:	3809883a 	mov	r4,r7
   25438:	318001c4 	addi	r6,r6,7
   2543c:	300cd0fa 	srli	r6,r6,3
   25440:	0026ee40 	call	26ee4 <memcpy>
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25444:	8880008b 	ldhu	r2,2(r17)
   25448:	1004d13a 	srli	r2,r2,4
   2544c:	1004907a 	slli	r2,r2,1
   25450:	00000b06 	br	25480 <OBJ_Write+0x550>
                            if(bCompleteAccess)
   25454:	a03fc926 	beq	r20,zero,2537c <OBJ_Write+0x44c>
                                if (((pEntry->BitLength & 0xF) > 0)
   25458:	8900008b 	ldhu	r4,2(r17)
   2545c:	218003cc 	andi	r6,r4,15
   25460:	217fffcc 	andi	r5,r4,65535
   25464:	30000426 	beq	r6,zero,25478 <OBJ_Write+0x548>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25468:	2089883a 	add	r4,r4,r2
   2546c:	210003cc 	andi	r4,r4,15
   25470:	2000011e 	bne	r4,zero,25478 <OBJ_Write+0x548>
                                    pData++;
   25474:	84000084 	addi	r16,r16,2
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
   25478:	2804d0fa 	srli	r2,r5,3
   2547c:	1080078c 	andi	r2,r2,30
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25480:	80a1883a 	add	r16,r16,r2
                            break;
   25484:	00001406 	br	254d8 <OBJ_Write+0x5a8>
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   25488:	8940008b 	ldhu	r5,2(r17)
   2548c:	010000b4 	movhi	r4,2
   25490:	130003cc 	andi	r12,r2,15
   25494:	280a907a 	slli	r5,r5,1
                            TmpValue &= ~bitMask;
   25498:	3b80000b 	ldhu	r14,0(r7)
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   2549c:	2909883a 	add	r4,r5,r4
   254a0:	211efe0b 	ldhu	r4,31736(r4)
   254a4:	217fffcc 	andi	r5,r4,65535
   254a8:	2b1a983a 	sll	r13,r5,r12
                            TmpValue &= ~bitMask;
   254ac:	034c303a 	nor	r6,zero,r13
   254b0:	338c703a 	and	r6,r6,r14
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   254b4:	8380000b 	ldhu	r14,0(r16)
                            if (bCompleteAccess) 
   254b8:	a0000926 	beq	r20,zero,254e0 <OBJ_Write+0x5b0>
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
   254bc:	6b9a703a 	and	r13,r13,r14
   254c0:	3348b03a 	or	r4,r6,r13
                            pVarPtr[0] = SWAPWORD(TmpValue);
   254c4:	3900000d 	sth	r4,0(r7)
                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
   254c8:	8900008b 	ldhu	r4,2(r17)
   254cc:	2085883a 	add	r2,r4,r2
   254d0:	108003cc 	andi	r2,r2,15
   254d4:	103f7126 	beq	r2,zero,2529c <OBJ_Write+0x36c>
                    bWritten = 1;
   254d8:	01800044 	movi	r6,1
   254dc:	003f6406 	br	25270 <OBJ_Write+0x340>
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
   254e0:	014a303a 	nor	r5,zero,r5
   254e4:	737fffcc 	andi	r13,r14,65535
   254e8:	2b4a703a 	and	r5,r5,r13
   254ec:	283f9d1e 	bne	r5,zero,25364 <OBJ_Write+0x434>
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
   254f0:	2388703a 	and	r4,r4,r14
   254f4:	213fffcc 	andi	r4,r4,65535
   254f8:	2308983a 	sll	r4,r4,r12
   254fc:	3108b03a 	or	r4,r6,r4
   25500:	003ff006 	br	254c4 <OBJ_Write+0x594>
                            if(index == 0x1C32 || index == 0x1C33)
   25504:	d8800117 	ldw	r2,4(sp)
   25508:	10b8f384 	addi	r2,r2,-7218
   2550c:	10bfffcc 	andi	r2,r2,65535
   25510:	108000b0 	cmpltui	r2,r2,2
   25514:	10000f26 	beq	r2,zero,25554 <OBJ_Write+0x624>
                               if (i == 1) /* "Synchronisation type" written */
   25518:	633fffcc 	andi	r12,r12,65535
   2551c:	60800058 	cmpnei	r2,r12,1
   25520:	10000e1e 	bne	r2,zero,2555c <OBJ_Write+0x62c>
                                  if (pVarPtr[0] != u16NewData)
   25524:	3880000b 	ldhu	r2,0(r7)
   25528:	897fffcc 	andi	r5,r17,65535
   2552c:	11400726 	beq	r2,r5,2554c <OBJ_Write+0x61c>
                                     result = CheckSyncTypeValue(index, u16NewData);
   25530:	d900010b 	ldhu	r4,4(sp)
   25534:	d9c00615 	stw	r7,24(sp)
   25538:	00248140 	call	24814 <CheckSyncTypeValue>
   2553c:	1039883a 	mov	fp,r2
                                     if (result != 0)
   25540:	10803fcc 	andi	r2,r2,255
   25544:	d9c00617 	ldw	r7,24(sp)
   25548:	103e961e 	bne	r2,zero,24fa4 <OBJ_Write+0x74>
                                  bSyncSetByUser = TRUE;
   2554c:	00800044 	movi	r2,1
   25550:	d0a16785 	stb	r2,-31330(gp)
                            pVarPtr[0] = u16NewData;
   25554:	3c40000d 	sth	r17,0(r7)
   25558:	003f5006 	br	2529c <OBJ_Write+0x36c>
                               if (i == 8) /* "Get Cycle Time" written*/
   2555c:	63000218 	cmpnei	r12,r12,8
   25560:	603ffc1e 	bne	r12,zero,25554 <OBJ_Write+0x624>
                                   sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   25564:	008000f4 	movhi	r2,3
   25568:	1021f015 	stw	zero,-30784(r2)
                                   sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   2556c:	008000b4 	movhi	r2,2
   25570:	10a1a804 	addi	r2,r2,-31072
   25574:	010000f4 	movhi	r4,3
   25578:	20a1ef15 	stw	r2,-30788(r4)
                                   sSyncManOutPar.u32CycleTime = 0;
   2557c:	010000f4 	movhi	r4,3
   25580:	2021ec15 	stw	zero,-30800(r4)
                                   sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   25584:	010000f4 	movhi	r4,3
   25588:	2021df15 	stw	zero,-30852(r4)
                                   sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   2558c:	010000f4 	movhi	r4,3
   25590:	20a1de15 	stw	r2,-30856(r4)
                                   sSyncManInPar.u32CycleTime = 0;
   25594:	008000f4 	movhi	r2,3
   25598:	1021db15 	stw	zero,-30868(r2)
                                  if ((u16NewData & 0x2) == 0x2)
   2559c:	8880008c 	andi	r2,r17,2
   255a0:	103fec26 	beq	r2,zero,25554 <OBJ_Write+0x624>
                                     sSyncManOutPar.u16SmEventMissedCounter = 0;
   255a4:	008000f4 	movhi	r2,3
   255a8:	1021f515 	stw	zero,-30764(r2)
                                     sSyncManOutPar.u8SyncError = 0;
   255ac:	008000f4 	movhi	r2,3
   255b0:	1021fb05 	stb	zero,-30740(r2)
                                     sSyncManInPar.u16SmEventMissedCounter = 0;
   255b4:	008000f4 	movhi	r2,3
   255b8:	1021e415 	stw	zero,-30832(r2)
                                     sSyncManInPar.u8SyncError = 0;
   255bc:	008000f4 	movhi	r2,3
   255c0:	1021ea05 	stb	zero,-30808(r2)
   255c4:	003fe306 	br	25554 <OBJ_Write+0x624>
                            if(bitOffset & 0xF)
   255c8:	108003cc 	andi	r2,r2,15
   255cc:	103e741e 	bne	r2,zero,24fa0 <OBJ_Write+0x70>
                            if(bClearSubindex0Required && 
   255d0:	99003fcc 	andi	r4,r19,255
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   255d4:	8080000b 	ldhu	r2,0(r16)
                            if(bClearSubindex0Required && 
   255d8:	20000626 	beq	r4,zero,255f4 <OBJ_Write+0x6c4>
   255dc:	3940000b 	ldhu	r5,0(r7)
   255e0:	113fffcc 	andi	r4,r2,65535
   255e4:	29001d1e 	bne	r5,r4,2565c <OBJ_Write+0x72c>
                                || (pVarPtr[1] != pData[1])))
   255e8:	3940008b 	ldhu	r5,2(r7)
   255ec:	8100008b 	ldhu	r4,2(r16)
   255f0:	29001a1e 	bne	r5,r4,2565c <OBJ_Write+0x72c>
                            pVarPtr[0] = pData[0];
   255f4:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   255f8:	8080008b 	ldhu	r2,2(r16)
                            pData += 2;
   255fc:	84000104 	addi	r16,r16,4
                            pVarPtr[1] = pData[1];
   25600:	3880008d 	sth	r2,2(r7)
                            break;
   25604:	003fb406 	br	254d8 <OBJ_Write+0x5a8>
                if(i == 0)
   25608:	6800031e 	bne	r13,zero,25618 <OBJ_Write+0x6e8>
                    pData++;
   2560c:	84000084 	addi	r16,r16,2
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25610:	07000604 	movi	fp,24
   25614:	003f1606 	br	25270 <OBJ_Write+0x340>
                    if (((pEntry->BitLength & 0xF) > 0)
   25618:	88c0008b 	ldhu	r3,2(r17)
   2561c:	190003cc 	andi	r4,r3,15
   25620:	20000426 	beq	r4,zero,25634 <OBJ_Write+0x704>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25624:	1885883a 	add	r2,r3,r2
   25628:	108003cc 	andi	r2,r2,15
   2562c:	1000011e 	bne	r2,zero,25634 <OBJ_Write+0x704>
                        pData++;
   25630:	84000084 	addi	r16,r16,2
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
   25634:	1806d0fa 	srli	r3,r3,3
   25638:	18c7ff8c 	andi	r3,r3,8190
   2563c:	80e1883a 	add	r16,r16,r3
   25640:	003ff306 	br	25610 <OBJ_Write+0x6e0>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25644:	07000444 	movi	fp,17
   25648:	003e5606 	br	24fa4 <OBJ_Write+0x74>
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   2564c:	07000684 	movi	fp,26
   25650:	003e5406 	br	24fa4 <OBJ_Write+0x74>
                            return ABORTIDX_VALUE_TOO_GREAT;
   25654:	070004c4 	movi	fp,19
   25658:	003e5206 	br	24fa4 <OBJ_Write+0x74>
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
   2565c:	07000704 	movi	fp,28
   25660:	003e5006 	br	24fa4 <OBJ_Write+0x74>
        if ((subindex == 0) && (dataSize > 0))
   25664:	b0803fcc 	andi	r2,r22,255
   25668:	103ead26 	beq	r2,zero,25120 <OBJ_Write+0x1f0>
   2566c:	003ea706 	br	2510c <OBJ_Write+0x1dc>

00025670 <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
   25670:	defffe04 	addi	sp,sp,-8
   25674:	dc000015 	stw	r16,0(sp)
   25678:	dc000317 	ldw	r16,12(sp)
	/* for an upload segment response the toggle bit was overwritten */
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   2567c:	29403fcc 	andi	r5,r5,255
{
   25680:	dfc00115 	stw	ra,4(sp)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
	}
	if (abort == 0)
	{
		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25684:	8080018b 	ldhu	r2,6(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25688:	28c01818 	cmpnei	r3,r5,96
{
   2568c:	da000217 	ldw	r8,8(sp)
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25690:	1083ffcc 	andi	r2,r2,4095
   25694:	21003fcc 	andi	r4,r4,255
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25698:	18000d1e 	bne	r3,zero,256d0 <SdoRes+0x60>
	if (abort == 0)
   2569c:	20003f1e 	bne	r4,zero,2579c <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   256a0:	108c0014 	ori	r2,r2,12288
   256a4:	8080018d 	sth	r2,6(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
	}

	// HBu 02.05.06: if the CoE-response could not be sent because the
	//               send mailbox is full it should be stored
	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
   256a8:	01400084 	movi	r5,2
   256ac:	8009883a 	mov	r4,r16
   256b0:	0023d8c0 	call	23d8c <MBX_MailboxSendReq>
   256b4:	10803fcc 	andi	r2,r2,255
   256b8:	10000126 	beq	r2,zero,256c0 <SdoRes+0x50>
	{
		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
   256bc:	d4214a15 	stw	r16,-31448(gp)
	}
}
   256c0:	dfc00117 	ldw	ra,4(sp)
   256c4:	dc000017 	ldw	r16,0(sp)
   256c8:	dec00204 	addi	sp,sp,8
   256cc:	f800283a 	ret
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   256d0:	80c0020b 	ldhu	r3,8(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   256d4:	2800081e 	bne	r5,zero,256f8 <SdoRes+0x88>
	if (abort == 0)
   256d8:	2000301e 	bne	r4,zero,2579c <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   256dc:	108c0014 	ori	r2,r2,12288
   256e0:	8080018d 	sth	r2,6(r16)
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   256e4:	00800284 	movi	r2,10
   256e8:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   256ec:	18c00814 	ori	r3,r3,32
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   256f0:	80c0020d 	sth	r3,8(r16)
   256f4:	003fec06 	br	256a8 <SdoRes+0x38>
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
   256f8:	027fc004 	movi	r9,-256
   256fc:	1a46703a 	and	r3,r3,r9
   25700:	80c0020d 	sth	r3,8(r16)
	if (abort == 0)
   25704:	2000251e 	bne	r4,zero,2579c <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25708:	108c0014 	ori	r2,r2,12288
   2570c:	8080018d 	sth	r2,6(r16)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25710:	29401018 	cmpnei	r5,r5,64
   25714:	28001d1e 	bne	r5,zero,2578c <SdoRes+0x11c>
			if ((objLength <= 4) && (objLength > 0))
   25718:	40bfffc4 	addi	r2,r8,-1
   2571c:	10800128 	cmpgeui	r2,r2,4
   25720:	10000c1e 	bne	r2,zero,25754 <SdoRes+0xe4>
				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
   25724:	00800284 	movi	r2,10
   25728:	8080000d 	sth	r2,0(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   2572c:	00800104 	movi	r2,4
   25730:	1205c83a 	sub	r2,r2,r8
   25734:	100490ba 	slli	r2,r2,2
   25738:	318000d4 	ori	r6,r6,3
   2573c:	31803fcc 	andi	r6,r6,255
   25740:	1184b03a 	or	r2,r2,r6
   25744:	1884b03a 	or	r2,r3,r2
   25748:	10801014 	ori	r2,r2,64
   2574c:	8080020d 	sth	r2,8(r16)
   25750:	003fd506 	br	256a8 <SdoRes+0x38>
				if (dataSize < objLength)
   25754:	38bfffcc 	andi	r2,r7,65535
   25758:	12000a2e 	bgeu	r2,r8,25784 <SdoRes+0x114>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   2575c:	39c00284 	addi	r7,r7,10
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
   25760:	8200030d 	sth	r8,12(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25764:	31801054 	ori	r6,r6,65
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25768:	4010d43a 	srli	r8,r8,16
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   2576c:	31803fcc 	andi	r6,r6,255
   25770:	198cb03a 	or	r6,r3,r6
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25774:	81c0000d 	sth	r7,0(r16)
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25778:	8200038d 	sth	r8,14(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   2577c:	8180020d 	sth	r6,8(r16)
   25780:	003fc906 	br	256a8 <SdoRes+0x38>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
   25784:	41c00284 	addi	r7,r8,10
   25788:	003ff506 	br	25760 <SdoRes+0xf0>
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   2578c:	00800284 	movi	r2,10
   25790:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   25794:	18c01814 	ori	r3,r3,96
   25798:	003fd506 	br	256f0 <SdoRes+0x80>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
   2579c:	10880014 	ori	r2,r2,8192
   257a0:	8080018d 	sth	r2,6(r16)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   257a4:	8080020b 	ldhu	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   257a8:	200890ba 	slli	r4,r4,2
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   257ac:	00c00284 	movi	r3,10
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   257b0:	10802014 	ori	r2,r2,128
   257b4:	8080020d 	sth	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   257b8:	008000b4 	movhi	r2,2
   257bc:	2085883a 	add	r2,r4,r2
   257c0:	109f0617 	ldw	r2,31768(r2)
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   257c4:	80c0000d 	sth	r3,0(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   257c8:	80800315 	stw	r2,12(r16)
   257cc:	003fb606 	br	256a8 <SdoRes+0x38>

000257d0 <SDOS_SdoInd>:
			is received from the master and calls depending from
			the command the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
{
   257d0:	defff004 	addi	sp,sp,-64
   257d4:	dd000a15 	stw	r20,40(sp)
	/* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
	UINT8 bCompleteAccess = 0;
	UINT32 objLength = 0;
	UINT32 dataSize = 0;

	if (bSdoInWork)
   257d8:	d5216dc3 	ldbu	r20,-31305(gp)
{
   257dc:	dd400b15 	stw	r21,44(sp)
	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK) >> SDOHEADER_COMMANDSHIFT;
   257e0:	2540020b 	ldhu	r21,8(r4)
{
   257e4:	dc800815 	stw	r18,32(sp)
   257e8:	dfc00f15 	stw	ra,60(sp)
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   257ec:	04bff804 	movi	r18,-32
{
   257f0:	df000e15 	stw	fp,56(sp)
   257f4:	ddc00d15 	stw	r23,52(sp)
   257f8:	dd800c15 	stw	r22,48(sp)
   257fc:	dcc00915 	stw	r19,36(sp)
   25800:	dc400715 	stw	r17,28(sp)
   25804:	dc000615 	stw	r16,24(sp)
	if (bSdoInWork)
   25808:	a0803fcc 	andi	r2,r20,255
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   2580c:	9564703a 	and	r18,r18,r21
	if (bSdoInWork)
   25810:	1002021e 	bne	r2,zero,2601c <SDOS_SdoInd+0x84c>
   25814:	a880040c 	andi	r2,r21,16
	{
		bCompleteAccess = 1;
	}
/* ECATCHANGE_END(V5.13) COE5*/

	switch (command)
   25818:	94803fcc 	andi	r18,r18,255
	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
   2581c:	2440000b 	ldhu	r17,0(r4)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   25820:	2021883a 	mov	r16,r4
   25824:	d8800315 	stw	r2,12(sp)
	switch (command)
   25828:	91001020 	cmpeqi	r4,r18,64
   2582c:	2000161e 	bne	r4,zero,25888 <SDOS_SdoInd+0xb8>
   25830:	91001068 	cmpgeui	r4,r18,65
   25834:	2000071e 	bne	r4,zero,25854 <SDOS_SdoInd+0x84>
   25838:	9000fe26 	beq	r18,zero,25c34 <SDOS_SdoInd+0x464>
   2583c:	90800820 	cmpeqi	r2,r18,32
   25840:	1000111e 	bne	r2,zero,25888 <SDOS_SdoInd+0xb8>
		}
		break;

	case SDOSERVICE_DOWNLOADSEGMENTREQ:
	case SDOSERVICE_UPLOADSEGMENTREQ:
		if (command == nSdoSegService)
   25844:	0013883a 	mov	r9,zero
   25848:	0039883a 	mov	fp,zero
   2584c:	044000c4 	movi	r17,3
   25850:	00008206 	br	25a5c <SDOS_SdoInd+0x28c>
	switch (command)
   25854:	90801820 	cmpeqi	r2,r18,96
   25858:	103ffa26 	beq	r2,zero,25844 <SDOS_SdoInd+0x74>
		if (command == nSdoSegService)
   2585c:	d0a16d83 	ldbu	r2,-31306(gp)
   25860:	10801818 	cmpnei	r2,r2,96
   25864:	103ff71e 	bne	r2,zero,25844 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25868:	80800203 	ldbu	r2,8(r16)
   2586c:	d1216a03 	ldbu	r4,-31320(gp)
   25870:	15c0040c 	andi	r23,r2,16
   25874:	25c1801e 	bne	r4,r23,25e78 <SDOS_SdoInd+0x6a8>
	UINT32 dataSize = 0;
   25878:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   2587c:	0039883a 	mov	fp,zero
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   25880:	04400044 	movi	r17,1
   25884:	00007506 	br	25a5c <SDOS_SdoInd+0x28c>
		index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
   25888:	8580028b 	ldhu	r22,10(r16)
		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT) & SDOHEADER_INDEXLOMASK;
   2588c:	acffffcc 	andi	r19,r21,65535
   25890:	9826d23a 	srli	r19,r19,8
   25894:	b004923a 	slli	r2,r22,8
   25898:	98a7883a 	add	r19,r19,r2
		pObjEntry = OBJ_GetObjectHandle(index);
   2589c:	98bfffcc 	andi	r2,r19,65535
   258a0:	1009883a 	mov	r4,r2
   258a4:	d8800215 	stw	r2,8(sp)
   258a8:	00241440 	call	24144 <OBJ_GetObjectHandle>
   258ac:	102f883a 	mov	r23,r2
		if (pObjEntry)
   258b0:	1001d226 	beq	r2,zero,25ffc <SDOS_SdoInd+0x82c>
		subindex = (pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT) & SDOHEADER_SUBINDEXMASK;
   258b4:	b0bfffcc 	andi	r2,r22,65535
   258b8:	102cd23a 	srli	r22,r2,8
				if (subindex > maxSubindex)
   258bc:	b9000303 	ldbu	r4,12(r23)
   258c0:	2581d236 	bltu	r4,r22,2600c <SDOS_SdoInd+0x83c>
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258c4:	a880040c 	andi	r2,r21,16
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   258c8:	b17fffcc 	andi	r5,r22,65535
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258cc:	1004c03a 	cmpne	r2,r2,zero
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   258d0:	a9c0040c 	andi	r7,r21,16
   258d4:	b80d883a 	mov	r6,r23
   258d8:	993fffcc 	andi	r4,r19,65535
   258dc:	d9400415 	stw	r5,16(sp)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258e0:	d8800215 	stw	r2,8(sp)
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   258e4:	00241800 	call	24180 <OBJ_GetObjectLength>
   258e8:	1039883a 	mov	fp,r2
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   258ec:	90801018 	cmpnei	r2,r18,64
   258f0:	d9400417 	ldw	r5,16(sp)
   258f4:	8c7fffcc 	andi	r17,r17,65535
   258f8:	1000151e 	bne	r2,zero,25950 <SDOS_SdoInd+0x180>
						if (mbxSize != EXPEDITED_FRAME_SIZE)
   258fc:	88800298 	cmpnei	r2,r17,10
   25900:	1001c81e 	bne	r2,zero,26024 <SDOS_SdoInd+0x854>
						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
   25904:	e0bfffc4 	addi	r2,fp,-1
   25908:	10800128 	cmpgeui	r2,r2,4
   2590c:	1000081e 	bne	r2,zero,25930 <SDOS_SdoInd+0x160>
							pData[0] = 0;
   25910:	8000030d 	sth	zero,12(r16)
							pData[1] = 0;
   25914:	8000038d 	sth	zero,14(r16)
			if ((abort == 0) && (bCompleteAccess == 1))
   25918:	a880040c 	andi	r2,r21,16
   2591c:	1001e626 	beq	r2,zero,260b8 <SDOS_SdoInd+0x8e8>
				if (subindex > 1)
   25920:	288000a8 	cmpgeui	r2,r5,2
   25924:	1001e426 	beq	r2,zero,260b8 <SDOS_SdoInd+0x8e8>
   25928:	e013883a 	mov	r9,fp
   2592c:	0001e006 	br	260b0 <SDOS_SdoInd+0x8e0>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   25930:	d2a1658b 	ldhu	r10,-31338(gp)
   25934:	52bffc04 	addi	r10,r10,-16
							if (dataSize < objLength)
   25938:	57007336 	bltu	r10,fp,25b08 <SDOS_SdoInd+0x338>
			if ((abort == 0) && (bCompleteAccess == 1))
   2593c:	a880040c 	andi	r2,r21,16
								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
   25940:	83000404 	addi	r12,r16,16
			if ((abort == 0) && (bCompleteAccess == 1))
   25944:	10004f26 	beq	r2,zero,25a84 <SDOS_SdoInd+0x2b4>
   25948:	5013883a 	mov	r9,r10
   2594c:	00000b06 	br	2597c <SDOS_SdoInd+0x1ac>
				if (bTransferType)
   25950:	a880008c 	andi	r2,r21,2
   25954:	10001226 	beq	r2,zero,259a0 <SDOS_SdoInd+0x1d0>
					if (mbxSize != EXPEDITED_FRAME_SIZE)
   25958:	8c400298 	cmpnei	r17,r17,10
   2595c:	8801b11e 	bne	r17,zero,26024 <SDOS_SdoInd+0x854>
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25960:	a804d0ba 	srli	r2,r21,2
   25964:	02400104 	movi	r9,4
					pData = (UINT16 MBXMEM *) &pSdoInd[1];
   25968:	83000304 	addi	r12,r16,12
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   2596c:	108000cc 	andi	r2,r2,3
   25970:	4893c83a 	sub	r9,r9,r2
			if ((abort == 0) && (bCompleteAccess == 1))
   25974:	a880040c 	andi	r2,r21,16
   25978:	1001ac26 	beq	r2,zero,2602c <SDOS_SdoInd+0x85c>
				if (subindex > 1)
   2597c:	288000a8 	cmpgeui	r2,r5,2
   25980:	1001cb1e 	bne	r2,zero,260b0 <SDOS_SdoInd+0x8e0>
					if (objLength == 0)
   25984:	e000031e 	bne	fp,zero,25994 <SDOS_SdoInd+0x1c4>
						nSdoSegIndex = index;
   25988:	d4e16c8d 	sth	r19,-31310(gp)
						nSdoSegSubindex = subindex;
   2598c:	d5a16c05 	stb	r22,-31312(gp)
						pSdoSegObjEntry = pObjEntry;
   25990:	d5e16815 	stw	r23,-31328(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25994:	90801018 	cmpnei	r2,r18,64
   25998:	1001a81e 	bne	r2,zero,2603c <SDOS_SdoInd+0x86c>
   2599c:	00003b06 	br	25a8c <SDOS_SdoInd+0x2bc>
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   259a0:	8280038b 	ldhu	r10,14(r16)
   259a4:	8080030b 	ldhu	r2,12(r16)
   259a8:	5014943a 	slli	r10,r10,16
   259ac:	5094b03a 	or	r10,r10,r2
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   259b0:	d0a1650b 	ldhu	r2,-31340(gp)
   259b4:	51000404 	addi	r4,r10,16
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   259b8:	5013883a 	mov	r9,r10
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   259bc:	11002f2e 	bgeu	r2,r4,25a7c <SDOS_SdoInd+0x2ac>
						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
   259c0:	10bffe84 	addi	r2,r2,-6
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   259c4:	8881971e 	bne	r17,r2,26024 <SDOS_SdoInd+0x854>
					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
   259c8:	88bffd84 	addi	r2,r17,-10
   259cc:	1280522e 	bgeu	r2,r10,25b18 <SDOS_SdoInd+0x348>
			if ((abort == 0) && (bCompleteAccess == 1))
   259d0:	a880040c 	andi	r2,r21,16
   259d4:	10000226 	beq	r2,zero,259e0 <SDOS_SdoInd+0x210>
				if (subindex > 1)
   259d8:	288000a8 	cmpgeui	r2,r5,2
   259dc:	1001b41e 	bne	r2,zero,260b0 <SDOS_SdoInd+0x8e0>
					bSdoSegFollows = TRUE;
   259e0:	00800044 	movi	r2,1
   259e4:	d0a16d45 	stb	r2,-31307(gp)
					bSdoSegLastToggle = 1;
   259e8:	d0a16a05 	stb	r2,-31320(gp)
					bSdoSegAccess = bCompleteAccess;
   259ec:	d8800217 	ldw	r2,8(sp)
					if (pSdoSegData != NULL)
   259f0:	d1217117 	ldw	r4,-31292(gp)
					nSdoSegIndex = index;
   259f4:	d4e16c8d 	sth	r19,-31310(gp)
					bSdoSegAccess = bCompleteAccess;
   259f8:	d0a16d05 	stb	r2,-31308(gp)
					nSdoSegSubindex = subindex;
   259fc:	d5a16c05 	stb	r22,-31312(gp)
					pSdoSegObjEntry = pObjEntry;
   25a00:	d5e16815 	stw	r23,-31328(gp)
						nSdoSegCompleteSize = objLength;
   25a04:	d2616915 	stw	r9,-31324(gp)
					if (pSdoSegData != NULL)
   25a08:	20000526 	beq	r4,zero,25a20 <SDOS_SdoInd+0x250>
   25a0c:	da800515 	stw	r10,20(sp)
   25a10:	d9400415 	stw	r5,16(sp)
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25a14:	0026bec0 	call	26bec <free>
   25a18:	da800517 	ldw	r10,20(sp)
   25a1c:	d9400417 	ldw	r5,16(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25a20:	d0a16917 	ldw	r2,-31324(gp)
   25a24:	013fff84 	movi	r4,-2
   25a28:	da800515 	stw	r10,20(sp)
   25a2c:	10800044 	addi	r2,r2,1
   25a30:	1108703a 	and	r4,r2,r4
   25a34:	d9400415 	stw	r5,16(sp)
   25a38:	0026bdc0 	call	26bdc <malloc>
   25a3c:	d0a17115 	stw	r2,-31292(gp)
					if (pSdoSegData == NULL)
   25a40:	d9400417 	ldw	r5,16(sp)
   25a44:	da800517 	ldw	r10,20(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25a48:	1009883a 	mov	r4,r2
					if (pSdoSegData == NULL)
   25a4c:	1000341e 	bne	r2,zero,25b20 <SDOS_SdoInd+0x350>
						if (bCompleteAccess)
   25a50:	d8800217 	ldw	r2,8(sp)
   25a54:	14400104 	addi	r17,r2,4
						nSdoSegBytesToHandle = dataSize;
   25a58:	5013883a 	mov	r9,r10
	}

	if (abort != ABORTIDX_WORKING)
	{
		/*  type cast was added because of warning */
		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
   25a5c:	d9800317 	ldw	r6,12(sp)
   25a60:	dc000115 	stw	r16,4(sp)
   25a64:	df000015 	stw	fp,0(sp)
   25a68:	49ffffcc 	andi	r7,r9,65535
   25a6c:	900b883a 	mov	r5,r18
   25a70:	89003fcc 	andi	r4,r17,255
   25a74:	00256700 	call	25670 <SdoRes>
   25a78:	00005506 	br	25bd0 <SDOS_SdoInd+0x400>
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25a7c:	50800284 	addi	r2,r10,10
   25a80:	003fd006 	br	259c4 <SDOS_SdoInd+0x1f4>
					if (objLength == 0)
   25a84:	e0006726 	beq	fp,zero,25c24 <SDOS_SdoInd+0x454>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25a88:	5013883a 	mov	r9,r10
						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
   25a8c:	d8800217 	ldw	r2,8(sp)
   25a90:	db000015 	stw	r12,0(sp)
   25a94:	b80f883a 	mov	r7,r23
   25a98:	d8800115 	stw	r2,4(sp)
   25a9c:	e00d883a 	mov	r6,fp
   25aa0:	993fffcc 	andi	r4,r19,65535
   25aa4:	da400515 	stw	r9,20(sp)
   25aa8:	db000415 	stw	r12,16(sp)
   25aac:	00249200 	call	24920 <OBJ_Read>
   25ab0:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   25ab4:	10803fcc 	andi	r2,r2,255
   25ab8:	10803fd8 	cmpnei	r2,r2,255
   25abc:	db000417 	ldw	r12,16(sp)
   25ac0:	da400517 	ldw	r9,20(sp)
   25ac4:	103fe51e 	bne	r2,zero,25a5c <SDOS_SdoInd+0x28c>
							u8PendingSdo = SDO_PENDING_READ;
   25ac8:	008000c4 	movi	r2,3
   25acc:	d0a17605 	stb	r2,-31272(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25ad0:	d8800217 	ldw	r2,8(sp)
							u8StoreSubindex = subindex;
   25ad4:	d5a17585 	stb	r22,-31274(gp)
							u16StoreIndex = index;
   25ad8:	d4e1750d 	sth	r19,-31276(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25adc:	d0a175c5 	stb	r2,-31273(gp)
							pSdoPendFunc = pObjEntry->Read;
   25ae0:	b8800717 	ldw	r2,28(r23)
							u32StoreDataSize = objLength;
   25ae4:	d7217415 	stw	fp,-31280(gp)
							pStoreData = pData;
   25ae8:	d3217315 	stw	r12,-31284(gp)
							pSdoPendFunc = pObjEntry->Read;
   25aec:	d0a17215 	stw	r2,-31288(gp)
							bSdoInWork = TRUE;
   25af0:	00800044 	movi	r2,1
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25af4:	a8c03c0c 	andi	r3,r21,240
							bSdoInWork = TRUE;
   25af8:	d0a16dc5 	stb	r2,-31305(gp)
							pSdoResStored = pSdoInd;
   25afc:	d4216e15 	stw	r16,-31304(gp)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25b00:	80c00205 	stb	r3,8(r16)
							return 0;
   25b04:	00003206 	br	25bd0 <SDOS_SdoInd+0x400>
			if ((abort == 0) && (bCompleteAccess == 1))
   25b08:	a880040c 	andi	r2,r21,16
   25b0c:	1001651e 	bne	r2,zero,260a4 <SDOS_SdoInd+0x8d4>
				if (subindex > 1)
   25b10:	e013883a 	mov	r9,fp
   25b14:	003fb206 	br	259e0 <SDOS_SdoInd+0x210>
					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
   25b18:	83000404 	addi	r12,r16,16
   25b1c:	003f9506 	br	25974 <SDOS_SdoInd+0x1a4>
						if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25b20:	90801018 	cmpnei	r2,r18,64
   25b24:	1000371e 	bne	r2,zero,25c04 <SDOS_SdoInd+0x434>
							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
   25b28:	d8800217 	ldw	r2,8(sp)
   25b2c:	d9000015 	stw	r4,0(sp)
   25b30:	b80f883a 	mov	r7,r23
   25b34:	d8800115 	stw	r2,4(sp)
   25b38:	e00d883a 	mov	r6,fp
   25b3c:	993fffcc 	andi	r4,r19,65535
   25b40:	da800415 	stw	r10,16(sp)
   25b44:	00249200 	call	24920 <OBJ_Read>
   25b48:	1023883a 	mov	r17,r2
							if (abort == 0)
   25b4c:	10803fcc 	andi	r2,r2,255
   25b50:	da800417 	ldw	r10,16(sp)
   25b54:	10000a1e 	bne	r2,zero,25b80 <SDOS_SdoInd+0x3b0>
								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
   25b58:	d1617117 	ldw	r5,-31292(gp)
   25b5c:	500d883a 	mov	r6,r10
   25b60:	81000404 	addi	r4,r16,16
   25b64:	da800215 	stw	r10,8(sp)
   25b68:	0026ee40 	call	26ee4 <memcpy>
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   25b6c:	00801804 	movi	r2,96
   25b70:	d0a16d85 	stb	r2,-31306(gp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25b74:	da800217 	ldw	r10,8(sp)
						nSdoSegBytesToHandle = dataSize;
   25b78:	d2a16b15 	stw	r10,-31316(gp)
   25b7c:	003fb606 	br	25a58 <SDOS_SdoInd+0x288>
							else if (abort == ABORTIDX_WORKING)
   25b80:	10803fd8 	cmpnei	r2,r2,255
   25b84:	103ffc1e 	bne	r2,zero,25b78 <SDOS_SdoInd+0x3a8>
								u8PendingSdo = SDO_PENDING_SEG_READ;
   25b88:	00800104 	movi	r2,4
   25b8c:	d0a17605 	stb	r2,-31272(gp)
								bStoreCompleteAccess = bCompleteAccess;
   25b90:	d8800217 	ldw	r2,8(sp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25b94:	a8c03c0c 	andi	r3,r21,240
								u8StoreSubindex = subindex;
   25b98:	d5a17585 	stb	r22,-31274(gp)
								bStoreCompleteAccess = bCompleteAccess;
   25b9c:	d0a175c5 	stb	r2,-31273(gp)
								pStoreData = pSdoSegData;
   25ba0:	d0a17117 	ldw	r2,-31292(gp)
								u16StoreIndex = index;
   25ba4:	d4e1750d 	sth	r19,-31276(gp)
								u32StoreDataSize = objLength;
   25ba8:	d7217415 	stw	fp,-31280(gp)
								pStoreData = pSdoSegData;
   25bac:	d0a17315 	stw	r2,-31284(gp)
								pSdoPendFunc = pObjEntry->Read;
   25bb0:	b8800717 	ldw	r2,28(r23)
								pSdoResStored = pSdoInd;
   25bb4:	d4216e15 	stw	r16,-31304(gp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25bb8:	80c00205 	stb	r3,8(r16)
								pSdoPendFunc = pObjEntry->Read;
   25bbc:	d0a17215 	stw	r2,-31288(gp)
								bSdoInWork = TRUE;
   25bc0:	00800044 	movi	r2,1
   25bc4:	d0a16dc5 	stb	r2,-31305(gp)
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   25bc8:	00801804 	movi	r2,96
   25bcc:	d0a16d85 	stb	r2,-31306(gp)
	}

	return 0;
}
   25bd0:	a005883a 	mov	r2,r20
   25bd4:	dfc00f17 	ldw	ra,60(sp)
   25bd8:	df000e17 	ldw	fp,56(sp)
   25bdc:	ddc00d17 	ldw	r23,52(sp)
   25be0:	dd800c17 	ldw	r22,48(sp)
   25be4:	dd400b17 	ldw	r21,44(sp)
   25be8:	dd000a17 	ldw	r20,40(sp)
   25bec:	dcc00917 	ldw	r19,36(sp)
   25bf0:	dc800817 	ldw	r18,32(sp)
   25bf4:	dc400717 	ldw	r17,28(sp)
   25bf8:	dc000617 	ldw	r16,24(sp)
   25bfc:	dec01004 	addi	sp,sp,64
   25c00:	f800283a 	ret
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25c04:	8abffd84 	addi	r10,r17,-10
   25c08:	500d883a 	mov	r6,r10
   25c0c:	81400404 	addi	r5,r16,16
   25c10:	da800215 	stw	r10,8(sp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25c14:	a023883a 	mov	r17,r20
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25c18:	0026ee40 	call	26ee4 <memcpy>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25c1c:	d0216d85 	stb	zero,-31306(gp)
							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25c20:	003fd406 	br	25b74 <SDOS_SdoInd+0x3a4>
						nSdoSegIndex = index;
   25c24:	d4e16c8d 	sth	r19,-31310(gp)
						nSdoSegSubindex = subindex;
   25c28:	d5a16c05 	stb	r22,-31312(gp)
						pSdoSegObjEntry = pObjEntry;
   25c2c:	d5e16815 	stw	r23,-31328(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25c30:	003f9506 	br	25a88 <SDOS_SdoInd+0x2b8>
		if (command == nSdoSegService)
   25c34:	d1216d83 	ldbu	r4,-31306(gp)
   25c38:	203f021e 	bne	r4,zero,25844 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c3c:	d1616a03 	ldbu	r5,-31320(gp)
		if (pSdoSegData)
   25c40:	d1217117 	ldw	r4,-31292(gp)
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c44:	28808826 	beq	r5,r2,25e68 <SDOS_SdoInd+0x698>
		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
   25c48:	d0a16a05 	stb	r2,-31320(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25c4c:	d4e1650b 	ldhu	r19,-31340(gp)
		if (pSdoSegData)
   25c50:	20008726 	beq	r4,zero,25e70 <SDOS_SdoInd+0x6a0>
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25c54:	d0a16b17 	ldw	r2,-31316(gp)
   25c58:	d1616917 	ldw	r5,-31324(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25c5c:	9cfffdc4 	addi	r19,r19,-9
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   25c60:	a980004c 	andi	r6,r21,1
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25c64:	288bc83a 	sub	r5,r5,r2
				if (bytesToSave <= maxData)
   25c68:	9cffffcc 	andi	r19,r19,65535
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   25c6c:	30003d26 	beq	r6,zero,25d64 <SDOS_SdoInd+0x594>
				if (bytesToSave <= maxData)
   25c70:	9940092e 	bgeu	r19,r5,25c98 <SDOS_SdoInd+0x4c8>
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
   25c74:	04400384 	movi	r17,14
		if (pSdoSegData)
   25c78:	d1217117 	ldw	r4,-31292(gp)
		bSdoSegFollows = FALSE;
   25c7c:	d0216d45 	stb	zero,-31307(gp)
		nSdoSegService = 0;
   25c80:	d0216d85 	stb	zero,-31306(gp)
		if (pSdoSegData)
   25c84:	20000226 	beq	r4,zero,25c90 <SDOS_SdoInd+0x4c0>
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25c88:	0026bec0 	call	26bec <free>
			pSdoSegData = NULL;
   25c8c:	d0217115 	stw	zero,-31292(gp)
		nSdoSegBytesToHandle = 0;
   25c90:	d0216b15 	stw	zero,-31316(gp)
   25c94:	00003006 	br	25d58 <SDOS_SdoInd+0x588>
					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   25c98:	8c7fffcc 	andi	r17,r17,65535
   25c9c:	8c7fff44 	addi	r17,r17,-3
   25ca0:	897ff436 	bltu	r17,r5,25c74 <SDOS_SdoInd+0x4a4>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25ca4:	a9bfffcc 	andi	r6,r21,65535
						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
   25ca8:	300dd07a 	srai	r6,r6,1
   25cac:	018c303a 	nor	r6,zero,r6
   25cb0:	318001cc 	andi	r6,r6,7
   25cb4:	29800326 	beq	r5,r6,25cc4 <SDOS_SdoInd+0x4f4>
						|| ((bytesToSave > MIN_SEGMENTED_DATA)
   25cb8:	29800230 	cmpltui	r6,r5,8
   25cbc:	303fed1e 	bne	r6,zero,25c74 <SDOS_SdoInd+0x4a4>
							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   25cc0:	2c7fec1e 	bne	r5,r17,25c74 <SDOS_SdoInd+0x4a4>
						bSdoSegFollows = FALSE;
   25cc4:	d0216d45 	stb	zero,-31307(gp)
   25cc8:	2827883a 	mov	r19,r5
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ccc:	11c0004c 	andi	r7,r2,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25cd0:	1004d07a 	srli	r2,r2,1
   25cd4:	81400284 	addi	r5,r16,10
   25cd8:	1004907a 	slli	r2,r2,1
   25cdc:	208d883a 	add	r6,r4,r2
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ce0:	38002426 	beq	r7,zero,25d74 <SDOS_SdoInd+0x5a4>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25ce4:	30c00003 	ldbu	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   25ce8:	10800084 	addi	r2,r2,2
   25cec:	2089883a 	add	r4,r4,r2
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25cf0:	30c0000d 	sth	r3,0(r6)
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
   25cf4:	81c0020b 	ldhu	r7,8(r16)
   25cf8:	39ffc00c 	andi	r7,r7,65280
   25cfc:	19c6b03a 	or	r3,r3,r7
   25d00:	30c0000d 	sth	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   25d04:	99bfffc4 	addi	r6,r19,-1
   25d08:	0026ee40 	call	26ee4 <memcpy>
				if (bSdoSegFollows == FALSE)
   25d0c:	d0a16d43 	ldbu	r2,-31307(gp)
   25d10:	10002b26 	beq	r2,zero,25dc0 <SDOS_SdoInd+0x5f0>
		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25d14:	00800284 	movi	r2,10
   25d18:	8080000d 	sth	r2,0(r16)
		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25d1c:	8080018b 	ldhu	r2,6(r16)
   25d20:	1083ffcc 	andi	r2,r2,4095
		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25d24:	108c0014 	ori	r2,r2,12288
   25d28:	8080018d 	sth	r2,6(r16)
		if (bSdoSegLastToggle)
   25d2c:	d0a16a03 	ldbu	r2,-31320(gp)
   25d30:	10004b1e 	bne	r2,zero,25e60 <SDOS_SdoInd+0x690>
   25d34:	00800804 	movi	r2,32
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
   25d38:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   25d3c:	d0a16d43 	ldbu	r2,-31307(gp)
   25d40:	10800058 	cmpnei	r2,r2,1
   25d44:	1000981e 	bne	r2,zero,25fa8 <SDOS_SdoInd+0x7d8>
			nSdoSegBytesToHandle += bytesToSave;
   25d48:	d0a16b17 	ldw	r2,-31316(gp)
   25d4c:	14c5883a 	add	r2,r2,r19
   25d50:	d0a16b15 	stw	r2,-31316(gp)
	if (abort != ABORTIDX_WORKING)
   25d54:	a023883a 	mov	r17,r20
	UINT32 dataSize = 0;
   25d58:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25d5c:	0039883a 	mov	fp,zero
   25d60:	003f3e06 	br	25a5c <SDOS_SdoInd+0x28c>
				bSdoSegFollows = TRUE;
   25d64:	01800044 	movi	r6,1
   25d68:	d1a16d45 	stb	r6,-31307(gp)
				if (bytesToSave <= maxData)
   25d6c:	997fc12e 	bgeu	r19,r5,25c74 <SDOS_SdoInd+0x4a4>
   25d70:	003fd606 	br	25ccc <SDOS_SdoInd+0x4fc>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   25d74:	8080028b 	ldhu	r2,10(r16)
   25d78:	a8ffffcc 	andi	r3,r21,65535
   25d7c:	1806d23a 	srli	r3,r3,8
   25d80:	1004923a 	slli	r2,r2,8
   25d84:	10c4b03a 	or	r2,r2,r3
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25d88:	98c00044 	addi	r3,r19,1
   25d8c:	1806d07a 	srli	r3,r3,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   25d90:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25d94:	39c00044 	addi	r7,r7,1
   25d98:	29400084 	addi	r5,r5,2
   25d9c:	31800084 	addi	r6,r6,2
   25da0:	38ffda2e 	bgeu	r7,r3,25d0c <SDOS_SdoInd+0x53c>
						pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
   25da4:	28bfff8b 	ldhu	r2,-2(r5)
   25da8:	2900000b 	ldhu	r4,0(r5)
   25dac:	1004d23a 	srli	r2,r2,8
   25db0:	2008923a 	slli	r4,r4,8
   25db4:	1104b03a 	or	r2,r2,r4
   25db8:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25dbc:	003ff506 	br	25d94 <SDOS_SdoInd+0x5c4>
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   25dc0:	d0a16d03 	ldbu	r2,-31308(gp)
   25dc4:	d1e16817 	ldw	r7,-31328(gp)
   25dc8:	d1a16917 	ldw	r6,-31324(gp)
   25dcc:	d8800115 	stw	r2,4(sp)
   25dd0:	d0a17117 	ldw	r2,-31292(gp)
   25dd4:	d1616c03 	ldbu	r5,-31312(gp)
   25dd8:	d1216c8b 	ldhu	r4,-31310(gp)
   25ddc:	d8800015 	stw	r2,0(sp)
   25de0:	0024f300 	call	24f30 <OBJ_Write>
					if (abort == ABORTIDX_WORKING)
   25de4:	15803fcc 	andi	r22,r2,255
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   25de8:	1023883a 	mov	r17,r2
					if (abort == ABORTIDX_WORKING)
   25dec:	b0803fd8 	cmpnei	r2,r22,255
   25df0:	1000161e 	bne	r2,zero,25e4c <SDOS_SdoInd+0x67c>
						u8PendingSdo = SDO_PENDING_SEG_WRITE;
   25df4:	00800084 	movi	r2,2
   25df8:	d0a17605 	stb	r2,-31272(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   25dfc:	d0a16d03 	ldbu	r2,-31308(gp)
						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
   25e00:	d4216e15 	stw	r16,-31304(gp)
						bSdoSegFollows = FALSE;
   25e04:	d0216d45 	stb	zero,-31307(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   25e08:	d0a175c5 	stb	r2,-31273(gp)
						u8StoreSubindex = nSdoSegSubindex;
   25e0c:	d0a16c03 	ldbu	r2,-31312(gp)
						nSdoSegService = 0;
   25e10:	d0216d85 	stb	zero,-31306(gp)
						nSdoSegBytesToHandle = 0;
   25e14:	d0216b15 	stw	zero,-31316(gp)
						u8StoreSubindex = nSdoSegSubindex;
   25e18:	d0a17585 	stb	r2,-31274(gp)
						u16StoreIndex = nSdoSegIndex;
   25e1c:	d0a16c8b 	ldhu	r2,-31310(gp)
   25e20:	d0a1750d 	sth	r2,-31276(gp)
						u32StoreDataSize = nSdoSegCompleteSize;
   25e24:	d0a16917 	ldw	r2,-31324(gp)
   25e28:	d0a17415 	stw	r2,-31280(gp)
						pStoreData = pSdoSegData;
   25e2c:	d0a17117 	ldw	r2,-31292(gp)
   25e30:	d0a17315 	stw	r2,-31284(gp)
						pSdoPendFunc = pSdoSegObjEntry->Write;
   25e34:	d0a16817 	ldw	r2,-31328(gp)
   25e38:	10800817 	ldw	r2,32(r2)
   25e3c:	d0a17215 	stw	r2,-31288(gp)
						bSdoInWork = TRUE;
   25e40:	00800044 	movi	r2,1
   25e44:	d0a16dc5 	stb	r2,-31305(gp)
	if (abort != ABORTIDX_WORKING)
   25e48:	003f6106 	br	25bd0 <SDOS_SdoInd+0x400>
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25e4c:	d1217117 	ldw	r4,-31292(gp)
   25e50:	0026bec0 	call	26bec <free>
						pSdoSegData = NULL;
   25e54:	d0217115 	stw	zero,-31292(gp)
	if (abort == 0)
   25e58:	b03fae26 	beq	r22,zero,25d14 <SDOS_SdoInd+0x544>
   25e5c:	003f8606 	br	25c78 <SDOS_SdoInd+0x4a8>
   25e60:	00800c04 	movi	r2,48
   25e64:	003fb406 	br	25d38 <SDOS_SdoInd+0x568>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   25e68:	04400044 	movi	r17,1
   25e6c:	003f8206 	br	25c78 <SDOS_SdoInd+0x4a8>
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   25e70:	044000c4 	movi	r17,3
   25e74:	003f8006 	br	25c78 <SDOS_SdoInd+0x4a8>
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25e78:	d461658b 	ldhu	r17,-31338(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e7c:	d4e16b17 	ldw	r19,-31316(gp)
   25e80:	d0a16917 	ldw	r2,-31324(gp)
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25e84:	8c7ffdc4 	addi	r17,r17,-9
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e88:	8c7fffcc 	andi	r17,r17,65535
		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
   25e8c:	d5e16a05 	stb	r23,-31320(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e90:	8cc9883a 	add	r4,r17,r19
   25e94:	1100242e 	bgeu	r2,r4,25f28 <SDOS_SdoInd+0x758>
			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25e98:	14e3c83a 	sub	r17,r2,r19
			bSdoSegFollows = FALSE;
   25e9c:	a039883a 	mov	fp,r20
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ea0:	980cd07a 	srli	r6,r19,1
   25ea4:	d5a17117 	ldw	r22,-31292(gp)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   25ea8:	a8c03fcc 	andi	r3,r21,255
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25eac:	300a907a 	slli	r5,r6,1
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   25eb0:	80c0020d 	sth	r3,8(r16)
			bSdoSegFollows = FALSE;
   25eb4:	d7216d45 	stb	fp,-31307(gp)
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25eb8:	b145883a 	add	r2,r22,r5
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ebc:	9900004c 	andi	r4,r19,1
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ec0:	1080000b 	ldhu	r2,0(r2)
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ec4:	20001a26 	beq	r4,zero,25f30 <SDOS_SdoInd+0x760>
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ec8:	10bfc00c 	andi	r2,r2,65280
   25ecc:	1886b03a 	or	r3,r3,r2
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   25ed0:	29400084 	addi	r5,r5,2
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ed4:	80c0020d 	sth	r3,8(r16)
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   25ed8:	89bfffc4 	addi	r6,r17,-1
   25edc:	b14b883a 	add	r5,r22,r5
   25ee0:	81000284 	addi	r4,r16,10
   25ee4:	0026ee40 	call	26ee4 <memcpy>
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25ee8:	8080018b 	ldhu	r2,6(r16)
		if (bSdoSegFollows)
   25eec:	e7003fcc 	andi	fp,fp,255
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25ef0:	8807883a 	mov	r3,r17
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25ef4:	1083ffcc 	andi	r2,r2,4095
		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25ef8:	108c0014 	ori	r2,r2,12288
   25efc:	8080018d 	sth	r2,6(r16)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
   25f00:	8080020b 	ldhu	r2,8(r16)
   25f04:	890001f0 	cmpltui	r4,r17,7
   25f08:	10bfc00c 	andi	r2,r2,65280
		if (bSdoSegFollows)
   25f0c:	e0001d26 	beq	fp,zero,25f84 <SDOS_SdoInd+0x7b4>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
   25f10:	15c4b03a 	or	r2,r2,r23
   25f14:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   25f18:	20002e1e 	bne	r4,zero,25fd4 <SDOS_SdoInd+0x804>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25f1c:	18c000c4 	addi	r3,r3,3
   25f20:	80c0000d 	sth	r3,0(r16)
		if (bSdoSegFollows == TRUE)
   25f24:	00003206 	br	25ff0 <SDOS_SdoInd+0x820>
   25f28:	07000044 	movi	fp,1
   25f2c:	003fdc06 	br	25ea0 <SDOS_SdoInd+0x6d0>
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   25f30:	1004923a 	slli	r2,r2,8
			for (i = 0; i < (size >> 1); i++)
   25f34:	880ed07a 	srli	r7,r17,1
   25f38:	000b883a 	mov	r5,zero
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   25f3c:	1886b03a 	or	r3,r3,r2
   25f40:	80c0020d 	sth	r3,8(r16)
			for (i = 0; i < (size >> 1); i++)
   25f44:	28bfffcc 	andi	r2,r5,65535
   25f48:	11ffe72e 	bgeu	r2,r7,25ee8 <SDOS_SdoInd+0x718>
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   25f4c:	1187883a 	add	r3,r2,r6
   25f50:	1806907a 	slli	r3,r3,1
   25f54:	10800104 	addi	r2,r2,4
   25f58:	1004907a 	slli	r2,r2,1
   25f5c:	b0c7883a 	add	r3,r22,r3
   25f60:	1900008b 	ldhu	r4,2(r3)
   25f64:	18c0000b 	ldhu	r3,0(r3)
   25f68:	8085883a 	add	r2,r16,r2
   25f6c:	2008923a 	slli	r4,r4,8
   25f70:	1806d23a 	srli	r3,r3,8
			for (i = 0; i < (size >> 1); i++)
   25f74:	29400044 	addi	r5,r5,1
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   25f78:	20c6b03a 	or	r3,r4,r3
   25f7c:	10c0008d 	sth	r3,2(r2)
			for (i = 0; i < (size >> 1); i++)
   25f80:	003ff006 	br	25f44 <SDOS_SdoInd+0x774>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
   25f84:	bdc00054 	ori	r23,r23,1
   25f88:	15c4b03a 	or	r2,r2,r23
   25f8c:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   25f90:	2000081e 	bne	r4,zero,25fb4 <SDOS_SdoInd+0x7e4>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25f94:	18c000c4 	addi	r3,r3,3
   25f98:	80c0000d 	sth	r3,0(r16)
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25f9c:	b009883a 	mov	r4,r22
   25fa0:	0026bec0 	call	26bec <free>
			pSdoSegData = NULL;
   25fa4:	d0217115 	stw	zero,-31292(gp)
			nSdoSegBytesToHandle = 0;
   25fa8:	d0216b15 	stw	zero,-31316(gp)
			nSdoSegService = 0;
   25fac:	d0216d85 	stb	zero,-31306(gp)
	if (abort != ABORTIDX_WORKING)
   25fb0:	003f6806 	br	25d54 <SDOS_SdoInd+0x584>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25fb4:	01000284 	movi	r4,10
   25fb8:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   25fbc:	010001c4 	movi	r4,7
   25fc0:	20c7c83a 	sub	r3,r4,r3
   25fc4:	1806907a 	slli	r3,r3,1
   25fc8:	1884b03a 	or	r2,r3,r2
   25fcc:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   25fd0:	003ff206 	br	25f9c <SDOS_SdoInd+0x7cc>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25fd4:	01000284 	movi	r4,10
   25fd8:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   25fdc:	010001c4 	movi	r4,7
   25fe0:	20c7c83a 	sub	r3,r4,r3
   25fe4:	1806907a 	slli	r3,r3,1
   25fe8:	1884b03a 	or	r2,r3,r2
   25fec:	8080020d 	sth	r2,8(r16)
			nSdoSegBytesToHandle += size;
   25ff0:	9c67883a 	add	r19,r19,r17
   25ff4:	d4e16b15 	stw	r19,-31316(gp)
	if (abort != ABORTIDX_WORKING)
   25ff8:	003f5606 	br	25d54 <SDOS_SdoInd+0x584>
	UINT32 dataSize = 0;
   25ffc:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   26000:	0039883a 	mov	fp,zero
			abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26004:	04400204 	movi	r17,8
   26008:	003e9406 	br	25a5c <SDOS_SdoInd+0x28c>
   2600c:	0013883a 	mov	r9,zero
   26010:	0039883a 	mov	fp,zero
   26014:	04400444 	movi	r17,17
   26018:	003e9006 	br	25a5c <SDOS_SdoInd+0x28c>
		return MBXERR_SERVICEINWORK;
   2601c:	05000244 	movi	r20,9
   26020:	003eeb06 	br	25bd0 <SDOS_SdoInd+0x400>
							return MBXERR_INVALIDSIZE;
   26024:	05000204 	movi	r20,8
   26028:	003ee906 	br	25bd0 <SDOS_SdoInd+0x400>
					if (objLength == 0)
   2602c:	e000031e 	bne	fp,zero,2603c <SDOS_SdoInd+0x86c>
						nSdoSegIndex = index;
   26030:	d4e16c8d 	sth	r19,-31310(gp)
						nSdoSegSubindex = subindex;
   26034:	d5a16c05 	stb	r22,-31312(gp)
						pSdoSegObjEntry = pObjEntry;
   26038:	d5e16815 	stw	r23,-31328(gp)
						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
   2603c:	d8800217 	ldw	r2,8(sp)
   26040:	db000015 	stw	r12,0(sp)
   26044:	480d883a 	mov	r6,r9
   26048:	d8800115 	stw	r2,4(sp)
   2604c:	b80f883a 	mov	r7,r23
   26050:	993fffcc 	andi	r4,r19,65535
   26054:	db000515 	stw	r12,20(sp)
   26058:	da400415 	stw	r9,16(sp)
   2605c:	0024f300 	call	24f30 <OBJ_Write>
   26060:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   26064:	10803fcc 	andi	r2,r2,255
   26068:	10803fd8 	cmpnei	r2,r2,255
   2606c:	da400417 	ldw	r9,16(sp)
   26070:	db000517 	ldw	r12,20(sp)
   26074:	103e791e 	bne	r2,zero,25a5c <SDOS_SdoInd+0x28c>
							bStoreCompleteAccess = bCompleteAccess;
   26078:	d8c00217 	ldw	r3,8(sp)
							pSdoPendFunc = pObjEntry->Write;
   2607c:	b9000817 	ldw	r4,32(r23)
							u8PendingSdo = SDO_PENDING_WRITE;
   26080:	00800044 	movi	r2,1
   26084:	d0a17605 	stb	r2,-31272(gp)
							bStoreCompleteAccess = bCompleteAccess;
   26088:	d0e175c5 	stb	r3,-31273(gp)
							u8StoreSubindex = subindex;
   2608c:	d5a17585 	stb	r22,-31274(gp)
							u16StoreIndex = index;
   26090:	d4e1750d 	sth	r19,-31276(gp)
							u32StoreDataSize = dataSize;
   26094:	d2617415 	stw	r9,-31280(gp)
							pStoreData = pData;
   26098:	d3217315 	stw	r12,-31284(gp)
							pSdoPendFunc = pObjEntry->Write;
   2609c:	d1217215 	stw	r4,-31288(gp)
   260a0:	003e9406 	br	25af4 <SDOS_SdoInd+0x324>
				if (subindex > 1)
   260a4:	288000a8 	cmpgeui	r2,r5,2
   260a8:	103e9926 	beq	r2,zero,25b10 <SDOS_SdoInd+0x340>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   260ac:	5013883a 	mov	r9,r10
							abort = ABORTIDX_UNSUPPORTED_ACCESS;
   260b0:	04400144 	movi	r17,5
   260b4:	003e6906 	br	25a5c <SDOS_SdoInd+0x28c>
							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
   260b8:	83000304 	addi	r12,r16,12
   260bc:	e013883a 	mov	r9,fp
   260c0:	003e7206 	br	25a8c <SDOS_SdoInd+0x2bc>

000260c4 <SDOS_SdoRes>:

void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
{
	UINT16 dataSize = 0;

	if (bSdoInWork)
   260c4:	d0a16dc3 	ldbu	r2,-31305(gp)
   260c8:	10004126 	beq	r2,zero,261d0 <SDOS_SdoRes+0x10c>
{
   260cc:	defff604 	addi	sp,sp,-40
   260d0:	dcc00515 	stw	r19,20(sp)
	{
		/* SDO-Response is expected */
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   260d4:	d4e16e17 	ldw	r19,-31304(gp)
{
   260d8:	dc800415 	stw	r18,16(sp)
   260dc:	dd400715 	stw	r21,28(sp)
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   260e0:	9c800203 	ldbu	r18,8(r19)
{
   260e4:	dd000615 	stw	r20,24(sp)
   260e8:	dc000215 	stw	r16,8(sp)
		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
   260ec:	9540040c 	andi	r21,r18,16

		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   260f0:	9480380c 	andi	r18,r18,224
{
   260f4:	dfc00915 	stw	ra,36(sp)
   260f8:	dd800815 	stw	r22,32(sp)
   260fc:	dc400315 	stw	r17,12(sp)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   26100:	90801018 	cmpnei	r2,r18,64
   26104:	2029883a 	mov	r20,r4
   26108:	2821883a 	mov	r16,r5
   2610c:	10002e1e 	bne	r2,zero,261c8 <SDOS_SdoRes+0x104>
		{
			/* dataSize contains the available size in one mailbox */
			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   26110:	d461658b 	ldhu	r17,-31338(gp)
   26114:	300b883a 	mov	r5,r6
   26118:	8c7ffc04 	addi	r17,r17,-16
   2611c:	882d883a 	mov	r22,r17
			if (dataSize < objLength)
   26120:	8c7fffcc 	andi	r17,r17,65535
   26124:	8c001e2e 	bgeu	r17,r16,261a0 <SDOS_SdoRes+0xdc>
			{
				/* Segmented Upload, the variables for the segmented transfer should be initialized */
				bSdoSegFollows = TRUE;
   26128:	00800044 	movi	r2,1
   2612c:	d0a16d45 	stb	r2,-31307(gp)
				bSdoSegLastToggle = 1;
   26130:	d0a16a05 	stb	r2,-31320(gp)
				bSdoSegAccess = completeAccess;
				nSdoSegCompleteSize = objLength;
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
				pSdoSegData = (UINT16 VARMEM *) pData;
   26134:	d1a17115 	stw	r6,-31292(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26138:	00801804 	movi	r2,96
				/* the first segment shall be copied */
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   2613c:	880d883a 	mov	r6,r17
   26140:	99000404 	addi	r4,r19,16
				bSdoSegAccess = completeAccess;
   26144:	d5616d05 	stb	r21,-31308(gp)
				nSdoSegCompleteSize = objLength;
   26148:	d4216915 	stw	r16,-31324(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   2614c:	d0a16d85 	stb	r2,-31306(gp)
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   26150:	0026ee40 	call	26ee4 <memcpy>
				nSdoSegBytesToHandle = dataSize;
   26154:	d4616b15 	stw	r17,-31316(gp)
				}
		}

		/* SDO access is finished, send the response */
		bSdoInWork = FALSE;
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26158:	dcc00115 	stw	r19,4(sp)
   2615c:	dc000015 	stw	r16,0(sp)
   26160:	b1ffffcc 	andi	r7,r22,65535
   26164:	a80d883a 	mov	r6,r21
   26168:	900b883a 	mov	r5,r18
   2616c:	a1003fcc 	andi	r4,r20,255
		bSdoInWork = FALSE;
   26170:	d0216dc5 	stb	zero,-31305(gp)
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26174:	00256700 	call	25670 <SdoRes>
	}
}
   26178:	dfc00917 	ldw	ra,36(sp)
   2617c:	dd800817 	ldw	r22,32(sp)
   26180:	dd400717 	ldw	r21,28(sp)
   26184:	dd000617 	ldw	r20,24(sp)
   26188:	dcc00517 	ldw	r19,20(sp)
   2618c:	dc800417 	ldw	r18,16(sp)
   26190:	dc400317 	ldw	r17,12(sp)
   26194:	dc000217 	ldw	r16,8(sp)
   26198:	dec00a04 	addi	sp,sp,40
   2619c:	f800283a 	ret
				if ((objLength <= 4) && (objLength > 0))
   261a0:	80bfffc4 	addi	r2,r16,-1
   261a4:	10800128 	cmpgeui	r2,r2,4
   261a8:	1000051e 	bne	r2,zero,261c0 <SDOS_SdoRes+0xfc>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
   261ac:	99000304 	addi	r4,r19,12
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   261b0:	217fe926 	beq	r4,r5,26158 <SDOS_SdoRes+0x94>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
   261b4:	800d883a 	mov	r6,r16
   261b8:	0026ee40 	call	26ee4 <memcpy>
   261bc:	003fe606 	br	26158 <SDOS_SdoRes+0x94>
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   261c0:	99000404 	addi	r4,r19,16
   261c4:	003ffa06 	br	261b0 <SDOS_SdoRes+0xec>
	UINT16 dataSize = 0;
   261c8:	002d883a 	mov	r22,zero
   261cc:	003fe206 	br	26158 <SDOS_SdoRes+0x94>
   261d0:	f800283a 	ret

000261d4 <SDOS_ClearPendingResponse>:
		   This function shall be called before the other mailbox data pointer are set to NULL
*////////////////////////////////////////////////////////////////////////////////////////

void  SDOS_ClearPendingResponse(void)
{
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   261d4:	d0a16dc3 	ldbu	r2,-31305(gp)
{
   261d8:	deffff04 	addi	sp,sp,-4
   261dc:	dfc00015 	stw	ra,0(sp)
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   261e0:	10800058 	cmpnei	r2,r2,1
   261e4:	1000081e 	bne	r2,zero,26208 <SDOS_ClearPendingResponse+0x34>
   261e8:	d1216e17 	ldw	r4,-31304(gp)
   261ec:	20000626 	beq	r4,zero,26208 <SDOS_ClearPendingResponse+0x34>
   261f0:	d0a16017 	ldw	r2,-31360(gp)
   261f4:	20800426 	beq	r4,r2,26208 <SDOS_ClearPendingResponse+0x34>
   261f8:	d0a15f17 	ldw	r2,-31364(gp)
   261fc:	20800226 	beq	r4,r2,26208 <SDOS_ClearPendingResponse+0x34>
	{
		APPL_FreeMailboxBuffer(pSdoResStored);
   26200:	0026bec0 	call	26bec <free>
		pSdoResStored = NULL;
   26204:	d0216e15 	stw	zero,-31304(gp)
	u32StoreDataSize = 0;
	pStoreData = NULL;
	pSdoPendFunc = NULL;
	bSdoInWork = FALSE;

	if (pSdoSegData != NULL)
   26208:	d1217117 	ldw	r4,-31292(gp)
	u8PendingSdo = 0;
   2620c:	d0217605 	stb	zero,-31272(gp)
	bStoreCompleteAccess = FALSE;
   26210:	d02175c5 	stb	zero,-31273(gp)
	u16StoreIndex = 0;
   26214:	d021750d 	sth	zero,-31276(gp)
	u8StoreSubindex = 0;
   26218:	d0217585 	stb	zero,-31274(gp)
	u32StoreDataSize = 0;
   2621c:	d0217415 	stw	zero,-31280(gp)
	pStoreData = NULL;
   26220:	d0217315 	stw	zero,-31284(gp)
	pSdoPendFunc = NULL;
   26224:	d0217215 	stw	zero,-31288(gp)
	bSdoInWork = FALSE;
   26228:	d0216dc5 	stb	zero,-31305(gp)
	if (pSdoSegData != NULL)
   2622c:	20000226 	beq	r4,zero,26238 <SDOS_ClearPendingResponse+0x64>
	{
		FREEMEM((UINT16 VARMEM *) pSdoSegData);
   26230:	0026bec0 	call	26bec <free>
		pSdoSegData = NULL;
   26234:	d0217115 	stw	zero,-31292(gp)
	}

	nSdoSegBytesToHandle = 0;
   26238:	d0216b15 	stw	zero,-31316(gp)
	nSdoSegService = 0;
   2623c:	d0216d85 	stb	zero,-31306(gp)

}
   26240:	dfc00017 	ldw	ra,0(sp)
   26244:	dec00104 	addi	sp,sp,4
   26248:	f800283a 	ret

0002624c <SDOS_SdoInfoInd>:
			is received from the master and calls depending from
			the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
{
   2624c:	defff804 	addi	sp,sp,-32
   26250:	dcc00515 	stw	r19,20(sp)
	UINT8 abort = 0;
	/* the variable opCode contains the requested SDO Information type */
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26254:	24c00203 	ldbu	r19,8(r4)
{
   26258:	dc800415 	stw	r18,16(sp)
   2625c:	dc000215 	stw	r16,8(sp)
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26260:	9c801fcc 	andi	r18,r19,127
{
   26264:	dfc00715 	stw	ra,28(sp)
   26268:	dd000615 	stw	r20,24(sp)
   2626c:	dc400315 	stw	r17,12(sp)
	UINT8 abort = 0;
   26270:	d8000145 	stb	zero,5(sp)
	UINT16 index;
	UINT8 flags = COE_SERVICE;

	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
	   great enough for the service header of the requested SDO Information type */
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26274:	90c00158 	cmpnei	r3,r18,5
   26278:	2080000b 	ldhu	r2,0(r4)
{
   2627c:	2021883a 	mov	r16,r4
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26280:	9027883a 	mov	r19,r18
   26284:	1800041e 	bne	r3,zero,26298 <SDOS_SdoInfoInd+0x4c>
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
   26288:	108002b0 	cmpltui	r2,r2,10
   2628c:	10000926 	beq	r2,zero,262b4 <SDOS_SdoInfoInd+0x68>
		{
			return MBXERR_SIZETOOSHORT;
   26290:	00800184 	movi	r2,6
   26294:	00004b06 	br	263c4 <SDOS_SdoInfoInd+0x178>
		}
	}
	else
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
   26298:	10800230 	cmpltui	r2,r2,8
   2629c:	103ffc1e 	bne	r2,zero,26290 <SDOS_SdoInfoInd+0x44>
		{
			return MBXERR_SIZETOOSHORT;
		}
	}

	switch (opCode)
   262a0:	90800060 	cmpeqi	r2,r18,1
   262a4:	10000b1e 	bne	r2,zero,262d4 <SDOS_SdoInfoInd+0x88>
   262a8:	9000dc26 	beq	r18,zero,2661c <SDOS_SdoInfoInd+0x3d0>
   262ac:	908000e0 	cmpeqi	r2,r18,3
   262b0:	1000da26 	beq	r2,zero,2661c <SDOS_SdoInfoInd+0x3d0>
		break;

	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
		/* get the requested index */
		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
   262b4:	8100030b 	ldhu	r4,12(r16)
   262b8:	d900018d 	sth	r4,6(sp)



		if (index < 0x1000)
   262bc:	213fffcc 	andi	r4,r4,65535
   262c0:	20840028 	cmpgeui	r2,r4,4096
   262c4:	1000741e 	bne	r2,zero,26498 <SDOS_SdoInfoInd+0x24c>
		{
			/*SDO Info access is only allowed for objects >= 0x1000*/
			abort = ABORTIDX_UNSUPPORTED_ACCESS;
   262c8:	00800144 	movi	r2,5
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
			}
		}
		break;
	default:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   262cc:	d8800145 	stb	r2,5(sp)
   262d0:	00009506 	br	26528 <SDOS_SdoInfoInd+0x2dc>
		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
   262d4:	2440030b 	ldhu	r17,12(r4)
   262d8:	8cbfffcc 	andi	r18,r17,65535
   262dc:	908001b0 	cmpltui	r2,r18,6
   262e0:	10009126 	beq	r2,zero,26528 <SDOS_SdoInfoInd+0x2dc>
			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
   262e4:	200b883a 	mov	r5,r4
   262e8:	010000f4 	movhi	r4,3
   262ec:	01800384 	movi	r6,14
   262f0:	2121fc04 	addi	r4,r4,-30736
   262f4:	0026ee40 	call	26ee4 <memcpy>
			if (listType-- == 0)
   262f8:	90003a1e 	bne	r18,zero,263e4 <SDOS_SdoInfoInd+0x198>
				nSdoInfoFragmentsLeft = 0;
   262fc:	d021708d 	sth	zero,-31294(gp)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26300:	84800384 	addi	r18,r16,14
				nSdoInfoFragmentsLeft = 0;
   26304:	0023883a 	mov	r17,zero
					UINT16 n = OBJ_GetNoOfObjects(i);
   26308:	8809883a 	mov	r4,r17
   2630c:	00244500 	call	24450 <OBJ_GetNoOfObjects>
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26310:	8c400044 	addi	r17,r17,1
					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
   26314:	9080000d 	sth	r2,0(r18)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26318:	88800158 	cmpnei	r2,r17,5
   2631c:	94800084 	addi	r18,r18,2
   26320:	103ff91e 	bne	r2,zero,26308 <SDOS_SdoInfoInd+0xbc>
				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
   26324:	00800484 	movi	r2,18
			pSdoInfoInd->MbxHeader.Length = size;
   26328:	8080000d 	sth	r2,0(r16)
			if (abort == 0)
   2632c:	d8800143 	ldbu	r2,5(sp)
   26330:	10007d1e 	bne	r2,zero,26528 <SDOS_SdoInfoInd+0x2dc>
				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26334:	8080020b 	ldhu	r2,8(r16)
   26338:	00ffe004 	movi	r3,-128
   2633c:	10c6703a 	and	r3,r2,r3
				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
   26340:	18c00094 	ori	r3,r3,2
   26344:	80c0020d 	sth	r3,8(r16)
				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
   26348:	d0e1708b 	ldhu	r3,-31294(gp)
   2634c:	80c0028d 	sth	r3,10(r16)
				if (nSdoInfoFragmentsLeft)
   26350:	18ffffcc 	andi	r3,r3,65535
   26354:	18007426 	beq	r3,zero,26528 <SDOS_SdoInfoInd+0x2dc>
					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
   26358:	00ffc004 	movi	r3,-256
   2635c:	10c4703a 	and	r2,r2,r3
   26360:	10802094 	ori	r2,r2,130
   26364:	8080020d 	sth	r2,8(r16)
					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
   26368:	017fe084 	movi	r5,-126
	}

	if (abort)
   2636c:	d8c00143 	ldbu	r3,5(sp)
   26370:	18000d26 	beq	r3,zero,263a8 <SDOS_SdoInfoInd+0x15c>
	{
		/* send a SDO Information Error response */
		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
   26374:	00800284 	movi	r2,10
   26378:	8080000d 	sth	r2,0(r16)

		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   2637c:	8080020b 	ldhu	r2,8(r16)
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);

		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   26380:	180690ba 	slli	r3,r3,2
		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26384:	8000028d 	sth	zero,10(r16)
		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26388:	10bfe00c 	andi	r2,r2,65408
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
   2638c:	108001d4 	ori	r2,r2,7
   26390:	8080020d 	sth	r2,8(r16)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   26394:	008000b4 	movhi	r2,2
   26398:	1885883a 	add	r2,r3,r2
   2639c:	109f0617 	ldw	r2,31768(r2)

		nSdoInfoFragmentsLeft = 0;
   263a0:	d021708d 	sth	zero,-31294(gp)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   263a4:	80800315 	stw	r2,12(r16)
	}

	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
   263a8:	29403fcc 	andi	r5,r5,255
   263ac:	8009883a 	mov	r4,r16
   263b0:	0023d8c0 	call	23d8c <MBX_MailboxSendReq>
   263b4:	10803fcc 	andi	r2,r2,255
   263b8:	10000126 	beq	r2,zero,263c0 <SDOS_SdoInfoInd+0x174>
	{
		/* if the mailbox response could not be sent (or stored), the response will be
		   stored in the variable pCoeSendStored and will be sent automatically
			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
			the next time from the master */
		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
   263bc:	d4214a15 	stw	r16,-31448(gp)
	}

	return 0;
   263c0:	0005883a 	mov	r2,zero
}
   263c4:	dfc00717 	ldw	ra,28(sp)
   263c8:	dd000617 	ldw	r20,24(sp)
   263cc:	dcc00517 	ldw	r19,20(sp)
   263d0:	dc800417 	ldw	r18,16(sp)
   263d4:	dc400317 	ldw	r17,12(sp)
   263d8:	dc000217 	ldw	r16,8(sp)
   263dc:	dec00804 	addi	sp,sp,32
   263e0:	f800283a 	ret
				if (nSdoInfoFragmentsLeft)
   263e4:	d4a1708b 	ldhu	r18,-31294(gp)
			if (listType-- == 0)
   263e8:	8c7fffc4 	addi	r17,r17,-1
					n = OBJ_GetNoOfObjects(listType);
   263ec:	8c403fcc 	andi	r17,r17,255
				if (nSdoInfoFragmentsLeft)
   263f0:	90bfffcc 	andi	r2,r18,65535
   263f4:	10001426 	beq	r2,zero,26448 <SDOS_SdoInfoInd+0x1fc>
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   263f8:	d4e1658b 	ldhu	r19,-31338(gp)
					index = nSdoInfoIndex;
   263fc:	d0a1700b 	ldhu	r2,-31296(gp)
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
   26400:	85000304 	addi	r20,r16,12
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   26404:	9cfffd04 	addi	r19,r19,-12
					index = nSdoInfoIndex;
   26408:	d880018d 	sth	r2,6(sp)
					nSdoInfoFragmentsLeft--;
   2640c:	94bfffc4 	addi	r18,r18,-1
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   26410:	d8800144 	addi	r2,sp,5
   26414:	d8800015 	stw	r2,0(sp)
   26418:	a00f883a 	mov	r7,r20
   2641c:	99bfffcc 	andi	r6,r19,65535
   26420:	d9400184 	addi	r5,sp,6
   26424:	8809883a 	mov	r4,r17
					nSdoInfoFragmentsLeft--;
   26428:	d4a1708d 	sth	r18,-31294(gp)
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   2642c:	00245080 	call	24508 <OBJ_GetObjectList>
				nSdoInfoIndex = index;
   26430:	d8c0018b 	ldhu	r3,6(sp)
   26434:	d0e1700d 	sth	r3,-31296(gp)
					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
   26438:	d0e1658b 	ldhu	r3,-31338(gp)
   2643c:	18fffe84 	addi	r3,r3,-6
   26440:	1885c83a 	sub	r2,r3,r2
   26444:	003fb806 	br	26328 <SDOS_SdoInfoInd+0xdc>
					n = OBJ_GetNoOfObjects(listType);
   26448:	8809883a 	mov	r4,r17
   2644c:	00244500 	call	24450 <OBJ_GetNoOfObjects>
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26450:	d161658b 	ldhu	r5,-31338(gp)
					if ((n << 1) > size)
   26454:	113fffcc 	andi	r4,r2,65535
					index = 0x1000;
   26458:	00c40004 	movi	r3,4096
					if ((n << 1) > size)
   2645c:	2008907a 	slli	r4,r4,1
					index = 0x1000;
   26460:	d8c0018d 	sth	r3,6(sp)
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26464:	28fffc84 	addi	r3,r5,-14
					if ((n << 1) > size)
   26468:	18bfffcc 	andi	r2,r3,65535
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   2646c:	1827883a 	mov	r19,r3
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
   26470:	85000384 	addi	r20,r16,14
					if ((n << 1) > size)
   26474:	113fe60e 	bge	r2,r4,26410 <SDOS_SdoInfoInd+0x1c4>
						UINT16 Fragsize = size + 2;
   26478:	297ffd04 	addi	r5,r5,-12
						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
   2647c:	297fffcc 	andi	r5,r5,65535
   26480:	2089c83a 	sub	r4,r4,r2
   26484:	28bfffc4 	addi	r2,r5,-1
   26488:	2089883a 	add	r4,r4,r2
   2648c:	0026a280 	call	26a28 <__divsi3>
   26490:	1025883a 	mov	r18,r2
   26494:	003fde06 	br	26410 <SDOS_SdoInfoInd+0x1c4>
			pObjEntry = OBJ_GetObjectHandle(index);
   26498:	00241440 	call	24144 <OBJ_GetObjectHandle>
   2649c:	1023883a 	mov	r17,r2
			if (pObjEntry)
   264a0:	10005c26 	beq	r2,zero,26614 <SDOS_SdoInfoInd+0x3c8>
				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
   264a4:	9cc000d8 	cmpnei	r19,r19,3
   264a8:	9800211e 	bne	r19,zero,26530 <SDOS_SdoInfoInd+0x2e4>
					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
   264ac:	1009883a 	mov	r4,r2
   264b0:	00246500 	call	24650 <OBJ_GetObjDesc>
   264b4:	01800104 	movi	r6,4
   264b8:	100b883a 	mov	r5,r2
   264bc:	81000384 	addi	r4,r16,14
   264c0:	0026ee40 	call	26ee4 <memcpy>
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   264c4:	d900018b 	ldhu	r4,6(sp)
   264c8:	000f883a 	mov	r7,zero
   264cc:	880d883a 	mov	r6,r17
   264d0:	000b883a 	mov	r5,zero
   264d4:	00242e40 	call	242e4 <OBJ_GetDesc>
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   264d8:	d0e1658b 	ldhu	r3,-31338(gp)
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   264dc:	10800304 	addi	r2,r2,12
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   264e0:	10bfffcc 	andi	r2,r2,65535
   264e4:	18fffec4 	addi	r3,r3,-5
   264e8:	10c0460e 	bge	r2,r3,26604 <SDOS_SdoInfoInd+0x3b8>
						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
   264ec:	d900018b 	ldhu	r4,6(sp)
   264f0:	81c00484 	addi	r7,r16,18
   264f4:	880d883a 	mov	r6,r17
   264f8:	000b883a 	mov	r5,zero
   264fc:	00242e40 	call	242e4 <OBJ_GetDesc>
   26500:	10800304 	addi	r2,r2,12
				if (abort == 0)
   26504:	d8c00143 	ldbu	r3,5(sp)
   26508:	1800071e 	bne	r3,zero,26528 <SDOS_SdoInfoInd+0x2dc>
						pSdoInfoInd->MbxHeader.Length = size;
   2650c:	8080000d 	sth	r2,0(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26510:	8080020b 	ldhu	r2,8(r16)
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26514:	94800044 	addi	r18,r18,1
						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26518:	8000028d 	sth	zero,10(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   2651c:	10bfe00c 	andi	r2,r2,65408
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26520:	14a4b03a 	or	r18,r2,r18
   26524:	8480020d 	sth	r18,8(r16)
	UINT8 flags = COE_SERVICE;
   26528:	01400084 	movi	r5,2
   2652c:	003f8f06 	br	2636c <SDOS_SdoInfoInd+0x120>
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26530:	1009883a 	mov	r4,r2
					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
   26534:	84c00383 	ldbu	r19,14(r16)
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26538:	00246500 	call	24650 <OBJ_GetObjDesc>
					if (subindex <= maxSubindex)
   2653c:	10800083 	ldbu	r2,2(r2)
   26540:	9cc03fcc 	andi	r19,r19,255
   26544:	14c02b36 	bltu	r2,r19,265f4 <SDOS_SdoInfoInd+0x3a8>
						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
   26548:	980b883a 	mov	r5,r19
   2654c:	8809883a 	mov	r4,r17
   26550:	002441c0 	call	2441c <OBJ_GetEntryDesc>
   26554:	01800184 	movi	r6,6
   26558:	100b883a 	mov	r5,r2
   2655c:	81000404 	addi	r4,r16,16
   26560:	0026ee40 	call	26ee4 <memcpy>
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26564:	80800383 	ldbu	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26568:	8809883a 	mov	r4,r17
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   2656c:	8080038d 	sth	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26570:	00246500 	call	24650 <OBJ_GetObjDesc>
						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   26574:	1080008b 	ldhu	r2,2(r2)
   26578:	1005d23a 	srai	r2,r2,8
   2657c:	108003cc 	andi	r2,r2,15
						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
   26580:	10bffe04 	addi	r2,r2,-8
   26584:	10bfffcc 	andi	r2,r2,65535
   26588:	108000a8 	cmpgeui	r2,r2,2
   2658c:	1000081e 	bne	r2,zero,265b0 <SDOS_SdoInfoInd+0x364>
   26590:	9800071e 	bne	r19,zero,265b0 <SDOS_SdoInfoInd+0x364>
							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
   26594:	014000f4 	movhi	r5,3
   26598:	01800344 	movi	r6,13
   2659c:	29600004 	addi	r5,r5,-32768
   265a0:	81000584 	addi	r4,r16,22
   265a4:	0026ee40 	call	26ee4 <memcpy>
							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
   265a8:	00800704 	movi	r2,28
   265ac:	003fd506 	br	26504 <SDOS_SdoInfoInd+0x2b8>
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265b0:	d900018b 	ldhu	r4,6(sp)
   265b4:	000f883a 	mov	r7,zero
   265b8:	880d883a 	mov	r6,r17
   265bc:	980b883a 	mov	r5,r19
   265c0:	00242e40 	call	242e4 <OBJ_GetDesc>
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   265c4:	d0e1658b 	ldhu	r3,-31338(gp)
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265c8:	10800404 	addi	r2,r2,16
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   265cc:	10bfffcc 	andi	r2,r2,65535
   265d0:	18fffec4 	addi	r3,r3,-5
   265d4:	10c00d0e 	bge	r2,r3,2660c <SDOS_SdoInfoInd+0x3c0>
								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265d8:	d900018b 	ldhu	r4,6(sp)
   265dc:	81c00584 	addi	r7,r16,22
   265e0:	880d883a 	mov	r6,r17
   265e4:	980b883a 	mov	r5,r19
   265e8:	00242e40 	call	242e4 <OBJ_GetDesc>
   265ec:	10800404 	addi	r2,r2,16
   265f0:	003fc406 	br	26504 <SDOS_SdoInfoInd+0x2b8>
						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
   265f4:	00800444 	movi	r2,17
   265f8:	d8800145 	stb	r2,5(sp)
				UINT16 size = 0;
   265fc:	0005883a 	mov	r2,zero
   26600:	003fc006 	br	26504 <SDOS_SdoInfoInd+0x2b8>
						size = SIZEOF_SDOINFOOBJSTRUCT;
   26604:	00800304 	movi	r2,12
   26608:	003fbe06 	br	26504 <SDOS_SdoInfoInd+0x2b8>
								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   2660c:	00800404 	movi	r2,16
   26610:	003fbc06 	br	26504 <SDOS_SdoInfoInd+0x2b8>
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26614:	00800204 	movi	r2,8
   26618:	003f2c06 	br	262cc <SDOS_SdoInfoInd+0x80>
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   2661c:	008000c4 	movi	r2,3
   26620:	003f2a06 	br	262cc <SDOS_SdoInfoInd+0x80>

00026624 <exti0_isr>:

volatile int edge_capture;

//ISR routine
void exti0_isr (void * context)
{
   26624:	deffff04 	addi	sp,sp,-4
   26628:	dfc00015 	stw	ra,0(sp)
	 //IOWR_32DIRECT(USER_HANDLER_0_BASE, 0x204, 1); //DC SYNC
	 PDI_Isr();
   2662c:	00213940 	call	21394 <PDI_Isr>
	 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0);
   26630:	00800134 	movhi	r2,4
   26634:	10040b35 	stwio	zero,4140(r2)
	 IORD_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE);
   26638:	10840b37 	ldwio	r2,4140(r2)
	 ECAT_CheckTimer();
   2663c:	0020de80 	call	20de8 <ECAT_CheckTimer>
	 appTimerRun();
	 // for debugging
	 //printf("Called ISR!\n");
}
   26640:	dfc00017 	ldw	ra,0(sp)
   26644:	dec00104 	addi	sp,sp,4
	 appTimerRun();
   26648:	00268041 	jmpi	26804 <appTimerRun>

0002664c <init_exti0_it>:

void init_exti0_it (void)
{
   2664c:	defffe04 	addi	sp,sp,-8
   26650:	dfc00115 	stw	ra,4(sp)
	 void* edge_capture_ptr = (void*) &edge_capture;
	 IOWR_ALTERA_AVALON_PIO_IRQ_MASK(ESC_SPI_SINT_BASE, 0x1);
   26654:	00c00044 	movi	r3,1
   26658:	00800134 	movhi	r2,4
   2665c:	10c40a35 	stwio	r3,4136(r2)
	 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0x0);
   26660:	10040b35 	stwio	zero,4140(r2)
	 alt_ic_isr_register(ESC_SPI_SINT_IRQ_INTERRUPT_CONTROLLER_ID, ESC_SPI_SINT_IRQ, exti0_isr, edge_capture_ptr, 0x0);
   26664:	018000b4 	movhi	r6,2
   26668:	d8000015 	stw	zero,0(sp)
   2666c:	d1e17704 	addi	r7,gp,-31268
   26670:	31998904 	addi	r6,r6,26148
   26674:	01400084 	movi	r5,2
   26678:	0009883a 	mov	r4,zero
   2667c:	00271880 	call	27188 <alt_ic_isr_register>
	 IORD_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE);
   26680:	00800134 	movhi	r2,4
   26684:	10840b37 	ldwio	r2,4140(r2)
	 //IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0x0);
}
   26688:	dfc00117 	ldw	ra,4(sp)
   2668c:	dec00204 	addi	sp,sp,8
   26690:	f800283a 	ret

00026694 <delay_ms>:
#include "stdint.h"

// Delay function
// No Parameters
void delay_ms(int milliseconds) {
    usleep(milliseconds * 1000);  // Convert to microseconds
   26694:	2100fa24 	muli	r4,r4,1000
   26698:	00273801 	jmpi	27380 <usleep>

0002669c <adc_init>:
// Parameter 2: Base address for SPI Chip Select Manual
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){

	int spi_check = -1;
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   2669c:	008100f4 	movhi	r2,1027
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   266a0:	defff404 	addi	sp,sp,-48
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   266a4:	10804044 	addi	r2,r2,257
   266a8:	d8800415 	stw	r2,16(sp)
	alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   266ac:	00954184 	movi	r2,21766
   266b0:	d8800515 	stw	r2,20(sp)
	alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
   266b4:	008201f4 	movhi	r2,2055
   266b8:	10818144 	addi	r2,r2,1541
   266bc:	d8800615 	stw	r2,24(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   266c0:	00954144 	movi	r2,21765
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   266c4:	dc400a15 	stw	r17,40(sp)
   266c8:	dc000915 	stw	r16,36(sp)
   266cc:	dfc00b15 	stw	ra,44(sp)
   266d0:	2021883a 	mov	r16,r4
   266d4:	2823883a 	mov	r17,r5
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   266d8:	d8000315 	stw	zero,12(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   266dc:	d8800715 	stw	r2,28(sp)
	uint8_t opcode_lock_receive[4] = {0x00, 0x00, 0x00, 0x00};
   266e0:	d8000815 	stw	zero,32(sp)

	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   266e4:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   266e8:	0104e204 	movi	r4,5000
   266ec:	00273800 	call	27380 <usleep>
	delay_ms(5);
	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   266f0:	00800044 	movi	r2,1
   266f4:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   266f8:	01138804 	movi	r4,20000
   266fc:	00273800 	call	27380 <usleep>
	delay_ms(20);

	spi_check = alt_avalon_spi_command(base,
   26700:	d9c00304 	addi	r7,sp,12
   26704:	01800104 	movi	r6,4
   26708:	000b883a 	mov	r5,zero
   2670c:	8009883a 	mov	r4,r16
   26710:	d8000215 	stw	zero,8(sp)
   26714:	d8000115 	stw	zero,4(sp)
   26718:	d8000015 	stw	zero,0(sp)
   2671c:	00274340 	call	27434 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26720:	0130d414 	movui	r4,50000
   26724:	00273800 	call	27380 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26728:	04400104 	movi	r17,4
   2672c:	d8800404 	addi	r2,sp,16
   26730:	8009883a 	mov	r4,r16
   26734:	d8000215 	stw	zero,8(sp)
   26738:	d8800115 	stw	r2,4(sp)
   2673c:	dc400015 	stw	r17,0(sp)
   26740:	000f883a 	mov	r7,zero
   26744:	000d883a 	mov	r6,zero
   26748:	000b883a 	mov	r5,zero
   2674c:	00274340 	call	27434 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_null_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26750:	d9c00504 	addi	r7,sp,20
   26754:	01800104 	movi	r6,4
   26758:	000b883a 	mov	r5,zero
   2675c:	8009883a 	mov	r4,r16
   26760:	d8000215 	stw	zero,8(sp)
   26764:	d8000115 	stw	zero,4(sp)
   26768:	d8000015 	stw	zero,0(sp)
   2676c:	00274340 	call	27434 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26770:	0130d414 	movui	r4,50000
   26774:	00273800 	call	27380 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26778:	d8800604 	addi	r2,sp,24
   2677c:	8009883a 	mov	r4,r16
   26780:	d8000215 	stw	zero,8(sp)
   26784:	d8800115 	stw	r2,4(sp)
   26788:	dc400015 	stw	r17,0(sp)
   2678c:	000f883a 	mov	r7,zero
   26790:	000d883a 	mov	r6,zero
   26794:	000b883a 	mov	r5,zero
   26798:	00274340 	call	27434 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   2679c:	d9c00704 	addi	r7,sp,28
   267a0:	01800104 	movi	r6,4
   267a4:	000b883a 	mov	r5,zero
   267a8:	8009883a 	mov	r4,r16
   267ac:	d8000215 	stw	zero,8(sp)
   267b0:	d8000115 	stw	zero,4(sp)
   267b4:	d8000015 	stw	zero,0(sp)
   267b8:	00274340 	call	27434 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   267bc:	0130d414 	movui	r4,50000
   267c0:	00273800 	call	27380 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   267c4:	d8800804 	addi	r2,sp,32
   267c8:	000f883a 	mov	r7,zero
   267cc:	000d883a 	mov	r6,zero
   267d0:	000b883a 	mov	r5,zero
   267d4:	8009883a 	mov	r4,r16
   267d8:	d8000215 	stw	zero,8(sp)
   267dc:	d8800115 	stw	r2,4(sp)
   267e0:	dc400015 	stw	r17,0(sp)
   267e4:	00274340 	call	27434 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   267e8:	0130d414 	movui	r4,50000
   267ec:	00273800 	call	27380 <usleep>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);
	 delay_ms(50);
}
   267f0:	dfc00b17 	ldw	ra,44(sp)
   267f4:	dc400a17 	ldw	r17,40(sp)
   267f8:	dc000917 	ldw	r16,36(sp)
   267fc:	dec00c04 	addi	sp,sp,48
   26800:	f800283a 	ret

00026804 <appTimerRun>:

volatile uint32_t timerCounter = 0;

// runs every 1ms //run timer timely task
void appTimerRun(void) {
    timerCounter++;
   26804:	d0a17817 	ldw	r2,-31264(gp)
   26808:	10800044 	addi	r2,r2,1
   2680c:	d0a17815 	stw	r2,-31264(gp)

    // prevent overflow
    if (timerCounter == 4294967294) {
   26810:	d0a17817 	ldw	r2,-31264(gp)
   26814:	10bfff98 	cmpnei	r2,r2,-2
   26818:	1000011e 	bne	r2,zero,26820 <appTimerRun+0x1c>
        timerCounter = 0;
   2681c:	d0217815 	stw	zero,-31264(gp)
    }

    // TODO do ethercat averaging for ad4111 with dc sync
    if ((timerCounter % 1000) == 0) {
   26820:	d0a17817 	ldw	r2,-31264(gp)
    	//HAL_GPIO_TogglePin(LED_BLINK_GPIO_Port, LED_BLINK_Pin);
    }
}
   26824:	f800283a 	ret

00026828 <spi_transmit_receive>:
int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
                           */
{
   26828:	deffff04 	addi	sp,sp,-4
   2682c:	d8800117 	ldw	r2,4(sp)
  alt_u8 *rx_ptr = rx_buf;

  alt_32 credits = 1;							// credits for managing the tx and rx

  // 1. Slave selection
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26830:	00c00044 	movi	r3,1
   26834:	1946983a 	sll	r3,r3,r5
  const alt_u8 * write_end = tx_buf + length;	// calculate the end of the pointer for tx_buf
   26838:	3097883a 	add	r11,r6,r2
  alt_u8 * read_end = rx_buf + length;			// calculate the end of the pointer for rx_buf
   2683c:	3895883a 	add	r10,r7,r2
  volatile alt_u32 status = 0;
   26840:	d8000015 	stw	zero,0(sp)
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26844:	20c00535 	stwio	r3,20(r4)
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  // 3. Clears the data in RXDATA register
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26848:	20c00037 	ldwio	r3,0(r4)
  alt_32 credits = 1;							// credits for managing the tx and rx
   2684c:	00c00044 	movi	r3,1
   26850:	014003f4 	movhi	r5,15
   26854:	29509004 	addi	r5,r5,16960
	  alt_u32 timeout = SPI_TIMEOUT_MAX;
	  // Wait until either TX ready or RX ready (or timeout)

    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26858:	22400204 	addi	r9,r4,8
   2685c:	22000237 	ldwio	r8,8(r4)
   26860:	da000015 	stw	r8,0(sp)
      if (--timeout == 0)
   26864:	297fffc4 	addi	r5,r5,-1
   26868:	2800071e 	bne	r5,zero,26888 <spi_transmit_receive+0x60>
	  {
		  // Timeout occurred, release CS and return error code
		  IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   2686c:	20000335 	stwio	zero,12(r4)
		  return -1;
   26870:	00bfffc4 	movi	r2,-1
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);

  return length;	//read_length;
}
   26874:	dec00104 	addi	sp,sp,4
   26878:	f800283a 	ret
   2687c:	380b883a 	mov	r5,r7
   26880:	280f883a 	mov	r7,r5
   26884:	003ff206 	br	26850 <spi_transmit_receive+0x28>
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   26888:	da000017 	ldw	r8,0(sp)
   2688c:	4200100c 	andi	r8,r8,64
   26890:	40000126 	beq	r8,zero,26898 <spi_transmit_receive+0x70>
   26894:	1800031e 	bne	r3,zero,268a4 <spi_transmit_receive+0x7c>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
   26898:	da000017 	ldw	r8,0(sp)
   2689c:	4200200c 	andi	r8,r8,128
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   268a0:	403fed26 	beq	r8,zero,26858 <spi_transmit_receive+0x30>
    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   268a4:	d9400017 	ldw	r5,0(sp)
   268a8:	2940100c 	andi	r5,r5,64
   268ac:	28000726 	beq	r5,zero,268cc <spi_transmit_receive+0xa4>
   268b0:	00c0060e 	bge	zero,r3,268cc <spi_transmit_receive+0xa4>
      if (tx_ptr < write_end)
   268b4:	32c0172e 	bgeu	r6,r11,26914 <spi_transmit_receive+0xec>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *tx_ptr++);
   268b8:	31400044 	addi	r5,r6,1
   268bc:	31800003 	ldbu	r6,0(r6)
      credits--;
   268c0:	18ffffc4 	addi	r3,r3,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *tx_ptr++);
   268c4:	21800135 	stwio	r6,4(r4)
   268c8:	280d883a 	mov	r6,r5
    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   268cc:	d9400017 	ldw	r5,0(sp)
   268d0:	2940200c 	andi	r5,r5,128
   268d4:	283fe926 	beq	r5,zero,2687c <spi_transmit_receive+0x54>
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   268d8:	22000037 	ldwio	r8,0(r4)
        *rx_ptr++ = (alt_u8)rxdata;
   268dc:	39400044 	addi	r5,r7,1
   268e0:	3a000005 	stb	r8,0(r7)
      credits++;
   268e4:	18c00044 	addi	r3,r3,1
      if (read_ignore == 0 && rx_ptr == read_end)
   268e8:	517fe51e 	bne	r10,r5,26880 <spi_transmit_receive+0x58>
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   268ec:	48c00037 	ldwio	r3,0(r9)
   268f0:	d8c00015 	stw	r3,0(sp)
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   268f4:	d8c00017 	ldw	r3,0(sp)
   268f8:	18c0080c 	andi	r3,r3,32
   268fc:	183ffb26 	beq	r3,zero,268ec <spi_transmit_receive+0xc4>
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   26900:	d8c00217 	ldw	r3,8(sp)
   26904:	18c0004c 	andi	r3,r3,1
   26908:	183fda1e 	bne	r3,zero,26874 <spi_transmit_receive+0x4c>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   2690c:	20000335 	stwio	zero,12(r4)
  return length;	//read_length;
   26910:	003fd806 	br	26874 <spi_transmit_receive+0x4c>
        credits = -1024;
   26914:	00ff0004 	movi	r3,-1024
   26918:	003fec06 	br	268cc <spi_transmit_receive+0xa4>

0002691c <adc_init_spi_transmit_receive>:
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   2691c:	defff304 	addi	sp,sp,-52
		alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   26920:	00954184 	movi	r2,21766
   26924:	d8800515 	stw	r2,20(sp)
		uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   26928:	00954144 	movi	r2,21765
   2692c:	d8800715 	stw	r2,28(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   26930:	00824274 	movhi	r2,2313
   26934:	108201c4 	addi	r2,r2,2055
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26938:	dc400a15 	stw	r17,40(sp)
   2693c:	dc000915 	stw	r16,36(sp)
   26940:	dfc00c15 	stw	ra,48(sp)
   26944:	dc800b15 	stw	r18,44(sp)
   26948:	2021883a 	mov	r16,r4
   2694c:	2823883a 	mov	r17,r5
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26950:	d8000315 	stw	zero,12(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   26954:	d8800815 	stw	r2,32(sp)
		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26958:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   2695c:	0104e204 	movi	r4,5000
   26960:	00273800 	call	27380 <usleep>
		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   26964:	00800044 	movi	r2,1
   26968:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   2696c:	01138804 	movi	r4,20000
   26970:	00273800 	call	27380 <usleep>
		spi_check = spi_transmit_receive(	base,
   26974:	04400104 	movi	r17,4
   26978:	d9c00404 	addi	r7,sp,16
   2697c:	d9800304 	addi	r6,sp,12
   26980:	000b883a 	mov	r5,zero
   26984:	8009883a 	mov	r4,r16
   26988:	d8000115 	stw	zero,4(sp)
   2698c:	dc400015 	stw	r17,0(sp)
   26990:	00268280 	call	26828 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26994:	0100fa04 	movi	r4,1000
   26998:	00273800 	call	27380 <usleep>
		spi_check = spi_transmit_receive(	base,
   2699c:	d9c00604 	addi	r7,sp,24
   269a0:	d9800504 	addi	r6,sp,20
   269a4:	000b883a 	mov	r5,zero
   269a8:	8009883a 	mov	r4,r16
   269ac:	d8000115 	stw	zero,4(sp)
   269b0:	dc400015 	stw	r17,0(sp)
   269b4:	00268280 	call	26828 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   269b8:	0100fa04 	movi	r4,1000
   269bc:	00273800 	call	27380 <usleep>
		spi_check = spi_transmit_receive(	base,
   269c0:	dc800804 	addi	r18,sp,32
   269c4:	900f883a 	mov	r7,r18
   269c8:	d9800704 	addi	r6,sp,28
   269cc:	000b883a 	mov	r5,zero
   269d0:	8009883a 	mov	r4,r16
   269d4:	d8000115 	stw	zero,4(sp)
   269d8:	dc400015 	stw	r17,0(sp)
   269dc:	00268280 	call	26828 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   269e0:	0100fa04 	movi	r4,1000
   269e4:	00273800 	call	27380 <usleep>
		spi_check = alt_avalon_spi_command(base,
   269e8:	000f883a 	mov	r7,zero
   269ec:	000d883a 	mov	r6,zero
   269f0:	000b883a 	mov	r5,zero
   269f4:	8009883a 	mov	r4,r16
   269f8:	d8000215 	stw	zero,8(sp)
   269fc:	dc800115 	stw	r18,4(sp)
   26a00:	dc400015 	stw	r17,0(sp)
   26a04:	00274340 	call	27434 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26a08:	0100fa04 	movi	r4,1000
   26a0c:	00273800 	call	27380 <usleep>
}
   26a10:	dfc00c17 	ldw	ra,48(sp)
   26a14:	dc800b17 	ldw	r18,44(sp)
   26a18:	dc400a17 	ldw	r17,40(sp)
   26a1c:	dc000917 	ldw	r16,36(sp)
   26a20:	dec00d04 	addi	sp,sp,52
   26a24:	f800283a 	ret

00026a28 <__divsi3>:
   26a28:	20001a16 	blt	r4,zero,26a94 <__divsi3+0x6c>
   26a2c:	000f883a 	mov	r7,zero
   26a30:	2800020e 	bge	r5,zero,26a3c <__divsi3+0x14>
   26a34:	014bc83a 	sub	r5,zero,r5
   26a38:	39c0005c 	xori	r7,r7,1
   26a3c:	200d883a 	mov	r6,r4
   26a40:	00c00044 	movi	r3,1
   26a44:	2900092e 	bgeu	r5,r4,26a6c <__divsi3+0x44>
   26a48:	00800804 	movi	r2,32
   26a4c:	00c00044 	movi	r3,1
   26a50:	00000106 	br	26a58 <__divsi3+0x30>
   26a54:	10001226 	beq	r2,zero,26aa0 <__divsi3+0x78>
   26a58:	294b883a 	add	r5,r5,r5
   26a5c:	10bfffc4 	addi	r2,r2,-1
   26a60:	18c7883a 	add	r3,r3,r3
   26a64:	293ffb36 	bltu	r5,r4,26a54 <__divsi3+0x2c>
   26a68:	18000d26 	beq	r3,zero,26aa0 <__divsi3+0x78>
   26a6c:	0005883a 	mov	r2,zero
   26a70:	31400236 	bltu	r6,r5,26a7c <__divsi3+0x54>
   26a74:	314dc83a 	sub	r6,r6,r5
   26a78:	10c4b03a 	or	r2,r2,r3
   26a7c:	1806d07a 	srli	r3,r3,1
   26a80:	280ad07a 	srli	r5,r5,1
   26a84:	183ffa1e 	bne	r3,zero,26a70 <__divsi3+0x48>
   26a88:	38000126 	beq	r7,zero,26a90 <__divsi3+0x68>
   26a8c:	0085c83a 	sub	r2,zero,r2
   26a90:	f800283a 	ret
   26a94:	0109c83a 	sub	r4,zero,r4
   26a98:	01c00044 	movi	r7,1
   26a9c:	003fe406 	br	26a30 <__divsi3+0x8>
   26aa0:	0005883a 	mov	r2,zero
   26aa4:	003ff806 	br	26a88 <__divsi3+0x60>

00026aa8 <__modsi3>:
   26aa8:	20001716 	blt	r4,zero,26b08 <__modsi3+0x60>
   26aac:	000f883a 	mov	r7,zero
   26ab0:	2005883a 	mov	r2,r4
   26ab4:	2800010e 	bge	r5,zero,26abc <__modsi3+0x14>
   26ab8:	014bc83a 	sub	r5,zero,r5
   26abc:	00c00044 	movi	r3,1
   26ac0:	2900092e 	bgeu	r5,r4,26ae8 <__modsi3+0x40>
   26ac4:	01800804 	movi	r6,32
   26ac8:	00c00044 	movi	r3,1
   26acc:	00000106 	br	26ad4 <__modsi3+0x2c>
   26ad0:	30001026 	beq	r6,zero,26b14 <__modsi3+0x6c>
   26ad4:	294b883a 	add	r5,r5,r5
   26ad8:	31bfffc4 	addi	r6,r6,-1
   26adc:	18c7883a 	add	r3,r3,r3
   26ae0:	293ffb36 	bltu	r5,r4,26ad0 <__modsi3+0x28>
   26ae4:	18000b26 	beq	r3,zero,26b14 <__modsi3+0x6c>
   26ae8:	1806d07a 	srli	r3,r3,1
   26aec:	11400136 	bltu	r2,r5,26af4 <__modsi3+0x4c>
   26af0:	1145c83a 	sub	r2,r2,r5
   26af4:	280ad07a 	srli	r5,r5,1
   26af8:	183ffb1e 	bne	r3,zero,26ae8 <__modsi3+0x40>
   26afc:	38000126 	beq	r7,zero,26b04 <__modsi3+0x5c>
   26b00:	0085c83a 	sub	r2,zero,r2
   26b04:	f800283a 	ret
   26b08:	0109c83a 	sub	r4,zero,r4
   26b0c:	01c00044 	movi	r7,1
   26b10:	003fe706 	br	26ab0 <__modsi3+0x8>
   26b14:	2005883a 	mov	r2,r4
   26b18:	003ff806 	br	26afc <__modsi3+0x54>

00026b1c <__udivsi3>:
   26b1c:	200d883a 	mov	r6,r4
   26b20:	2900152e 	bgeu	r5,r4,26b78 <__udivsi3+0x5c>
   26b24:	28001416 	blt	r5,zero,26b78 <__udivsi3+0x5c>
   26b28:	00800804 	movi	r2,32
   26b2c:	00c00044 	movi	r3,1
   26b30:	00000206 	br	26b3c <__udivsi3+0x20>
   26b34:	10000e26 	beq	r2,zero,26b70 <__udivsi3+0x54>
   26b38:	28000416 	blt	r5,zero,26b4c <__udivsi3+0x30>
   26b3c:	294b883a 	add	r5,r5,r5
   26b40:	10bfffc4 	addi	r2,r2,-1
   26b44:	18c7883a 	add	r3,r3,r3
   26b48:	293ffa36 	bltu	r5,r4,26b34 <__udivsi3+0x18>
   26b4c:	18000826 	beq	r3,zero,26b70 <__udivsi3+0x54>
   26b50:	0005883a 	mov	r2,zero
   26b54:	31400236 	bltu	r6,r5,26b60 <__udivsi3+0x44>
   26b58:	314dc83a 	sub	r6,r6,r5
   26b5c:	10c4b03a 	or	r2,r2,r3
   26b60:	1806d07a 	srli	r3,r3,1
   26b64:	280ad07a 	srli	r5,r5,1
   26b68:	183ffa1e 	bne	r3,zero,26b54 <__udivsi3+0x38>
   26b6c:	f800283a 	ret
   26b70:	0005883a 	mov	r2,zero
   26b74:	f800283a 	ret
   26b78:	00c00044 	movi	r3,1
   26b7c:	003ff406 	br	26b50 <__udivsi3+0x34>

00026b80 <__umodsi3>:
   26b80:	2005883a 	mov	r2,r4
   26b84:	2900132e 	bgeu	r5,r4,26bd4 <__umodsi3+0x54>
   26b88:	28001216 	blt	r5,zero,26bd4 <__umodsi3+0x54>
   26b8c:	01800804 	movi	r6,32
   26b90:	00c00044 	movi	r3,1
   26b94:	00000206 	br	26ba0 <__umodsi3+0x20>
   26b98:	30000c26 	beq	r6,zero,26bcc <__umodsi3+0x4c>
   26b9c:	28000416 	blt	r5,zero,26bb0 <__umodsi3+0x30>
   26ba0:	294b883a 	add	r5,r5,r5
   26ba4:	31bfffc4 	addi	r6,r6,-1
   26ba8:	18c7883a 	add	r3,r3,r3
   26bac:	293ffa36 	bltu	r5,r4,26b98 <__umodsi3+0x18>
   26bb0:	18000626 	beq	r3,zero,26bcc <__umodsi3+0x4c>
   26bb4:	1806d07a 	srli	r3,r3,1
   26bb8:	11400136 	bltu	r2,r5,26bc0 <__umodsi3+0x40>
   26bbc:	1145c83a 	sub	r2,r2,r5
   26bc0:	280ad07a 	srli	r5,r5,1
   26bc4:	183ffb1e 	bne	r3,zero,26bb4 <__umodsi3+0x34>
   26bc8:	f800283a 	ret
   26bcc:	2005883a 	mov	r2,r4
   26bd0:	f800283a 	ret
   26bd4:	00c00044 	movi	r3,1
   26bd8:	003ff606 	br	26bb4 <__umodsi3+0x34>

00026bdc <malloc>:
   26bdc:	008000f4 	movhi	r2,3
   26be0:	200b883a 	mov	r5,r4
   26be4:	11203817 	ldw	r4,-32544(r2)
   26be8:	0026c881 	jmpi	26c88 <_malloc_r>

00026bec <free>:
   26bec:	008000f4 	movhi	r2,3
   26bf0:	200b883a 	mov	r5,r4
   26bf4:	11203817 	ldw	r4,-32544(r2)
   26bf8:	0026f901 	jmpi	26f90 <_free_r>

00026bfc <sbrk_aligned>:
   26bfc:	008000f4 	movhi	r2,3
   26c00:	10a19517 	ldw	r2,-31148(r2)
   26c04:	defffd04 	addi	sp,sp,-12
   26c08:	dc400115 	stw	r17,4(sp)
   26c0c:	dc000015 	stw	r16,0(sp)
   26c10:	dfc00215 	stw	ra,8(sp)
   26c14:	2023883a 	mov	r17,r4
   26c18:	2821883a 	mov	r16,r5
   26c1c:	1000041e 	bne	r2,zero,26c30 <sbrk_aligned+0x34>
   26c20:	000b883a 	mov	r5,zero
   26c24:	0026f480 	call	26f48 <_sbrk_r>
   26c28:	00c000f4 	movhi	r3,3
   26c2c:	18a19515 	stw	r2,-31148(r3)
   26c30:	800b883a 	mov	r5,r16
   26c34:	8809883a 	mov	r4,r17
   26c38:	0026f480 	call	26f48 <_sbrk_r>
   26c3c:	10ffffd8 	cmpnei	r3,r2,-1
   26c40:	1800071e 	bne	r3,zero,26c60 <sbrk_aligned+0x64>
   26c44:	043fffc4 	movi	r16,-1
   26c48:	8005883a 	mov	r2,r16
   26c4c:	dfc00217 	ldw	ra,8(sp)
   26c50:	dc400117 	ldw	r17,4(sp)
   26c54:	dc000017 	ldw	r16,0(sp)
   26c58:	dec00304 	addi	sp,sp,12
   26c5c:	f800283a 	ret
   26c60:	140000c4 	addi	r16,r2,3
   26c64:	00ffff04 	movi	r3,-4
   26c68:	80e0703a 	and	r16,r16,r3
   26c6c:	143ff626 	beq	r2,r16,26c48 <sbrk_aligned+0x4c>
   26c70:	808bc83a 	sub	r5,r16,r2
   26c74:	8809883a 	mov	r4,r17
   26c78:	0026f480 	call	26f48 <_sbrk_r>
   26c7c:	10bfffe0 	cmpeqi	r2,r2,-1
   26c80:	103ff126 	beq	r2,zero,26c48 <sbrk_aligned+0x4c>
   26c84:	003fef06 	br	26c44 <sbrk_aligned+0x48>

00026c88 <_malloc_r>:
   26c88:	defffb04 	addi	sp,sp,-20
   26c8c:	00bfff04 	movi	r2,-4
   26c90:	dc400115 	stw	r17,4(sp)
   26c94:	2c4000c4 	addi	r17,r5,3
   26c98:	88a2703a 	and	r17,r17,r2
   26c9c:	8c400204 	addi	r17,r17,8
   26ca0:	dc800215 	stw	r18,8(sp)
   26ca4:	dfc00415 	stw	ra,16(sp)
   26ca8:	dcc00315 	stw	r19,12(sp)
   26cac:	dc000015 	stw	r16,0(sp)
   26cb0:	88800328 	cmpgeui	r2,r17,12
   26cb4:	2025883a 	mov	r18,r4
   26cb8:	10002a1e 	bne	r2,zero,26d64 <_malloc_r+0xdc>
   26cbc:	04400304 	movi	r17,12
   26cc0:	89402936 	bltu	r17,r5,26d68 <_malloc_r+0xe0>
   26cc4:	9009883a 	mov	r4,r18
   26cc8:	002732c0 	call	2732c <__malloc_lock>
   26ccc:	008000f4 	movhi	r2,3
   26cd0:	10a19617 	ldw	r2,-31144(r2)
   26cd4:	1021883a 	mov	r16,r2
   26cd8:	80002d1e 	bne	r16,zero,26d90 <_malloc_r+0x108>
   26cdc:	880b883a 	mov	r5,r17
   26ce0:	9009883a 	mov	r4,r18
   26ce4:	0026bfc0 	call	26bfc <sbrk_aligned>
   26ce8:	1021883a 	mov	r16,r2
   26cec:	10bfffd8 	cmpnei	r2,r2,-1
   26cf0:	1000561e 	bne	r2,zero,26e4c <_malloc_r+0x1c4>
   26cf4:	008000f4 	movhi	r2,3
   26cf8:	14219617 	ldw	r16,-31144(r2)
   26cfc:	8005883a 	mov	r2,r16
   26d00:	1000481e 	bne	r2,zero,26e24 <_malloc_r+0x19c>
   26d04:	80004c26 	beq	r16,zero,26e38 <_malloc_r+0x1b0>
   26d08:	84c00017 	ldw	r19,0(r16)
   26d0c:	000b883a 	mov	r5,zero
   26d10:	9009883a 	mov	r4,r18
   26d14:	84e7883a 	add	r19,r16,r19
   26d18:	0026f480 	call	26f48 <_sbrk_r>
   26d1c:	9880461e 	bne	r19,r2,26e38 <_malloc_r+0x1b0>
   26d20:	80800017 	ldw	r2,0(r16)
   26d24:	9009883a 	mov	r4,r18
   26d28:	88a3c83a 	sub	r17,r17,r2
   26d2c:	880b883a 	mov	r5,r17
   26d30:	0026bfc0 	call	26bfc <sbrk_aligned>
   26d34:	10bfffe0 	cmpeqi	r2,r2,-1
   26d38:	10003f1e 	bne	r2,zero,26e38 <_malloc_r+0x1b0>
   26d3c:	80800017 	ldw	r2,0(r16)
   26d40:	1445883a 	add	r2,r2,r17
   26d44:	80800015 	stw	r2,0(r16)
   26d48:	008000f4 	movhi	r2,3
   26d4c:	10a19617 	ldw	r2,-31144(r2)
   26d50:	10000226 	beq	r2,zero,26d5c <_malloc_r+0xd4>
   26d54:	10c00117 	ldw	r3,4(r2)
   26d58:	1c00351e 	bne	r3,r16,26e30 <_malloc_r+0x1a8>
   26d5c:	10000115 	stw	zero,4(r2)
   26d60:	00001806 	br	26dc4 <_malloc_r+0x13c>
   26d64:	883fd60e 	bge	r17,zero,26cc0 <_malloc_r+0x38>
   26d68:	00800304 	movi	r2,12
   26d6c:	90800015 	stw	r2,0(r18)
   26d70:	0005883a 	mov	r2,zero
   26d74:	dfc00417 	ldw	ra,16(sp)
   26d78:	dcc00317 	ldw	r19,12(sp)
   26d7c:	dc800217 	ldw	r18,8(sp)
   26d80:	dc400117 	ldw	r17,4(sp)
   26d84:	dc000017 	ldw	r16,0(sp)
   26d88:	dec00504 	addi	sp,sp,20
   26d8c:	f800283a 	ret
   26d90:	81000017 	ldw	r4,0(r16)
   26d94:	2449c83a 	sub	r4,r4,r17
   26d98:	20001f16 	blt	r4,zero,26e18 <_malloc_r+0x190>
   26d9c:	20c00330 	cmpltui	r3,r4,12
   26da0:	1800161e 	bne	r3,zero,26dfc <_malloc_r+0x174>
   26da4:	84400015 	stw	r17,0(r16)
   26da8:	8447883a 	add	r3,r16,r17
   26dac:	1400111e 	bne	r2,r16,26df4 <_malloc_r+0x16c>
   26db0:	008000f4 	movhi	r2,3
   26db4:	10e19615 	stw	r3,-31144(r2)
   26db8:	80800117 	ldw	r2,4(r16)
   26dbc:	19000015 	stw	r4,0(r3)
   26dc0:	18800115 	stw	r2,4(r3)
   26dc4:	9009883a 	mov	r4,r18
   26dc8:	00273300 	call	27330 <__malloc_unlock>
   26dcc:	013ffe04 	movi	r4,-8
   26dd0:	808002c4 	addi	r2,r16,11
   26dd4:	80c00104 	addi	r3,r16,4
   26dd8:	1104703a 	and	r2,r2,r4
   26ddc:	10c9c83a 	sub	r4,r2,r3
   26de0:	10ffe426 	beq	r2,r3,26d74 <_malloc_r+0xec>
   26de4:	8121883a 	add	r16,r16,r4
   26de8:	1887c83a 	sub	r3,r3,r2
   26dec:	80c00015 	stw	r3,0(r16)
   26df0:	003fe006 	br	26d74 <_malloc_r+0xec>
   26df4:	10c00115 	stw	r3,4(r2)
   26df8:	003fef06 	br	26db8 <_malloc_r+0x130>
   26dfc:	80c00117 	ldw	r3,4(r16)
   26e00:	1400031e 	bne	r2,r16,26e10 <_malloc_r+0x188>
   26e04:	008000f4 	movhi	r2,3
   26e08:	10e19615 	stw	r3,-31144(r2)
   26e0c:	003fed06 	br	26dc4 <_malloc_r+0x13c>
   26e10:	10c00115 	stw	r3,4(r2)
   26e14:	003feb06 	br	26dc4 <_malloc_r+0x13c>
   26e18:	8005883a 	mov	r2,r16
   26e1c:	84000117 	ldw	r16,4(r16)
   26e20:	003fad06 	br	26cd8 <_malloc_r+0x50>
   26e24:	1021883a 	mov	r16,r2
   26e28:	10800117 	ldw	r2,4(r2)
   26e2c:	003fb406 	br	26d00 <_malloc_r+0x78>
   26e30:	1805883a 	mov	r2,r3
   26e34:	003fc606 	br	26d50 <_malloc_r+0xc8>
   26e38:	00800304 	movi	r2,12
   26e3c:	90800015 	stw	r2,0(r18)
   26e40:	9009883a 	mov	r4,r18
   26e44:	00273300 	call	27330 <__malloc_unlock>
   26e48:	003fc906 	br	26d70 <_malloc_r+0xe8>
   26e4c:	84400015 	stw	r17,0(r16)
   26e50:	003fdc06 	br	26dc4 <_malloc_r+0x13c>

00026e54 <_puts_r>:
   26e54:	defffd04 	addi	sp,sp,-12
   26e58:	dc000015 	stw	r16,0(sp)
   26e5c:	2021883a 	mov	r16,r4
   26e60:	2809883a 	mov	r4,r5
   26e64:	dfc00215 	stw	ra,8(sp)
   26e68:	dc400115 	stw	r17,4(sp)
   26e6c:	2823883a 	mov	r17,r5
   26e70:	0026f2c0 	call	26f2c <strlen>
   26e74:	81400217 	ldw	r5,8(r16)
   26e78:	00c000b4 	movhi	r3,2
   26e7c:	18dc2404 	addi	r3,r3,28816
   26e80:	28c00115 	stw	r3,4(r5)
   26e84:	100f883a 	mov	r7,r2
   26e88:	880d883a 	mov	r6,r17
   26e8c:	8009883a 	mov	r4,r16
   26e90:	00270900 	call	27090 <__sfvwrite_small_dev>
   26e94:	10ffffe0 	cmpeqi	r3,r2,-1
   26e98:	1800091e 	bne	r3,zero,26ec0 <_puts_r+0x6c>
   26e9c:	81400217 	ldw	r5,8(r16)
   26ea0:	018000b4 	movhi	r6,2
   26ea4:	01c00044 	movi	r7,1
   26ea8:	28800117 	ldw	r2,4(r5)
   26eac:	319f2404 	addi	r6,r6,31888
   26eb0:	8009883a 	mov	r4,r16
   26eb4:	103ee83a 	callr	r2
   26eb8:	10bfffe0 	cmpeqi	r2,r2,-1
   26ebc:	0085c83a 	sub	r2,zero,r2
   26ec0:	dfc00217 	ldw	ra,8(sp)
   26ec4:	dc400117 	ldw	r17,4(sp)
   26ec8:	dc000017 	ldw	r16,0(sp)
   26ecc:	dec00304 	addi	sp,sp,12
   26ed0:	f800283a 	ret

00026ed4 <puts>:
   26ed4:	008000f4 	movhi	r2,3
   26ed8:	200b883a 	mov	r5,r4
   26edc:	11203817 	ldw	r4,-32544(r2)
   26ee0:	0026e541 	jmpi	26e54 <_puts_r>

00026ee4 <memcpy>:
   26ee4:	2005883a 	mov	r2,r4
   26ee8:	0007883a 	mov	r3,zero
   26eec:	30c0011e 	bne	r6,r3,26ef4 <memcpy+0x10>
   26ef0:	f800283a 	ret
   26ef4:	28cf883a 	add	r7,r5,r3
   26ef8:	39c00003 	ldbu	r7,0(r7)
   26efc:	10c9883a 	add	r4,r2,r3
   26f00:	18c00044 	addi	r3,r3,1
   26f04:	21c00005 	stb	r7,0(r4)
   26f08:	003ff806 	br	26eec <memcpy+0x8>

00026f0c <memset>:
   26f0c:	2005883a 	mov	r2,r4
   26f10:	218d883a 	add	r6,r4,r6
   26f14:	2007883a 	mov	r3,r4
   26f18:	1980011e 	bne	r3,r6,26f20 <memset+0x14>
   26f1c:	f800283a 	ret
   26f20:	18c00044 	addi	r3,r3,1
   26f24:	197fffc5 	stb	r5,-1(r3)
   26f28:	003ffb06 	br	26f18 <memset+0xc>

00026f2c <strlen>:
   26f2c:	2005883a 	mov	r2,r4
   26f30:	10c00007 	ldb	r3,0(r2)
   26f34:	1800021e 	bne	r3,zero,26f40 <strlen+0x14>
   26f38:	1105c83a 	sub	r2,r2,r4
   26f3c:	f800283a 	ret
   26f40:	10800044 	addi	r2,r2,1
   26f44:	003ffa06 	br	26f30 <strlen+0x4>

00026f48 <_sbrk_r>:
   26f48:	defffe04 	addi	sp,sp,-8
   26f4c:	dc000015 	stw	r16,0(sp)
   26f50:	008000f4 	movhi	r2,3
   26f54:	2021883a 	mov	r16,r4
   26f58:	2809883a 	mov	r4,r5
   26f5c:	dfc00115 	stw	ra,4(sp)
   26f60:	10219715 	stw	zero,-31140(r2)
   26f64:	00273340 	call	27334 <sbrk>
   26f68:	10ffffd8 	cmpnei	r3,r2,-1
   26f6c:	1800041e 	bne	r3,zero,26f80 <_sbrk_r+0x38>
   26f70:	00c000f4 	movhi	r3,3
   26f74:	18e19717 	ldw	r3,-31140(r3)
   26f78:	18000126 	beq	r3,zero,26f80 <_sbrk_r+0x38>
   26f7c:	80c00015 	stw	r3,0(r16)
   26f80:	dfc00117 	ldw	ra,4(sp)
   26f84:	dc000017 	ldw	r16,0(sp)
   26f88:	dec00204 	addi	sp,sp,8
   26f8c:	f800283a 	ret

00026f90 <_free_r>:
   26f90:	28003e26 	beq	r5,zero,2708c <_free_r+0xfc>
   26f94:	28bfff17 	ldw	r2,-4(r5)
   26f98:	defffd04 	addi	sp,sp,-12
   26f9c:	dc000115 	stw	r16,4(sp)
   26fa0:	dfc00215 	stw	ra,8(sp)
   26fa4:	2c3fff04 	addi	r16,r5,-4
   26fa8:	1000010e 	bge	r2,zero,26fb0 <_free_r+0x20>
   26fac:	80a1883a 	add	r16,r16,r2
   26fb0:	d9000015 	stw	r4,0(sp)
   26fb4:	002732c0 	call	2732c <__malloc_lock>
   26fb8:	008000f4 	movhi	r2,3
   26fbc:	10a19617 	ldw	r2,-31144(r2)
   26fc0:	d9000017 	ldw	r4,0(sp)
   26fc4:	1000071e 	bne	r2,zero,26fe4 <_free_r+0x54>
   26fc8:	80000115 	stw	zero,4(r16)
   26fcc:	008000f4 	movhi	r2,3
   26fd0:	14219615 	stw	r16,-31144(r2)
   26fd4:	dfc00217 	ldw	ra,8(sp)
   26fd8:	dc000117 	ldw	r16,4(sp)
   26fdc:	dec00304 	addi	sp,sp,12
   26fe0:	00273301 	jmpi	27330 <__malloc_unlock>
   26fe4:	8080092e 	bgeu	r16,r2,2700c <_free_r+0x7c>
   26fe8:	81400017 	ldw	r5,0(r16)
   26fec:	8147883a 	add	r3,r16,r5
   26ff0:	10c0041e 	bne	r2,r3,27004 <_free_r+0x74>
   26ff4:	10c00017 	ldw	r3,0(r2)
   26ff8:	10800117 	ldw	r2,4(r2)
   26ffc:	1947883a 	add	r3,r3,r5
   27000:	80c00015 	stw	r3,0(r16)
   27004:	80800115 	stw	r2,4(r16)
   27008:	003ff006 	br	26fcc <_free_r+0x3c>
   2700c:	1007883a 	mov	r3,r2
   27010:	10800117 	ldw	r2,4(r2)
   27014:	10000126 	beq	r2,zero,2701c <_free_r+0x8c>
   27018:	80bffc2e 	bgeu	r16,r2,2700c <_free_r+0x7c>
   2701c:	19400017 	ldw	r5,0(r3)
   27020:	194d883a 	add	r6,r3,r5
   27024:	34000b1e 	bne	r6,r16,27054 <_free_r+0xc4>
   27028:	81800017 	ldw	r6,0(r16)
   2702c:	298b883a 	add	r5,r5,r6
   27030:	19400015 	stw	r5,0(r3)
   27034:	194d883a 	add	r6,r3,r5
   27038:	11bfe61e 	bne	r2,r6,26fd4 <_free_r+0x44>
   2703c:	11800017 	ldw	r6,0(r2)
   27040:	10800117 	ldw	r2,4(r2)
   27044:	314b883a 	add	r5,r6,r5
   27048:	19400015 	stw	r5,0(r3)
   2704c:	18800115 	stw	r2,4(r3)
   27050:	003fe006 	br	26fd4 <_free_r+0x44>
   27054:	8180032e 	bgeu	r16,r6,27064 <_free_r+0xd4>
   27058:	00800304 	movi	r2,12
   2705c:	20800015 	stw	r2,0(r4)
   27060:	003fdc06 	br	26fd4 <_free_r+0x44>
   27064:	81800017 	ldw	r6,0(r16)
   27068:	818b883a 	add	r5,r16,r6
   2706c:	1140041e 	bne	r2,r5,27080 <_free_r+0xf0>
   27070:	11400017 	ldw	r5,0(r2)
   27074:	10800117 	ldw	r2,4(r2)
   27078:	298b883a 	add	r5,r5,r6
   2707c:	81400015 	stw	r5,0(r16)
   27080:	80800115 	stw	r2,4(r16)
   27084:	1c000115 	stw	r16,4(r3)
   27088:	003fd206 	br	26fd4 <_free_r+0x44>
   2708c:	f800283a 	ret

00027090 <__sfvwrite_small_dev>:
   27090:	2880000b 	ldhu	r2,0(r5)
   27094:	1080020c 	andi	r2,r2,8
   27098:	10002526 	beq	r2,zero,27130 <__sfvwrite_small_dev+0xa0>
   2709c:	2880008f 	ldh	r2,2(r5)
   270a0:	defffb04 	addi	sp,sp,-20
   270a4:	dcc00315 	stw	r19,12(sp)
   270a8:	dc800215 	stw	r18,8(sp)
   270ac:	dc400115 	stw	r17,4(sp)
   270b0:	dc000015 	stw	r16,0(sp)
   270b4:	dfc00415 	stw	ra,16(sp)
   270b8:	2027883a 	mov	r19,r4
   270bc:	2821883a 	mov	r16,r5
   270c0:	3025883a 	mov	r18,r6
   270c4:	3823883a 	mov	r17,r7
   270c8:	1000100e 	bge	r2,zero,2710c <__sfvwrite_small_dev+0x7c>
   270cc:	8080000b 	ldhu	r2,0(r16)
   270d0:	10801014 	ori	r2,r2,64
   270d4:	8080000d 	sth	r2,0(r16)
   270d8:	00bfffc4 	movi	r2,-1
   270dc:	00000d06 	br	27114 <__sfvwrite_small_dev+0x84>
   270e0:	88810050 	cmplti	r2,r17,1025
   270e4:	880f883a 	mov	r7,r17
   270e8:	1000011e 	bne	r2,zero,270f0 <__sfvwrite_small_dev+0x60>
   270ec:	01c10004 	movi	r7,1024
   270f0:	8140008f 	ldh	r5,2(r16)
   270f4:	900d883a 	mov	r6,r18
   270f8:	9809883a 	mov	r4,r19
   270fc:	00271380 	call	27138 <_write_r>
   27100:	00bff20e 	bge	zero,r2,270cc <__sfvwrite_small_dev+0x3c>
   27104:	88a3c83a 	sub	r17,r17,r2
   27108:	90a5883a 	add	r18,r18,r2
   2710c:	047ff416 	blt	zero,r17,270e0 <__sfvwrite_small_dev+0x50>
   27110:	0005883a 	mov	r2,zero
   27114:	dfc00417 	ldw	ra,16(sp)
   27118:	dcc00317 	ldw	r19,12(sp)
   2711c:	dc800217 	ldw	r18,8(sp)
   27120:	dc400117 	ldw	r17,4(sp)
   27124:	dc000017 	ldw	r16,0(sp)
   27128:	dec00504 	addi	sp,sp,20
   2712c:	f800283a 	ret
   27130:	00bfffc4 	movi	r2,-1
   27134:	f800283a 	ret

00027138 <_write_r>:
   27138:	defffe04 	addi	sp,sp,-8
   2713c:	dc000015 	stw	r16,0(sp)
   27140:	008000f4 	movhi	r2,3
   27144:	2021883a 	mov	r16,r4
   27148:	2809883a 	mov	r4,r5
   2714c:	300b883a 	mov	r5,r6
   27150:	380d883a 	mov	r6,r7
   27154:	dfc00115 	stw	ra,4(sp)
   27158:	10219715 	stw	zero,-31140(r2)
   2715c:	00273840 	call	27384 <write>
   27160:	10ffffd8 	cmpnei	r3,r2,-1
   27164:	1800041e 	bne	r3,zero,27178 <_write_r+0x40>
   27168:	00c000f4 	movhi	r3,3
   2716c:	18e19717 	ldw	r3,-31140(r3)
   27170:	18000126 	beq	r3,zero,27178 <_write_r+0x40>
   27174:	80c00015 	stw	r3,0(r16)
   27178:	dfc00117 	ldw	ra,4(sp)
   2717c:	dc000017 	ldw	r16,0(sp)
   27180:	dec00204 	addi	sp,sp,8
   27184:	f800283a 	ret

00027188 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   27188:	00272141 	jmpi	27214 <alt_iic_isr_register>

0002718c <alt_ic_irq_enable>:
  NIOS2_READ_STATUS (context);
   2718c:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27190:	00bfff84 	movi	r2,-2
   27194:	1884703a 	and	r2,r3,r2
   27198:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   2719c:	00800044 	movi	r2,1
   271a0:	d1217c17 	ldw	r4,-31248(gp)
   271a4:	114a983a 	sll	r5,r2,r5
   271a8:	290ab03a 	or	r5,r5,r4
   271ac:	d1617c15 	stw	r5,-31248(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   271b0:	d0a17c17 	ldw	r2,-31248(gp)
   271b4:	100170fa 	wrctl	ienable,r2
  NIOS2_WRITE_STATUS (context);
   271b8:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   271bc:	0005883a 	mov	r2,zero
   271c0:	f800283a 	ret

000271c4 <alt_ic_irq_disable>:
  NIOS2_READ_STATUS (context);
   271c4:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   271c8:	00bfff84 	movi	r2,-2
   271cc:	1884703a 	and	r2,r3,r2
   271d0:	1001703a 	wrctl	status,r2
  alt_irq_active &= ~(1 << id);
   271d4:	00bfff84 	movi	r2,-2
   271d8:	d1217c17 	ldw	r4,-31248(gp)
   271dc:	114a183a 	rol	r5,r2,r5
   271e0:	290a703a 	and	r5,r5,r4
   271e4:	d1617c15 	stw	r5,-31248(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   271e8:	d0a17c17 	ldw	r2,-31248(gp)
   271ec:	100170fa 	wrctl	ienable,r2
  NIOS2_WRITE_STATUS (context);
   271f0:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   271f4:	0005883a 	mov	r2,zero
   271f8:	f800283a 	ret

000271fc <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   271fc:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
   27200:	00800044 	movi	r2,1
   27204:	1144983a 	sll	r2,r2,r5
   27208:	10c4703a 	and	r2,r2,r3
}
   2720c:	1004c03a 	cmpne	r2,r2,zero
   27210:	f800283a 	ret

00027214 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   27214:	28800808 	cmpgei	r2,r5,32
   27218:	1000161e 	bne	r2,zero,27274 <alt_iic_isr_register+0x60>
{
   2721c:	defffe04 	addi	sp,sp,-8
   27220:	dfc00115 	stw	ra,4(sp)
   27224:	dc000015 	stw	r16,0(sp)
  NIOS2_READ_STATUS (context);
   27228:	0021303a 	rdctl	r16,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2722c:	00bfff84 	movi	r2,-2
   27230:	8084703a 	and	r2,r16,r2
   27234:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   27238:	280690fa 	slli	r3,r5,3
   2723c:	008000f4 	movhi	r2,3
   27240:	10a20004 	addi	r2,r2,-30720
   27244:	10c5883a 	add	r2,r2,r3
   27248:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   2724c:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   27250:	30000626 	beq	r6,zero,2726c <alt_iic_isr_register+0x58>
   27254:	002718c0 	call	2718c <alt_ic_irq_enable>
  NIOS2_WRITE_STATUS (context);
   27258:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   2725c:	dfc00117 	ldw	ra,4(sp)
   27260:	dc000017 	ldw	r16,0(sp)
   27264:	dec00204 	addi	sp,sp,8
   27268:	f800283a 	ret
    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   2726c:	00271c40 	call	271c4 <alt_ic_irq_disable>
   27270:	003ff906 	br	27258 <alt_iic_isr_register+0x44>
  int rc = -EINVAL;  
   27274:	00bffa84 	movi	r2,-22
}
   27278:	f800283a 	ret

0002727c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   2727c:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   27280:	010000b4 	movhi	r4,2
   27284:	014000f4 	movhi	r5,3
   27288:	dfc00015 	stw	ra,0(sp)
   2728c:	211f2504 	addi	r4,r4,31892
   27290:	29603d04 	addi	r5,r5,-32524
   27294:	21400426 	beq	r4,r5,272a8 <alt_load+0x2c>
  {
    while( to != end )
    {
      *to++ = *from++;
   27298:	018000f4 	movhi	r6,3
   2729c:	31a03d04 	addi	r6,r6,-32524
   272a0:	310dc83a 	sub	r6,r6,r4
   272a4:	0026ee40 	call	26ee4 <memcpy>
  if (to != from)
   272a8:	010000b4 	movhi	r4,2
   272ac:	014000b4 	movhi	r5,2
   272b0:	21000804 	addi	r4,r4,32
   272b4:	29400804 	addi	r5,r5,32
   272b8:	21400426 	beq	r4,r5,272cc <alt_load+0x50>
      *to++ = *from++;
   272bc:	018000b4 	movhi	r6,2
   272c0:	31806204 	addi	r6,r6,392
   272c4:	310dc83a 	sub	r6,r6,r4
   272c8:	0026ee40 	call	26ee4 <memcpy>
  if (to != from)
   272cc:	010000b4 	movhi	r4,2
   272d0:	014000b4 	movhi	r5,2
   272d4:	211d8f04 	addi	r4,r4,30268
   272d8:	295d8f04 	addi	r5,r5,30268
   272dc:	21400426 	beq	r4,r5,272f0 <alt_load+0x74>
      *to++ = *from++;
   272e0:	018000b4 	movhi	r6,2
   272e4:	319f2504 	addi	r6,r6,31892
   272e8:	310dc83a 	sub	r6,r6,r4
   272ec:	0026ee40 	call	26ee4 <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   272f0:	00275900 	call	27590 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   272f4:	dfc00017 	ldw	ra,0(sp)
   272f8:	dec00104 	addi	sp,sp,4
  alt_icache_flush_all();
   272fc:	00275a81 	jmpi	275a8 <alt_icache_flush_all>

00027300 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   27300:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   27304:	0009883a 	mov	r4,zero
{
   27308:	dfc00015 	stw	ra,0(sp)
  alt_irq_init (NULL);
   2730c:	00273e00 	call	273e0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   27310:	00274000 	call	27400 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   27314:	d1a17d17 	ldw	r6,-31244(gp)
   27318:	d1617e17 	ldw	r5,-31240(gp)
   2731c:	d1217f17 	ldw	r4,-31236(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   27320:	dfc00017 	ldw	ra,0(sp)
   27324:	dec00104 	addi	sp,sp,4
  main (alt_argc, alt_argv, alt_envp);
   27328:	00201d41 	jmpi	201d4 <main>

0002732c <__malloc_lock>:
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
}
   2732c:	f800283a 	ret

00027330 <__malloc_unlock>:

/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
   27330:	f800283a 	ret

00027334 <sbrk>:
  NIOS2_READ_STATUS (context);
   27334:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27338:	00bfff84 	movi	r2,-2
   2733c:	1884703a 	and	r2,r3,r2
   27340:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   27344:	d0a01e17 	ldw	r2,-32648(gp)
   27348:	017fff04 	movi	r5,-4
   2734c:	108000c4 	addi	r2,r2,3
   27350:	1144703a 	and	r2,r2,r5
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   27354:	014000f4 	movhi	r5,3
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   27358:	d0a01e15 	stw	r2,-32648(gp)
  if ((heap_end + incr) > __alt_heap_limit) {
   2735c:	1109883a 	add	r4,r2,r4
   27360:	29500004 	addi	r5,r5,16384
   27364:	2900032e 	bgeu	r5,r4,27374 <sbrk+0x40>
  NIOS2_WRITE_STATUS (context);
   27368:	1801703a 	wrctl	status,r3
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   2736c:	00bfffc4 	movi	r2,-1
   27370:	f800283a 	ret
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
   27374:	d1201e15 	stw	r4,-32648(gp)
   27378:	1801703a 	wrctl	status,r3
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
   2737c:	f800283a 	ret

00027380 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   27380:	002750c1 	jmpi	2750c <alt_busy_sleep>

00027384 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   27384:	213fffc4 	addi	r4,r4,-1
   27388:	210000a8 	cmpgeui	r4,r4,2
   2738c:	2000041e 	bne	r4,zero,273a0 <write+0x1c>
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
   27390:	010000f4 	movhi	r4,3
   27394:	000f883a 	mov	r7,zero
   27398:	21203b04 	addi	r4,r4,-32532
   2739c:	00274041 	jmpi	27404 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   273a0:	d0a02017 	ldw	r2,-32640(gp)
   273a4:	10000926 	beq	r2,zero,273cc <write+0x48>
{
   273a8:	deffff04 	addi	sp,sp,-4
   273ac:	dfc00015 	stw	ra,0(sp)
   273b0:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   273b4:	00c01444 	movi	r3,81
   273b8:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   273bc:	00bfffc4 	movi	r2,-1
   273c0:	dfc00017 	ldw	ra,0(sp)
   273c4:	dec00104 	addi	sp,sp,4
   273c8:	f800283a 	ret
   273cc:	d0a17b04 	addi	r2,gp,-31252
        ALT_ERRNO = EBADFD;
   273d0:	00c01444 	movi	r3,81
   273d4:	10c00015 	stw	r3,0(r2)
}
   273d8:	00bfffc4 	movi	r2,-1
   273dc:	f800283a 	ret

000273e0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   273e0:	deffff04 	addi	sp,sp,-4
   273e4:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, NIOS);
   273e8:	00275d80 	call	275d8 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   273ec:	00800044 	movi	r2,1
   273f0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   273f4:	dfc00017 	ldw	ra,0(sp)
   273f8:	dec00104 	addi	sp,sp,4
   273fc:	f800283a 	ret

00027400 <alt_sys_init>:
{
    ALTERA_AVALON_TIMER_INIT ( TIMER_0, timer_0);
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
    ALTERA_AVALON_SPI_INIT ( ESC_SPI, ESC_SPI);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, SYSID);
}
   27400:	f800283a 	ret

00027404 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   27404:	20c00017 	ldw	r3,0(r4)
{
   27408:	3005883a 	mov	r2,r6

  const char * end = ptr + count;
   2740c:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   27410:	01bfffd4 	movui	r6,65535
  while (ptr < end)
   27414:	29000136 	bltu	r5,r4,2741c <altera_avalon_jtag_uart_write+0x18>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
   27418:	f800283a 	ret
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   2741c:	19c00137 	ldwio	r7,4(r3)
   27420:	31fffc2e 	bgeu	r6,r7,27414 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   27424:	29c00007 	ldb	r7,0(r5)
   27428:	29400044 	addi	r5,r5,1
   2742c:	19c00035 	stwio	r7,0(r3)
   27430:	003ff806 	br	27414 <altera_avalon_jtag_uart_write+0x10>

00027434 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   27434:	d8800017 	ldw	r2,0(sp)
   27438:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   2743c:	00c00044 	movi	r3,1
{
   27440:	da400217 	ldw	r9,8(sp)
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   27444:	1946983a 	sll	r3,r3,r5
  const alt_u8 * write_end = write_data + write_length;
   27448:	399b883a 	add	r13,r7,r6
  alt_u8 * read_end = read_data + read_length;
   2744c:	4099883a 	add	r12,r8,r2
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   27450:	20c00535 	stwio	r3,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   27454:	48c0008c 	andi	r3,r9,2
   27458:	1800021e 	bne	r3,zero,27464 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   2745c:	00c10004 	movi	r3,1024
   27460:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   27464:	20c00037 	ldwio	r3,0(r4)
  alt_32 credits = 1;
   27468:	00c00044 	movi	r3,1
  alt_u32 write_zeros = read_length;
   2746c:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27470:	22c00204 	addi	r11,r4,8
   27474:	21400237 	ldwio	r5,8(r4)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   27478:	2b80100c 	andi	r14,r5,64
   2747c:	2940200c 	andi	r5,r5,128
   27480:	70000126 	beq	r14,zero,27488 <alt_avalon_spi_command+0x54>
   27484:	1800101e 	bne	r3,zero,274c8 <alt_avalon_spi_command+0x94>
      }
      else
        credits = -1024;
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   27488:	283ff926 	beq	r5,zero,27470 <alt_avalon_spi_command+0x3c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   2748c:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
        read_ignore--;
      else
        *read_data++ = (alt_u8)rxdata;
      credits++;
   27490:	18c00044 	addi	r3,r3,1
      if (read_ignore > 0)
   27494:	30001a26 	beq	r6,zero,27500 <alt_avalon_spi_command+0xcc>
        read_ignore--;
   27498:	31bfffc4 	addi	r6,r6,-1

      if (read_ignore == 0 && read_data == read_end)
   2749c:	303ff41e 	bne	r6,zero,27470 <alt_avalon_spi_command+0x3c>
   274a0:	6200071e 	bne	r12,r8,274c0 <alt_avalon_spi_command+0x8c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   274a4:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   274a8:	18c0080c 	andi	r3,r3,32
   274ac:	183ffd26 	beq	r3,zero,274a4 <alt_avalon_spi_command+0x70>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   274b0:	4a40004c 	andi	r9,r9,1
   274b4:	4800011e 	bne	r9,zero,274bc <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   274b8:	20000335 	stwio	zero,12(r4)

  return read_length;
}
   274bc:	f800283a 	ret
   274c0:	000d883a 	mov	r6,zero
   274c4:	003fea06 	br	27470 <alt_avalon_spi_command+0x3c>
    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   274c8:	00ffef0e 	bge	zero,r3,27488 <alt_avalon_spi_command+0x54>
      credits--;
   274cc:	18ffffc4 	addi	r3,r3,-1
      if (write_data < write_end)
   274d0:	3b40052e 	bgeu	r7,r13,274e8 <alt_avalon_spi_command+0xb4>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   274d4:	3b800044 	addi	r14,r7,1
   274d8:	39c00003 	ldbu	r7,0(r7)
   274dc:	21c00135 	stwio	r7,4(r4)
   274e0:	700f883a 	mov	r7,r14
   274e4:	003fe806 	br	27488 <alt_avalon_spi_command+0x54>
      else if (write_zeros > 0)
   274e8:	50000326 	beq	r10,zero,274f8 <alt_avalon_spi_command+0xc4>
        write_zeros--;
   274ec:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   274f0:	20000135 	stwio	zero,4(r4)
   274f4:	003fe406 	br	27488 <alt_avalon_spi_command+0x54>
        credits = -1024;
   274f8:	00ff0004 	movi	r3,-1024
   274fc:	003fe206 	br	27488 <alt_avalon_spi_command+0x54>
        *read_data++ = (alt_u8)rxdata;
   27500:	41400005 	stb	r5,0(r8)
   27504:	42000044 	addi	r8,r8,1
   27508:	003fe506 	br	274a0 <alt_avalon_spi_command+0x6c>

0002750c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   2750c:	defffe04 	addi	sp,sp,-8
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   27510:	00820034 	movhi	r2,2048
{
   27514:	dc000015 	stw	r16,0(sp)
   27518:	dfc00115 	stw	ra,4(sp)
  if (big_loops)
   2751c:	10bfff84 	addi	r2,r2,-2
{
   27520:	2021883a 	mov	r16,r4
  if (big_loops)
   27524:	1100162e 	bgeu	r2,r4,27580 <alt_busy_sleep+0x74>
  big_loops = us / (INT_MAX/
   27528:	01420034 	movhi	r5,2048
   2752c:	297fffc4 	addi	r5,r5,-1
   27530:	0026b1c0 	call	26b1c <__udivsi3>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   27534:	01200034 	movhi	r4,32768
    for(i=0;i<big_loops;i++)
   27538:	0007883a 	mov	r3,zero
      __asm__ volatile (
   2753c:	213fffc4 	addi	r4,r4,-1
   27540:	213fffc4 	addi	r4,r4,-1
   27544:	203ffe1e 	bne	r4,zero,27540 <alt_busy_sleep+0x34>
    for(i=0;i<big_loops;i++)
   27548:	18c00044 	addi	r3,r3,1
   2754c:	18bffc16 	blt	r3,r2,27540 <alt_busy_sleep+0x34>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   27550:	00fe0034 	movhi	r3,63488
   27554:	18c00044 	addi	r3,r3,1
   27558:	10c5383a 	mul	r2,r2,r3
   2755c:	1405883a 	add	r2,r2,r16
   27560:	1004913a 	slli	r2,r2,4
    __asm__ volatile (
   27564:	10bfffc4 	addi	r2,r2,-1
   27568:	103ffe1e 	bne	r2,zero,27564 <alt_busy_sleep+0x58>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   2756c:	0005883a 	mov	r2,zero
   27570:	dfc00117 	ldw	ra,4(sp)
   27574:	dc000017 	ldw	r16,0(sp)
   27578:	dec00204 	addi	sp,sp,8
   2757c:	f800283a 	ret
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   27580:	2020913a 	slli	r16,r4,4
    __asm__ volatile (
   27584:	843fffc4 	addi	r16,r16,-1
   27588:	043ffe16 	blt	zero,r16,27584 <alt_busy_sleep+0x78>
   2758c:	003ff706 	br	2756c <alt_busy_sleep+0x60>

00027590 <alt_dcache_flush_all>:
void alt_dcache_flush_all (void)
{
#if NIOS2_DCACHE_SIZE > 0
  char* i;
  
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
   27590:	0005883a 	mov	r2,zero
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
   27594:	1000003b 	flushd	0(r2)
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
   27598:	10800804 	addi	r2,r2,32
   2759c:	10c20018 	cmpnei	r3,r2,2048
   275a0:	183ffc1e 	bne	r3,zero,27594 <alt_dcache_flush_all+0x4>
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   275a4:	f800283a 	ret

000275a8 <alt_icache_flush_all>:
 */

void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
   275a8:	01440004 	movi	r5,4096
   275ac:	0009883a 	mov	r4,zero
   275b0:	00275e01 	jmpi	275e0 <alt_icache_flush>

000275b4 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
   275b4:	213ffe84 	addi	r4,r4,-6
   275b8:	20800428 	cmpgeui	r2,r4,16
   275bc:	1000041e 	bne	r2,zero,275d0 <alt_exception_cause_generated_bad_addr+0x1c>
   275c0:	00a2c8d4 	movui	r2,35619
   275c4:	1104d83a 	srl	r2,r2,r4
   275c8:	1080004c 	andi	r2,r2,1
   275cc:	f800283a 	ret
   275d0:	0005883a 	mov	r2,zero
    return 0;

  default:
    return 0;
  }
}
   275d4:	f800283a 	ret

000275d8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   275d8:	000170fa 	wrctl	ienable,zero
}
   275dc:	f800283a 	ret

000275e0 <alt_icache_flush>:

  /*
   * This is the most we would ever need to flush.
   */
 
  if (len > NIOS2_ICACHE_SIZE)
   275e0:	28840070 	cmpltui	r2,r5,4097
   275e4:	1000011e 	bne	r2,zero,275ec <alt_icache_flush+0xc>
   275e8:	01440004 	movi	r5,4096
  {
    len = NIOS2_ICACHE_SIZE;
  }

  end = ((char*) start) + len;
   275ec:	214b883a 	add	r5,r4,r5

  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   275f0:	2005883a 	mov	r2,r4
   275f4:	11400c36 	bltu	r2,r5,27628 <alt_icache_flush+0x48>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_ICACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_ICACHE_LINE_SIZE - 1))
   275f8:	208007cc 	andi	r2,r4,31
   275fc:	10000826 	beq	r2,zero,27620 <alt_icache_flush+0x40>
  {
    __asm__ volatile ("flushi %0" :: "r" (i));
   27600:	20bff844 	addi	r2,r4,-31
   27604:	28800b36 	bltu	r5,r2,27634 <alt_icache_flush+0x54>
   27608:	290bc83a 	sub	r5,r5,r4
   2760c:	294007c4 	addi	r5,r5,31
   27610:	280ad17a 	srli	r5,r5,5
   27614:	280a917a 	slli	r5,r5,5
   27618:	2149883a 	add	r4,r4,r5
   2761c:	2000603a 	flushi	r4
  /* 
   * Having flushed the cache, flush any stale instructions in the 
   * pipeline 
   */

  __asm__ volatile ("flushp");
   27620:	0000203a 	flushp

#endif /* NIOS2_ICACHE_SIZE > 0 */
}
   27624:	f800283a 	ret
    __asm__ volatile ("flushi %0" :: "r" (i)); 
   27628:	1000603a 	flushi	r2
  for (i = start; i < end; i+= NIOS2_ICACHE_LINE_SIZE)
   2762c:	10800804 	addi	r2,r2,32
   27630:	003ff006 	br	275f4 <alt_icache_flush+0x14>
    __asm__ volatile ("flushi %0" :: "r" (i));
   27634:	000b883a 	mov	r5,zero
   27638:	003ff706 	br	27618 <alt_icache_flush+0x38>
