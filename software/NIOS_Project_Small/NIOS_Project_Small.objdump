
NIOS_Project_Small.elf:     file format elf32-littlenios2
NIOS_Project_Small.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00020180

Program Header:
    LOAD off    0x00001000 vaddr 0x00020000 paddr 0x00020000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00020020 paddr 0x00020020 align 2**12
         filesz 0x00007b98 memsz 0x00007b98 flags r-x
    LOAD off    0x00008bb8 vaddr 0x00027bb8 paddr 0x00027fb8 align 2**12
         filesz 0x00000400 memsz 0x00000400 flags rw-
    LOAD off    0x000003b8 vaddr 0x000283b8 paddr 0x000283b8 align 2**12
         filesz 0x00000000 memsz 0x000003a0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00020000  00020000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000160  00020020  00020020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00007440  00020180  00020180  00001180  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000005f8  000275c0  000275c0  000085c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000400  00027bb8  00027fb8  00008bb8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000003a0  000283b8  000283b8  000093b8  2**2
                  ALLOC, SMALL_DATA
  6 .RAM          00000000  00028758  00028758  00008fb8  2**0
                  CONTENTS
  7 .comment      0000002d  00000000  00000000  00008fb8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000628  00000000  00000000  00008fe8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_info   0000e120  00000000  00000000  00009610  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_abbrev 00004463  00000000  00000000  00017730  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_line   00008153  00000000  00000000  0001bb93  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_frame  00001530  00000000  00000000  00023ce8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    00002d0e  00000000  00000000  00025218  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_alt_sim_info 00000040  00000000  00000000  00027f28  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_ranges 00000070  00000000  00000000  00027f68  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 000006f8  00000000  00000000  00027fd8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line_str 00001043  00000000  00000000  000286d0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_loclists 0000578e  00000000  00000000  00029713  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .thread_model 00000003  00000000  00000000  0003286e  2**0
                  CONTENTS, READONLY
 20 .cpu          00000004  00000000  00000000  00032871  2**0
                  CONTENTS, READONLY
 21 .qsys         00000001  00000000  00000000  00032875  2**0
                  CONTENTS, READONLY
 22 .simulation_enabled 00000001  00000000  00000000  00032876  2**0
                  CONTENTS, READONLY
 23 .sysid_hash   00000004  00000000  00000000  00032877  2**0
                  CONTENTS, READONLY
 24 .sysid_base   00000004  00000000  00000000  0003287b  2**0
                  CONTENTS, READONLY
 25 .sysid_time   00000004  00000000  00000000  0003287f  2**0
                  CONTENTS, READONLY
 26 .stderr_dev   00000005  00000000  00000000  00032883  2**0
                  CONTENTS, READONLY
 27 .stdin_dev    00000005  00000000  00000000  00032888  2**0
                  CONTENTS, READONLY
 28 .stdout_dev   00000005  00000000  00000000  0003288d  2**0
                  CONTENTS, READONLY
 29 .sopc_system_name 00000015  00000000  00000000  00032892  2**0
                  CONTENTS, READONLY
 30 .quartus_project_dir 0000004c  00000000  00000000  000328a7  2**0
                  CONTENTS, READONLY
 31 .jdi          0000527d  00000000  00000000  000328f3  2**0
                  CONTENTS, READONLY
 32 .sopcinfo     0004fef6  00000000  00000000  00037b70  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00020000 l    d  .entry	00000000 .entry
00020020 l    d  .exceptions	00000000 .exceptions
00020180 l    d  .text	00000000 .text
000275c0 l    d  .rodata	00000000 .rodata
00027bb8 l    d  .rwdata	00000000 .rwdata
000283b8 l    d  .bss	00000000 .bss
00028758 l    d  .RAM	00000000 .RAM
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_rnglists	00000000 .debug_rnglists
00000000 l    d  .debug_line_str	00000000 .debug_line_str
00000000 l    d  .debug_loclists	00000000 .debug_loclists
00000000 l    df *ABS*	00000000 crt0.o
000201b8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 hello_world_small.c
00027f44 l     O .rwdata	00000001 invert_me.0
00000000 l    df *ABS*	00000000 TENCL040_ESC.c
00000000 l    df *ABS*	00000000 ax58100_hw.c
000204b8 l     F .text	00000144 HW_SPI_Read
000205fc l     F .text	00000118 HW_SPI_Write
00000000 l    df *ABS*	00000000 coeappl.c
00000000 l    df *ABS*	00000000 ecatappl.c
00000000 l    df *ABS*	00000000 ecatcoe.c
00000000 l    df *ABS*	00000000 ecatslv.c
00000000 l    df *ABS*	00000000 mailbox.c
00000000 l    df *ABS*	00000000 objdef.c
00000000 l    df *ABS*	00000000 sdoserv.c
00000000 l    df *ABS*	00000000 nios_it.c
00000000 l    df *ABS*	00000000 peripheral_linker.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 mallocr.c
00026bec l     F .text	0000008c sbrk_aligned
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 impure.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 freer.c
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
00027fac l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
000284d4 g     O .bss	00000004 alt_instruction_exception_handler
0002842c g     O .bss	00000001 b3BufferMode
00026664 g     F .text	00000048 init_exti0_it
00028424 g     O .bss	00000002 nEcatStateTrans
00028410 g     O .bss	00000002 u16IdValue
000272f0 g     F .text	0000002c alt_main
00026e44 g     F .text	00000080 _puts_r
00028658 g     O .bss	00000100 alt_irq
00027f9a g     O .rwdata	00000006 sEntryDesc0x1000
00027fb8 g       *ABS*	00000000 __flash_rwdata_start
000207b8 g     F .text	0000000c HW_EscReadIsr
00028758 g       *ABS*	00000000 __alt_heap_start
00027bb8 g     O .rwdata	000001e0 GenObjDic
00027f8e g     O .rwdata	00000006 sEntryDesc0x1008
00027934 g     O .rodata	00000047 aName0x1018
0002466c g     F .text	00000008 OBJ_GetObjDesc
00028427 g     O .bss	00000001 bApplEsmPending
0002089c g     F .text	00000004 HW_SYNC1_IRQHandler
00022508 g     F .text	0000005c StartOutputHandler
00020424 g     F .text	0000004c APPL_OutputMapping
00027320 g     F .text	00000004 __malloc_unlock
00028400 g     O .bss	00000004 pCoeSendStored
00026834 g     F .text	000000b0 spi_transmit_receive
00023e58 g     F .text	000000e0 MBX_MailboxWriteInd
00028498 g     O .bss	00000002 nSdoInfoIndex
00023378 g     F .text	000001e4 ECAT_StateChange
000284a4 g     O .bss	00000004 pStoreData
000283f8 g     O .bss	00000004 pAPPL_CoeReadInd
00028465 g     O .bss	00000001 u8MbxReadCounter
00021908 g     F .text	00000068 COE_ContinueInd
0002841b g     O .bss	00000001 nAlStatus
00028420 g     O .bss	00000002 nPdOutputSize
000275b8 g     F .text	00000008 altera_nios2_gen2_irq_init
000284d8 g     O .bss	0000000c spiRxBuf
00020000 g     F .entry	0000000c __reset
000283d4 g     O .bss	00000001 bInitFinished
000284b4 g     O .bss	00000004 edge_capture
00020020 g       *ABS*	00000000 __flash_exceptions_start
0002842a g     O .bss	00000002 u16LocalErrorCode
00028484 g     O .bss	00000004 nSdoSegBytesToHandle
00020484 g     F .text	00000034 main_initial
00021970 g     F .text	0000004c ResetALEventMask
000284c0 g     O .bss	00000004 errno
000283b8 g     O .bss	00000002 bootSwitchID
00028428 g     O .bss	00000001 u8LocalErrorState
00027dac g     O .rwdata	0000000d acDevicename
00027a20 g     O .rodata	0000000c asEntryDesc0x7000
0002858c g     O .bss	00000034 sMbxSendQueue
0002841a g     O .bss	00000001 bExplicitDevIdRequested
00027ee4 g     O .rwdata	0000000c sErrorSettings
000284cc g     O .bss	00000004 alt_argv
000201e4 g     F .text	00000004 APPL_AckErrorInd
0002ff44 g       *ABS*	00000000 _gp
00027370 g     F .text	00000004 usleep
00027f74 g     O .rwdata	00000006 sEntryDesc0x100A
00022570 g     F .text	000000a0 StopInputHandler
00028558 g     O .bss	00000034 sMbxReceiveQueue
00028450 g     O .bss	00000001 bNoMbxMemoryAvailable
00023c70 g     F .text	000000a0 MBX_MailboxReadInd
00027d98 g     O .rwdata	00000014 sIdentity
0002843a g     O .bss	00000002 Sync0WdCounter
00026ed4 g     F .text	00000028 memcpy
00024830 g     F .text	0000010c CheckSyncTypeValue
00027f54 g     O .rwdata	00000004 sRxPDOassign
000283e0 g     O .bss	00000001 bMinCycleTimeMeasurementStarted
00026ec4 g     F .text	00000010 puts
00027594 g     F .text	00000024 alt_exception_cause_generated_bad_addr
0002088c g     F .text	0000000c HW_EscWriteIsr
00028472 g     O .bss	00000001 bSendMbxIsFull
000283ec g     O .bss	00000004 u32CycleTimeStartValue
000278cc g     O .rodata	00000013 aName0x10F8
00028430 g     O .bss	00000002 LatchInputSync0Counter
00026bcc g     F .text	00000010 malloc
0002843c g     O .bss	00000002 i16WaitForPllRunningCnt
00026ae4 g     F .text	00000064 .hidden __udivsi3
00028416 g     O .bss	00000002 nEscAddrOutputData
00028471 g     O .bss	00000001 bMbxRunning
000257ec g     F .text	000008f4 SDOS_SdoInd
00027f48 g     O .rwdata	00000004 OUT_GENERIC0x7000
00020210 g     F .text	00000008 APPL_StopOutputHandler
00021b2c g     F .text	00000270 CheckSmSettings
000276dc g     O .rodata	00000108 aName0x1C32
00028438 g     O .bss	00000002 Sync0WdValue
00026f38 g     F .text	00000048 _sbrk_r
00024430 g     F .text	0000003c OBJ_GetEntryDesc
000279f8 g     O .rodata	0000000c aName0x1000
00020e44 g     F .text	00000068 GetSystemTimeDelay
00020200 g     F .text	00000008 APPL_StopInputHandler
0002843e g     O .bss	00000002 i16WaitForPllRunningTimeout
0002848c g     O .bss	00000001 bSdoSegAccess
00028434 g     O .bss	00000002 Sync1WdValue
00021d9c g     F .text	0000076c StartInputHandler
000208a0 g     F .text	00000004 HW_TIMETASK_IRQHandler
00027a7c g     O .rodata	0000001b aName0x1C12
00027f50 g     O .rwdata	00000004 sTxPDOassign
00023928 g     F .text	000000d4 MBX_StartMailboxHandler
00028758 g       *ABS*	00000000 __bss_end
00027204 g     F .text	00000068 alt_iic_isr_register
00028404 g     O .bss	00000001 EepromLoaded
00027a2c g     O .rodata	00000019 aName0x6000
00027b10 g     O .rodata	0000000c asEntryDesc0x1600
0002848d g     O .bss	00000001 bSdoSegFollows
0002847c g     O .bss	00000004 nSdoSegCompleteSize
0002840f g     O .bss	00000001 u8dummy
00028412 g     O .bss	00000002 u16ALEventMask
000271ec g     F .text	00000018 alt_ic_irq_enabled
00027b3c g     O .rodata	00000078 cAbortCode
000284a0 g     O .bss	00000004 pSdoPendFunc
00028446 g     O .bss	00000001 bDcRunning
000284c4 g     O .bss	00000004 alt_irq_active
0002493c g     F .text	00000610 OBJ_Read
000200fc g     F .exceptions	00000060 alt_irq_handler
000283fc g     O .bss	00000001 bRunApplication
00027a04 g     O .rodata	0000001c aName0x7000
0002846a g     O .bss	00000002 u16EscAddrReceiveMbx
00028454 g     O .bss	00000004 psStoreMbx
0002406c g     F .text	000000c4 MBX_Main
00028406 g     O .bss	00000008 SyncManInfo
00027f68 g     O .rwdata	00000006 sSyncmanagertype
0002842e g     O .bss	00000001 b32BitDc
00021ad0 g     F .text	0000005c EnableSyncManChannel
0002758c g     F .text	00000004 alt_dcache_flush_all
00027ae0 g     O .rodata	00000030 aName0x1600
00027fb8 g       *ABS*	00000000 __ram_rwdata_end
000209b0 g     F .text	0000005c COE_UpdateSyncErrorStatus
00027f60 g     O .rwdata	00000008 OUT_GENERICProcessDataMapping0x1600
00027374 g     F .text	0000005c write
000283e4 g     O .bss	00000004 u32SystemTimeReadFailure
000239fc g     F .text	00000108 MBX_StopMailboxHandler
000278e0 g     O .rodata	0000003f aName0x10F1
000284b0 g     O .bss	00000001 u8PendingSdo
00027bb8 g       *ABS*	00000000 __ram_rodata_end
00027fb0 g     O .rwdata	00000004 DEBUG
00027dbc g     O .rwdata	00000118 ApplicationObjDic
00020f5c g     F .text	0000006c HandleCycleTimeMeasurement
00028432 g     O .bss	00000002 LatchInputSync0Value
00026b48 g     F .text	0000005c .hidden __umodsi3
00027f58 g     O .rwdata	00000008 IN_GENERICProcessDataMapping0x1A00
0002797c g     O .rodata	0000001e asEntryDesc0x1018
00028758 g       *ABS*	00000000 end
000201f8 g     F .text	00000008 APPL_StartInputHandler
0002846e g     O .bss	00000002 u16SendMbxSize
00028426 g     O .bss	00000001 bEcatWaitForAlControlRes
000261f0 g     F .text	00000078 SDOS_ClearPendingResponse
0002015c g     F .exceptions	00000024 alt_instruction_exception_entry
0002845c g     O .bss	00000004 psReadMbx
00022564 g     F .text	0000000c StopOutputHandler
000279bc g     O .rodata	0000001e aName0x1009
000283ff g     O .bss	00000001 bEcatWaitForInputUpdate
00021358 g     F .text	000001c0 PDI_Isr
000285c0 g     O .bss	00000044 sSyncManInPar
00034000 g       *ABS*	00000000 __alt_stack_pointer
00027f88 g     O .rwdata	00000006 acHardwareversion
00026268 g     F .text	000003d8 SDOS_SdoInfoInd
000273f4 g     F .text	00000030 altera_avalon_jtag_uart_write
000283dc g     O .bss	00000004 u32MinCycleTimeValue
00028422 g     O .bss	00000002 nPdInputSize
00026f80 g     F .text	00000100 _free_r
000279e8 g     O .rodata	0000000f aName0x1001
00027f4c g     O .rwdata	00000004 IN_GENERIC0x6000
000207c4 g     F .text	00000038 HW_EscWrite
000201f0 g     F .text	00000008 APPL_StopMailboxHandler
00027ed4 g     O .rwdata	0000000d aSubindexDesc
00023878 g     F .text	000000b0 MBX_Init
00020180 g     F .text	0000003c _start
000268e4 g     F .text	0000010c adc_init_spi_transmit_receive
0002848f g     O .bss	00000001 bSdoInWork
00020898 g     F .text	00000004 HW_SYNC0_IRQHandler
00028442 g     O .bss	00000002 u16SmSync0Value
000284af g     O .bss	00000001 bStoreCompleteAccess
00027424 g     F .text	000000d8 alt_avalon_spi_command
00024278 g     F .text	00000080 OBJ_CopyNumberToString
000209a8 g     F .text	00000008 COE_GetObjectDictionary
000273f0 g     F .text	00000004 alt_sys_init
0002446c g     F .text	000000b8 OBJ_GetNoOfObjects
000283d6 g     O .bss	00000004 aPdOutputData
00028480 g     O .bss	00000001 bSdoSegLastToggle
00023b24 g     F .text	0000014c MBX_CopyToSendMailbox
000226bc g     F .text	0000081c AL_ControlInd
00026ba4 g     F .text	00000028 .hidden __mulsi3
00027bb8 g       *ABS*	00000000 __ram_rwdata_start
000275c0 g       *ABS*	00000000 __ram_rodata_start
0002848e g     O .bss	00000001 nSdoSegService
00027f6e g     O .rwdata	00000006 sEntryDesc0x10F8
00020db4 g     F .text	00000090 ECAT_CheckTimer
0002363c g     F .text	000001a8 ECAT_Main
00028473 g     O .bss	00000001 bReceiveMbxIsLocked
00028468 g     O .bss	00000002 u16EscAddrSendMbx
0002841c g     O .bss	00000002 nMaxEscAddress
0002844c g     O .bss	00000001 bEcatFirstOutputsReceived
000274fc g     F .text	00000090 alt_busy_sleep
00028460 g     O .bss	00000004 psWriteMbx
000283cc g     O .bss	00000008 u64Timestamp
000278be g     O .rodata	0000000c asEntryDesc0x1C00
000201e8 g     F .text	00000008 APPL_StartMailboxHandler
00028466 g     O .bss	00000001 u8MbxWriteCounter
000207fc g     F .text	00000090 HW_Init
00028758 g       *ABS*	00000000 __alt_stack_base
00027b1c g     O .rodata	00000020 cBitMask
0002840e g     O .bss	00000001 SMActivate
000283c8 g     O .bss	00000004 u32LastDc32Value
00023b04 g     F .text	00000020 MailboxServiceInd
000237e4 g     F .text	00000050 PutInMbxQueue
000242f8 g     F .text	00000138 OBJ_GetDesc
000283c4 g     O .bss	00000004 u32CheckForDcOverrunCnt
00023d10 g     F .text	00000068 MBX_MailboxRepeatReq
00028464 g     O .bss	00000001 u8MailboxSendReqStored
000218b4 g     F .text	0000000c COE_Init
00020a98 g     F .text	00000054 COE_RemoveDicEntry
00020eac g     F .text	000000b0 PDO_InputMapping
00027f7c g     O .rwdata	00000006 acSoftwareversion
000283c0 g     O .bss	00000002 u16ErrorRegister
0002731c g     F .text	00000004 __malloc_lock
00027324 g     F .text	0000004c sbrk
000283f4 g     O .bss	00000004 pAPPL_CoeWriteInd
000260e0 g     F .text	00000110 SDOS_SdoRes
00028494 g     O .bss	00000004 pSdoInfoObjEntry
000215ec g     F .text	00000218 ESC_EepromAccess
00027080 g     F .text	000000a8 __sfvwrite_small_dev
00028440 g     O .bss	00000001 bSmSyncSequenceValid
0002849a g     O .bss	00000002 nSdoInfoFragmentsLeft
00022ed8 g     F .text	00000308 AL_ControlRes
000283b8 g       *ABS*	00000000 __bss_start
00026efc g     F .text	00000020 memset
00024f4c g     F .text	00000740 OBJ_Write
000201bc g     F .text	00000028 main
00020000 g       *ABS*	00000000 __alt_mem_RAM
000266ac g     F .text	00000020 delay_ms
00027a98 g     O .rodata	0000000c asEntryDesc0x1C12
000284c8 g     O .bss	00000004 alt_envp
00027f94 g     O .rwdata	00000006 sEntryDesc0x1001
00020218 g     F .text	000001c0 APPL_GenerateMapping
00020718 g     F .text	00000028 HW_GetALEventRegister_Isr
00028448 g     O .bss	00000002 EsmTimeoutCounter
00020ce8 g     F .text	000000cc COE_Main
00034000 g       *ABS*	00000000 __alt_heap_limit
00021804 g     F .text	000000b0 ESC_EepromWriteCRC
00026c78 g     F .text	000001cc _malloc_r
00020910 g     F .text	00000098 Read0x10F8
000283ba g     O .bss	00000002 EscALEvent
0002846c g     O .bss	00000002 u16ReceiveMbxSize
000283bc g     O .bss	00000004 ObjDicList
00027fb4 g     O .rwdata	00000004 alt_errno
00027f82 g     O .rwdata	00000006 sEntryDesc0x1009
00028490 g     O .bss	00000004 pSdoResStored
000284a8 g     O .bss	00000004 u32StoreDataSize
000269f0 g     F .text	00000080 .hidden __divsi3
000231e0 g     F .text	000000c0 DC_CheckWatchdog
0002849c g     O .bss	00000004 pSdoSegData
000275c0 g       *ABS*	00000000 __flash_rodata_start
00021a70 g     F .text	00000060 DisableSyncManChannel
0002844a g     O .bss	00000001 bDcSyncActive
0002844e g     O .bss	00000001 bEcatOutputUpdateRunning
000273d0 g     F .text	00000020 alt_irq_init
00021518 g     F .text	000000d4 MainLoop
00023d78 g     F .text	000000e0 MBX_MailboxSendReq
000283f0 g     O .bss	00000004 pAPPL_MainLoop
000210d4 g     F .text	000000e8 MainInit
00020a0c g     F .text	0000008c COE_AddObjectToDic
00027128 g     F .text	00000050 _write_r
00028604 g     O .bss	00000044 sSyncManOutPar
00028436 g     O .bss	00000002 Sync1WdCounter
00027fa4 g     O .rwdata	00000004 _impure_ptr
000284d0 g     O .bss	00000004 alt_argc
000266cc g     F .text	00000168 adc_init
00021a40 g     F .text	00000030 GetSyncMan
000218c0 g     F .text	00000048 COE_ServiceInd
00027920 g     O .rodata	00000012 asEntryDesc0x10F1
00027a54 g     O .rodata	0000001b aName0x1C13
00020020 g       .exceptions	00000000 alt_irq_entry
00027a70 g     O .rodata	0000000c asEntryDesc0x1C13
00022618 g     F .text	000000a4 SetALStatus
000211f8 g     F .text	00000160 Sync0_Isr
00028418 g     O .bss	00000002 EcatWdValue
000283fd g     O .bss	00000001 bEtherCATErrorLed
000208a4 g     F .text	0000006c COE_SyncTimeStamp
00020020 g       *ABS*	00000000 __ram_exceptions_start
00020778 g     F .text	00000040 HW_GetALEventRegister
000283e8 g     O .bss	00000004 u32MinCycleTimeStartValue
00027178 g     F .text	00000004 alt_ic_isr_register
000278ac g     O .rodata	00000012 aName0x1C00
00027fb8 g       *ABS*	00000000 _edata
000219bc g     F .text	0000004c SetALEventMask
00028476 g     O .bss	00000001 bSyncSetByUser
00028758 g       *ABS*	00000000 _end
00028470 g     O .bss	00000001 bMbxRepeatToggle
0002799c g     O .rodata	0000001e aName0x100A
0002844d g     O .bss	00000001 bEcatInputUpdateRunning
00021a08 g     F .text	00000038 UpdateEEPROMLoadedState
00021080 g     F .text	00000054 Sync1_Isr
00020180 g       *ABS*	00000000 __ram_exceptions_end
0002842d g     O .bss	00000001 bEscIntEnabled
00028458 g     O .bss	00000004 psRepeatMbx
0002047c g     F .text	00000008 APPL_GetDeviceID
000277e4 g     O .rodata	000000c6 asEntryDesc0x1C3x
00024130 g     F .text	0000003c OBJ_GetObjectHandle
0002848a g     O .bss	00000002 nSdoSegIndex
00028648 g     O .bss	00000010 aSdoInfoHeader
000271b4 g     F .text	00000038 alt_ic_irq_disable
00027aa4 g     O .rodata	0000002f aName0x1A00
00020208 g     F .text	00000008 APPL_StartOutputHandler
00028478 g     O .bss	00000004 pSdoSegObjEntry
00027ad4 g     O .rodata	0000000c asEntryDesc0x1A00
00024674 g     F .text	000001bc OBJ_GetEntryOffset
00020b78 g     F .text	00000040 COE_ObjDictionaryInit
00023f38 g     F .text	00000134 MBX_CheckAndCopyMailbox
00020bb8 g     F .text	00000130 COE_ObjInit
000284f0 g     O .bss	00000068 aPdInputData
00020aec g     F .text	0000003c COE_ClearObjDictionary
0002844b g     O .bss	00000001 bWdTrigger
00026a70 g     F .text	00000074 .hidden __modsi3
00020fc8 g     F .text	000000b8 PDO_OutputMapping
00028488 g     O .bss	00000001 nSdoSegSubindex
00027ef0 g     O .rwdata	00000054 _impure_data
00034000 g       *ABS*	00000000 __alt_data_end
00020020 g     F .exceptions	00000000 alt_exception
0002568c g     F .text	00000160 SdoRes
00020740 g     F .text	00000038 HW_EscRead
000284ac g     O .bss	00000002 u16StoreIndex
000283fe g     O .bss	00000001 bEtherCATRunLed
000232a0 g     F .text	000000d8 CheckIfEcatError
00024524 g     F .text	00000148 OBJ_GetObjectList
00027a46 g     O .rodata	0000000c asEntryDesc0x6000
0002000c g       .entry	00000000 _exit
00028444 g     O .bss	00000002 u16SmSync0Counter
0002841e g     O .bss	00000001 nMaxSyncMan
00026f1c g     F .text	0000001c strlen
000203d8 g     F .text	0000004c APPL_InputMapping
00020470 g     F .text	0000000c APPL_Application
00027fa0 g     O .rwdata	00000004 u32Devicetype
000284b8 g     O .bss	00000004 __malloc_sbrk_start
000284ae g     O .bss	00000001 u8StoreSubindex
000275d4 g     O .rodata	00000107 aName0x1C33
00022610 g     F .text	00000008 BackToInitTransition
0002416c g     F .text	0000010c OBJ_GetObjectLength
00023834 g     F .text	00000044 GetOutOfMbxQueue
00027590 g     F .text	00000004 alt_icache_flush_all
00027fa8 g     O .rwdata	00000004 alt_priority_mask
000284bc g     O .bss	00000004 __malloc_free_list
0002717c g     F .text	00000038 alt_ic_irq_enable
00020b28 g     F .text	00000050 AddObjectsToObjDictionary
000284e4 g     O .bss	0000000c spiTxBuf
00028474 g     O .bss	00000002 sCycleDiag
000211bc g     F .text	0000003c ECAT_Application
000279dc g     O .rodata	0000000c aName0x1008
0002355c g     F .text	000000e0 ECAT_Init
0002726c g     F .text	00000084 alt_load
00028414 g     O .bss	00000002 nEscAddrInputData
00026bdc g     F .text	00000010 free
00026640 g     F .text	00000024 exti0_isr
00020714 g     F .text	00000004 HW_Release



Disassembly of section .entry:

00020000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   20000:	004000b4 	movhi	at,2
    ori r1, r1, %lo(_start)
   20004:	08406014 	ori	at,at,384
    jmp r1
   20008:	0800683a 	jmp	at

0002000c <_exit>:
	...

Disassembly of section .exceptions:

00020020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
   20020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
   20024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
   20028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
   2002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
   20030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
   20034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
   20038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
   2003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
   20040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
   20044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
   20048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
   2004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
   20050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
   20054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
   20058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
   2005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
   20060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
   20064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
   20068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
   2006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
   20070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
   20074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
   20078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
   2007c:	10000326 	beq	r2,zero,2008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
   20080:	20000226 	beq	r4,zero,2008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
   20084:	00200fc0 	call	200fc <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
   20088:	00000706 	br	200a8 <alt_exception+0x88>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
   2008c:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
   20090:	e8bfff17 	ldw	r2,-4(ea)
   20094:	e93fff04 	addi	r4,ea,-4
   20098:	002015c0 	call	2015c <alt_instruction_exception_entry>
   2009c:	1000021e 	bne	r2,zero,200a8 <alt_exception+0x88>
   200a0:	ebffff04 	addi	r15,ea,-4
   200a4:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
   200a8:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
   200ac:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
   200b0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
   200b4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
   200b8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
   200bc:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
   200c0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
   200c4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
   200c8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
   200cc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
   200d0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
   200d4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
   200d8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
   200dc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
   200e0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
   200e4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
   200e8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
   200ec:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
   200f0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
   200f4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
   200f8:	ef80083a 	eret

000200fc <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
   200fc:	defffe04 	addi	sp,sp,-8
   20100:	dfc00115 	stw	ra,4(sp)
   20104:	dc000015 	stw	r16,0(sp)
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
   20108:	0009313a 	rdctl	r4,ipending
    do
    {
      if (active & mask)
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
   2010c:	040000f4 	movhi	r16,3
   20110:	84219604 	addi	r16,r16,-31144
    i = 0;
   20114:	0005883a 	mov	r2,zero
    mask = 1;
   20118:	00c00044 	movi	r3,1
      if (active & mask)
   2011c:	20ca703a 	and	r5,r4,r3
   20120:	28000b26 	beq	r5,zero,20150 <alt_irq_handler+0x54>
        alt_irq[i].handler(alt_irq[i].context); 
   20124:	100490fa 	slli	r2,r2,3
   20128:	8085883a 	add	r2,r16,r2
   2012c:	10c00017 	ldw	r3,0(r2)
   20130:	11000117 	ldw	r4,4(r2)
   20134:	183ee83a 	callr	r3
   20138:	0009313a 	rdctl	r4,ipending

    } while (1);

    active = alt_irq_pending ();
    
  } while (active);
   2013c:	203ff51e 	bne	r4,zero,20114 <alt_irq_handler+0x18>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
   20140:	dfc00117 	ldw	ra,4(sp)
   20144:	dc000017 	ldw	r16,0(sp)
   20148:	dec00204 	addi	sp,sp,8
   2014c:	f800283a 	ret
      mask <<= 1;
   20150:	1806907a 	slli	r3,r3,1
      i++;
   20154:	10800044 	addi	r2,r2,1
      if (active & mask)
   20158:	003ff006 	br	2011c <alt_irq_handler+0x20>

0002015c <alt_instruction_exception_entry>:
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
   2015c:	d0a16417 	ldw	r2,-31344(gp)
{
   20160:	200b883a 	mov	r5,r4
  if(alt_instruction_exception_handler) {
   20164:	10000326 	beq	r2,zero,20174 <alt_instruction_exception_entry+0x18>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
   20168:	000d883a 	mov	r6,zero
   2016c:	013fffc4 	movi	r4,-1
   20170:	1000683a 	jmp	r2
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
   20174:	003da03a 	break	0
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
}
   20178:	0005883a 	mov	r2,zero
   2017c:	f800283a 	ret

Disassembly of section .text:

00020180 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   20180:	06c000f4 	movhi	sp,3
    ori sp, sp, %lo(__alt_stack_pointer)
   20184:	ded00014 	ori	sp,sp,16384
    movhi gp, %hi(_gp)
   20188:	068000b4 	movhi	gp,2
    ori gp, gp, %lo(_gp)
   2018c:	d6bfd114 	ori	gp,gp,65348
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   20190:	008000b4 	movhi	r2,2
    ori r2, r2, %lo(__bss_start)
   20194:	10a0ee14 	ori	r2,r2,33720

    movhi r3, %hi(__bss_end)
   20198:	00c000b4 	movhi	r3,2
    ori r3, r3, %lo(__bss_end)
   2019c:	18e1d614 	ori	r3,r3,34648

    beq r2, r3, 1f
   201a0:	10c00326 	beq	r2,r3,201b0 <_start+0x30>

0:
    stw zero, (r2)
   201a4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   201a8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   201ac:	10fffd36 	bltu	r2,r3,201a4 <_start+0x24>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   201b0:	002726c0 	call	2726c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   201b4:	00272f00 	call	272f0 <alt_main>

000201b8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   201b8:	003fff06 	br	201b8 <alt_after_alt_main>

000201bc <main>:
#include "imported_source/ax58100_hw.h"

int main()
{

  printf("Hello from Nios II!\n");
   201bc:	010000b4 	movhi	r4,2
{
   201c0:	deffff04 	addi	sp,sp,-4
  printf("Hello from Nios II!\n");
   201c4:	211d7004 	addi	r4,r4,30144
{
   201c8:	dfc00015 	stw	ra,0(sp)
  printf("Hello from Nios II!\n");
   201cc:	0026ec40 	call	26ec4 <puts>
  	  IOWR_ALTERA_AVALON_PIO_DATA(LED_BASE, invert_me);
  	  delay_ms(1000);
  	  invert_me = ~invert_me;
  }*/

  main_initial();
   201d0:	00204840 	call	20484 <main_initial>

  return 0;
}
   201d4:	0005883a 	mov	r2,zero
   201d8:	dfc00017 	ldw	ra,0(sp)
   201dc:	dec00104 	addi	sp,sp,4
   201e0:	f800283a 	ret

000201e4 <APPL_AckErrorInd>:
*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{

}
   201e4:	f800283a 	ret

000201e8 <APPL_StartMailboxHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
    return ALSTATUSCODE_NOERROR;
}
   201e8:	0005883a 	mov	r2,zero
   201ec:	f800283a 	ret

000201f0 <APPL_StopMailboxHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
   201f0:	0005883a 	mov	r2,zero
   201f4:	f800283a 	ret

000201f8 <APPL_StartInputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
    return ALSTATUSCODE_NOERROR;
}
   201f8:	0005883a 	mov	r2,zero
   201fc:	f800283a 	ret

00020200 <APPL_StopInputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
   20200:	0005883a 	mov	r2,zero
   20204:	f800283a 	ret

00020208 <APPL_StartOutputHandler>:
           The return code NOERROR_INWORK can be used, if the application cannot confirm
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
   20208:	0005883a 	mov	r2,zero
   2020c:	f800283a 	ret

00020210 <APPL_StopOutputHandler>:
             about the state transition, the application cannot refuse
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
   20210:	0005883a 	mov	r2,zero
   20214:	f800283a 	ret

00020218 <APPL_GenerateMapping>:

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
{
   20218:	defff404 	addi	sp,sp,-48
   2021c:	dd800815 	stw	r22,32(sp)
   20220:	dd400715 	stw	r21,28(sp)
   20224:	dd000615 	stw	r20,24(sp)
   20228:	dcc00515 	stw	r19,20(sp)
   2022c:	dc000215 	stw	r16,8(sp)
   20230:	dfc00b15 	stw	ra,44(sp)
   20234:	df000a15 	stw	fp,40(sp)
   20238:	ddc00915 	stw	r23,36(sp)
   2023c:	dc800415 	stw	r18,16(sp)
   20240:	dc400315 	stw	r17,12(sp)
   20244:	2029883a 	mov	r20,r4
   20248:	2827883a 	mov	r19,r5
    UINT32 *pPDOEntry = NULL;
    UINT16 PDOEntryCnt = 0;
   
#if MAX_PD_OUTPUT_SIZE > 0
    /*Scan object 0x1C12 RXPDO assign*/
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   2024c:	002d883a 	mov	r22,zero
    UINT16 OutputSize = 0;
   20250:	0021883a 	mov	r16,zero
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20254:	d5600404 	addi	r21,gp,-32752
   20258:	d0e0040b 	ldhu	r3,-32752(gp)
   2025c:	b0bfffcc 	andi	r2,r22,65535
   20260:	10c01a36 	bltu	r2,r3,202cc <APPL_GenerateMapping+0xb4>
    UINT16 result = ALSTATUSCODE_NOERROR;
   20264:	0023883a 	mov	r17,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
            break;
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
   20268:	84bfffcc 	andi	r18,r16,65535
   2026c:	948001c4 	addi	r18,r18,7
#endif

#if MAX_PD_INPUT_SIZE > 0
    if(result == 0)
   20270:	88bfffcc 	andi	r2,r17,65535
    OutputSize = (OutputSize + 7) >> 3;
   20274:	9025d0fa 	srai	r18,r18,3
    if(result == 0)
   20278:	10005026 	beq	r2,zero,203bc <APPL_GenerateMapping+0x1a4>
    UINT16 InputSize = 0;
   2027c:	0021883a 	mov	r16,zero
   20280:	04400944 	movi	r17,37
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
                break;
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
   20284:	843fffcc 	andi	r16,r16,65535
   20288:	840001c4 	addi	r16,r16,7
   2028c:	8021d0fa 	srai	r16,r16,3
#endif

    *pInputSize = InputSize;
    *pOutputSize = OutputSize;
    return result;
}
   20290:	8805883a 	mov	r2,r17
    InputSize = (InputSize + 7) >> 3;
   20294:	a400000d 	sth	r16,0(r20)
    *pOutputSize = OutputSize;
   20298:	9c80000d 	sth	r18,0(r19)
}
   2029c:	dfc00b17 	ldw	ra,44(sp)
   202a0:	df000a17 	ldw	fp,40(sp)
   202a4:	ddc00917 	ldw	r23,36(sp)
   202a8:	dd800817 	ldw	r22,32(sp)
   202ac:	dd400717 	ldw	r21,28(sp)
   202b0:	dd000617 	ldw	r20,24(sp)
   202b4:	dcc00517 	ldw	r19,20(sp)
   202b8:	dc800417 	ldw	r18,16(sp)
   202bc:	dc400317 	ldw	r17,12(sp)
   202c0:	dc000217 	ldw	r16,8(sp)
   202c4:	dec00c04 	addi	sp,sp,48
   202c8:	f800283a 	ret
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
   202cc:	1004907a 	slli	r2,r2,1
   202d0:	a885883a 	add	r2,r21,r2
   202d4:	1100008b 	ldhu	r4,2(r2)
   202d8:	00241300 	call	24130 <OBJ_GetObjectHandle>
   202dc:	1025883a 	mov	r18,r2
        if(pPDO != NULL)
   202e0:	10001326 	beq	r2,zero,20330 <APPL_GenerateMapping+0x118>
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   202e4:	10800617 	ldw	r2,24(r2)
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   202e8:	0007883a 	mov	r3,zero
   202ec:	1700000b 	ldhu	fp,0(r2)
   202f0:	18bfffcc 	andi	r2,r3,65535
   202f4:	1700021e 	bne	r2,fp,20300 <APPL_GenerateMapping+0xe8>
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   202f8:	b5800044 	addi	r22,r22,1
   202fc:	003fd606 	br	20258 <APPL_GenerateMapping+0x40>
                pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   20300:	1c400044 	addi	r17,r3,1
   20304:	900b883a 	mov	r5,r18
   20308:	89003fcc 	andi	r4,r17,255
   2030c:	95c00617 	ldw	r23,24(r18)
   20310:	00246740 	call	24674 <OBJ_GetEntryOffset>
   20314:	1004d0fa 	srli	r2,r2,3
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20318:	8807883a 	mov	r3,r17
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   2031c:	1087ff8c 	andi	r2,r2,8190
   20320:	b8af883a 	add	r23,r23,r2
   20324:	b8800003 	ldbu	r2,0(r23)
   20328:	1421883a 	add	r16,r2,r16
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   2032c:	003ff006 	br	202f0 <APPL_GenerateMapping+0xd8>
            OutputSize = 0;
   20330:	0021883a 	mov	r16,zero
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
   20334:	04400944 	movi	r17,37
   20338:	003fcb06 	br	20268 <APPL_GenerateMapping+0x50>
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
   2033c:	1004907a 	slli	r2,r2,1
   20340:	b885883a 	add	r2,r23,r2
   20344:	1100008b 	ldhu	r4,2(r2)
   20348:	00241300 	call	24130 <OBJ_GetObjectHandle>
   2034c:	102d883a 	mov	r22,r2
            if(pPDO != NULL)
   20350:	10001e26 	beq	r2,zero,203cc <APPL_GenerateMapping+0x1b4>
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
   20354:	10800617 	ldw	r2,24(r2)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   20358:	8807883a 	mov	r3,r17
   2035c:	11c0000b 	ldhu	r7,0(r2)
   20360:	18bfffcc 	andi	r2,r3,65535
   20364:	11c0051e 	bne	r2,r7,2037c <APPL_GenerateMapping+0x164>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   20368:	e7000044 	addi	fp,fp,1
   2036c:	d0e0030b 	ldhu	r3,-32756(gp)
   20370:	e0bfffcc 	andi	r2,fp,65535
   20374:	10fff136 	bltu	r2,r3,2033c <APPL_GenerateMapping+0x124>
   20378:	003fc206 	br	20284 <APPL_GenerateMapping+0x6c>
                    pPDOEntry = (UINT32 *)(((UINT16 *)pPDO->pVarPtr) + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>4));    //goto PDO entry
   2037c:	b1800617 	ldw	r6,24(r22)
   20380:	1d400044 	addi	r21,r3,1
   20384:	b00b883a 	mov	r5,r22
   20388:	a9003fcc 	andi	r4,r21,255
   2038c:	d9c00115 	stw	r7,4(sp)
   20390:	d9800015 	stw	r6,0(sp)
   20394:	00246740 	call	24674 <OBJ_GetEntryOffset>
   20398:	1004d0fa 	srli	r2,r2,3
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   2039c:	d9800017 	ldw	r6,0(sp)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203a0:	d9c00117 	ldw	r7,4(sp)
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   203a4:	1087ff8c 	andi	r2,r2,8190
   203a8:	308d883a 	add	r6,r6,r2
   203ac:	30800003 	ldbu	r2,0(r6)
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203b0:	a807883a 	mov	r3,r21
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
   203b4:	1421883a 	add	r16,r2,r16
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
   203b8:	003fe906 	br	20360 <APPL_GenerateMapping+0x148>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   203bc:	8839883a 	mov	fp,r17
    UINT16 InputSize = 0;
   203c0:	8821883a 	mov	r16,r17
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
   203c4:	d5e00304 	addi	r23,gp,-32756
   203c8:	003fe806 	br	2036c <APPL_GenerateMapping+0x154>
                InputSize = 0;
   203cc:	8821883a 	mov	r16,r17
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
   203d0:	04400904 	movi	r17,36
   203d4:	003fab06 	br	20284 <APPL_GenerateMapping+0x6c>

000203d8 <APPL_InputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   203d8:	0007883a 	mov	r3,zero
   203dc:	d1a00304 	addi	r6,gp,-32756
   203e0:	d160030b 	ldhu	r5,-32756(gp)
   203e4:	18803fcc 	andi	r2,r3,255
   203e8:	11400136 	bltu	r2,r5,203f0 <APPL_InputMapping+0x18>
					   sizeof(IN_GENERIC0x6000.IN_GEN_INT1));
				pTmpData += sizeof(IN_GENERIC0x6000.IN_GEN_INT1);
				break;
		}
	}
}
   203ec:	f800283a 	ret
		switch (sTxPDOassign.aEntries[j]) {
   203f0:	18803fcc 	andi	r2,r3,255
   203f4:	1004907a 	slli	r2,r2,1
   203f8:	3085883a 	add	r2,r6,r2
   203fc:	1080008b 	ldhu	r2,2(r2)
   20400:	10868018 	cmpnei	r2,r2,6656
   20404:	1000051e 	bne	r2,zero,2041c <APPL_InputMapping+0x44>
				memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   20408:	d0a00283 	ldbu	r2,-32758(gp)
				pTmpData += sizeof(IN_GENERIC0x6000.IN_GEN_INT1);
   2040c:	21000084 	addi	r4,r4,2
				memcpy(pTmpData, &IN_GENERIC0x6000.IN_GEN_INT1,
   20410:	20bfff85 	stb	r2,-2(r4)
   20414:	d0a002c3 	ldbu	r2,-32757(gp)
   20418:	20bfffc5 	stb	r2,-1(r4)
	for (UINT8 j = 0; j < sTxPDOassign.u16SubIndex0; j++) {
   2041c:	18c00044 	addi	r3,r3,1
   20420:	003fef06 	br	203e0 <APPL_InputMapping+0x8>

00020424 <APPL_OutputMapping>:
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16* pData)
{
	UINT8 *pTmpData = (UINT8 *)pData;
	    for (UINT8 k = 0; k < sRxPDOassign.u16SubIndex0; k++) {
   20424:	0007883a 	mov	r3,zero
   20428:	d1a00404 	addi	r6,gp,-32752
   2042c:	d160040b 	ldhu	r5,-32752(gp)
   20430:	18803fcc 	andi	r2,r3,255
   20434:	11400136 	bltu	r2,r5,2043c <APPL_OutputMapping+0x18>
	                       sizeof(OUT_GENERIC0x7000.OUT_GEN_UINT1));
	                pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_UINT1);
	                break;
	        }
	    }
}
   20438:	f800283a 	ret
	        switch (sRxPDOassign.aEntries[k]) {
   2043c:	18803fcc 	andi	r2,r3,255
   20440:	1004907a 	slli	r2,r2,1
   20444:	3085883a 	add	r2,r6,r2
   20448:	1080008b 	ldhu	r2,2(r2)
   2044c:	10858018 	cmpnei	r2,r2,5632
   20450:	1000051e 	bne	r2,zero,20468 <APPL_OutputMapping+0x44>
	                memcpy(&OUT_GENERIC0x7000.OUT_GEN_UINT1, pTmpData,
   20454:	20800003 	ldbu	r2,0(r4)
	                pTmpData += sizeof(OUT_GENERIC0x7000.OUT_GEN_UINT1);
   20458:	21000084 	addi	r4,r4,2
	                memcpy(&OUT_GENERIC0x7000.OUT_GEN_UINT1, pTmpData,
   2045c:	d0a00185 	stb	r2,-32762(gp)
   20460:	20bfffc3 	ldbu	r2,-1(r4)
   20464:	d0a001c5 	stb	r2,-32761(gp)
	    for (UINT8 k = 0; k < sRxPDOassign.u16SubIndex0; k++) {
   20468:	18c00044 	addi	r3,r3,1
   2046c:	003fef06 	br	2042c <APPL_OutputMapping+0x8>

00020470 <APPL_Application>:
            or from the mainloop if no synchronisation is supported
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
	//static uint32_t haha = 0;
	IN_GENERIC0x6000.IN_GEN_INT1 = OUT_GENERIC0x7000.OUT_GEN_UINT1; //haha++;
   20470:	d0a0018b 	ldhu	r2,-32762(gp)
   20474:	d0a0028d 	sth	r2,-32758(gp)

}
   20478:	f800283a 	ret

0002047c <APPL_GetDeviceID>:
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GetDeviceID()
{
    /* Explicit Device 5 is expected by Explicit Device ID conformance tests*/
    return 0x5;
}
   2047c:	00800144 	movi	r2,5
   20480:	f800283a 	ret

00020484 <main_initial>:
/**

 \brief    This is the main function

*////////////////////////////////////////////////////////////////////////////////////////
void main_initial(void) {
   20484:	deffff04 	addi	sp,sp,-4
   20488:	dfc00015 	stw	ra,0(sp)
    /* initialize the Hardware and the EtherCAT Slave Controller */
    HW_Init();
   2048c:	00207fc0 	call	207fc <HW_Init>
    MainInit();
   20490:	00210d40 	call	210d4 <MainInit>

    bRunApplication = TRUE;
   20494:	00800044 	movi	r2,1
   20498:	d0a12e05 	stb	r2,-31560(gp)
    do {
        MainLoop();
   2049c:	00215180 	call	21518 <MainLoop>
    } while (bRunApplication == TRUE);
   204a0:	d0a12e03 	ldbu	r2,-31560(gp)
   204a4:	10800060 	cmpeqi	r2,r2,1
   204a8:	103ffc1e 	bne	r2,zero,2049c <main_initial+0x18>

    HW_Release();
}
   204ac:	dfc00017 	ldw	ra,0(sp)
   204b0:	dec00104 	addi	sp,sp,4
    HW_Release();
   204b4:	00207141 	jmpi	20714 <HW_Release>

000204b8 <HW_SPI_Read>:
 * @param pBuf
 * @param Addr
 * @param ByteLen
 */

static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   204b8:	defff504 	addi	sp,sp,-44
   204bc:	ddc00915 	stw	r23,36(sp)
   204c0:	dd000615 	stw	r20,24(sp)

        /* Set dummy byte */
        spiTxBuf[DataOffset] = 0xff;

        /* Set read terminal byte */
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   204c4:	05c000f4 	movhi	r23,3
        spiTxBuf[0] = ptr[1];
   204c8:	050000f4 	movhi	r20,3
static void HW_SPI_Read(uint8_t* pBuf, uint16_t Addr, uint16_t ByteLen) {
   204cc:	dd400715 	stw	r21,28(sp)
   204d0:	dc800415 	stw	r18,16(sp)
   204d4:	dc400315 	stw	r17,12(sp)
   204d8:	dc000215 	stw	r16,8(sp)
   204dc:	dfc00a15 	stw	ra,40(sp)
   204e0:	dd800815 	stw	r22,32(sp)
   204e4:	dcc00515 	stw	r19,20(sp)
   204e8:	2023883a 	mov	r17,r4
   204ec:	2825883a 	mov	r18,r5
   204f0:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   204f4:	a5213904 	addi	r20,r20,-31516
        spiTxBuf[DataOffset] = 0xff;
   204f8:	057fffc4 	movi	r21,-1
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   204fc:	bde139c4 	addi	r23,r23,-31513
    while (ByteLen) {
   20500:	80bfffcc 	andi	r2,r16,65535
   20504:	10000b1e 	bne	r2,zero,20534 <HW_SPI_Read+0x7c>
        /* Next section */
        Addr += XferLen;
        pBuf += XferLen;
        ByteLen -= XferLen;
    }
}
   20508:	dfc00a17 	ldw	ra,40(sp)
   2050c:	ddc00917 	ldw	r23,36(sp)
   20510:	dd800817 	ldw	r22,32(sp)
   20514:	dd400717 	ldw	r21,28(sp)
   20518:	dd000617 	ldw	r20,24(sp)
   2051c:	dcc00517 	ldw	r19,20(sp)
   20520:	dc800417 	ldw	r18,16(sp)
   20524:	dc400317 	ldw	r17,12(sp)
   20528:	dc000217 	ldw	r16,8(sp)
   2052c:	dec00b04 	addi	sp,sp,44
   20530:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   20534:	10800270 	cmpltui	r2,r2,9
   20538:	802d883a 	mov	r22,r16
   2053c:	1000011e 	bne	r2,zero,20544 <HW_SPI_Read+0x8c>
   20540:	05800204 	movi	r22,8
        AddrTmp = AddrTmp << 3;
   20544:	900490fa 	slli	r2,r18,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20548:	b4ffffcc 	andi	r19,r22,65535
        spiTxBuf[0] = ptr[1];
   2054c:	010000f4 	movhi	r4,3
   20550:	10ffffcc 	andi	r3,r2,65535
   20554:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   20558:	108000d4 	ori	r2,r2,3
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   2055c:	980d883a 	mov	r6,r19
        spiTxBuf[0] = ptr[1];
   20560:	20e13905 	stb	r3,-31516(r4)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20564:	000b883a 	mov	r5,zero
   20568:	b809883a 	mov	r4,r23
        spiTxBuf[1] = ptr[0] | HW_SPI_READ_WITH_WAIT_CMD;
   2056c:	a0800045 	stb	r2,1(r20)
        spiTxBuf[DataOffset] = 0xff;
   20570:	a5400085 	stb	r21,2(r20)
        memset(&spiTxBuf[DataOffset + 1], 0, XferLen);
   20574:	0026efc0 	call	26efc <memset>
        spiTxBuf[DataOffset + XferLen] = 0xff;
   20578:	008000f4 	movhi	r2,3
   2057c:	9885883a 	add	r2,r19,r2
   20580:	15613985 	stb	r21,-31514(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   20584:	00800134 	movhi	r2,4
   20588:	10041435 	stwio	zero,4176(r2)
													DataOffset + XferLen, 0);
   2058c:	988000c4 	addi	r2,r19,3
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   20590:	01c000f4 	movhi	r7,3
   20594:	018000f4 	movhi	r6,3
   20598:	01000134 	movhi	r4,4
   2059c:	d8000115 	stw	zero,4(sp)
   205a0:	d8800015 	stw	r2,0(sp)
   205a4:	39e13604 	addi	r7,r7,-31528
   205a8:	31a13904 	addi	r6,r6,-31516
   205ac:	000b883a 	mov	r5,zero
   205b0:	21040004 	addi	r4,r4,4096
   205b4:	00268340 	call	26834 <spi_transmit_receive>
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   205b8:	00c00044 	movi	r3,1
   205bc:	00800134 	movhi	r2,4
   205c0:	10c41435 	stwio	r3,4176(r2)
        for (i = 0; i < XferLen; i++) {
   205c4:	008000f4 	movhi	r2,3
   205c8:	10a13604 	addi	r2,r2,-31528
IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   205cc:	0007883a 	mov	r3,zero
            pBuf[i] = spiRxBuf[DataOffset + i];
   205d0:	114000c3 	ldbu	r5,3(r2)
   205d4:	88c9883a 	add	r4,r17,r3
        for (i = 0; i < XferLen; i++) {
   205d8:	18c00044 	addi	r3,r3,1
            pBuf[i] = spiRxBuf[DataOffset + i];
   205dc:	21400005 	stb	r5,0(r4)
        for (i = 0; i < XferLen; i++) {
   205e0:	193fffcc 	andi	r4,r3,65535
   205e4:	10800044 	addi	r2,r2,1
   205e8:	24fff936 	bltu	r4,r19,205d0 <HW_SPI_Read+0x118>
        Addr += XferLen;
   205ec:	b4a5883a 	add	r18,r22,r18
        pBuf += XferLen;
   205f0:	8ce3883a 	add	r17,r17,r19
        ByteLen -= XferLen;
   205f4:	85a1c83a 	sub	r16,r16,r22
   205f8:	003fc106 	br	20500 <HW_SPI_Read+0x48>

000205fc <HW_SPI_Write>:
 *
 * @param pData
 * @param Addr
 * @param ByteLen
 */
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   205fc:	defff604 	addi	sp,sp,-40
   20600:	dd400715 	stw	r21,28(sp)
   20604:	dd000615 	stw	r20,24(sp)
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
        DataOffset = 2;
#endif

        /* Set transmit data bytes */
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20608:	054000f4 	movhi	r21,3
        spiTxBuf[0] = ptr[1];
   2060c:	050000f4 	movhi	r20,3
static void HW_SPI_Write(uint8_t* pData, uint16_t Addr, uint16_t ByteLen) {
   20610:	dcc00515 	stw	r19,20(sp)
   20614:	dc800415 	stw	r18,16(sp)
   20618:	dc000215 	stw	r16,8(sp)
   2061c:	dfc00915 	stw	ra,36(sp)
   20620:	dd800815 	stw	r22,32(sp)
   20624:	dc400315 	stw	r17,12(sp)
   20628:	2025883a 	mov	r18,r4
   2062c:	2827883a 	mov	r19,r5
   20630:	3021883a 	mov	r16,r6
        spiTxBuf[0] = ptr[1];
   20634:	a5213904 	addi	r20,r20,-31516
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20638:	ad613984 	addi	r21,r21,-31514
    while (ByteLen) {
   2063c:	80bfffcc 	andi	r2,r16,65535
   20640:	10000a1e 	bne	r2,zero,2066c <HW_SPI_Write+0x70>

        Addr += XferLen;
        pData += XferLen;
        ByteLen -= XferLen;
    }
}
   20644:	dfc00917 	ldw	ra,36(sp)
   20648:	dd800817 	ldw	r22,32(sp)
   2064c:	dd400717 	ldw	r21,28(sp)
   20650:	dd000617 	ldw	r20,24(sp)
   20654:	dcc00517 	ldw	r19,20(sp)
   20658:	dc800417 	ldw	r18,16(sp)
   2065c:	dc400317 	ldw	r17,12(sp)
   20660:	dc000217 	ldw	r16,8(sp)
   20664:	dec00a04 	addi	sp,sp,40
   20668:	f800283a 	ret
        if (ByteLen > HW_SPI_MAX_DATA_FRAGMENT_SIZE) {
   2066c:	10c00268 	cmpgeui	r3,r2,9
   20670:	1800241e 	bne	r3,zero,20704 <HW_SPI_Write+0x108>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   20674:	108000e0 	cmpeqi	r2,r2,3
   20678:	1000241e 	bne	r2,zero,2070c <HW_SPI_Write+0x110>
   2067c:	8023883a 	mov	r17,r16
        AddrTmp = AddrTmp << 3;
   20680:	980490fa 	slli	r2,r19,3
        spiTxBuf[0] = ptr[1];
   20684:	010000f4 	movhi	r4,3
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20688:	8dbfffcc 	andi	r22,r17,65535
        spiTxBuf[0] = ptr[1];
   2068c:	10ffffcc 	andi	r3,r2,65535
   20690:	1806d23a 	srli	r3,r3,8
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   20694:	10800114 	ori	r2,r2,4
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   20698:	b00d883a 	mov	r6,r22
        spiTxBuf[0] = ptr[1];
   2069c:	20e13905 	stb	r3,-31516(r4)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   206a0:	900b883a 	mov	r5,r18
   206a4:	a809883a 	mov	r4,r21
        spiTxBuf[1] = ptr[0] | HW_SPI_WRITE_CMD;
   206a8:	a0800045 	stb	r2,1(r20)
        memcpy(&(spiTxBuf[DataOffset]), pData, XferLen);
   206ac:	0026ed40 	call	26ed4 <memcpy>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 0);
   206b0:	00800134 	movhi	r2,4
   206b4:	10041435 	stwio	zero,4176(r2)
		uint8_t spi_check =  spi_transmit_receive(ESC_SPI_BASE, 0,
   206b8:	88800084 	addi	r2,r17,2
   206bc:	10bfffcc 	andi	r2,r2,65535
   206c0:	01c000f4 	movhi	r7,3
   206c4:	018000f4 	movhi	r6,3
   206c8:	01000134 	movhi	r4,4
   206cc:	d8000115 	stw	zero,4(sp)
   206d0:	d8800015 	stw	r2,0(sp)
   206d4:	39e13604 	addi	r7,r7,-31528
   206d8:	31a13904 	addi	r6,r6,-31516
   206dc:	000b883a 	mov	r5,zero
   206e0:	21040004 	addi	r4,r4,4096
   206e4:	00268340 	call	26834 <spi_transmit_receive>
		IOWR_ALTERA_AVALON_PIO_DATA(ESC_SPI_CS_BASE, 1);
   206e8:	00c00044 	movi	r3,1
   206ec:	00800134 	movhi	r2,4
   206f0:	10c41435 	stwio	r3,4176(r2)
        Addr += XferLen;
   206f4:	9c67883a 	add	r19,r19,r17
        pData += XferLen;
   206f8:	95a5883a 	add	r18,r18,r22
        ByteLen -= XferLen;
   206fc:	8461c83a 	sub	r16,r16,r17
   20700:	003fce06 	br	2063c <HW_SPI_Write+0x40>
            XferLen = HW_SPI_MAX_DATA_FRAGMENT_SIZE;
   20704:	04400204 	movi	r17,8
   20708:	003fdd06 	br	20680 <HW_SPI_Write+0x84>
            XferLen = ((ByteLen == 3) ? 2 : ByteLen);
   2070c:	04400084 	movi	r17,2
   20710:	003fdb06 	br	20680 <HW_SPI_Write+0x84>

00020714 <HW_Release>:
 * @brief  This function shall be implemented if hardware resources need to be
 * release when the sample application stops.
 * @param  None
 * @retval None
 */
void HW_Release(void) {}
   20714:	f800283a 	ret

00020718 <HW_GetALEventRegister_Isr>:
 * interrupts service routines. The behaviour is equal to
 * "HW_GetALEventRegister()"
 * @param  None
 * @retval First two Bytes of ALEvent register (0x220)
 */
uint16_t HW_GetALEventRegister_Isr(void) {
   20718:	deffff04 	addi	sp,sp,-4
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscReadIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   2071c:	01800084 	movi	r6,2
   20720:	01408804 	movi	r5,544
   20724:	d1211d84 	addi	r4,gp,-31626
uint16_t HW_GetALEventRegister_Isr(void) {
   20728:	dfc00015 	stw	ra,0(sp)
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   2072c:	00204b80 	call	204b8 <HW_SPI_Read>
}
   20730:	d0a11d8b 	ldhu	r2,-31626(gp)
   20734:	dfc00017 	ldw	ra,0(sp)
   20738:	dec00104 	addi	sp,sp,4
   2073c:	f800283a 	ret

00020740 <HW_EscRead>:
void HW_EscRead(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   20740:	deffff04 	addi	sp,sp,-4
   20744:	dfc00015 	stw	ra,0(sp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
   20748:	0005303a 	rdctl	r2,status

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2074c:	00ffff84 	movi	r3,-2
   20750:	10c4703a 	and	r2,r2,r3
   20754:	1001703a 	wrctl	status,r2
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   20758:	31bfffcc 	andi	r6,r6,65535
   2075c:	297fffcc 	andi	r5,r5,65535
   20760:	00204b80 	call	204b8 <HW_SPI_Read>
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
   20764:	00800044 	movi	r2,1
   20768:	1001703a 	wrctl	status,r2
}
   2076c:	dfc00017 	ldw	ra,0(sp)
   20770:	dec00104 	addi	sp,sp,4
   20774:	f800283a 	ret

00020778 <HW_GetALEventRegister>:
uint16_t HW_GetALEventRegister(void) {
   20778:	deffff04 	addi	sp,sp,-4
   2077c:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   20780:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   20784:	00ffff84 	movi	r3,-2
   20788:	10c4703a 	and	r2,r2,r3
   2078c:	1001703a 	wrctl	status,r2
    HW_EscRead((MEM_ADDR*)EscALEvent.Byte, ESC_AL_EVENT_OFFSET, 2);
   20790:	01800084 	movi	r6,2
   20794:	01408804 	movi	r5,544
   20798:	d1211d84 	addi	r4,gp,-31626
   2079c:	00207400 	call	20740 <HW_EscRead>
  NIOS2_WRITE_STATUS (context);
   207a0:	00800044 	movi	r2,1
   207a4:	1001703a 	wrctl	status,r2
}
   207a8:	d0a11d8b 	ldhu	r2,-31626(gp)
   207ac:	dfc00017 	ldw	ra,0(sp)
   207b0:	dec00104 	addi	sp,sp,4
   207b4:	f800283a 	ret

000207b8 <HW_EscReadIsr>:
    HW_SPI_Read((uint8_t*)pData, Address, Len);
   207b8:	31bfffcc 	andi	r6,r6,65535
   207bc:	297fffcc 	andi	r5,r5,65535
   207c0:	00204b81 	jmpi	204b8 <HW_SPI_Read>

000207c4 <HW_EscWrite>:
 * @param  Address     EtherCAT ASIC address ( upper limit is 0x1FFF ) for
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWrite(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
   207c4:	deffff04 	addi	sp,sp,-4
   207c8:	dfc00015 	stw	ra,0(sp)
  NIOS2_READ_STATUS (context);
   207cc:	0005303a 	rdctl	r2,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   207d0:	00ffff84 	movi	r3,-2
   207d4:	10c4703a 	and	r2,r2,r3
   207d8:	1001703a 	wrctl	status,r2

#if AL_EVENT_ENABLED
    DISABLE_AL_EVENT_INT;
#endif
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   207dc:	31bfffcc 	andi	r6,r6,65535
   207e0:	297fffcc 	andi	r5,r5,65535
   207e4:	00205fc0 	call	205fc <HW_SPI_Write>
  NIOS2_WRITE_STATUS (context);
   207e8:	00800044 	movi	r2,1
   207ec:	1001703a 	wrctl	status,r2
#if AL_EVENT_ENABLED
    ENABLE_AL_EVENT_INT;
#endif
}
   207f0:	dfc00017 	ldw	ra,0(sp)
   207f4:	dec00104 	addi	sp,sp,4
   207f8:	f800283a 	ret

000207fc <HW_Init>:
uint8_t HW_Init(void) {
   207fc:	defffd04 	addi	sp,sp,-12
   20800:	dc000115 	stw	r16,4(sp)
   20804:	dfc00215 	stw	ra,8(sp)
        intMask = 0x93;
   20808:	040024c4 	movi	r16,147
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   2080c:	01800104 	movi	r6,4
   20810:	01408104 	movi	r5,516
   20814:	d809883a 	mov	r4,sp
        intMask = 0x93;
   20818:	dc000015 	stw	r16,0(sp)
        HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   2081c:	00207c40 	call	207c4 <HW_EscWrite>
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20820:	01800104 	movi	r6,4
   20824:	01408104 	movi	r5,516
   20828:	d809883a 	mov	r4,sp
        intMask = 0;
   2082c:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20830:	00207400 	call	20740 <HW_EscRead>
    } while (intMask != 0x93);
   20834:	d8800017 	ldw	r2,0(sp)
   20838:	108024d8 	cmpnei	r2,r2,147
   2083c:	103ff31e 	bne	r2,zero,2080c <HW_Init+0x10>
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20840:	01800104 	movi	r6,4
   20844:	01408104 	movi	r5,516
   20848:	d809883a 	mov	r4,sp
    intMask = 0x00;
   2084c:	d8000015 	stw	zero,0(sp)
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
   20850:	00207c40 	call	207c4 <HW_EscWrite>
	init_exti0_it();
   20854:	00266640 	call	26664 <init_exti0_it>
   20858:	00800044 	movi	r2,1
   2085c:	1001703a 	wrctl	status,r2
    if (bootSwitchID) {
   20860:	d0a11d0b 	ldhu	r2,-31628(gp)
   20864:	10000426 	beq	r2,zero,20878 <HW_Init+0x7c>
        HW_EscWriteWord(bootSwitchID, ESC_ALIAS_ADDRESS_OFFSET);
   20868:	01800084 	movi	r6,2
   2086c:	01400484 	movi	r5,18
   20870:	d1211d04 	addi	r4,gp,-31628
   20874:	00207c40 	call	207c4 <HW_EscWrite>
}
   20878:	0005883a 	mov	r2,zero
   2087c:	dfc00217 	ldw	ra,8(sp)
   20880:	dc000117 	ldw	r16,4(sp)
   20884:	dec00304 	addi	sp,sp,12
   20888:	f800283a 	ret

0002088c <HW_EscWriteIsr>:
 * access.
 * @param  Len         Access size in Bytes.
 * @retval None
 */
void HW_EscWriteIsr(MEM_ADDR* pData, uint16_t Address, uint16_t Len) {
    HW_SPI_Write((uint8_t*)pData, Address, Len);
   2088c:	31bfffcc 	andi	r6,r6,65535
   20890:	297fffcc 	andi	r5,r5,65535
   20894:	00205fc1 	jmpi	205fc <HW_SPI_Write>

00020898 <HW_SYNC0_IRQHandler>:
 */
void HW_SYNC0_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC0_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC0_PIN);
        Sync0_Isr();
   20898:	00211f81 	jmpi	211f8 <Sync0_Isr>

0002089c <HW_SYNC1_IRQHandler>:

void HW_SYNC1_IRQHandler(void) {
#if DC_SUPPORTED
    //if (__HAL_GPIO_EXTI_GET_FLAG(HW_SYNC1_PIN)) {
        //__HAL_GPIO_EXTI_CLEAR_FLAG(HW_SYNC1_PIN);
        Sync1_Isr();
   2089c:	00210801 	jmpi	21080 <Sync1_Isr>

000208a0 <HW_TIMETASK_IRQHandler>:
	if ((__HAL_TIM_GET_IT_SOURCE(&HW_TIMETASK_INSTANCE_H, TIM_IT_UPDATE) ==
		 SET) &&
		(__HAL_TIM_GET_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE) != 0)) {
		__HAL_TIM_CLEAR_FLAG(&HW_TIMETASK_INSTANCE_H, TIM_FLAG_UPDATE);
		*/
		ECAT_CheckTimer();
   208a0:	0020db41 	jmpi	20db4 <ECAT_CheckTimer>

000208a4 <COE_SyncTimeStamp>:
          Called from the Timer handler 
*////////////////////////////////////////////////////////////////////////////////////////
void COE_SyncTimeStamp(void)
{

    if (b32BitDc)
   208a4:	d0a13a83 	ldbu	r2,-31510(gp)
{
   208a8:	defffe04 	addi	sp,sp,-8
   208ac:	dfc00115 	stw	ra,4(sp)
    if (b32BitDc)
   208b0:	10001226 	beq	r2,zero,208fc <COE_SyncTimeStamp+0x58>
    {
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   208b4:	d0a12217 	ldw	r2,-31608(gp)


        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   208b8:	d809883a 	mov	r4,sp
   208bc:	01800104 	movi	r6,4
   208c0:	01424404 	movi	r5,2320
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
   208c4:	d8800015 	stw	r2,0(sp)
        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
   208c8:	00207400 	call	20740 <HW_EscRead>

        /*update the lower 32Bit*/
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   208cc:	d8800017 	ldw	r2,0(sp)

        if (DcTime < u32LastDc32Value)
   208d0:	d1212117 	ldw	r4,-31612(gp)
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
   208d4:	d0e12317 	ldw	r3,-31604(gp)
   208d8:	d0a12215 	stw	r2,-31608(gp)
        if (DcTime < u32LastDc32Value)
   208dc:	1100022e 	bgeu	r2,r4,208e8 <COE_SyncTimeStamp+0x44>
        {
            /*32Bit overrun*/
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
   208e0:	18c00044 	addi	r3,r3,1
   208e4:	d0e12315 	stw	r3,-31604(gp)
        }
        
        u32LastDc32Value = DcTime;
   208e8:	d0a12115 	stw	r2,-31612(gp)
        /*The DC unit supports 64Bit => update the complete object*/
        
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
    }

    u32CheckForDcOverrunCnt = 0;
   208ec:	d0212015 	stw	zero,-31616(gp)

}
   208f0:	dfc00117 	ldw	ra,4(sp)
   208f4:	dec00204 	addi	sp,sp,8
   208f8:	f800283a 	ret
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
   208fc:	01800204 	movi	r6,8
   20900:	01424404 	movi	r5,2320
   20904:	d1212204 	addi	r4,gp,-31608
   20908:	00207400 	call	20740 <HW_EscRead>
   2090c:	003ff706 	br	208ec <COE_SyncTimeStamp+0x48>

00020910 <Read0x10F8>:
{
   20910:	defffc04 	addi	sp,sp,-16
    if (index != 0x10F8)
   20914:	20bfffcc 	andi	r2,r4,65535
{
   20918:	dfc00315 	stw	ra,12(sp)
   2091c:	dc800215 	stw	r18,8(sp)
   20920:	dc400115 	stw	r17,4(sp)
   20924:	dc000015 	stw	r16,0(sp)
    if (index != 0x10F8)
   20928:	10843e18 	cmpnei	r2,r2,4344
{
   2092c:	d8c00403 	ldbu	r3,16(sp)
    if (index != 0x10F8)
   20930:	1000151e 	bne	r2,zero,20988 <Read0x10F8+0x78>
    if (bCompleteAccess)
   20934:	18c03fcc 	andi	r3,r3,255
   20938:	1800151e 	bne	r3,zero,20990 <Read0x10F8+0x80>
   2093c:	2821883a 	mov	r16,r5
    if (subindex > 0)
   20940:	29403fcc 	andi	r5,r5,255
   20944:	2800141e 	bne	r5,zero,20998 <Read0x10F8+0x88>
    if (dataSize > 8)
   20948:	30800268 	cmpgeui	r2,r6,9
   2094c:	3023883a 	mov	r17,r6
   20950:	1000131e 	bne	r2,zero,209a0 <Read0x10F8+0x90>
   20954:	3825883a 	mov	r18,r7
    COE_SyncTimeStamp();
   20958:	00208a40 	call	208a4 <COE_SyncTimeStamp>
    MEMCPY(pData, &u64Timestamp, dataSize);
   2095c:	880d883a 	mov	r6,r17
   20960:	d1612204 	addi	r5,gp,-31608
   20964:	9009883a 	mov	r4,r18
   20968:	0026ed40 	call	26ed4 <memcpy>
}
   2096c:	8005883a 	mov	r2,r16
   20970:	dfc00317 	ldw	ra,12(sp)
   20974:	dc800217 	ldw	r18,8(sp)
   20978:	dc400117 	ldw	r17,4(sp)
   2097c:	dc000017 	ldw	r16,0(sp)
   20980:	dec00404 	addi	sp,sp,16
   20984:	f800283a 	ret
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
   20988:	040002c4 	movi	r16,11
   2098c:	003ff706 	br	2096c <Read0x10F8+0x5c>
        return ABORTIDX_UNSUPPORTED_ACCESS;
   20990:	04000144 	movi	r16,5
   20994:	003ff506 	br	2096c <Read0x10F8+0x5c>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   20998:	04000444 	movi	r16,17
   2099c:	003ff306 	br	2096c <Read0x10F8+0x5c>
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
   209a0:	040003c4 	movi	r16,15
   209a4:	003ff106 	br	2096c <Read0x10F8+0x5c>

000209a8 <COE_GetObjectDictionary>:
 \brief    returns the pointer to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
OBJCONST TOBJECT OBJMEM * COE_GetObjectDictionary(void)
{
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
}
   209a8:	d0a11e17 	ldw	r2,-31624(gp)
   209ac:	f800283a 	ret

000209b0 <COE_UpdateSyncErrorStatus>:
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   209b0:	00c000f4 	movhi	r3,3
   209b4:	18e18104 	addi	r3,r3,-31228
   209b8:	18800a8b 	ldhu	r2,42(r3)
   209bc:	10000f1e 	bne	r2,zero,209fc <COE_UpdateSyncErrorStatus+0x4c>
   209c0:	008000b4 	movhi	r2,2
   209c4:	19000a0b 	ldhu	r4,40(r3)
   209c8:	109fbb0b 	ldhu	r2,32492(r2)
   209cc:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManOutPar.u8SyncError = 1;
   209d0:	18801005 	stb	r2,64(r3)
    {
        sSyncManOutPar.u8SyncError = 0;
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
   209d4:	00c000f4 	movhi	r3,3
   209d8:	18e17004 	addi	r3,r3,-31296
   209dc:	18800a8b 	ldhu	r2,42(r3)
   209e0:	1000081e 	bne	r2,zero,20a04 <COE_UpdateSyncErrorStatus+0x54>
   209e4:	008000b4 	movhi	r2,2
   209e8:	19000a0b 	ldhu	r4,40(r3)
   209ec:	109fbb0b 	ldhu	r2,32492(r2)
   209f0:	1105803a 	cmpltu	r2,r2,r4
    {
        sSyncManInPar.u8SyncError = 1;
   209f4:	18801005 	stb	r2,64(r3)
    else
    {
        sSyncManInPar.u8SyncError = 0;
    }

}
   209f8:	f800283a 	ret
   209fc:	00800044 	movi	r2,1
   20a00:	003ff306 	br	209d0 <COE_UpdateSyncErrorStatus+0x20>
   20a04:	00800044 	movi	r2,1
   20a08:	003ffa06 	br	209f4 <COE_UpdateSyncErrorStatus+0x44>

00020a0c <COE_AddObjectToDic>:

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
    if(pNewObjEntry != NULL)
   20a0c:	20002026 	beq	r4,zero,20a90 <COE_AddObjectToDic+0x84>
    {
        if(ObjDicList == NULL)
   20a10:	d0a11e17 	ldw	r2,-31624(gp)
   20a14:	1000051e 	bne	r2,zero,20a2c <COE_AddObjectToDic+0x20>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
   20a18:	d1211e15 	stw	r4,-31624(gp)
            ObjDicList->pNext = NULL;
   20a1c:	20000115 	stw	zero,4(r4)
            ObjDicList->pPrev = NULL;
   20a20:	20000015 	stw	zero,0(r4)
            return 0;
   20a24:	0005883a 	mov	r2,zero
   20a28:	f800283a 	ret
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
   20a2c:	1140020b 	ldhu	r5,8(r2)
   20a30:	20c0020b 	ldhu	r3,8(r4)
   20a34:	1940142e 	bgeu	r3,r5,20a88 <COE_AddObjectToDic+0x7c>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
   20a38:	20000015 	stw	zero,0(r4)
            pNewObjEntry->pNext = ObjDicList;
   20a3c:	20800115 	stw	r2,4(r4)
            ObjDicList->pPrev = pNewObjEntry;
   20a40:	11000015 	stw	r4,0(r2)
            ObjDicList = pNewObjEntry;
   20a44:	d1211e15 	stw	r4,-31624(gp)
            return 0;
   20a48:	003ff606 	br	20a24 <COE_AddObjectToDic+0x18>
                if(pDicEntry->Index == pNewObjEntry->Index)
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
   20a4c:	1940072e 	bgeu	r3,r5,20a6c <COE_AddObjectToDic+0x60>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20a50:	10c00017 	ldw	r3,0(r2)
                    pNewObjEntry->pNext = pDicEntry;
   20a54:	20800115 	stw	r2,4(r4)
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
   20a58:	20c00015 	stw	r3,0(r4)

                    if(pDicEntry->pPrev != NULL)
   20a5c:	18000126 	beq	r3,zero,20a64 <COE_AddObjectToDic+0x58>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
   20a60:	19000115 	stw	r4,4(r3)

                    pDicEntry->pPrev = pNewObjEntry;
   20a64:	11000015 	stw	r4,0(r2)

                    return 0;
   20a68:	003fee06 	br	20a24 <COE_AddObjectToDic+0x18>
                }
                else if(pDicEntry->pNext == NULL)
   20a6c:	11400117 	ldw	r5,4(r2)
   20a70:	2800041e 	bne	r5,zero,20a84 <COE_AddObjectToDic+0x78>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
   20a74:	11000115 	stw	r4,4(r2)
                    pNewObjEntry->pPrev = pDicEntry;
   20a78:	20800015 	stw	r2,0(r4)
                    pNewObjEntry->pNext = NULL;
   20a7c:	20000115 	stw	zero,4(r4)
                    return 0;
   20a80:	003fe806 	br	20a24 <COE_AddObjectToDic+0x18>
   20a84:	2805883a 	mov	r2,r5
                if(pDicEntry->Index == pNewObjEntry->Index)
   20a88:	1140020b 	ldhu	r5,8(r2)
   20a8c:	197fef1e 	bne	r3,r5,20a4c <COE_AddObjectToDic+0x40>
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
   20a90:	00800044 	movi	r2,1
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
}
   20a94:	f800283a 	ret

00020a98 <COE_RemoveDicEntry>:

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20a98:	d1611e17 	ldw	r5,-31624(gp)

    while(pDicEntry != NULL)
    {
        if(pDicEntry->Index == index)
   20a9c:	213fffcc 	andi	r4,r4,65535
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
   20aa0:	2805883a 	mov	r2,r5
    while(pDicEntry != NULL)
   20aa4:	1000011e 	bne	r2,zero,20aac <COE_RemoveDicEntry+0x14>
            return;
        }

        pDicEntry = pDicEntry->pNext;
    }
}
   20aa8:	f800283a 	ret
        if(pDicEntry->Index == index)
   20aac:	1180020b 	ldhu	r6,8(r2)
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20ab0:	10c00117 	ldw	r3,4(r2)
        if(pDicEntry->Index == index)
   20ab4:	31000b1e 	bne	r6,r4,20ae4 <COE_RemoveDicEntry+0x4c>
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
   20ab8:	11000017 	ldw	r4,0(r2)
            if(pPrevEntry != NULL)
   20abc:	20000126 	beq	r4,zero,20ac4 <COE_RemoveDicEntry+0x2c>
                pPrevEntry->pNext = pNextEntry;
   20ac0:	20c00115 	stw	r3,4(r4)
            if(pNextEntry != NULL)
   20ac4:	18000126 	beq	r3,zero,20acc <COE_RemoveDicEntry+0x34>
                pNextEntry->pPrev = pPrevEntry;
   20ac8:	19000015 	stw	r4,0(r3)
            pDicEntry->pPrev = NULL;
   20acc:	10000015 	stw	zero,0(r2)
            pDicEntry->pNext = NULL;
   20ad0:	10000115 	stw	zero,4(r2)
            if(pDicEntry->Index == ObjDicList->Index)
   20ad4:	2880020b 	ldhu	r2,8(r5)
   20ad8:	30bff31e 	bne	r6,r2,20aa8 <COE_RemoveDicEntry+0x10>
                ObjDicList = pNextEntry;
   20adc:	d0e11e15 	stw	r3,-31624(gp)
   20ae0:	f800283a 	ret
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
   20ae4:	1805883a 	mov	r2,r3
   20ae8:	003fee06 	br	20aa4 <COE_RemoveDicEntry+0xc>

00020aec <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
   20aec:	defffe04 	addi	sp,sp,-8
   20af0:	dc000015 	stw	r16,0(sp)
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
   20af4:	d4211e17 	ldw	r16,-31624(gp)
{
   20af8:	dfc00115 	stw	ra,4(sp)
    UINT16 Index = 0;

    while(pObjEntry != NULL)
   20afc:	8000051e 	bne	r16,zero,20b14 <COE_ClearObjDictionary+0x28>
        Index = pObjEntry->Index;
        pObjEntry = pObjEntry->pNext;

        COE_RemoveDicEntry(Index);
    }
    ObjDicList = NULL;
   20b00:	d0211e15 	stw	zero,-31624(gp)
}
   20b04:	dfc00117 	ldw	ra,4(sp)
   20b08:	dc000017 	ldw	r16,0(sp)
   20b0c:	dec00204 	addi	sp,sp,8
   20b10:	f800283a 	ret
        Index = pObjEntry->Index;
   20b14:	8100020b 	ldhu	r4,8(r16)
        pObjEntry = pObjEntry->pNext;
   20b18:	84000117 	ldw	r16,4(r16)
        COE_RemoveDicEntry(Index);
   20b1c:	213fffcc 	andi	r4,r4,65535
   20b20:	0020a980 	call	20a98 <COE_RemoveDicEntry>
   20b24:	003ff506 	br	20afc <COE_ClearObjDictionary+0x10>

00020b28 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
   20b28:	defffd04 	addi	sp,sp,-12
   20b2c:	dc400115 	stw	r17,4(sp)
   20b30:	dc000015 	stw	r16,0(sp)
   20b34:	dfc00215 	stw	ra,8(sp)
   20b38:	2021883a 	mov	r16,r4
    UINT16 result = 0;
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;

    while(pEntry->Index != 0xFFFF)
   20b3c:	047fffd4 	movui	r17,65535
   20b40:	8080020b 	ldhu	r2,8(r16)
   20b44:	1440061e 	bne	r2,r17,20b60 <AddObjectsToObjDictionary+0x38>
        }

        pEntry++;
    }

    return result;
   20b48:	0005883a 	mov	r2,zero

}
   20b4c:	dfc00217 	ldw	ra,8(sp)
   20b50:	dc400117 	ldw	r17,4(sp)
   20b54:	dc000017 	ldw	r16,0(sp)
   20b58:	dec00304 	addi	sp,sp,12
   20b5c:	f800283a 	ret
        result = COE_AddObjectToDic(pEntry);
   20b60:	8009883a 	mov	r4,r16
   20b64:	0020a0c0 	call	20a0c <COE_AddObjectToDic>
        if(result != 0)
   20b68:	10ffffcc 	andi	r3,r2,65535
   20b6c:	183ff71e 	bne	r3,zero,20b4c <AddObjectsToObjDictionary+0x24>
        pEntry++;
   20b70:	84000a04 	addi	r16,r16,40
   20b74:	003ff206 	br	20b40 <AddObjectsToObjDictionary+0x18>

00020b78 <COE_ObjDictionaryInit>:
    UINT16 result = 0;

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20b78:	010000b4 	movhi	r4,2
{
   20b7c:	deffff04 	addi	sp,sp,-4
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20b80:	211eee04 	addi	r4,r4,31672
{
   20b84:	dfc00015 	stw	ra,0(sp)
    ObjDicList = NULL;
   20b88:	d0211e15 	stw	zero,-31624(gp)
    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
   20b8c:	0020b280 	call	20b28 <AddObjectsToObjDictionary>

    if(result != 0)
   20b90:	10ffffcc 	andi	r3,r2,65535
   20b94:	1800051e 	bne	r3,zero,20bac <COE_ObjDictionaryInit+0x34>
        return result;
    }
    
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20b98:	010000b4 	movhi	r4,2
   20b9c:	211f6f04 	addi	r4,r4,32188
    }



    return result;
}
   20ba0:	dfc00017 	ldw	ra,0(sp)
   20ba4:	dec00104 	addi	sp,sp,4
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
   20ba8:	0020b281 	jmpi	20b28 <AddObjectsToObjDictionary>
}
   20bac:	dfc00017 	ldw	ra,0(sp)
   20bb0:	dec00104 	addi	sp,sp,4
   20bb4:	f800283a 	ret

00020bb8 <COE_ObjInit>:
    sSyncManOutPar.subindex0         = 32;
   20bb8:	01400804 	movi	r5,32
   20bbc:	00c000f4 	movhi	r3,3
   20bc0:	19618115 	stw	r5,-31228(r3)
    sSyncManOutPar.u32CycleTime     = 0;
   20bc4:	00c000f4 	movhi	r3,3
{
   20bc8:	defffe04 	addi	sp,sp,-8
    sSyncManOutPar.u32CycleTime     = 0;
   20bcc:	18218215 	stw	zero,-31224(r3)
    sSyncManOutPar.subindex0         = 32;
   20bd0:	008000f4 	movhi	r2,3
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20bd4:	00c000b4 	movhi	r3,2
{
   20bd8:	dfc00115 	stw	ra,4(sp)
    sSyncManOutPar.subindex0         = 32;
   20bdc:	10a18104 	addi	r2,r2,-31228
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20be0:	011007c4 	movi	r4,16415
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20be4:	18e1a804 	addi	r3,r3,-31072
    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
   20be8:	1100030d 	sth	r4,12(r2)
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20bec:	10c00415 	stw	r3,16(r2)
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   20bf0:	008000f4 	movhi	r2,3
   20bf4:	10218615 	stw	zero,-31208(r2)
    sSyncManOutPar.u16GetCycleTime = 0;
   20bf8:	008000f4 	movhi	r2,3
   20bfc:	1021880d 	sth	zero,-31200(r2)
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
   20c00:	008000f4 	movhi	r2,3
   20c04:	10218915 	stw	zero,-31196(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   20c08:	008000f4 	movhi	r2,3
   20c0c:	10218b15 	stw	zero,-31188(r2)
    sSyncManOutPar.u8SyncError = 0;
   20c10:	008000f4 	movhi	r2,3
   20c14:	10219105 	stb	zero,-31164(r2)
    sSyncManInPar.subindex0         = 32;
   20c18:	008000f4 	movhi	r2,3
   20c1c:	10a17004 	addi	r2,r2,-31296
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
   20c20:	1100030d 	sth	r4,12(r2)
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
   20c24:	10c00415 	stw	r3,16(r2)
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   20c28:	008000f4 	movhi	r2,3
   20c2c:	10217515 	stw	zero,-31276(r2)
    sSyncManInPar.u16GetCycleTime = 0;
   20c30:	008000f4 	movhi	r2,3
   20c34:	1021770d 	sth	zero,-31268(r2)
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20c38:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20c3c:	018000f4 	movhi	r6,3
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
   20c40:	10217815 	stw	zero,-31264(r2)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20c44:	008000f4 	movhi	r2,3
    sSyncManInPar.subindex0         = 32;
   20c48:	31617015 	stw	r5,-31296(r6)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   20c4c:	10217a15 	stw	zero,-31256(r2)
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20c50:	014000f4 	movhi	r5,3
    sSyncManInPar.u8SyncError = 0;
   20c54:	008000f4 	movhi	r2,3
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
   20c58:	28217115 	stw	zero,-31292(r5)
    sSyncManInPar.u8SyncError = 0;
   20c5c:	10218005 	stb	zero,-31232(r2)
    bSyncSetByUser = FALSE;
   20c60:	d0214c85 	stb	zero,-31438(gp)
    UINT16 result = COE_ObjDictionaryInit();
   20c64:	0020b780 	call	20b78 <COE_ObjDictionaryInit>
    if(result != 0)
   20c68:	10bfffcc 	andi	r2,r2,65535
   20c6c:	10000126 	beq	r2,zero,20c74 <COE_ObjInit+0xbc>
        COE_ClearObjDictionary();
   20c70:	0020aec0 	call	20aec <COE_ClearObjDictionary>
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20c74:	01800104 	movi	r6,4
   20c78:	01400204 	movi	r5,8
   20c7c:	d809883a 	mov	r4,sp
    u8PendingSdo = 0;
   20c80:	d0215b05 	stb	zero,-31380(gp)
    bStoreCompleteAccess = FALSE;
   20c84:	d0215ac5 	stb	zero,-31381(gp)
    u16StoreIndex   =   0;
   20c88:	d0215a0d 	sth	zero,-31384(gp)
    u8StoreSubindex = 0;
   20c8c:	d0215a85 	stb	zero,-31382(gp)
    u32StoreDataSize = 0;
   20c90:	d0215915 	stw	zero,-31388(gp)
    pStoreData = NULL;
   20c94:	d0215815 	stw	zero,-31392(gp)
    pSdoPendFunc    = NULL;
   20c98:	d0215715 	stw	zero,-31396(gp)
    pSdoSegData = NULL;
   20c9c:	d0215615 	stw	zero,-31400(gp)
        UINT32 EscFeature = 0;
   20ca0:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
   20ca4:	00207400 	call	20740 <HW_EscRead>
        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
   20ca8:	d8800017 	ldw	r2,0(sp)
   20cac:	1080020c 	andi	r2,r2,8
   20cb0:	10000626 	beq	r2,zero,20ccc <COE_ObjInit+0x114>
            b32BitDc = FALSE;
   20cb4:	d0213a85 	stb	zero,-31510(gp)
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20cb8:	0083e804 	movi	r2,4000
   20cbc:	d0a12015 	stw	r2,-31616(gp)
}
   20cc0:	dfc00117 	ldw	ra,4(sp)
   20cc4:	dec00204 	addi	sp,sp,8
   20cc8:	f800283a 	ret
            b32BitDc = TRUE;
   20ccc:	00800044 	movi	r2,1
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20cd0:	01800104 	movi	r6,4
   20cd4:	01424404 	movi	r5,2320
   20cd8:	d1212104 	addi	r4,gp,-31612
            b32BitDc = TRUE;
   20cdc:	d0a13a85 	stb	r2,-31510(gp)
            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
   20ce0:	00207400 	call	20740 <HW_EscRead>
   20ce4:	003ff406 	br	20cb8 <COE_ObjInit+0x100>

00020ce8 <COE_Main>:

void COE_Main(void)
{
     UINT8 abort = 0;
     
    if(pSdoPendFunc != NULL)
   20ce8:	d0a15717 	ldw	r2,-31396(gp)
   20cec:	10003026 	beq	r2,zero,20db0 <COE_Main+0xc8>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20cf0:	d0e15ac3 	ldbu	r3,-31381(gp)
   20cf4:	d1e15817 	ldw	r7,-31392(gp)
   20cf8:	d1a15917 	ldw	r6,-31388(gp)
   20cfc:	d1615a83 	ldbu	r5,-31382(gp)
   20d00:	d1215a0b 	ldhu	r4,-31384(gp)
{
   20d04:	defffd04 	addi	sp,sp,-12
   20d08:	dc000115 	stw	r16,4(sp)
   20d0c:	dfc00215 	stw	ra,8(sp)
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
   20d10:	d8c00015 	stw	r3,0(sp)
   20d14:	103ee83a 	callr	r2

        if(abort != ABORTIDX_WORKING)
   20d18:	14003fcc 	andi	r16,r2,255
   20d1c:	80803fe0 	cmpeqi	r2,r16,255
   20d20:	10000f1e 	bne	r2,zero,20d60 <COE_Main+0x78>
        {
            switch(u8PendingSdo)
   20d24:	d0e15b03 	ldbu	r3,-31380(gp)
   20d28:	18803fcc 	andi	r2,r3,255
   20d2c:	110000a0 	cmpeqi	r4,r2,2
   20d30:	2000161e 	bne	r4,zero,20d8c <COE_Main+0xa4>
   20d34:	110000e8 	cmpgeui	r4,r2,3
   20d38:	20000d1e 	bne	r4,zero,20d70 <COE_Main+0x88>
   20d3c:	10800060 	cmpeqi	r2,r2,1
   20d40:	1000161e 	bne	r2,zero,20d9c <COE_Main+0xb4>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
                    break;

            }

            u8PendingSdo = 0;
   20d44:	d0215b05 	stb	zero,-31380(gp)
            u16StoreIndex = 0;
   20d48:	d0215a0d 	sth	zero,-31384(gp)
            u8StoreSubindex = 0;
   20d4c:	d0215a85 	stb	zero,-31382(gp)
            u32StoreDataSize = 0;
   20d50:	d0215915 	stw	zero,-31388(gp)
            pStoreData = NULL;
   20d54:	d0215815 	stw	zero,-31392(gp)
            bStoreCompleteAccess = 0;
   20d58:	d0215ac5 	stb	zero,-31381(gp)
            pSdoPendFunc = NULL;
   20d5c:	d0215715 	stw	zero,-31396(gp)
        }
    }
}
   20d60:	dfc00217 	ldw	ra,8(sp)
   20d64:	dc000117 	ldw	r16,4(sp)
   20d68:	dec00304 	addi	sp,sp,12
   20d6c:	f800283a 	ret
            switch(u8PendingSdo)
   20d70:	18ffff44 	addi	r3,r3,-3
   20d74:	18c03fcc 	andi	r3,r3,255
   20d78:	18c000a8 	cmpgeui	r3,r3,2
   20d7c:	183ff11e 	bne	r3,zero,20d44 <COE_Main+0x5c>
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20d80:	d1a15817 	ldw	r6,-31392(gp)
   20d84:	d1615917 	ldw	r5,-31388(gp)
   20d88:	00000606 	br	20da4 <COE_Main+0xbc>
                    if(pSdoSegData)
   20d8c:	d1215617 	ldw	r4,-31400(gp)
   20d90:	20000226 	beq	r4,zero,20d9c <COE_Main+0xb4>
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
   20d94:	0026bdc0 	call	26bdc <free>
                        pSdoSegData = NULL;
   20d98:	d0215615 	stw	zero,-31400(gp)
                    SDOS_SdoRes(abort, 0, NULL);
   20d9c:	000d883a 	mov	r6,zero
   20da0:	000b883a 	mov	r5,zero
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
   20da4:	8009883a 	mov	r4,r16
   20da8:	00260e00 	call	260e0 <SDOS_SdoRes>
                    break;
   20dac:	003fe506 	br	20d44 <COE_Main+0x5c>
   20db0:	f800283a 	ret

00020db4 <ECAT_CheckTimer>:

void ECAT_CheckTimer(void)
{

    /*decrement the state transition timeout counter*/
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20db4:	d0a13883 	ldbu	r2,-31518(gp)
{
   20db8:	deffff04 	addi	sp,sp,-4
   20dbc:	dfc00015 	stw	ra,0(sp)
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
   20dc0:	10000726 	beq	r2,zero,20de0 <ECAT_CheckTimer+0x2c>
   20dc4:	d0a1410b 	ldhu	r2,-31484(gp)
   20dc8:	10ffffcc 	andi	r3,r2,65535
   20dcc:	18e0001c 	xori	r3,r3,32768
   20dd0:	18e00004 	addi	r3,r3,-32768
   20dd4:	00c0020e 	bge	zero,r3,20de0 <ECAT_CheckTimer+0x2c>
    {
        EsmTimeoutCounter--;
   20dd8:	10bfffc4 	addi	r2,r2,-1
   20ddc:	d0a1410d 	sth	r2,-31484(gp)
    }



    DC_CheckWatchdog();
   20de0:	00231e00 	call	231e0 <DC_CheckWatchdog>



/*ECATCHANGE_START(V5.13) */
    /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
   20de4:	d0a13a83 	ldbu	r2,-31510(gp)
   20de8:	10000426 	beq	r2,zero,20dfc <ECAT_CheckTimer+0x48>
   20dec:	d0e12217 	ldw	r3,-31608(gp)
   20df0:	00bff8b4 	movhi	r2,65506
   20df4:	10bed004 	addi	r2,r2,-1216
   20df8:	10c00f36 	bltu	r2,r3,20e38 <ECAT_CheckTimer+0x84>
/*ECATCHANGE_END(V5.13) */
    {

        /* the timestamp is stored in ns */
        u64Timestamp = u64Timestamp + 1000000;
   20dfc:	d0a12217 	ldw	r2,-31608(gp)
   20e00:	00c003f4 	movhi	r3,15
   20e04:	d1212317 	ldw	r4,-31604(gp)
   20e08:	18d09004 	addi	r3,r3,16960
   20e0c:	10c7883a 	add	r3,r2,r3
   20e10:	1885803a 	cmpltu	r2,r3,r2
   20e14:	1105883a 	add	r2,r2,r4
   20e18:	d0e12215 	stw	r3,-31608(gp)
   20e1c:	d0a12315 	stw	r2,-31604(gp)
    {
        /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
    }

    u32CheckForDcOverrunCnt++;
   20e20:	d0a12017 	ldw	r2,-31616(gp)
   20e24:	10800044 	addi	r2,r2,1
   20e28:	d0a12015 	stw	r2,-31616(gp)


}
   20e2c:	dfc00017 	ldw	ra,0(sp)
   20e30:	dec00104 	addi	sp,sp,4
   20e34:	f800283a 	ret
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
   20e38:	0083e804 	movi	r2,4000
   20e3c:	d0a12015 	stw	r2,-31616(gp)
   20e40:	003ff706 	br	20e20 <ECAT_CheckTimer+0x6c>

00020e44 <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
   20e44:	defffd04 	addi	sp,sp,-12
   20e48:	dc000115 	stw	r16,4(sp)
   UINT32 u32CurValue = 0;
   UINT32 u32Delta = 0;

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e4c:	01800104 	movi	r6,4
{
   20e50:	2021883a 	mov	r16,r4
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e54:	01424404 	movi	r5,2320
   20e58:	d809883a 	mov	r4,sp
{
   20e5c:	dfc00215 	stw	ra,8(sp)
   UINT32 u32CurValue = 0;
   20e60:	d8000015 	stw	zero,0(sp)
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
   20e64:	00207b80 	call	207b8 <HW_EscReadIsr>

   if (u32CurValue > 0)
   20e68:	d8800017 	ldw	r2,0(sp)
   20e6c:	10000626 	beq	r2,zero,20e88 <GetSystemTimeDelay+0x44>
   {
      if (u32StartTime <= u32CurValue)
   20e70:	14000936 	bltu	r2,r16,20e98 <GetSystemTimeDelay+0x54>
      {
         u32Delta = u32CurValue - u32StartTime;
   20e74:	1405c83a 	sub	r2,r2,r16
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
      }
   }// current value successfully read out

   if (u32StartTime > 0)
   20e78:	80000326 	beq	r16,zero,20e88 <GetSystemTimeDelay+0x44>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
   20e7c:	d0e12817 	ldw	r3,-31584(gp)
   20e80:	1880082e 	bgeu	r3,r2,20ea4 <GetSystemTimeDelay+0x60>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
   20e84:	10c5c83a 	sub	r2,r2,r3
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
       }
   }
   return u32Delta;
}
   20e88:	dfc00217 	ldw	ra,8(sp)
   20e8c:	dc000117 	ldw	r16,4(sp)
   20e90:	dec00304 	addi	sp,sp,12
   20e94:	f800283a 	ret
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
   20e98:	10bfffc4 	addi	r2,r2,-1
   20e9c:	1405c83a 	sub	r2,r2,r16
   if (u32StartTime > 0)
   20ea0:	003ff606 	br	20e7c <GetSystemTimeDelay+0x38>
   UINT32 u32Delta = 0;
   20ea4:	0005883a 	mov	r2,zero
   return u32Delta;
   20ea8:	003ff706 	br	20e88 <GetSystemTimeDelay+0x44>

00020eac <PDO_InputMapping>:
{
   20eac:	defffc04 	addi	sp,sp,-16
   20eb0:	dc800215 	stw	r18,8(sp)
   20eb4:	dc000015 	stw	r16,0(sp)
    if (MEASUREMENT_ACTIVE)
   20eb8:	048000f4 	movhi	r18,3
   20ebc:	040000f4 	movhi	r16,3
{
   20ec0:	dfc00315 	stw	ra,12(sp)
   20ec4:	dc400115 	stw	r17,4(sp)
    if (MEASUREMENT_ACTIVE)
   20ec8:	94a18104 	addi	r18,r18,-31228
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
   20ecc:	00207180 	call	20718 <HW_GetALEventRegister_Isr>
    if (MEASUREMENT_ACTIVE)
   20ed0:	84217004 	addi	r16,r16,-31296
   20ed4:	9080070b 	ldhu	r2,28(r18)
   20ed8:	80c0070b 	ldhu	r3,28(r16)
   20edc:	10c4b03a 	or	r2,r2,r3
   20ee0:	1080004c 	andi	r2,r2,1
   20ee4:	10001b26 	beq	r2,zero,20f54 <PDO_InputMapping+0xa8>
        u32TimeValue = GetSystemTimeDelay(0);
   20ee8:	0009883a 	mov	r4,zero
   20eec:	0020e440 	call	20e44 <GetSystemTimeDelay>
   20ef0:	1023883a 	mov	r17,r2
    APPL_InputMapping((UINT16*)aPdInputData);
   20ef4:	010000f4 	movhi	r4,3
   20ef8:	21213c04 	addi	r4,r4,-31504
   20efc:	00203d80 	call	203d8 <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
   20f00:	d1a1378b 	ldhu	r6,-31522(gp)
   20f04:	d161340b 	ldhu	r5,-31536(gp)
   20f08:	010000f4 	movhi	r4,3
   20f0c:	21213c04 	addi	r4,r4,-31504
   20f10:	002088c0 	call	2088c <HW_EscWriteIsr>
    if (MEASUREMENT_ACTIVE)
   20f14:	90c0070b 	ldhu	r3,28(r18)
   20f18:	8080070b 	ldhu	r2,28(r16)
   20f1c:	1886b03a 	or	r3,r3,r2
   20f20:	18c0004c 	andi	r3,r3,1
   20f24:	18000526 	beq	r3,zero,20f3c <PDO_InputMapping+0x90>
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   20f28:	8809883a 	mov	r4,r17
   20f2c:	0020e440 	call	20e44 <GetSystemTimeDelay>
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
   20f30:	80c00517 	ldw	r3,20(r16)
   20f34:	1880012e 	bgeu	r3,r2,20f3c <PDO_InputMapping+0x90>
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
   20f38:	80800515 	stw	r2,20(r16)
}
   20f3c:	dfc00317 	ldw	ra,12(sp)
   20f40:	dc800217 	ldw	r18,8(sp)
   20f44:	dc400117 	ldw	r17,4(sp)
   20f48:	dc000017 	ldw	r16,0(sp)
   20f4c:	dec00404 	addi	sp,sp,16
   20f50:	f800283a 	ret
    UINT32 u32TimeValue = 0;
   20f54:	0023883a 	mov	r17,zero
   20f58:	003fe606 	br	20ef4 <PDO_InputMapping+0x48>

00020f5c <HandleCycleTimeMeasurement>:
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
   20f5c:	d0a14183 	ldbu	r2,-31482(gp)
   20f60:	1000181e 	bne	r2,zero,20fc4 <HandleCycleTimeMeasurement+0x68>
        if (u32CycleTimeStartValue > 0)
   20f64:	d1212a17 	ldw	r4,-31576(gp)
{
   20f68:	deffff04 	addi	sp,sp,-4
   20f6c:	dfc00015 	stw	ra,0(sp)
        if (u32CycleTimeStartValue > 0)
   20f70:	20000e26 	beq	r4,zero,20fac <HandleCycleTimeMeasurement+0x50>
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20f74:	0020e440 	call	20e44 <GetSystemTimeDelay>
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20f78:	00c000f4 	movhi	r3,3
   20f7c:	18e18104 	addi	r3,r3,-31228
   20f80:	19000117 	ldw	r4,4(r3)
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
   20f84:	d0a12a15 	stw	r2,-31576(gp)
            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
   20f88:	20000126 	beq	r4,zero,20f90 <HandleCycleTimeMeasurement+0x34>
   20f8c:	1100012e 	bgeu	r2,r4,20f94 <HandleCycleTimeMeasurement+0x38>
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
   20f90:	18800115 	stw	r2,4(r3)
            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
   20f94:	00c000f4 	movhi	r3,3
   20f98:	18e17004 	addi	r3,r3,-31296
   20f9c:	19000117 	ldw	r4,4(r3)
   20fa0:	20000126 	beq	r4,zero,20fa8 <HandleCycleTimeMeasurement+0x4c>
   20fa4:	1100012e 	bgeu	r2,r4,20fac <HandleCycleTimeMeasurement+0x50>
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
   20fa8:	18800115 	stw	r2,4(r3)
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
   20fac:	0009883a 	mov	r4,zero
   20fb0:	0020e440 	call	20e44 <GetSystemTimeDelay>
   20fb4:	d0a12a15 	stw	r2,-31576(gp)
}
   20fb8:	dfc00017 	ldw	ra,0(sp)
   20fbc:	dec00104 	addi	sp,sp,4
   20fc0:	f800283a 	ret
   20fc4:	f800283a 	ret

00020fc8 <PDO_OutputMapping>:
{
   20fc8:	defffc04 	addi	sp,sp,-16
   20fcc:	dc800215 	stw	r18,8(sp)
   20fd0:	dc000015 	stw	r16,0(sp)
   if (MEASUREMENT_ACTIVE)
   20fd4:	048000f4 	movhi	r18,3
   20fd8:	040000f4 	movhi	r16,3
   20fdc:	84218104 	addi	r16,r16,-31228
   20fe0:	94a17004 	addi	r18,r18,-31296
   20fe4:	8080070b 	ldhu	r2,28(r16)
   20fe8:	90c0070b 	ldhu	r3,28(r18)
{
   20fec:	dfc00315 	stw	ra,12(sp)
   20ff0:	dc400115 	stw	r17,4(sp)
   if (MEASUREMENT_ACTIVE)
   20ff4:	10c4b03a 	or	r2,r2,r3
   20ff8:	1080004c 	andi	r2,r2,1
   20ffc:	10001e26 	beq	r2,zero,21078 <PDO_OutputMapping+0xb0>
      u32TimeValue = GetSystemTimeDelay(0);
   21000:	0009883a 	mov	r4,zero
   21004:	0020e440 	call	20e44 <GetSystemTimeDelay>
   21008:	1023883a 	mov	r17,r2
      u32MinCycleTimeStartValue = u32TimeValue;
   2100c:	d0a12915 	stw	r2,-31580(gp)
      bMinCycleTimeMeasurementStarted = TRUE;
   21010:	00800044 	movi	r2,1
   21014:	d0a12705 	stb	r2,-31588(gp)
      u32MinCycleTimeValue = 0;
   21018:	d0212615 	stw	zero,-31592(gp)
      HandleCycleTimeMeasurement();
   2101c:	0020f5c0 	call	20f5c <HandleCycleTimeMeasurement>
    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
   21020:	d1a1370b 	ldhu	r6,-31524(gp)
   21024:	d161348b 	ldhu	r5,-31534(gp)
   21028:	d1212484 	addi	r4,gp,-31598
   2102c:	00207b80 	call	207b8 <HW_EscReadIsr>
    APPL_OutputMapping((UINT16*) aPdOutputData);
   21030:	d1212484 	addi	r4,gp,-31598
   21034:	00204240 	call	20424 <APPL_OutputMapping>
    if (MEASUREMENT_ACTIVE)
   21038:	8080070b 	ldhu	r2,28(r16)
   2103c:	90c0070b 	ldhu	r3,28(r18)
   21040:	10c4b03a 	or	r2,r2,r3
   21044:	1080004c 	andi	r2,r2,1
   21048:	10000526 	beq	r2,zero,21060 <PDO_OutputMapping+0x98>
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
   2104c:	8809883a 	mov	r4,r17
   21050:	0020e440 	call	20e44 <GetSystemTimeDelay>
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
   21054:	80c00517 	ldw	r3,20(r16)
   21058:	1880012e 	bgeu	r3,r2,21060 <PDO_OutputMapping+0x98>
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
   2105c:	80800515 	stw	r2,20(r16)
}
   21060:	dfc00317 	ldw	ra,12(sp)
   21064:	dc800217 	ldw	r18,8(sp)
   21068:	dc400117 	ldw	r17,4(sp)
   2106c:	dc000017 	ldw	r16,0(sp)
   21070:	dec00404 	addi	sp,sp,16
   21074:	f800283a 	ret
   UINT32 u32TimeValue = 0;
   21078:	0023883a 	mov	r17,zero
   2107c:	003fe806 	br	21020 <PDO_OutputMapping+0x58>

00021080 <Sync1_Isr>:
void Sync1_Isr(void)
{
    Sync1WdCounter = 0;

    /*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21080:	d0a14243 	ldbu	r2,-31479(gp)
    Sync1WdCounter = 0;
   21084:	d0213c8d 	sth	zero,-31502(gp)
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   21088:	10800058 	cmpnei	r2,r2,1
   2108c:	10000f1e 	bne	r2,zero,210cc <Sync1_Isr+0x4c>
   21090:	d0a1378b 	ldhu	r2,-31522(gp)
   21094:	10000d26 	beq	r2,zero,210cc <Sync1_Isr+0x4c>
/*ECATCHANGE_END(V5.13) ECAT 5*/
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
   21098:	008000f4 	movhi	r2,3
   2109c:	10a1708b 	ldhu	r2,-31294(r2)
   210a0:	108000d8 	cmpnei	r2,r2,3
   210a4:	1000091e 	bne	r2,zero,210cc <Sync1_Isr+0x4c>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
   210a8:	d0a13b8b 	ldhu	r2,-31506(gp)
   210ac:	1000071e 	bne	r2,zero,210cc <Sync1_Isr+0x4c>
{
   210b0:	deffff04 	addi	sp,sp,-4
   210b4:	dfc00015 	stw	ra,0(sp)
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
   210b8:	0020eac0 	call	20eac <PDO_InputMapping>
        }

        /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
        LatchInputSync0Counter = 0;
   210bc:	d0213b0d 	sth	zero,-31508(gp)
}
   210c0:	dfc00017 	ldw	ra,0(sp)
   210c4:	dec00104 	addi	sp,sp,4
   210c8:	f800283a 	ret
        LatchInputSync0Counter = 0;
   210cc:	d0213b0d 	sth	zero,-31508(gp)
   210d0:	f800283a 	ret

000210d4 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
   210d4:	defffc04 	addi	sp,sp,-16
   210d8:	dfc00315 	stw	ra,12(sp)
   210dc:	dc000215 	stw	r16,8(sp)




    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
   210e0:	d0212d15 	stw	zero,-31564(gp)
    pAPPL_CoeWriteInd = NULL;
   210e4:	d0212c15 	stw	zero,-31568(gp)
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
   210e8:	d0212b15 	stw	zero,-31572(gp)

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
   210ec:	002355c0 	call	2355c <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
   210f0:	0020bb80 	call	20bb8 <COE_ObjInit>

    /*Reset PDI Access*/
    {
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values

    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   210f4:	01800084 	movi	r6,2
   210f8:	01414004 	movi	r5,1280
   210fc:	d9000104 	addi	r4,sp,4
    UINT16 eepromConfigControl = 0; //register (0x0500 : 0x0503) values
   21100:	d800010d 	sth	zero,4(sp)
    HW_EscReadWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21104:	00207400 	call	20740 <HW_EscRead>
    eepromConfigControl = SWAPWORD(eepromConfigControl);
   21108:	d880010b 	ldhu	r2,4(sp)

    if((eepromConfigControl & ESC_EEPROM_ASSIGN_TO_PDI_MASK) > 0)
   2110c:	10c0004c 	andi	r3,r2,1
   21110:	18000626 	beq	r3,zero,2112c <MainInit+0x58>
    {
        /*Clear access register(0x0501.1)*/
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21114:	10bfbfcc 	andi	r2,r2,65279

        eepromConfigControl = SWAPWORD(eepromConfigControl);
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21118:	01800084 	movi	r6,2
   2111c:	01414004 	movi	r5,1280
   21120:	d9000104 	addi	r4,sp,4
        eepromConfigControl &= ~ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21124:	d880010d 	sth	r2,4(sp)
        HW_EscWriteWord(eepromConfigControl,ESC_EEPROM_CONFIG_OFFSET);
   21128:	00207c40 	call	207c4 <HW_EscWrite>
    }
    }
    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
   2112c:	00800044 	movi	r2,1
   21130:	d0a12405 	stb	r2,-31600(gp)


    bMinCycleTimeMeasurementStarted = FALSE;
   21134:	d0212705 	stb	zero,-31588(gp)
    u32CycleTimeStartValue = 0;
   21138:	d0212a15 	stw	zero,-31576(gp)
    u32MinCycleTimeStartValue = 0;
   2113c:	d0212915 	stw	zero,-31580(gp)

    u32SystemTimeReadFailure = 0;
   21140:	d0212815 	stw	zero,-31584(gp)

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
   21144:	d8000015 	stw	zero,0(sp)
       UINT32 u32Cnt = 0;
       UINT32 u32Delta = 0;
   21148:	d8000115 	stw	zero,4(sp)
   2114c:	0400fa04 	movi	r16,1000

       while (u32Cnt < 1000)
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
   21150:	01800104 	movi	r6,4
   21154:	01424404 	movi	r5,2320
   21158:	d809883a 	mov	r4,sp
   2115c:	00207b80 	call	207b8 <HW_EscReadIsr>
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
   21160:	01800104 	movi	r6,4
   21164:	01424404 	movi	r5,2320
   21168:	d9000104 	addi	r4,sp,4
   2116c:	00207b80 	call	207b8 <HW_EscReadIsr>

            if (u32TimeValue <= u32Delta)
   21170:	d8800017 	ldw	r2,0(sp)
   21174:	d8c00117 	ldw	r3,4(sp)
   21178:	18800636 	bltu	r3,r2,21194 <MainInit+0xc0>
                    u32Delta = u32Delta - u32TimeValue;
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   2117c:	1885c83a 	sub	r2,r3,r2
            }


            if (u32SystemTimeReadFailure == 0)
   21180:	d0e12817 	ldw	r3,-31584(gp)
                    u32Delta = u32Delta - u32TimeValue;
   21184:	d8800115 	stw	r2,4(sp)
            if (u32SystemTimeReadFailure == 0)
   21188:	1800041e 	bne	r3,zero,2119c <MainInit+0xc8>
            {
                u32SystemTimeReadFailure = u32Delta;
            }
            else if (u32SystemTimeReadFailure > u32Delta)
            {
                u32SystemTimeReadFailure = u32Delta;
   2118c:	d0a12815 	stw	r2,-31584(gp)
   21190:	00000306 	br	211a0 <MainInit+0xcc>
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
   21194:	18ffffc4 	addi	r3,r3,-1
   21198:	003ff806 	br	2117c <MainInit+0xa8>
            else if (u32SystemTimeReadFailure > u32Delta)
   2119c:	10fffb36 	bltu	r2,r3,2118c <MainInit+0xb8>
       while (u32Cnt < 1000)
   211a0:	843fffc4 	addi	r16,r16,-1
   211a4:	803fea1e 	bne	r16,zero,21150 <MainInit+0x7c>



/*Application Init need to be called from the application layer*/
     return Error;
}
   211a8:	0005883a 	mov	r2,zero
   211ac:	dfc00317 	ldw	ra,12(sp)
   211b0:	dc000217 	ldw	r16,8(sp)
   211b4:	dec00404 	addi	sp,sp,16
   211b8:	f800283a 	ret

000211bc <ECAT_Application>:
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
   211bc:	008000f4 	movhi	r2,3
   211c0:	00c000f4 	movhi	r3,3
   211c4:	10a1880b 	ldhu	r2,-31200(r2)
   211c8:	18e1770b 	ldhu	r3,-31268(r3)
   211cc:	10c4b03a 	or	r2,r2,r3
   211d0:	1080004c 	andi	r2,r2,1
   211d4:	10000726 	beq	r2,zero,211f4 <ECAT_Application+0x38>
    {
        if (nPdOutputSize == 0)
   211d8:	d0a1370b 	ldhu	r2,-31524(gp)
   211dc:	1000051e 	bne	r2,zero,211f4 <ECAT_Application+0x38>
{
   211e0:	deffff04 	addi	sp,sp,-4
   211e4:	dfc00015 	stw	ra,0(sp)
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
   211e8:	0020f5c0 	call	20f5c <HandleCycleTimeMeasurement>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
   211ec:	dfc00017 	ldw	ra,0(sp)
   211f0:	dec00104 	addi	sp,sp,4
    APPL_Application();
   211f4:	00204701 	jmpi	20470 <APPL_Application>

000211f8 <Sync0_Isr>:
    if(bDcSyncActive)
   211f8:	d0a14183 	ldbu	r2,-31482(gp)
     Sync0WdCounter = 0;
   211fc:	d0213d8d 	sth	zero,-31498(gp)
    if(bDcSyncActive)
   21200:	10000d26 	beq	r2,zero,21238 <Sync0_Isr+0x40>
{
   21204:	defffe04 	addi	sp,sp,-8
   21208:	dc000015 	stw	r16,0(sp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   2120c:	d4214243 	ldbu	r16,-31479(gp)
{
   21210:	dfc00115 	stw	ra,4(sp)
   21214:	d0a13f8b 	ldhu	r2,-31490(gp)
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   21218:	80c03fcc 	andi	r3,r16,255
   2121c:	18c00060 	cmpeqi	r3,r3,1
   21220:	1800061e 	bne	r3,zero,2123c <Sync0_Isr+0x44>
        if(u16SmSync0Value > 0)
   21224:	1000181e 	bne	r2,zero,21288 <Sync0_Isr+0x90>
        ECAT_Application();
   21228:	00211bc0 	call	211bc <ECAT_Application>
}
   2122c:	dfc00117 	ldw	ra,4(sp)
   21230:	dc000017 	ldw	r16,0(sp)
   21234:	dec00204 	addi	sp,sp,8
    COE_UpdateSyncErrorStatus();
   21238:	00209b01 	jmpi	209b0 <COE_UpdateSyncErrorStatus>
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
   2123c:	d1213b8b 	ldhu	r4,-31506(gp)
   21240:	203ff826 	beq	r4,zero,21224 <Sync0_Isr+0x2c>
   21244:	d0e1378b 	ldhu	r3,-31522(gp)
   21248:	183ff626 	beq	r3,zero,21224 <Sync0_Isr+0x2c>
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
   2124c:	d0e13b0b 	ldhu	r3,-31508(gp)
   21250:	197fffcc 	andi	r5,r3,65535
   21254:	2900022e 	bgeu	r5,r4,21260 <Sync0_Isr+0x68>
                LatchInputSync0Counter++;
   21258:	18c00044 	addi	r3,r3,1
   2125c:	d0e13b0d 	sth	r3,-31508(gp)
            if (LatchInputSync0Value == LatchInputSync0Counter)
   21260:	d0e13b0b 	ldhu	r3,-31508(gp)
   21264:	20ffef1e 	bne	r4,r3,21224 <Sync0_Isr+0x2c>
        if(u16SmSync0Value > 0)
   21268:	1000081e 	bne	r2,zero,2128c <Sync0_Isr+0x94>
        ECAT_Application();
   2126c:	00211bc0 	call	211bc <ECAT_Application>
            PDO_InputMapping();
   21270:	0020eac0 	call	20eac <PDO_InputMapping>
            if(LatchInputSync0Value == 1)
   21274:	d0a13b8b 	ldhu	r2,-31506(gp)
   21278:	10800058 	cmpnei	r2,r2,1
   2127c:	103feb1e 	bne	r2,zero,2122c <Sync0_Isr+0x34>
                LatchInputSync0Counter = 0;
   21280:	d0213b0d 	sth	zero,-31508(gp)
   21284:	003fe906 	br	2122c <Sync0_Isr+0x34>
        BOOL bCallInputMapping = FALSE;
   21288:	0021883a 	mov	r16,zero
           if (u16SmSync0Counter > u16SmSync0Value)
   2128c:	d0e1400b 	ldhu	r3,-31488(gp)
   21290:	d121370b 	ldhu	r4,-31524(gp)
   21294:	197fffcc 	andi	r5,r3,65535
   21298:	11400a36 	bltu	r2,r5,212c4 <Sync0_Isr+0xcc>
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   2129c:	20002b1e 	bne	r4,zero,2134c <Sync0_Isr+0x154>
   212a0:	d0a1378b 	ldhu	r2,-31522(gp)
   212a4:	10002926 	beq	r2,zero,2134c <Sync0_Isr+0x154>
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
   212a8:	00207180 	call	20718 <HW_GetALEventRegister_Isr>
              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
   212ac:	1082000c 	andi	r2,r2,2048
   212b0:	10001f26 	beq	r2,zero,21330 <Sync0_Isr+0x138>
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   212b4:	008000f4 	movhi	r2,3
                 u16SmSync0Counter = 0;
   212b8:	d021400d 	sth	zero,-31488(gp)
                 sSyncManInPar.u16SmEventMissedCounter = 0;
   212bc:	10217a0d 	sth	zero,-31256(r2)
   212c0:	00001606 	br	2131c <Sync0_Isr+0x124>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   212c4:	20000c1e 	bne	r4,zero,212f8 <Sync0_Isr+0x100>
               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   212c8:	d0a1378b 	ldhu	r2,-31522(gp)
   212cc:	10001326 	beq	r2,zero,2131c <Sync0_Isr+0x124>
   212d0:	008000f4 	movhi	r2,3
   212d4:	10a17004 	addi	r2,r2,-31296
   212d8:	10c00a0b 	ldhu	r3,40(r2)
   212dc:	014000b4 	movhi	r5,2
   212e0:	295fbb0b 	ldhu	r5,32492(r5)
   212e4:	193fffcc 	andi	r4,r3,65535
   212e8:	293fef36 	bltu	r5,r4,212a8 <Sync0_Isr+0xb0>
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
   212ec:	18c000c4 	addi	r3,r3,3
   212f0:	10c00a0d 	sth	r3,40(r2)
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
   212f4:	003fec06 	br	212a8 <Sync0_Isr+0xb0>
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
   212f8:	008000f4 	movhi	r2,3
   212fc:	10a18104 	addi	r2,r2,-31228
   21300:	010000b4 	movhi	r4,2
   21304:	10c00a0b 	ldhu	r3,40(r2)
   21308:	215fbb0b 	ldhu	r5,32492(r4)
   2130c:	193fffcc 	andi	r4,r3,65535
   21310:	29000236 	bltu	r5,r4,2131c <Sync0_Isr+0x124>
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
   21314:	18c000c4 	addi	r3,r3,3
   21318:	10c00a0d 	sth	r3,40(r2)
        if (bCallInputMapping == TRUE)
   2131c:	84003fcc 	andi	r16,r16,255
   21320:	84000058 	cmpnei	r16,r16,1
        ECAT_Application();
   21324:	00211bc0 	call	211bc <ECAT_Application>
        if (bCallInputMapping == TRUE)
   21328:	803fd126 	beq	r16,zero,21270 <Sync0_Isr+0x78>
   2132c:	003fbf06 	br	2122c <Sync0_Isr+0x34>
                if (u16SmSync0Counter <= u16SmSync0Value)
   21330:	d0a1400b 	ldhu	r2,-31488(gp)
   21334:	d1213f8b 	ldhu	r4,-31490(gp)
   21338:	10ffffcc 	andi	r3,r2,65535
   2133c:	20fff736 	bltu	r4,r3,2131c <Sync0_Isr+0x124>
                    u16SmSync0Counter++;
   21340:	10800044 	addi	r2,r2,1
   21344:	d0a1400d 	sth	r2,-31488(gp)
   21348:	003ff406 	br	2131c <Sync0_Isr+0x124>
               u16SmSync0Counter++;
   2134c:	18c00044 	addi	r3,r3,1
   21350:	d0e1400d 	sth	r3,-31488(gp)
   21354:	003ff106 	br	2131c <Sync0_Isr+0x124>

00021358 <PDI_Isr>:
{
   21358:	defffb04 	addi	sp,sp,-20
   2135c:	dc000115 	stw	r16,4(sp)
   21360:	dfc00415 	stw	ra,16(sp)
   21364:	dc800315 	stw	r18,12(sp)
   21368:	dc400215 	stw	r17,8(sp)
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
   2136c:	00207180 	call	20718 <HW_GetALEventRegister_Isr>
   21370:	1021883a 	mov	r16,r2
    if (ALEvent & SYNC1_EVENT)
   21374:	8080020c 	andi	r2,r16,8
   21378:	10000b1e 	bne	r2,zero,213a8 <PDI_Isr+0x50>
    if(bEscIntEnabled)
   2137c:	d0a13a43 	ldbu	r2,-31511(gp)
   21380:	10000f1e 	bne	r2,zero,213c0 <PDI_Isr+0x68>
    if (ALEvent & SYNC0_EVENT)
   21384:	8400010c 	andi	r16,r16,4
   21388:	80004d26 	beq	r16,zero,214c0 <PDI_Isr+0x168>
        Sync0_Isr();
   2138c:	00211f80 	call	211f8 <Sync0_Isr>
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   21390:	01800104 	movi	r6,4
   21394:	01426304 	movi	r5,2444
   21398:	d809883a 	mov	r4,sp
        volatile UINT32 SyncState = 0;
   2139c:	d8000015 	stw	zero,0(sp)
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
   213a0:	00207400 	call	20740 <HW_EscRead>
   213a4:	00004606 	br	214c0 <PDI_Isr+0x168>
        Sync1_Isr();
   213a8:	00210800 	call	21080 <Sync1_Isr>
    if(bEscIntEnabled)
   213ac:	d0a13a43 	ldbu	r2,-31511(gp)
   213b0:	10004a1e 	bne	r2,zero,214dc <PDI_Isr+0x184>
    if (ALEvent & SYNC0_EVENT)
   213b4:	8400010c 	andi	r16,r16,4
   213b8:	803ff526 	beq	r16,zero,21390 <PDI_Isr+0x38>
   213bc:	003ff306 	br	2138c <PDI_Isr+0x34>
    BOOL SyncAcknowledgePending = FALSE;
   213c0:	0025883a 	mov	r18,zero
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
   213c4:	044000f4 	movhi	r17,3
   213c8:	8401000c 	andi	r16,r16,1024
   213cc:	8c618104 	addi	r17,r17,-31228
   213d0:	80001226 	beq	r16,zero,2141c <PDI_Isr+0xc4>
            if(bDcRunning && bDcSyncActive)
   213d4:	d0a14083 	ldbu	r2,-31486(gp)
   213d8:	10000326 	beq	r2,zero,213e8 <PDI_Isr+0x90>
   213dc:	d0a14183 	ldbu	r2,-31482(gp)
   213e0:	10000126 	beq	r2,zero,213e8 <PDI_Isr+0x90>
                u16SmSync0Counter = 0;
   213e4:	d021400d 	sth	zero,-31488(gp)
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
   213e8:	88800a0b 	ldhu	r2,40(r17)
   213ec:	10ffffcc 	andi	r3,r2,65535
   213f0:	18000226 	beq	r3,zero,213fc <PDI_Isr+0xa4>
                sSyncManOutPar.u16SmEventMissedCounter--;
   213f4:	10bfffc4 	addi	r2,r2,-1
   213f8:	88800a0d 	sth	r2,40(r17)
            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
   213fc:	88c00a0b 	ldhu	r3,40(r17)
   21400:	008000f4 	movhi	r2,3
   21404:	10e17a0d 	sth	r3,-31256(r2)
        bEcatFirstOutputsReceived = TRUE;
   21408:	00800044 	movi	r2,1
   2140c:	d0a14205 	stb	r2,-31480(gp)
        if ( bEcatOutputUpdateRunning )
   21410:	d0a14283 	ldbu	r2,-31478(gp)
   21414:	10003326 	beq	r2,zero,214e4 <PDI_Isr+0x18c>
            PDO_OutputMapping();
   21418:	0020fc80 	call	20fc8 <PDO_OutputMapping>
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
   2141c:	8880008b 	ldhu	r2,2(r17)
   21420:	10800058 	cmpnei	r2,r2,1
   21424:	1000011e 	bne	r2,zero,2142c <PDI_Isr+0xd4>
            ECAT_Application();
   21428:	00211bc0 	call	211bc <ECAT_Application>
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
   2142c:	d0a14243 	ldbu	r2,-31479(gp)
   21430:	10800058 	cmpnei	r2,r2,1
   21434:	1000091e 	bne	r2,zero,2145c <PDI_Isr+0x104>
   21438:	d0a1378b 	ldhu	r2,-31522(gp)
   2143c:	10000726 	beq	r2,zero,2145c <PDI_Isr+0x104>
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
   21440:	008000f4 	movhi	r2,3
   21444:	10a1708b 	ldhu	r2,-31294(r2)
   21448:	10c00060 	cmpeqi	r3,r2,1
   2144c:	1800021e 	bne	r3,zero,21458 <PDI_Isr+0x100>
   21450:	10800898 	cmpnei	r2,r2,34
   21454:	1000011e 	bne	r2,zero,2145c <PDI_Isr+0x104>
        PDO_InputMapping();
   21458:	0020eac0 	call	20eac <PDO_InputMapping>
    ALEvent = HW_GetALEventRegister_Isr();
   2145c:	00207180 	call	20718 <HW_GetALEventRegister_Isr>
   21460:	1021883a 	mov	r16,r2
    if ( ALEvent & PROCESS_OUTPUT_EVENT )
   21464:	8081000c 	andi	r2,r16,1024
   21468:	10001126 	beq	r2,zero,214b0 <PDI_Isr+0x158>
        sSyncManOutPar.u16CycleExceededCounter++;
   2146c:	88800a8b 	ldhu	r2,42(r17)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   21470:	d161348b 	ldhu	r5,-31534(gp)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21474:	00c000f4 	movhi	r3,3
        sSyncManOutPar.u16CycleExceededCounter++;
   21478:	10800044 	addi	r2,r2,1
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   2147c:	01800044 	movi	r6,1
   21480:	d12132c4 	addi	r4,gp,-31541
        sSyncManOutPar.u16CycleExceededCounter++;
   21484:	88800a8d 	sth	r2,42(r17)
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
   21488:	18a17a8d 	sth	r2,-31254(r3)
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   2148c:	00207b80 	call	207b8 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   21490:	d161348b 	ldhu	r5,-31534(gp)
   21494:	d0a1370b 	ldhu	r2,-31524(gp)
   21498:	01800044 	movi	r6,1
   2149c:	d12132c4 	addi	r4,gp,-31541
   214a0:	288b883a 	add	r5,r5,r2
   214a4:	297fffc4 	addi	r5,r5,-1
   214a8:	297fffcc 	andi	r5,r5,65535
   214ac:	00207b80 	call	207b8 <HW_EscReadIsr>
    if (ALEvent & SYNC0_EVENT)
   214b0:	8400010c 	andi	r16,r16,4
   214b4:	803fb51e 	bne	r16,zero,2138c <PDI_Isr+0x34>
    if (SyncAcknowledgePending)
   214b8:	94803fcc 	andi	r18,r18,255
   214bc:	903fb41e 	bne	r18,zero,21390 <PDI_Isr+0x38>
    COE_UpdateSyncErrorStatus();
   214c0:	00209b00 	call	209b0 <COE_UpdateSyncErrorStatus>
}
   214c4:	dfc00417 	ldw	ra,16(sp)
   214c8:	dc800317 	ldw	r18,12(sp)
   214cc:	dc400217 	ldw	r17,8(sp)
   214d0:	dc000117 	ldw	r16,4(sp)
   214d4:	dec00504 	addi	sp,sp,20
   214d8:	f800283a 	ret
        SyncAcknowledgePending = TRUE;
   214dc:	04800044 	movi	r18,1
   214e0:	003fb806 	br	213c4 <PDI_Isr+0x6c>
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
   214e4:	d161348b 	ldhu	r5,-31534(gp)
   214e8:	01800044 	movi	r6,1
   214ec:	d12132c4 	addi	r4,gp,-31541
   214f0:	00207b80 	call	207b8 <HW_EscReadIsr>
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
   214f4:	d0a1370b 	ldhu	r2,-31524(gp)
   214f8:	d161348b 	ldhu	r5,-31534(gp)
   214fc:	01800044 	movi	r6,1
   21500:	d12132c4 	addi	r4,gp,-31541
   21504:	288b883a 	add	r5,r5,r2
   21508:	297fffc4 	addi	r5,r5,-1
   2150c:	297fffcc 	andi	r5,r5,65535
   21510:	00207b80 	call	207b8 <HW_EscReadIsr>
   21514:	003fc106 	br	2141c <PDI_Isr+0xc4>

00021518 <MainLoop>:
    if(bInitFinished == FALSE)
   21518:	d0a12403 	ldbu	r2,-31600(gp)
   2151c:	10003226 	beq	r2,zero,215e8 <MainLoop+0xd0>
        if (
   21520:	d0a13a43 	ldbu	r2,-31511(gp)
{
   21524:	deffff04 	addi	sp,sp,-4
   21528:	dfc00015 	stw	ra,0(sp)
          && !bDcSyncActive                                               /* DC-Synchronous */
   2152c:	d0e14183 	ldbu	r3,-31482(gp)
        if (
   21530:	10000e1e 	bne	r2,zero,2156c <MainLoop+0x54>
          && !bDcSyncActive                                               /* DC-Synchronous */
   21534:	18c03fcc 	andi	r3,r3,255
   21538:	18001826 	beq	r3,zero,2159c <MainLoop+0x84>
        if (u32CheckForDcOverrunCnt >= CHECK_DC_OVERRUN_IN_MS)
   2153c:	d0a12017 	ldw	r2,-31616(gp)
   21540:	1083e830 	cmpltui	r2,r2,4000
   21544:	1000011e 	bne	r2,zero,2154c <MainLoop+0x34>
            COE_SyncTimeStamp();
   21548:	00208a40 	call	208a4 <COE_SyncTimeStamp>
        ECAT_Main();
   2154c:	002363c0 	call	2363c <ECAT_Main>
       COE_Main();
   21550:	0020ce80 	call	20ce8 <COE_Main>
       CheckIfEcatError();
   21554:	00232a00 	call	232a0 <CheckIfEcatError>
    if (pAPPL_MainLoop != NULL)
   21558:	d0a12b17 	ldw	r2,-31572(gp)
   2155c:	10001f26 	beq	r2,zero,215dc <MainLoop+0xc4>
}
   21560:	dfc00017 	ldw	ra,0(sp)
   21564:	dec00104 	addi	sp,sp,4
        pAPPL_MainLoop();
   21568:	1000683a 	jmp	r2
          && !bDcSyncActive                                               /* DC-Synchronous */
   2156c:	d0a14203 	ldbu	r2,-31480(gp)
   21570:	10c4b03a 	or	r2,r2,r3
   21574:	10803fcc 	andi	r2,r2,255
   21578:	103ff01e 	bne	r2,zero,2153c <MainLoop+0x24>
             ECAT_Application();
   2157c:	00211bc0 	call	211bc <ECAT_Application>
             if ( (bEcatInputUpdateRunning  == TRUE) && (nPdInputSize > 0))
   21580:	d0a14243 	ldbu	r2,-31479(gp)
   21584:	10800058 	cmpnei	r2,r2,1
   21588:	103fec1e 	bne	r2,zero,2153c <MainLoop+0x24>
   2158c:	d0a1378b 	ldhu	r2,-31522(gp)
   21590:	103fea26 	beq	r2,zero,2153c <MainLoop+0x24>
                PDO_InputMapping();
   21594:	0020eac0 	call	20eac <PDO_InputMapping>
   21598:	003fe806 	br	2153c <MainLoop+0x24>
                UINT16 ALEvent = HW_GetALEventRegister();
   2159c:	00207780 	call	20778 <HW_GetALEventRegister>
                if ( ALEvent & PROCESS_OUTPUT_EVENT )
   215a0:	10c1000c 	andi	r3,r2,1024
   215a4:	18000626 	beq	r3,zero,215c0 <MainLoop+0xa8>
                    bEcatFirstOutputsReceived = TRUE;
   215a8:	00800044 	movi	r2,1
   215ac:	d0a14205 	stb	r2,-31480(gp)
                    if ( bEcatOutputUpdateRunning )
   215b0:	d0a14283 	ldbu	r2,-31478(gp)
   215b4:	103ff126 	beq	r2,zero,2157c <MainLoop+0x64>
                        PDO_OutputMapping();
   215b8:	0020fc80 	call	20fc8 <PDO_OutputMapping>
   215bc:	003fef06 	br	2157c <MainLoop+0x64>
                else if ( nPdOutputSize == 0 )
   215c0:	d0e1370b 	ldhu	r3,-31524(gp)
   215c4:	183fed1e 	bne	r3,zero,2157c <MainLoop+0x64>
                    if ( ALEvent & PROCESS_INPUT_EVENT )
   215c8:	1082000c 	andi	r2,r2,2048
   215cc:	103feb26 	beq	r2,zero,2157c <MainLoop+0x64>
                        bEcatFirstOutputsReceived = TRUE;
   215d0:	00800044 	movi	r2,1
   215d4:	d0a14205 	stb	r2,-31480(gp)
   215d8:	003fe806 	br	2157c <MainLoop+0x64>
}
   215dc:	dfc00017 	ldw	ra,0(sp)
   215e0:	dec00104 	addi	sp,sp,4
   215e4:	f800283a 	ret
   215e8:	f800283a 	ret

000215ec <ESC_EepromAccess>:
 \brief        Controller (switch BIG_ENDIAN_FORMAT set) the data has to be swapped outside
 \brief        of this function)
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 ESC_EepromAccess(UINT32 wordaddress, UINT16 wordsize, UINT16 MBXMEM *pData, UINT8 access)
{
   215ec:	defff404 	addi	sp,sp,-48
   215f0:	dd000615 	stw	r20,24(sp)
   215f4:	dcc00515 	stw	r19,20(sp)
   215f8:	d9000015 	stw	r4,0(sp)
   215fc:	3029883a 	mov	r20,r6
    UINT8 RetryCnt = MAX_CMD_RETIRES; //Maximum number of retries (evaluated in case of an Acknowledge Error)

    UINT16 nConfig;
    VARVOLATILE UINT16 nControl;

    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21600:	d9000104 	addi	r4,sp,4
   21604:	01800084 	movi	r6,2
{
   21608:	2827883a 	mov	r19,r5
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   2160c:	01414004 	movi	r5,1280
{
   21610:	dfc00b15 	stw	ra,44(sp)
   21614:	dd800815 	stw	r22,32(sp)
   21618:	dc000215 	stw	r16,8(sp)
   2161c:	382d883a 	mov	r22,r7
   21620:	3821883a 	mov	r16,r7
   21624:	df000a15 	stw	fp,40(sp)
   21628:	ddc00915 	stw	r23,36(sp)
   2162c:	dd400715 	stw	r21,28(sp)
   21630:	dc800415 	stw	r18,16(sp)
   21634:	dc400315 	stw	r17,12(sp)
    HW_EscReadWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21638:	00207400 	call	20740 <HW_EscRead>
    HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   2163c:	01800084 	movi	r6,2
   21640:	01414084 	movi	r5,1282
   21644:	d9000184 	addi	r4,sp,6
   21648:	00207400 	call	20740 <HW_EscRead>



    if ( nConfig & ESC_EEPROM_ASSIGN_TO_PDI_MASK )
   2164c:	d880010b 	ldhu	r2,4(sp)
   21650:	1080004c 	andi	r2,r2,1
   21654:	10006926 	beq	r2,zero,217fc <ESC_EepromAccess+0x210>
    {
        /* register 0x500.0 is set (should be written by the master before sending
        the state transition request to PREOP),we have access to the EEPROM */
        UINT16 step = 1; /* we write always only 1 word with one write access */

        if ( access == ESC_RD )
   21658:	84003fcc 	andi	r16,r16,255
   2165c:	84000098 	cmpnei	r16,r16,2
   21660:	1023883a 	mov	r17,r2
   21664:	8000041e 	bne	r16,zero,21678 <ESC_EepromAccess+0x8c>
        {
            /* read access requested, we have to check if we read 2 (register 0x502.6=0)
            or 4 words (register 0x502.6=1) with one access */
            if ( nControl & ESC_EEPROM_SUPPORTED_READBYTES_MASK )
   21668:	d880018b 	ldhu	r2,6(sp)
   2166c:	1080100c 	andi	r2,r2,64
   21670:	10002126 	beq	r2,zero,216f8 <ESC_EepromAccess+0x10c>
            {
                step = 4; /* we get 4 words with one read access */
   21674:	04400104 	movi	r17,4
            }
            else
            {
                if ( access == ESC_RD )
                {
                    UINT16 u16BytesToCopy = (step << 1);
   21678:	882e907a 	slli	r23,r17,1
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   2167c:	00804004 	movi	r2,256
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21680:	01800084 	movi	r6,2
   21684:	01414004 	movi	r5,1280
   21688:	d9000104 	addi	r4,sp,4
            if ( access == ESC_RD )
   2168c:	b5803fcc 	andi	r22,r22,255
        nConfig = ESC_EEPROM_LOCKED_BY_PDI_MASK;
   21690:	d880010d 	sth	r2,4(sp)
        for (i = 0; i < wordsize;)
   21694:	0025883a 	mov	r18,zero
        HW_EscWriteWord(nConfig,ESC_EEPROM_CONFIG_OFFSET);
   21698:	00207c40 	call	207c4 <HW_EscWrite>
        for (i = 0; i < wordsize;)
   2169c:	9d7fffcc 	andi	r21,r19,65535
                if ( access == ESC_RD )
   216a0:	b7000098 	cmpnei	fp,r22,2
        for (i = 0; i < wordsize;)
   216a4:	943fffcc 	andi	r16,r18,65535
   216a8:	85401536 	bltu	r16,r21,21700 <ESC_EepromAccess+0x114>
    UINT16 u16RetErr = 0;
   216ac:	0021883a 	mov	r16,zero
    }

    /* clear EEPROM control register 0x500 */
    nConfig = 0;

    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   216b0:	01800084 	movi	r6,2
   216b4:	01414004 	movi	r5,1280
   216b8:	d9000104 	addi	r4,sp,4
    nConfig = 0;
   216bc:	d800010d 	sth	zero,4(sp)
    HW_EscWriteWord(nConfig, ESC_EEPROM_CONFIG_OFFSET);
   216c0:	00207c40 	call	207c4 <HW_EscWrite>
    return u16RetErr;
}
   216c4:	8005883a 	mov	r2,r16
   216c8:	dfc00b17 	ldw	ra,44(sp)
   216cc:	df000a17 	ldw	fp,40(sp)
   216d0:	ddc00917 	ldw	r23,36(sp)
   216d4:	dd800817 	ldw	r22,32(sp)
   216d8:	dd400717 	ldw	r21,28(sp)
   216dc:	dd000617 	ldw	r20,24(sp)
   216e0:	dcc00517 	ldw	r19,20(sp)
   216e4:	dc800417 	ldw	r18,16(sp)
   216e8:	dc400317 	ldw	r17,12(sp)
   216ec:	dc000217 	ldw	r16,8(sp)
   216f0:	dec00c04 	addi	sp,sp,48
   216f4:	f800283a 	ret
                step = 2; /* we get 2 words with one read access */
   216f8:	04400084 	movi	r17,2
   216fc:	003fde06 	br	21678 <ESC_EepromAccess+0x8c>
            HW_EscWrite((MEM_ADDR *) &wordaddress, ESC_EEPROM_ADDRESS_OFFSET, 4);
   21700:	01800104 	movi	r6,4
   21704:	01414104 	movi	r5,1284
   21708:	d809883a 	mov	r4,sp
   2170c:	00207c40 	call	207c4 <HW_EscWrite>
            if ( access == ESC_RD )
   21710:	b0800098 	cmpnei	r2,r22,2
   21714:	10001b1e 	bne	r2,zero,21784 <ESC_EepromAccess+0x198>
                nControl = ESC_EEPROM_CMD_READ_MASK;
   21718:	00804004 	movi	r2,256
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   2171c:	01800084 	movi	r6,2
   21720:	01414084 	movi	r5,1282
   21724:	d9000184 	addi	r4,sp,6
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   21728:	d880018d 	sth	r2,6(sp)
                HW_EscWriteWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   2172c:	00207c40 	call	207c4 <HW_EscWrite>
                HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21730:	01800084 	movi	r6,2
   21734:	01414084 	movi	r5,1282
   21738:	d9000184 	addi	r4,sp,6
   2173c:	00207400 	call	20740 <HW_EscRead>
            while ( nControl & (ESC_EEPROM_BUSY_MASK));
   21740:	d880018b 	ldhu	r2,6(sp)
   21744:	10bfffcc 	andi	r2,r2,65535
   21748:	10a0001c 	xori	r2,r2,32768
   2174c:	10a00004 	addi	r2,r2,-32768
   21750:	103ff716 	blt	r2,zero,21730 <ESC_EepromAccess+0x144>
            HW_EscReadWord(nControl, ESC_EEPROM_CONTROL_OFFSET);
   21754:	01800084 	movi	r6,2
   21758:	01414084 	movi	r5,1282
   2175c:	d9000184 	addi	r4,sp,6
   21760:	00207400 	call	20740 <HW_EscRead>
            if ( nControl & ESC_EEPROM_ERROR_MASK )
   21764:	d880018b 	ldhu	r2,6(sp)
   21768:	109e000c 	andi	r2,r2,30720
   2176c:	10000c26 	beq	r2,zero,217a0 <ESC_EepromAccess+0x1b4>
                if(!(nControl & ESC_EEPROM_ERROR_CMD_ACK) && (RetryCnt != 0))
   21770:	d880018b 	ldhu	r2,6(sp)
   21774:	1088000c 	andi	r2,r2,8192
   21778:	1000141e 	bne	r2,zero,217cc <ESC_EepromAccess+0x1e0>
                    u16RetErr =  ALSTATUSCODE_EE_ERROR;
   2177c:	04001444 	movi	r16,81
   21780:	003fcb06 	br	216b0 <ESC_EepromAccess+0xc4>
                HW_EscWriteWord(pData[i],ESC_EEPROM_DATA_OFFSET);
   21784:	8008907a 	slli	r4,r16,1
   21788:	01800084 	movi	r6,2
   2178c:	01414204 	movi	r5,1288
   21790:	a109883a 	add	r4,r20,r4
   21794:	00207c40 	call	207c4 <HW_EscWrite>
                nControl = SWAPWORD(ESC_EEPROM_CMD_WRITE_MASK);
   21798:	00808004 	movi	r2,512
   2179c:	003fdf06 	br	2171c <ESC_EepromAccess+0x130>
                if ( access == ESC_RD )
   217a0:	e0000a1e 	bne	fp,zero,217cc <ESC_EepromAccess+0x1e0>
                    if((u16WordOffset + step) > wordsize)
   217a4:	88bfffcc 	andi	r2,r17,65535
   217a8:	8085883a 	add	r2,r16,r2
   217ac:	a880100e 	bge	r21,r2,217f0 <ESC_EepromAccess+0x204>
                        u16BytesToCopy = (wordsize - u16WordOffset) << 1;
   217b0:	9c8dc83a 	sub	r6,r19,r18
   217b4:	300c907a 	slli	r6,r6,1
                    HW_EscRead((MEM_ADDR *) &pData[i], ESC_EEPROM_DATA_OFFSET, u16BytesToCopy);
   217b8:	8008907a 	slli	r4,r16,1
   217bc:	31bfffcc 	andi	r6,r6,65535
   217c0:	01414204 	movi	r5,1288
   217c4:	a109883a 	add	r4,r20,r4
   217c8:	00207400 	call	20740 <HW_EscRead>
            if(!(nControl & ESC_EEPROM_ERROR_MASK))
   217cc:	d880018b 	ldhu	r2,6(sp)
   217d0:	109e000c 	andi	r2,r2,30720
   217d4:	1000081e 	bne	r2,zero,217f8 <ESC_EepromAccess+0x20c>
                wordaddress += step;
   217d8:	d8800017 	ldw	r2,0(sp)
   217dc:	88ffffcc 	andi	r3,r17,65535
                u16WordOffset +=step;
   217e0:	9465883a 	add	r18,r18,r17
                wordaddress += step;
   217e4:	10c5883a 	add	r2,r2,r3
   217e8:	d8800015 	stw	r2,0(sp)
                i += step;
   217ec:	003fad06 	br	216a4 <ESC_EepromAccess+0xb8>
                    UINT16 u16BytesToCopy = (step << 1);
   217f0:	b80d883a 	mov	r6,r23
   217f4:	003ff006 	br	217b8 <ESC_EepromAccess+0x1cc>
                    while(i32TimeoutTicks > 0)
   217f8:	003fff06 	br	217f8 <ESC_EepromAccess+0x20c>
        u16RetErr = ALSTATUSCODE_EE_NOACCESS;
   217fc:	04001404 	movi	r16,80
   21800:	003fab06 	br	216b0 <ESC_EepromAccess+0xc4>

00021804 <ESC_EepromWriteCRC>:

 \brief        This function recalculates the EEPROM CRC and writes the updated value to EEPROM.
            After writing the ESC Config Area a device restart is required!
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 ESC_EepromWriteCRC(void)
{
   21804:	defffa04 	addi	sp,sp,-24
    UINT16 u16Return = ALSTATUSCODE_UNSPECIFIEDERROR;
    UINT16 EscCfgData[8];
    UINT16 u16Crc = 0x00FF;
   21808:	00803fc4 	movi	r2,255
    UINT16 i,j;

    
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   2180c:	01c00084 	movi	r7,2
   21810:	d9800104 	addi	r6,sp,4
   21814:	014001c4 	movi	r5,7
   21818:	0009883a 	mov	r4,zero
{
   2181c:	dfc00515 	stw	ra,20(sp)
    UINT16 u16Crc = 0x00FF;
   21820:	d880008d 	sth	r2,2(sp)
    u16Return = ESC_EepromAccess(0,7,(UINT16 *)EscCfgData,ESC_RD);
   21824:	00215ec0 	call	215ec <ESC_EepromAccess>
    if(u16Return == 0)
   21828:	10ffffcc 	andi	r3,r2,65535
   2182c:	18001c1e 	bne	r3,zero,218a0 <ESC_EepromWriteCRC+0x9c>
   21830:	d880008b 	ldhu	r2,2(sp)
    {
        UINT8 *pData = (UINT8 *)EscCfgData;

        for(i = 0; i < 14; i++ )
        {
            u16Crc ^= pData[i];
   21834:	d9000104 	addi	r4,sp,4
   21838:	20c9883a 	add	r4,r4,r3
   2183c:	21000003 	ldbu	r4,0(r4)
   21840:	01400204 	movi	r5,8
   21844:	2084f03a 	xor	r2,r4,r2

            for(j=0; j<8; j++ )
            {
                if( u16Crc & 0x80 )
   21848:	1100200c 	andi	r4,r2,128
   2184c:	20001726 	beq	r4,zero,218ac <ESC_EepromWriteCRC+0xa8>
   21850:	10bfffcc 	andi	r2,r2,65535
                {
                    u16Crc = (u16Crc<<1) ^ 0x07;
   21854:	1004907a 	slli	r2,r2,1
   21858:	108001dc 	xori	r2,r2,7
            for(j=0; j<8; j++ )
   2185c:	293fffc4 	addi	r4,r5,-1
   21860:	200b883a 	mov	r5,r4
   21864:	213fffcc 	andi	r4,r4,65535
   21868:	203ff71e 	bne	r4,zero,21848 <ESC_EepromWriteCRC+0x44>
        for(i = 0; i < 14; i++ )
   2186c:	18c00044 	addi	r3,r3,1
   21870:	19000398 	cmpnei	r4,r3,14
   21874:	203fef1e 	bne	r4,zero,21834 <ESC_EepromWriteCRC+0x30>
                }
            }
        }

        /*only low Byte shall be written*/
        u16Crc &= 0x00FF;
   21878:	10803fcc 	andi	r2,r2,255

        /*write new calculated Crc to Esc Config area*/
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   2187c:	01c00104 	movi	r7,4
   21880:	d9800084 	addi	r6,sp,2
   21884:	01400044 	movi	r5,1
   21888:	010001c4 	movi	r4,7
        u16Crc &= 0x00FF;
   2188c:	d880008d 	sth	r2,2(sp)
        u16Return = ESC_EepromAccess(7,1,&u16Crc,ESC_WR);
   21890:	00215ec0 	call	215ec <ESC_EepromAccess>
        if(u16Return == 0)
   21894:	10ffffcc 	andi	r3,r2,65535
   21898:	1800011e 	bne	r3,zero,218a0 <ESC_EepromWriteCRC+0x9c>
        {
            u16Return =  ALSTATUSCODE_WAITFORCOLDSTART;
   2189c:	00800804 	movi	r2,32
        }
    }

    return u16Return;
}
   218a0:	dfc00517 	ldw	ra,20(sp)
   218a4:	dec00604 	addi	sp,sp,24
   218a8:	f800283a 	ret
                    u16Crc <<= 1;
   218ac:	1004907a 	slli	r2,r2,1
   218b0:	003fea06 	br	2185c <ESC_EepromWriteCRC+0x58>

000218b4 <COE_Init>:
 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
    pCoeSendStored = 0;
   218b4:	d0212f15 	stw	zero,-31556(gp)
    nSdoInfoFragmentsLeft = 0;
   218b8:	d021558d 	sth	zero,-31402(gp)
}
   218bc:	f800283a 	ret

000218c0 <COE_ServiceInd>:

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
    UINT8 result = 0;

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
   218c0:	2080018b 	ldhu	r2,6(r4)
   218c4:	1004d33a 	srli	r2,r2,12
   218c8:	10c00228 	cmpgeui	r3,r2,8
   218cc:	1800081e 	bne	r3,zero,218f0 <COE_ServiceInd+0x30>
   218d0:	10c000e8 	cmpgeui	r3,r2,3
   218d4:	18000a1e 	bne	r3,zero,21900 <COE_ServiceInd+0x40>
   218d8:	10c00060 	cmpeqi	r3,r2,1
   218dc:	1800081e 	bne	r3,zero,21900 <COE_ServiceInd+0x40>
   218e0:	108000a0 	cmpeqi	r2,r2,2
   218e4:	1000051e 	bne	r2,zero,218fc <COE_ServiceInd+0x3c>
   218e8:	00800144 	movi	r2,5
   218ec:	f800283a 	ret
   218f0:	10800220 	cmpeqi	r2,r2,8
   218f4:	103ffc26 	beq	r2,zero,218e8 <COE_ServiceInd+0x28>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
        break;

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
   218f8:	00262681 	jmpi	26268 <SDOS_SdoInfoInd>
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
   218fc:	00257ec1 	jmpi	257ec <SDOS_SdoInd>
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
   21900:	00800104 	movi	r2,4
    default:
        result = MBXERR_INVALIDHEADER;
        break;
    }
    return result;
}
   21904:	f800283a 	ret

00021908 <COE_ContinueInd>:
 \brief  be put in the send mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
{
    if (pCoeSendStored)
   21908:	d1212f17 	ldw	r4,-31556(gp)
{
   2190c:	deffff04 	addi	sp,sp,-4
   21910:	dfc00015 	stw	ra,0(sp)
    if (pCoeSendStored)
   21914:	20000926 	beq	r4,zero,2193c <COE_ContinueInd+0x34>
    {
        /* send the stored CoE service which could not be sent before */
/*ECATCHANGE_START(V5.13) COE8*/
        if (MBX_MailboxSendReq(pCoeSendStored, COE_SERVICE) == 0)
   21918:	01400084 	movi	r5,2
   2191c:	0023d780 	call	23d78 <MBX_MailboxSendReq>
   21920:	10803fcc 	andi	r2,r2,255
   21924:	1000011e 	bne	r2,zero,2192c <COE_ContinueInd+0x24>
        {
            pCoeSendStored = 0;
   21928:	d0212f15 	stw	zero,-31556(gp)
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
        }
    }

    return 0;
   2192c:	0005883a 	mov	r2,zero
}
   21930:	dfc00017 	ldw	ra,0(sp)
   21934:	dec00104 	addi	sp,sp,4
   21938:	f800283a 	ret
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
   2193c:	01002004 	movi	r4,128
   21940:	0026bcc0 	call	26bcc <malloc>
   21944:	1009883a 	mov	r4,r2
        if (pMbx == NULL)
   21948:	10000726 	beq	r2,zero,21968 <COE_ContinueInd+0x60>
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
   2194c:	014000f4 	movhi	r5,3
   21950:	01800384 	movi	r6,14
   21954:	29619204 	addi	r5,r5,-31160
   21958:	0026ed40 	call	26ed4 <memcpy>
   2195c:	1009883a 	mov	r4,r2
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
   21960:	00262680 	call	26268 <SDOS_SdoInfoInd>
   21964:	003ff106 	br	2192c <COE_ContinueInd+0x24>
            return MBXERR_NOMOREMEMORY;
   21968:	008001c4 	movi	r2,7
   2196c:	003ff006 	br	21930 <COE_ContinueInd+0x28>

00021970 <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
   21970:	defffd04 	addi	sp,sp,-12
   21974:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21978:	01800084 	movi	r6,2
{
   2197c:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21980:	01408104 	movi	r5,516
   21984:	d9000084 	addi	r4,sp,2
{
   21988:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   2198c:	00207400 	call	20740 <HW_EscRead>
    
    mask &= intMask;
   21990:	d880008b 	ldhu	r2,2(sp)


    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   21994:	01800084 	movi	r6,2
   21998:	01408104 	movi	r5,516
    mask &= intMask;
   2199c:	80a0703a 	and	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219a0:	d9000084 	addi	r4,sp,2
    mask &= intMask;
   219a4:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219a8:	00207c40 	call	207c4 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   219ac:	dfc00217 	ldw	ra,8(sp)
   219b0:	dc000117 	ldw	r16,4(sp)
   219b4:	dec00304 	addi	sp,sp,12
   219b8:	f800283a 	ret

000219bc <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
   219bc:	defffd04 	addi	sp,sp,-12
   219c0:	dc000115 	stw	r16,4(sp)
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219c4:	01800084 	movi	r6,2
{
   219c8:	2021883a 	mov	r16,r4
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219cc:	01408104 	movi	r5,516
   219d0:	d9000084 	addi	r4,sp,2
{
   219d4:	dfc00215 	stw	ra,8(sp)
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219d8:	00207400 	call	20740 <HW_EscRead>
    

    mask |= intMask;
   219dc:	d880008b 	ldhu	r2,2(sp)

    DISABLE_ESC_INT();


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219e0:	01800084 	movi	r6,2
   219e4:	01408104 	movi	r5,516
    mask |= intMask;
   219e8:	80a0b03a 	or	r16,r16,r2
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219ec:	d9000084 	addi	r4,sp,2
    mask |= intMask;
   219f0:	dc00008d 	sth	r16,2(sp)
    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
   219f4:	00207c40 	call	207c4 <HW_EscWrite>
    ENABLE_ESC_INT();
}
   219f8:	dfc00217 	ldw	ra,8(sp)
   219fc:	dc000117 	ldw	r16,4(sp)
   21a00:	dec00304 	addi	sp,sp,12
   21a04:	f800283a 	ret

00021a08 <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
   21a08:	defffe04 	addi	sp,sp,-8
    UINT16 TmpVar = 0;
    //read EEPROM loaded information
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21a0c:	01800084 	movi	r6,2
   21a10:	01414084 	movi	r5,1282
   21a14:	d9000084 	addi	r4,sp,2
{
   21a18:	dfc00115 	stw	ra,4(sp)
    UINT16 TmpVar = 0;
   21a1c:	d800008d 	sth	zero,2(sp)
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
   21a20:	00207400 	call	20740 <HW_EscRead>
    TmpVar = SWAPWORD(TmpVar);


    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
   21a24:	d880008b 	ldhu	r2,2(sp)
   21a28:	1086000c 	andi	r2,r2,6144
   21a2c:	1005003a 	cmpeq	r2,r2,zero
   21a30:	d0a13005 	stb	r2,-31552(gp)
    }
    else
    {
        EepromLoaded = TRUE;
    }
}
   21a34:	dfc00117 	ldw	ra,4(sp)
   21a38:	dec00204 	addi	sp,sp,8
   21a3c:	f800283a 	ret

00021a40 <GetSyncMan>:
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a40:	21403fcc 	andi	r5,r4,255
   21a44:	29404004 	addi	r5,r5,256
   21a48:	280a90fa 	slli	r5,r5,3
{
   21a4c:	deffff04 	addi	sp,sp,-4
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a50:	01800204 	movi	r6,8
   21a54:	d1213084 	addi	r4,gp,-31550
{
   21a58:	dfc00015 	stw	ra,0(sp)
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
   21a5c:	00207400 	call	20740 <HW_EscRead>



    return &SyncManInfo;
}
   21a60:	d0a13084 	addi	r2,gp,-31550
   21a64:	dfc00017 	ldw	ra,0(sp)
   21a68:	dec00104 	addi	sp,sp,4
   21a6c:	f800283a 	ret

00021a70 <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
   21a70:	defffd04 	addi	sp,sp,-12
   21a74:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21a78:	24003fcc 	andi	r16,r4,255
   21a7c:	802090fa 	slli	r16,r16,3
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21a80:	00800044 	movi	r2,1

    HW_EscWriteByte(smStatus,Offset);
   21a84:	01800044 	movi	r6,1
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21a88:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21a8c:	843fffcc 	andi	r16,r16,65535
   21a90:	800b883a 	mov	r5,r16
   21a94:	d90000c4 	addi	r4,sp,3
{
   21a98:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
   21a9c:	d88000c5 	stb	r2,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21aa0:	00207c40 	call	207c4 <HW_EscWrite>
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadByte(smStatus, Offset);
   21aa4:	01800044 	movi	r6,1
   21aa8:	800b883a 	mov	r5,r16
   21aac:	d90000c4 	addi	r4,sp,3
   21ab0:	00207400 	call	20740 <HW_EscRead>
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
   21ab4:	d88000c3 	ldbu	r2,3(sp)
   21ab8:	1080004c 	andi	r2,r2,1
   21abc:	103ff926 	beq	r2,zero,21aa4 <DisableSyncManChannel+0x34>
}
   21ac0:	dfc00217 	ldw	ra,8(sp)
   21ac4:	dc000117 	ldw	r16,4(sp)
   21ac8:	dec00304 	addi	sp,sp,12
   21acc:	f800283a 	ret

00021ad0 <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
   21ad0:	defffd04 	addi	sp,sp,-12
   21ad4:	dc000115 	stw	r16,4(sp)
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = 0x00;
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21ad8:	24003fcc 	andi	r16,r4,255
   21adc:	802090fa 	slli	r16,r16,3

    HW_EscWriteByte(smStatus,Offset);
   21ae0:	01800044 	movi	r6,1
   21ae4:	d90000c4 	addi	r4,sp,3
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
   21ae8:	840201c4 	addi	r16,r16,2055
    HW_EscWriteByte(smStatus,Offset);
   21aec:	843fffcc 	andi	r16,r16,65535
   21af0:	800b883a 	mov	r5,r16
{
   21af4:	dfc00215 	stw	ra,8(sp)
    VARVOLATILE UINT8 smStatus = 0x00;
   21af8:	d80000c5 	stb	zero,3(sp)
    HW_EscWriteByte(smStatus,Offset);
   21afc:	00207c40 	call	207c4 <HW_EscWrite>
    
    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadByte(smStatus,Offset);
   21b00:	01800044 	movi	r6,1
   21b04:	800b883a 	mov	r5,r16
   21b08:	d90000c4 	addi	r4,sp,3
   21b0c:	00207400 	call	20740 <HW_EscRead>
    }while((smStatus & SM_SETTING_PDI_DISABLE));
   21b10:	d88000c3 	ldbu	r2,3(sp)
   21b14:	1080004c 	andi	r2,r2,1
   21b18:	103ff91e 	bne	r2,zero,21b00 <EnableSyncManChannel+0x30>
}
   21b1c:	dfc00217 	ldw	ra,8(sp)
   21b20:	dc000117 	ldw	r16,4(sp)
   21b24:	dec00304 	addi	sp,sp,12
   21b28:	f800283a 	ret

00021b2c <CheckSmSettings>:
    UINT16 SMLength = 0;
    UINT16 SMAddress = 0;


        //Check if max address defines are within the available ESC address range
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21b2c:	d0a1360b 	ldhu	r2,-31528(gp)
{
   21b30:	defffc04 	addi	sp,sp,-16
   21b34:	dfc00315 	stw	ra,12(sp)
   21b38:	dc800215 	stw	r18,8(sp)
   21b3c:	dc400115 	stw	r17,4(sp)
   21b40:	dc000015 	stw	r16,0(sp)
        if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
   21b44:	108bfff0 	cmpltui	r2,r2,12287
   21b48:	1000921e 	bne	r2,zero,21d94 <CheckSmSettings+0x268>
   21b4c:	2025883a 	mov	r18,r4
   21b50:	2023883a 	mov	r17,r4

                return ALSTATUSCODE_NOVALIDFIRMWARE;
        }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
   21b54:	0009883a 	mov	r4,zero
   21b58:	0021a400 	call	21a40 <GetSyncMan>
    SMLength = pSyncMan->Length;
    SMAddress = pSyncMan->PhysicalStartAddress;



    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b5c:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21b60:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21b64:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21b68:	2940004c 	andi	r5,r5,1
   21b6c:	2800081e 	bne	r5,zero,21b90 <CheckSmSettings+0x64>
            result = SYNCMANCHSIZE + 1;
        }

        if ( result != 0 )
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21b70:	04000584 	movi	r16,22
            pSyncMan = GetSyncMan(i);
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
        }
    }
    return result;
}
   21b74:	8005883a 	mov	r2,r16
   21b78:	dfc00317 	ldw	ra,12(sp)
   21b7c:	dc800217 	ldw	r18,8(sp)
   21b80:	dc400117 	ldw	r17,4(sp)
   21b84:	dc000017 	ldw	r16,0(sp)
   21b88:	dec00404 	addi	sp,sp,16
   21b8c:	f800283a 	ret
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
   21b90:	10800103 	ldbu	r2,4(r2)
   21b94:	1140030c 	andi	r5,r2,12
   21b98:	29400118 	cmpnei	r5,r5,4
   21b9c:	283ff41e 	bne	r5,zero,21b70 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21ba0:	1080008c 	andi	r2,r2,2
   21ba4:	103ff226 	beq	r2,zero,21b70 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21ba8:	20bff704 	addi	r2,r4,-36
   21bac:	10bfffcc 	andi	r2,r2,65535
   21bb0:	10801768 	cmpgeui	r2,r2,93
   21bb4:	103fee1e 	bne	r2,zero,21b70 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
   21bb8:	18bc0004 	addi	r2,r3,-4096
   21bbc:	10bfffcc 	andi	r2,r2,65535
   21bc0:	10880028 	cmpgeui	r2,r2,8192
   21bc4:	103fea1e 	bne	r2,zero,21b70 <CheckSmSettings+0x44>
        pSyncMan = GetSyncMan(MAILBOX_READ);
   21bc8:	01000044 	movi	r4,1
   21bcc:	0021a400 	call	21a40 <GetSyncMan>
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21bd0:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21bd4:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21bd8:	10c0000b 	ldhu	r3,0(r2)
    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
   21bdc:	2940004c 	andi	r5,r5,1
   21be0:	283fe326 	beq	r5,zero,21b70 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
   21be4:	10800103 	ldbu	r2,4(r2)
   21be8:	1140030c 	andi	r5,r2,12
   21bec:	2821883a 	mov	r16,r5
   21bf0:	283fdf1e 	bne	r5,zero,21b70 <CheckSmSettings+0x44>
    else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21bf4:	1080008c 	andi	r2,r2,2
   21bf8:	103fdd26 	beq	r2,zero,21b70 <CheckSmSettings+0x44>
    else if (SMLength < MIN_MBX_SIZE)
   21bfc:	20bff704 	addi	r2,r4,-36
   21c00:	10bfffcc 	andi	r2,r2,65535
   21c04:	10801768 	cmpgeui	r2,r2,93
   21c08:	103fd91e 	bne	r2,zero,21b70 <CheckSmSettings+0x44>
    else if (SMAddress < MIN_MBX_READ_ADDRESS)
   21c0c:	18bc0004 	addi	r2,r3,-4096
   21c10:	10bfffcc 	andi	r2,r2,65535
   21c14:	10880028 	cmpgeui	r2,r2,8192
   21c18:	103fd51e 	bne	r2,zero,21b70 <CheckSmSettings+0x44>
    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
   21c1c:	94803fcc 	andi	r18,r18,255
   21c20:	90800130 	cmpltui	r2,r18,4
   21c24:	1000421e 	bne	r2,zero,21d30 <CheckSmSettings+0x204>
        b3BufferMode = TRUE;
   21c28:	00800044 	movi	r2,1
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21c2c:	010000c4 	movi	r4,3
        b3BufferMode = TRUE;
   21c30:	d0a13a05 	stb	r2,-31512(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21c34:	0021a400 	call	21a40 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21c38:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21c3c:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21c40:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21c44:	2940004c 	andi	r5,r5,1
   21c48:	28003426 	beq	r5,zero,21d1c <CheckSmSettings+0x1f0>
   21c4c:	217fffc4 	addi	r5,r4,-1
   21c50:	297fffcc 	andi	r5,r5,65535
   21c54:	29401a28 	cmpgeui	r5,r5,104
   21c58:	28000d1e 	bne	r5,zero,21c90 <CheckSmSettings+0x164>
                if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
   21c5c:	d161378b 	ldhu	r5,-31522(gp)
   21c60:	213fffcc 	andi	r4,r4,65535
   21c64:	21400a1e 	bne	r4,r5,21c90 <CheckSmSettings+0x164>
                    if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE)
   21c68:	10800103 	ldbu	r2,4(r2)
   21c6c:	1100030c 	andi	r4,r2,12
   21c70:	2000071e 	bne	r4,zero,21c90 <CheckSmSettings+0x164>
                        if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (SMAddress <= MAX_PD_READ_ADDRESS))
   21c74:	d12135c3 	ldbu	r4,-31529(gp)
   21c78:	21000098 	cmpnei	r4,r4,2
   21c7c:	2000061e 	bne	r4,zero,21c98 <CheckSmSettings+0x16c>
   21c80:	18fc0004 	addi	r3,r3,-4096
   21c84:	18ffffcc 	andi	r3,r3,65535
   21c88:	18c80030 	cmpltui	r3,r3,8192
   21c8c:	1800051e 	bne	r3,zero,21ca4 <CheckSmSettings+0x178>
            result = ALSTATUSCODE_INVALIDSMINCFG;
   21c90:	04000784 	movi	r16,30
   21c94:	003fb706 	br	21b74 <CheckSmSettings+0x48>
                            || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
   21c98:	d121340b 	ldhu	r4,-31536(gp)
   21c9c:	18ffffcc 	andi	r3,r3,65535
   21ca0:	193ffb1e 	bne	r3,r4,21c90 <CheckSmSettings+0x164>
                                if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21ca4:	1080008c 	andi	r2,r2,2
   21ca8:	10000126 	beq	r2,zero,21cb0 <CheckSmSettings+0x184>
                                    b3BufferMode = FALSE;
   21cac:	d0213a05 	stb	zero,-31512(gp)
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21cb0:	01000084 	movi	r4,2
   21cb4:	0021a400 	call	21a40 <GetSyncMan>
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21cb8:	11400183 	ldbu	r5,6(r2)
    SMLength = pSyncMan->Length;
   21cbc:	1100008b 	ldhu	r4,2(r2)
    SMAddress = pSyncMan->PhysicalStartAddress;
   21cc0:	10c0000b 	ldhu	r3,0(r2)
    if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0)
   21cc4:	2940004c 	andi	r5,r5,1
   21cc8:	28002d26 	beq	r5,zero,21d80 <CheckSmSettings+0x254>
   21ccc:	217fffc4 	addi	r5,r4,-1
   21cd0:	297fffcc 	andi	r5,r5,65535
   21cd4:	29400128 	cmpgeui	r5,r5,4
   21cd8:	28000e1e 	bne	r5,zero,21d14 <CheckSmSettings+0x1e8>
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
   21cdc:	d161370b 	ldhu	r5,-31524(gp)
   21ce0:	213fffcc 	andi	r4,r4,65535
   21ce4:	21400b1e 	bne	r4,r5,21d14 <CheckSmSettings+0x1e8>
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
   21ce8:	10800103 	ldbu	r2,4(r2)
   21cec:	1100030c 	andi	r4,r2,12
   21cf0:	21000118 	cmpnei	r4,r4,4
   21cf4:	2000071e 	bne	r4,zero,21d14 <CheckSmSettings+0x1e8>
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
   21cf8:	d12135c3 	ldbu	r4,-31529(gp)
   21cfc:	21000098 	cmpnei	r4,r4,2
   21d00:	2000151e 	bne	r4,zero,21d58 <CheckSmSettings+0x22c>
   21d04:	18fc0004 	addi	r3,r3,-4096
   21d08:	18ffffcc 	andi	r3,r3,65535
   21d0c:	18c80030 	cmpltui	r3,r3,8192
   21d10:	1800141e 	bne	r3,zero,21d64 <CheckSmSettings+0x238>
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
   21d14:	04000744 	movi	r16,29
   21d18:	003f9606 	br	21b74 <CheckSmSettings+0x48>
        else if (SMLength != 0 || nPdInputSize != 0)
   21d1c:	d0a1378b 	ldhu	r2,-31522(gp)
   21d20:	1104b03a 	or	r2,r2,r4
   21d24:	10bfffcc 	andi	r2,r2,65535
   21d28:	103fe126 	beq	r2,zero,21cb0 <CheckSmSettings+0x184>
   21d2c:	003fd806 	br	21c90 <CheckSmSettings+0x164>
    if (result == 0 && maxChannel > PROCESS_DATA_OUT)
   21d30:	948000e0 	cmpeqi	r18,r18,3
   21d34:	903fde1e 	bne	r18,zero,21cb0 <CheckSmSettings+0x184>
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d38:	d0a13683 	ldbu	r2,-31526(gp)
   21d3c:	89003fcc 	andi	r4,r17,255
   21d40:	20bf8c2e 	bgeu	r4,r2,21b74 <CheckSmSettings+0x48>
            pSyncMan = GetSyncMan(i);
   21d44:	0021a400 	call	21a40 <GetSyncMan>
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21d48:	10800183 	ldbu	r2,6(r2)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d4c:	8c400044 	addi	r17,r17,1
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
   21d50:	d0a13285 	stb	r2,-31542(gp)
        for (i = maxChannel; i < nMaxSyncMan; i++)
   21d54:	003ff806 	br	21d38 <CheckSmSettings+0x20c>
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
   21d58:	d121348b 	ldhu	r4,-31534(gp)
   21d5c:	18ffffcc 	andi	r3,r3,65535
   21d60:	193fec1e 	bne	r3,r4,21d14 <CheckSmSettings+0x1e8>
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   21d64:	1006d1ba 	srli	r3,r2,6
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21d68:	1080008c 	andi	r2,r2,2
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
   21d6c:	18c0004c 	andi	r3,r3,1
                                bWdTrigger = TRUE;
   21d70:	d0e141c5 	stb	r3,-31481(gp)
                            if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21d74:	103ff026 	beq	r2,zero,21d38 <CheckSmSettings+0x20c>
                                b3BufferMode = FALSE;
   21d78:	d0213a05 	stb	zero,-31512(gp)
   21d7c:	003fee06 	br	21d38 <CheckSmSettings+0x20c>
        else if (SMLength != 0 || nPdOutputSize != 0)
   21d80:	d0a1370b 	ldhu	r2,-31524(gp)
   21d84:	1104b03a 	or	r2,r2,r4
   21d88:	10bfffcc 	andi	r2,r2,65535
   21d8c:	103fea26 	beq	r2,zero,21d38 <CheckSmSettings+0x20c>
   21d90:	003fe006 	br	21d14 <CheckSmSettings+0x1e8>
                return ALSTATUSCODE_NOVALIDFIRMWARE;
   21d94:	04000504 	movi	r16,20
   21d98:	003f7606 	br	21b74 <CheckSmSettings+0x48>

00021d9c <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
   21d9c:	defff104 	addi	sp,sp,-60
   21da0:	dc800715 	stw	r18,28(sp)
   21da4:	dc000515 	stw	r16,20(sp)
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21da8:	048000f4 	movhi	r18,3
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   21dac:	040000f4 	movhi	r16,3
   21db0:	84218104 	addi	r16,r16,-31228
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21db4:	94a17004 	addi	r18,r18,-31296
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21db8:	01000084 	movi	r4,2
{
   21dbc:	dd000915 	stw	r20,36(sp)
   21dc0:	dcc00815 	stw	r19,32(sp)
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21dc4:	9500030b 	ldhu	r20,12(r18)
    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
   21dc8:	84c0030b 	ldhu	r19,12(r16)
{
   21dcc:	dfc00e15 	stw	ra,56(sp)
   21dd0:	df000d15 	stw	fp,52(sp)
   21dd4:	ddc00c15 	stw	r23,48(sp)
   21dd8:	dd800b15 	stw	r22,44(sp)
   21ddc:	dd400a15 	stw	r21,40(sp)
   21de0:	dc400615 	stw	r17,24(sp)
    UINT16     wdiv = 0;
   21de4:	d800020d 	sth	zero,8(sp)
    UINT16     wd = 0;
   21de8:	d800028d 	sth	zero,10(sp)
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
   21dec:	d8000315 	stw	zero,12(sp)
    UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
   21df0:	d8000415 	stw	zero,16(sp)
    u16ALEventMask = 0;
   21df4:	d021338d 	sth	zero,-31538(gp)
    bEcatFirstOutputsReceived = FALSE;
   21df8:	d0214205 	stb	zero,-31480(gp)
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
   21dfc:	0021a400 	call	21a40 <GetSyncMan>
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   21e00:	10c0000b 	ldhu	r3,0(r2)
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e04:	10800103 	ldbu	r2,4(r2)
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
   21e08:	d0e1348d 	sth	r3,-31534(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e0c:	1080008c 	andi	r2,r2,2
   21e10:	1000491e 	bne	r2,zero,21f38 <StartInputHandler+0x19c>
    UINT16    nPdOutputBuffer = 3;
   21e14:	070000c4 	movi	fp,3
       nPdOutputBuffer = 1;
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
   21e18:	010000c4 	movi	r4,3
   21e1c:	0021a400 	call	21a40 <GetSyncMan>
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   21e20:	1440000b 	ldhu	r17,0(r2)


    /* get the number of input buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e24:	10800103 	ldbu	r2,4(r2)
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
   21e28:	d461340d 	sth	r17,-31536(gp)
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
   21e2c:	1080008c 	andi	r2,r2,2
   21e30:	1000431e 	bne	r2,zero,21f40 <StartInputHandler+0x1a4>
    UINT16    nPdInputBuffer = 3;
   21e34:	010000c4 	movi	r4,3
        nPdInputBuffer = 1;
    }
    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e38:	d5a1378b 	ldhu	r22,-31522(gp)
   21e3c:	210000cc 	andi	r4,r4,3
   21e40:	8c7fffcc 	andi	r17,r17,65535
   21e44:	b00b883a 	mov	r5,r22
   21e48:	0026ba40 	call	26ba4 <__mulsi3>
   21e4c:	d0e1490b 	ldhu	r3,-31452(gp)
   21e50:	1445883a 	add	r2,r2,r17
   21e54:	1880030e 	bge	r3,r2,21e64 <StartInputHandler+0xc8>
   21e58:	d1214a8b 	ldhu	r4,-31446(gp)
   21e5c:	20c9883a 	add	r4,r4,r3
   21e60:	8901a316 	blt	r17,r4,224f0 <StartInputHandler+0x754>
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   21e64:	d5e1498b 	ldhu	r23,-31450(gp)
   21e68:	b880030e 	bge	r23,r2,21e78 <StartInputHandler+0xdc>
   21e6c:	d0a14a0b 	ldhu	r2,-31448(gp)
   21e70:	15c5883a 	add	r2,r2,r23
   21e74:	88819e16 	blt	r17,r2,224f0 <StartInputHandler+0x754>
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e78:	d121370b 	ldhu	r4,-31524(gp)
   21e7c:	e14000cc 	andi	r5,fp,3
   21e80:	d8c00015 	stw	r3,0(sp)
   21e84:	d561348b 	ldhu	r21,-31534(gp)
   21e88:	0026ba40 	call	26ba4 <__mulsi3>
    if (
   21e8c:	d8c00017 	ldw	r3,0(sp)
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e90:	1545883a 	add	r2,r2,r21
    if (
   21e94:	1880030e 	bge	r3,r2,21ea4 <StartInputHandler+0x108>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
   21e98:	d1214a8b 	ldhu	r4,-31446(gp)
   21e9c:	20c7883a 	add	r3,r4,r3
   21ea0:	a8c19516 	blt	r21,r3,224f8 <StartInputHandler+0x75c>
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
   21ea4:	b880030e 	bge	r23,r2,21eb4 <StartInputHandler+0x118>
   21ea8:	d0e14a0b 	ldhu	r3,-31448(gp)
   21eac:	1dc7883a 	add	r3,r3,r23
   21eb0:	a8c19116 	blt	r21,r3,224f8 <StartInputHandler+0x75c>
        ||
   21eb4:	8880020e 	bge	r17,r2,21ec0 <StartInputHandler+0x124>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
   21eb8:	8da3883a 	add	r17,r17,r22
   21ebc:	ac418e16 	blt	r21,r17,224f8 <StartInputHandler+0x75c>
        --- Check configured synchronization ---
    */

    /* Get the DC Control/Activation register value*/
    /*Read register 0x981 (corresponding masks are adapted)*/
    HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
   21ec0:	01800044 	movi	r6,1
   21ec4:	01426044 	movi	r5,2433
   21ec8:	d9000184 	addi	r4,sp,6
   21ecc:	00207400 	call	20740 <HW_EscRead>

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
   21ed0:	01800104 	movi	r6,4
   21ed4:	01426804 	movi	r5,2464
   21ed8:	d9000304 	addi	r4,sp,12
   21edc:	00207400 	call	20740 <HW_EscRead>
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);

    // Cycle time for Sync1
        HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
   21ee0:	01800104 	movi	r6,4
   21ee4:	01426904 	movi	r5,2468
   21ee8:	d9000404 	addi	r4,sp,16
   21eec:	00207400 	call	20740 <HW_EscRead>
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   21ef0:	d9400183 	ldbu	r5,6(sp)
        shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
   21ef4:	dd400417 	ldw	r21,16(sp)
    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
   21ef8:	80c0008b 	ldhu	r3,2(r16)
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
   21efc:	2980024c 	andi	r6,r5,9
   21f00:	9080008b 	ldhu	r2,2(r18)
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
   21f04:	3000101e 	bne	r6,zero,21f48 <StartInputHandler+0x1ac>


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
   21f08:	d1214c83 	ldbu	r4,-31438(gp)
   21f0c:	21403fcc 	andi	r5,r4,255
   21f10:	28003f1e 	bne	r5,zero,22010 <StartInputHandler+0x274>
            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
                
                if (nPdInputSize > 0)
   21f14:	d0a1378b 	ldhu	r2,-31522(gp)
            if (nPdOutputSize > 0)
   21f18:	d161370b 	ldhu	r5,-31524(gp)
   21f1c:	10ffffcc 	andi	r3,r2,65535
   21f20:	28005826 	beq	r5,zero,22084 <StartInputHandler+0x2e8>
                if (nPdInputSize > 0)
   21f24:	1800c21e 	bne	r3,zero,22230 <StartInputHandler+0x494>
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
   21f28:	d0e13a03 	ldbu	r3,-31512(gp)
   21f2c:	1800a426 	beq	r3,zero,221c0 <StartInputHandler+0x424>
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
   21f30:	00c00044 	movi	r3,1
   21f34:	00007d06 	br	2212c <StartInputHandler+0x390>
       nPdOutputBuffer = 1;
   21f38:	07000044 	movi	fp,1
   21f3c:	003fb606 	br	21e18 <StartInputHandler+0x7c>
        nPdInputBuffer = 1;
   21f40:	01000044 	movi	r4,1
   21f44:	003fbc06 	br	21e38 <StartInputHandler+0x9c>
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
   21f48:	2900008c 	andi	r4,r5,2
   21f4c:	20004926 	beq	r4,zero,22074 <StartInputHandler+0x2d8>
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
   21f50:	9d08703a 	and	r4,r19,r20
        if(u16MinSuppSyncType != 0)
   21f54:	21bfffcc 	andi	r6,r4,65535
   21f58:	30000626 	beq	r6,zero,21f74 <StartInputHandler+0x1d8>
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
   21f5c:	2180010c 	andi	r6,r4,4
   21f60:	30004426 	beq	r6,zero,22074 <StartInputHandler+0x2d8>
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
   21f64:	2180020c 	andi	r6,r4,8
   21f68:	3000021e 	bne	r6,zero,21f74 <StartInputHandler+0x1d8>
   21f6c:	2980010c 	andi	r6,r5,4
   21f70:	3000401e 	bne	r6,zero,22074 <StartInputHandler+0x2d8>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21f74:	d9c00317 	ldw	r7,12(sp)
            curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
   21f78:	82000417 	ldw	r8,16(r16)
   21f7c:	2980018c 	andi	r6,r5,6
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21f80:	3800131e 	bne	r7,zero,21fd0 <StartInputHandler+0x234>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   21f84:	31800198 	cmpnei	r6,r6,6
   21f88:	3000011e 	bne	r6,zero,21f90 <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   21f8c:	a800171e 	bne	r21,zero,21fec <StartInputHandler+0x250>
    if(bSyncSetByUser)
   21f90:	d1214c83 	ldbu	r4,-31438(gp)
   21f94:	2000391e 	bne	r4,zero,2207c <StartInputHandler+0x2e0>
            if (nPdOutputSize > 0)
   21f98:	d0a1370b 	ldhu	r2,-31524(gp)
   21f9c:	1000701e 	bne	r2,zero,22160 <StartInputHandler+0x3c4>
   21fa0:	0009883a 	mov	r4,zero
            if (nPdInputSize > 0)
   21fa4:	d0e1378b 	ldhu	r3,-31522(gp)
   21fa8:	d0a13a03 	ldbu	r2,-31512(gp)
   21fac:	18003726 	beq	r3,zero,2208c <StartInputHandler+0x2f0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   21fb0:	2940010c 	andi	r5,r5,4
   21fb4:	2800911e 	bne	r5,zero,221fc <StartInputHandler+0x460>
    if ( !b3BufferMode )
   21fb8:	10008126 	beq	r2,zero,221c0 <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   21fbc:	00800084 	movi	r2,2

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
   21fc0:	00c00044 	movi	r3,1
   21fc4:	d0e13a45 	stb	r3,-31511(gp)
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
   21fc8:	0007883a 	mov	r3,zero
   21fcc:	00005906 	br	22134 <StartInputHandler+0x398>
            if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD_CYCLE_TIME))
   21fd0:	3a014b36 	bltu	r7,r8,22500 <StartInputHandler+0x764>
   21fd4:	0230d434 	movhi	r8,50000
   21fd8:	41c14936 	bltu	r8,r7,22500 <StartInputHandler+0x764>
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
   21fdc:	318001a0 	cmpeqi	r6,r6,6
   21fe0:	303feb26 	beq	r6,zero,21f90 <StartInputHandler+0x1f4>
            if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
   21fe4:	a83fea26 	beq	r21,zero,21f90 <StartInputHandler+0x1f4>
   21fe8:	a9ffe936 	bltu	r21,r7,21f90 <StartInputHandler+0x1f4>
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
   21fec:	2100040c 	andi	r4,r4,16
   21ff0:	20002026 	beq	r4,zero,22074 <StartInputHandler+0x2d8>
    if(bSyncSetByUser)
   21ff4:	d1214c83 	ldbu	r4,-31438(gp)
   21ff8:	2000151e 	bne	r4,zero,22050 <StartInputHandler+0x2b4>
            if (nPdOutputSize > 0)
   21ffc:	d0e1370b 	ldhu	r3,-31524(gp)
                if (nPdInputSize > 0)
   22000:	d0a1378b 	ldhu	r2,-31522(gp)
            if (nPdOutputSize > 0)
   22004:	18003c1e 	bne	r3,zero,220f8 <StartInputHandler+0x35c>
                bSubordinatedCycles = TRUE;
   22008:	01000044 	movi	r4,1
   2200c:	003fe506 	br	21fa4 <StartInputHandler+0x208>
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22010:	193fff84 	addi	r4,r3,-2
   22014:	213fffcc 	andi	r4,r4,65535
   22018:	210000b0 	cmpltui	r4,r4,2
   2201c:	2000151e 	bne	r4,zero,22074 <StartInputHandler+0x2d8>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
   22020:	113fff84 	addi	r4,r2,-2
   22024:	213fffcc 	andi	r4,r4,65535
   22028:	210000b0 	cmpltui	r4,r4,2
   2202c:	2000111e 	bne	r4,zero,22074 <StartInputHandler+0x2d8>
   22030:	3009883a 	mov	r4,r6
    if ( !b3BufferMode )
   22034:	d1a13a03 	ldbu	r6,-31512(gp)
   22038:	197fffcc 	andi	r5,r3,65535
   2203c:	3000761e 	bne	r6,zero,22218 <StartInputHandler+0x47c>
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
   22040:	28005f26 	beq	r5,zero,221c0 <StartInputHandler+0x424>
   22044:	117fffcc 	andi	r5,r2,65535
   22048:	2800381e 	bne	r5,zero,2212c <StartInputHandler+0x390>
   2204c:	00005c06 	br	221c0 <StartInputHandler+0x424>
                bSubordinatedCycles = TRUE;
   22050:	01000044 	movi	r4,1
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
   22054:	2940010c 	andi	r5,r5,4
   22058:	19bfffcc 	andi	r6,r3,65535
   2205c:	2800491e 	bne	r5,zero,22184 <StartInputHandler+0x3e8>
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
   22060:	314000e0 	cmpeqi	r5,r6,3
   22064:	2800031e 	bne	r5,zero,22074 <StartInputHandler+0x2d8>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
   22068:	117fffcc 	andi	r5,r2,65535
   2206c:	294000e0 	cmpeqi	r5,r5,3
   22070:	28004626 	beq	r5,zero,2218c <StartInputHandler+0x3f0>
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
   22074:	00800c04 	movi	r2,48
   22078:	00005206 	br	221c4 <StartInputHandler+0x428>
    BOOL bSubordinatedCycles = FALSE;
   2207c:	0009883a 	mov	r4,zero
   22080:	003ff406 	br	22054 <StartInputHandler+0x2b8>
            else if (nPdInputSize > 0)
   22084:	d0a13a03 	ldbu	r2,-31512(gp)
   22088:	18004c1e 	bne	r3,zero,221bc <StartInputHandler+0x420>
    if ( !b3BufferMode )
   2208c:	10004c26 	beq	r2,zero,221c0 <StartInputHandler+0x424>
        if(bEscIntEnabled)
   22090:	d0a13a43 	ldbu	r2,-31511(gp)
   22094:	1000681e 	bne	r2,zero,22238 <StartInputHandler+0x49c>
   22098:	0007883a 	mov	r3,zero
            }
        }



    sSyncManOutPar.u16SyncType = SyncType0x1C32;
   2209c:	80c0008d 	sth	r3,2(r16)
    LatchInputSync0Counter = 0;
    u16SmSync0Value = 0;
    u16SmSync0Counter = 0;


    if(bSubordinatedCycles == TRUE)
   220a0:	24003fcc 	andi	r16,r4,255
    sSyncManInPar.u16SyncType = SyncType0x1C33;
   220a4:	9080008d 	sth	r2,2(r18)
    LatchInputSync0Value = 0;
   220a8:	d0213b8d 	sth	zero,-31506(gp)
    LatchInputSync0Counter = 0;
   220ac:	d0213b0d 	sth	zero,-31508(gp)
    u16SmSync0Value = 0;
   220b0:	d0213f8d 	sth	zero,-31490(gp)
    u16SmSync0Counter = 0;
   220b4:	d021400d 	sth	zero,-31488(gp)
    if(bSubordinatedCycles == TRUE)
   220b8:	81000058 	cmpnei	r4,r16,1
   220bc:	2000d31e 	bne	r4,zero,2240c <StartInputHandler+0x670>
    {
        
        UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
   220c0:	dc800317 	ldw	r18,12(sp)
   220c4:	aca7883a 	add	r19,r21,r18

        /* get the number of Sync0 event within on SM cycle */
        if(shiftTimeSync1 >= cycleTimeSync0)
        {

            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   220c8:	900b883a 	mov	r5,r18
   220cc:	9809883a 	mov	r4,r19
   220d0:	0026ae40 	call	26ae4 <__udivsi3>
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   220d4:	900b883a 	mov	r5,r18
   220d8:	9809883a 	mov	r4,r19
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   220dc:	1023883a 	mov	r17,r2
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   220e0:	0026b480 	call	26b48 <__umodsi3>
        if(shiftTimeSync1 >= cycleTimeSync0)
   220e4:	ac80c636 	bltu	r21,r18,22400 <StartInputHandler+0x664>
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
   220e8:	10006c26 	beq	r2,zero,2229c <StartInputHandler+0x500>
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
   220ec:	d4613f8d 	sth	r17,-31490(gp)
        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);

        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
        {
            LatchInputSync0Value++;
   220f0:	8c400044 	addi	r17,r17,1
   220f4:	00006b06 	br	222a4 <StartInputHandler+0x508>
            if (nPdInputSize > 0)
   220f8:	10ffffcc 	andi	r3,r2,65535
   220fc:	18000326 	beq	r3,zero,2210c <StartInputHandler+0x370>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   22100:	2940010c 	andi	r5,r5,4
   22104:	28002b26 	beq	r5,zero,221b4 <StartInputHandler+0x418>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   22108:	008000c4 	movi	r2,3
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   2210c:	01000044 	movi	r4,1
    if ( !b3BufferMode )
   22110:	d0e13a03 	ldbu	r3,-31512(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22114:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22118:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   2211c:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   22120:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   22124:	18003826 	beq	r3,zero,22208 <StartInputHandler+0x46c>
   22128:	00c000c4 	movi	r3,3
        bEscIntEnabled = TRUE;
   2212c:	01400044 	movi	r5,1
   22130:	d1613a45 	stb	r5,-31511(gp)
            if(nPdOutputSize > 0)
   22134:	d1a1370b 	ldhu	r6,-31524(gp)
   22138:	197fff84 	addi	r5,r3,-2
   2213c:	30004026 	beq	r6,zero,22240 <StartInputHandler+0x4a4>
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   22140:	01810004 	movi	r6,1024
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22144:	297fffcc 	andi	r5,r5,65535
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
   22148:	d1a1338d 	sth	r6,-31538(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   2214c:	294000a8 	cmpgeui	r5,r5,2
   22150:	2800461e 	bne	r5,zero,2226c <StartInputHandler+0x4d0>
            bDcSyncActive = TRUE;
   22154:	01400044 	movi	r5,1
   22158:	d1614185 	stb	r5,-31482(gp)
            if (nPdOutputSize == 0)
   2215c:	003fcf06 	br	2209c <StartInputHandler+0x300>
            if (nPdInputSize > 0)
   22160:	d0a1378b 	ldhu	r2,-31522(gp)
   22164:	10ffffcc 	andi	r3,r2,65535
   22168:	18000426 	beq	r3,zero,2217c <StartInputHandler+0x3e0>
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
   2216c:	2940010c 	andi	r5,r5,4
   22170:	2809883a 	mov	r4,r5
   22174:	28001f26 	beq	r5,zero,221f4 <StartInputHandler+0x458>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   22178:	008000c4 	movi	r2,3
            if (nPdInputSize > 0)
   2217c:	0009883a 	mov	r4,zero
   22180:	00000406 	br	22194 <StartInputHandler+0x3f8>
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22184:	314000d8 	cmpnei	r5,r6,3
   22188:	283fe126 	beq	r5,zero,22110 <StartInputHandler+0x374>
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   2218c:	31800098 	cmpnei	r6,r6,2
   22190:	303fa81e 	bne	r6,zero,22034 <StartInputHandler+0x298>
    if ( !b3BufferMode )
   22194:	d0e13a03 	ldbu	r3,-31512(gp)
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   22198:	81c00915 	stw	r7,36(r16)
        sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
   2219c:	81c00115 	stw	r7,4(r16)
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
   221a0:	91c00915 	stw	r7,36(r18)
        sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
   221a4:	91c00115 	stw	r7,4(r18)
    if ( !b3BufferMode )
   221a8:	18001926 	beq	r3,zero,22210 <StartInputHandler+0x474>
   221ac:	00c00084 	movi	r3,2
   221b0:	003fde06 	br	2212c <StartInputHandler+0x390>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   221b4:	00800084 	movi	r2,2
   221b8:	003fd406 	br	2210c <StartInputHandler+0x370>
    if ( !b3BufferMode )
   221bc:	10001a1e 	bne	r2,zero,22228 <StartInputHandler+0x48c>
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
   221c0:	00800a44 	movi	r2,41

    /*write initial input data*/
    PDO_InputMapping();

    return ALSTATUSCODE_NOERROR;
}
   221c4:	dfc00e17 	ldw	ra,56(sp)
   221c8:	df000d17 	ldw	fp,52(sp)
   221cc:	ddc00c17 	ldw	r23,48(sp)
   221d0:	dd800b17 	ldw	r22,44(sp)
   221d4:	dd400a17 	ldw	r21,40(sp)
   221d8:	dd000917 	ldw	r20,36(sp)
   221dc:	dcc00817 	ldw	r19,32(sp)
   221e0:	dc800717 	ldw	r18,28(sp)
   221e4:	dc400617 	ldw	r17,24(sp)
   221e8:	dc000517 	ldw	r16,20(sp)
   221ec:	dec00f04 	addi	sp,sp,60
   221f0:	f800283a 	ret
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
   221f4:	00800084 	movi	r2,2
   221f8:	003fe606 	br	22194 <StartInputHandler+0x3f8>
    if ( !b3BufferMode )
   221fc:	103ff026 	beq	r2,zero,221c0 <StartInputHandler+0x424>
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
   22200:	008000c4 	movi	r2,3
   22204:	003f6e06 	br	21fc0 <StartInputHandler+0x224>
    if ( !b3BufferMode )
   22208:	00c000c4 	movi	r3,3
   2220c:	003f8d06 	br	22044 <StartInputHandler+0x2a8>
   22210:	00c00084 	movi	r3,2
   22214:	003f8b06 	br	22044 <StartInputHandler+0x2a8>
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
   22218:	283fc41e 	bne	r5,zero,2212c <StartInputHandler+0x390>
   2221c:	10ffffcc 	andi	r3,r2,65535
   22220:	183f9b26 	beq	r3,zero,22090 <StartInputHandler+0x2f4>
   22224:	003f6606 	br	21fc0 <StartInputHandler+0x224>
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
   22228:	00800044 	movi	r2,1
   2222c:	003f6406 	br	21fc0 <StartInputHandler+0x224>
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
   22230:	00800884 	movi	r2,34
   22234:	003f3e06 	br	21f30 <StartInputHandler+0x194>
        if(bEscIntEnabled)
   22238:	0005883a 	mov	r2,zero
   2223c:	003f6206 	br	21fc8 <StartInputHandler+0x22c>
            else if(nPdInputSize > 0)
   22240:	d1a1378b 	ldhu	r6,-31522(gp)
   22244:	30000226 	beq	r6,zero,22250 <StartInputHandler+0x4b4>
                u16ALEventMask = PROCESS_INPUT_EVENT;
   22248:	01820004 	movi	r6,2048
   2224c:	d1a1338d 	sth	r6,-31538(gp)
        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
   22250:	297fffcc 	andi	r5,r5,65535
   22254:	294000b0 	cmpltui	r5,r5,2
   22258:	28000a26 	beq	r5,zero,22284 <StartInputHandler+0x4e8>
            bDcSyncActive = TRUE;
   2225c:	01400044 	movi	r5,1
   22260:	d1614185 	stb	r5,-31482(gp)
               u16ALEventMask = 0;
   22264:	d021338d 	sth	zero,-31538(gp)
   22268:	003f8c06 	br	2209c <StartInputHandler+0x300>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
   2226c:	117fffcc 	andi	r5,r2,65535
   22270:	29800098 	cmpnei	r6,r5,2
   22274:	303fb726 	beq	r6,zero,22154 <StartInputHandler+0x3b8>
   22278:	294000d8 	cmpnei	r5,r5,3
   2227c:	283fb526 	beq	r5,zero,22154 <StartInputHandler+0x3b8>
   22280:	003f8606 	br	2209c <StartInputHandler+0x300>
   22284:	117fffcc 	andi	r5,r2,65535
   22288:	298000a0 	cmpeqi	r6,r5,2
   2228c:	303ff31e 	bne	r6,zero,2225c <StartInputHandler+0x4c0>
   22290:	294000d8 	cmpnei	r5,r5,3
   22294:	283ff126 	beq	r5,zero,2225c <StartInputHandler+0x4c0>
   22298:	003f8006 	br	2209c <StartInputHandler+0x300>
                u16SmSync0Value ++;
   2229c:	88800044 	addi	r2,r17,1
   222a0:	d0a13f8d 	sth	r2,-31490(gp)
            LatchInputSync0Value++;
   222a4:	d4613b8d 	sth	r17,-31506(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   222a8:	01800084 	movi	r6,2
   222ac:	01410804 	movi	r5,1056
   222b0:	d9000284 	addi	r4,sp,10
    sCycleDiag.syncFailedCounter = 0;
   222b4:	d0214c0d 	sth	zero,-31440(gp)
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
   222b8:	00207400 	call	20740 <HW_EscRead>
    if (nPdOutputSize > 0 &&  wd != 0 )
   222bc:	d0e1370b 	ldhu	r3,-31524(gp)
    wd = SWAPWORD(wd);
   222c0:	d880028b 	ldhu	r2,10(sp)
    if (nPdOutputSize > 0 &&  wd != 0 )
   222c4:	18005f26 	beq	r3,zero,22444 <StartInputHandler+0x6a8>
   222c8:	10bfffcc 	andi	r2,r2,65535
   222cc:	10005d26 	beq	r2,zero,22444 <StartInputHandler+0x6a8>
    HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
   222d0:	01410004 	movi	r5,1024
   222d4:	01800084 	movi	r6,2
   222d8:	d9000204 	addi	r4,sp,8
   222dc:	00207400 	call	20740 <HW_EscRead>
        if ( wdiv != 0 )
   222e0:	d940020b 	ldhu	r5,8(sp)
   222e4:	28005426 	beq	r5,zero,22438 <StartInputHandler+0x69c>
            d *= wd;
   222e8:	d900028b 	ldhu	r4,10(sp)
   222ec:	29400084 	addi	r5,r5,2
   222f0:	0026ba40 	call	26ba4 <__mulsi3>
            d /= 25000;
   222f4:	01586a04 	movi	r5,25000
   222f8:	111869c4 	addi	r4,r2,24999
   222fc:	0026ae40 	call	26ae4 <__udivsi3>
            EcatWdValue = (UINT16) d;
   22300:	d0a1350d 	sth	r2,-31532(gp)
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   22304:	10bfffcc 	andi	r2,r2,65535
   22308:	d0e141c3 	ldbu	r3,-31481(gp)
   2230c:	10004f1e 	bne	r2,zero,2244c <StartInputHandler+0x6b0>
   22310:	d0a141c3 	ldbu	r2,-31481(gp)
   22314:	10004f1e 	bne	r2,zero,22454 <StartInputHandler+0x6b8>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   22318:	d0a13a43 	ldbu	r2,-31511(gp)
   2231c:	10004f1e 	bne	r2,zero,2245c <StartInputHandler+0x6c0>
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   22320:	01800044 	movi	r6,1
   22324:	01405444 	movi	r5,337
   22328:	d90001c4 	addi	r4,sp,7
    Sync0WdValue = 0;
   2232c:	d0213d0d 	sth	zero,-31500(gp)
    Sync0WdCounter = 0;
   22330:	d0213d8d 	sth	zero,-31498(gp)
    Sync1WdCounter = 0;
   22334:	d0213c8d 	sth	zero,-31502(gp)
    Sync1WdValue = 0;
   22338:	d0213c0d 	sth	zero,-31504(gp)
    bDcRunning = FALSE;
   2233c:	d0214085 	stb	zero,-31486(gp)
    bSmSyncSequenceValid = FALSE;
   22340:	d0213f05 	stb	zero,-31492(gp)
    i16WaitForPllRunningTimeout = 0;
   22344:	d0213e8d 	sth	zero,-31494(gp)
        UINT8 u8TmpVar = 0;
   22348:	d80001c5 	stb	zero,7(sp)
        HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
   2234c:	00207400 	call	20740 <HW_EscRead>
        if ((u8TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
   22350:	d88001c3 	ldbu	r2,7(sp)
   22354:	10c0020c 	andi	r3,r2,8
   22358:	18000326 	beq	r3,zero,22368 <StartInputHandler+0x5cc>
            u16ALEventMask |= SYNC0_EVENT;
   2235c:	d0e1338b 	ldhu	r3,-31538(gp)
   22360:	18c00114 	ori	r3,r3,4
   22364:	d0e1338d 	sth	r3,-31538(gp)
        if ((u8TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
   22368:	10803fcc 	andi	r2,r2,255
   2236c:	1080201c 	xori	r2,r2,128
   22370:	10bfe004 	addi	r2,r2,-128
   22374:	1000030e 	bge	r2,zero,22384 <StartInputHandler+0x5e8>
            u16ALEventMask |= SYNC1_EVENT;
   22378:	d0a1338b 	ldhu	r2,-31538(gp)
   2237c:	10800214 	ori	r2,r2,8
   22380:	d0a1338d 	sth	r2,-31538(gp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   22384:	008000f4 	movhi	r2,3
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   22388:	dc400183 	ldbu	r17,6(sp)
    sSyncManInPar.u16SmEventMissedCounter = 0;
   2238c:	10217a15 	stw	zero,-31256(r2)
    sSyncManInPar.u8SyncError = 0;
   22390:	008000f4 	movhi	r2,3
   22394:	10218005 	stb	zero,-31232(r2)
    sSyncManOutPar.u16SmEventMissedCounter = 0;
   22398:	008000f4 	movhi	r2,3
   2239c:	10218b15 	stw	zero,-31188(r2)
    sSyncManOutPar.u8SyncError = 0;
   223a0:	008000f4 	movhi	r2,3
   223a4:	10219105 	stb	zero,-31164(r2)
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
   223a8:	8880008c 	andi	r2,r17,2
   223ac:	10004126 	beq	r2,zero,224b4 <StartInputHandler+0x718>
        if(cycleTimeSync0 == 0)
   223b0:	dc000317 	ldw	r16,12(sp)
   223b4:	8c40010c 	andi	r17,r17,4
   223b8:	80002e1e 	bne	r16,zero,22474 <StartInputHandler+0x6d8>
            Sync0WdValue = 0;
   223bc:	d0213d0d 	sth	zero,-31500(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   223c0:	88003c26 	beq	r17,zero,224b4 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   223c4:	d8c00417 	ldw	r3,16(sp)
                if(Sync1Cycle < 5)
   223c8:	00800234 	movhi	r2,8
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   223cc:	80c9883a 	add	r4,r16,r3
                if(Sync1Cycle < 5)
   223d0:	10a847c4 	addi	r2,r2,-24289
   223d4:	1100442e 	bgeu	r2,r4,224e8 <StartInputHandler+0x74c>
                UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
   223d8:	014000b4 	movhi	r5,2
   223dc:	2961a804 	addi	r5,r5,-31072
   223e0:	0026ae40 	call	26ae4 <__udivsi3>
                    Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
   223e4:	1008907a 	slli	r4,r2,1
   223e8:	01400284 	movi	r5,10
   223ec:	0026ae40 	call	26ae4 <__udivsi3>
                Sync1WdValue += Sync0WdValue/2;
   223f0:	d0e13d0b 	ldhu	r3,-31500(gp)
   223f4:	1806d07a 	srli	r3,r3,1
   223f8:	1885883a 	add	r2,r3,r2
   223fc:	00002c06 	br	224b0 <StartInputHandler+0x714>
            u16SmSync0Value = 1;
   22400:	d4213f8d 	sth	r16,-31490(gp)
        if ((cycleTimeSync1 % cycleTimeSync0) > 0)
   22404:	103f3a1e 	bne	r2,zero,220f0 <StartInputHandler+0x354>
   22408:	003fa606 	br	222a4 <StartInputHandler+0x508>
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
   2240c:	18ffffcc 	andi	r3,r3,65535
   22410:	18c00098 	cmpnei	r3,r3,2
   22414:	1800021e 	bne	r3,zero,22420 <StartInputHandler+0x684>
            u16SmSync0Value = 1;
   22418:	00c00044 	movi	r3,1
   2241c:	d0e13f8d 	sth	r3,-31490(gp)
        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
   22420:	10bfffcc 	andi	r2,r2,65535
   22424:	108000e0 	cmpeqi	r2,r2,3
   22428:	103f9f1e 	bne	r2,zero,222a8 <StartInputHandler+0x50c>
            LatchInputSync0Value = 1;
   2242c:	00800044 	movi	r2,1
   22430:	d0a13b8d 	sth	r2,-31506(gp)
   22434:	003f9c06 	br	222a8 <StartInputHandler+0x50c>
            wd = 0;
   22438:	d800028d 	sth	zero,10(sp)
        EcatWdValue = 0;
   2243c:	d021350d 	sth	zero,-31532(gp)
   22440:	003fb306 	br	22310 <StartInputHandler+0x574>
        wdiv = 0;
   22444:	d800020d 	sth	zero,8(sp)
   22448:	003ffc06 	br	2243c <StartInputHandler+0x6a0>
    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
   2244c:	18803fcc 	andi	r2,r3,255
   22450:	103fb11e 	bne	r2,zero,22318 <StartInputHandler+0x57c>
        return ALSTATUSCODE_INVALIDWDCFG;
   22454:	008007c4 	movi	r2,31
   22458:	003f5a06 	br	221c4 <StartInputHandler+0x428>
    if ( bEscIntEnabled && nPdOutputSize != 0 )
   2245c:	d0a1370b 	ldhu	r2,-31524(gp)
   22460:	103faf26 	beq	r2,zero,22320 <StartInputHandler+0x584>
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
   22464:	d0a1338b 	ldhu	r2,-31538(gp)
   22468:	10810014 	ori	r2,r2,1024
   2246c:	d0a1338d 	sth	r2,-31538(gp)
   22470:	003fab06 	br	22320 <StartInputHandler+0x584>
            if(Sync0Cycle < 5)
   22474:	00800234 	movhi	r2,8
   22478:	10a847c4 	addi	r2,r2,-24289
   2247c:	1400182e 	bgeu	r2,r16,224e0 <StartInputHandler+0x744>
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
   22480:	014000b4 	movhi	r5,2
   22484:	2961a804 	addi	r5,r5,-31072
   22488:	8009883a 	mov	r4,r16
   2248c:	0026ae40 	call	26ae4 <__udivsi3>
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
   22490:	1008907a 	slli	r4,r2,1
   22494:	01400284 	movi	r5,10
   22498:	213fff8c 	andi	r4,r4,65534
   2249c:	0026ae40 	call	26ae4 <__udivsi3>
   224a0:	d0a13d0d 	sth	r2,-31500(gp)
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
   224a4:	88000326 	beq	r17,zero,224b4 <StartInputHandler+0x718>
            if(shiftTimeSync1 < cycleTimeSync0)
   224a8:	d8c00417 	ldw	r3,16(sp)
   224ac:	1c3fc62e 	bgeu	r3,r16,223c8 <StartInputHandler+0x62c>
                Sync1WdValue += Sync0WdValue/2;
   224b0:	d0a13c0d 	sth	r2,-31504(gp)
    if(nPdOutputSize > 0)
   224b4:	d0a1370b 	ldhu	r2,-31524(gp)
   224b8:	10000226 	beq	r2,zero,224c4 <StartInputHandler+0x728>
        EnableSyncManChannel(PROCESS_DATA_OUT);
   224bc:	01000084 	movi	r4,2
   224c0:	0021ad00 	call	21ad0 <EnableSyncManChannel>
    if(nPdInputSize > 0)
   224c4:	d0a1378b 	ldhu	r2,-31522(gp)
   224c8:	10000226 	beq	r2,zero,224d4 <StartInputHandler+0x738>
        EnableSyncManChannel(PROCESS_DATA_IN);
   224cc:	010000c4 	movi	r4,3
   224d0:	0021ad00 	call	21ad0 <EnableSyncManChannel>
    PDO_InputMapping();
   224d4:	0020eac0 	call	20eac <PDO_InputMapping>
    return ALSTATUSCODE_NOERROR;
   224d8:	0005883a 	mov	r2,zero
   224dc:	003f3906 	br	221c4 <StartInputHandler+0x428>
   224e0:	00800044 	movi	r2,1
   224e4:	003fee06 	br	224a0 <StartInputHandler+0x704>
   224e8:	00800044 	movi	r2,1
   224ec:	003fc006 	br	223f0 <StartInputHandler+0x654>
        return ALSTATUSCODE_INVALIDSMINCFG;
   224f0:	00800784 	movi	r2,30
   224f4:	003f3306 	br	221c4 <StartInputHandler+0x428>
        return ALSTATUSCODE_INVALIDSMOUTCFG;
   224f8:	00800744 	movi	r2,29
   224fc:	003f3106 	br	221c4 <StartInputHandler+0x428>
                    return ALSTATUSCODE_DCSYNC0CYCLETIME;
   22500:	00800d84 	movi	r2,54
   22504:	003f2f06 	br	221c4 <StartInputHandler+0x428>

00022508 <StartOutputHandler>:
    /* by default the SO transition should be completed in AlControlRes().
       required to support also masters which starts to send process data after the SO transition was triggered
       (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
    UINT16 result = NOERROR_INWORK;
    /*ECATCHANGE_START(V5.13) ESM1*/
    if(STATE_VALID(u8LocalErrorState))
   22508:	d0e13903 	ldbu	r3,-31516(gp)
   2250c:	00804584 	movi	r2,278
   22510:	18c003cc 	andi	r3,r3,15
   22514:	10c4d83a 	srl	r2,r2,r3
   22518:	1080004c 	andi	r2,r2,1
   2251c:	10000226 	beq	r2,zero,22528 <StartOutputHandler+0x20>
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
        return u16LocalErrorCode;
   22520:	d0a1398b 	ldhu	r2,-31514(gp)
   22524:	f800283a 	ret
    }
/*The application ESM function is separated from this function to handle pending transitions*/


    /*DC synchronisation is active wait until pll is valid*/
    if(bDcSyncActive)
   22528:	d0a14183 	ldbu	r2,-31482(gp)
   2252c:	10000326 	beq	r2,zero,2253c <StartOutputHandler+0x34>
    {
        i16WaitForPllRunningTimeout = 200;
   22530:	00803204 	movi	r2,200
   22534:	d0a13e8d 	sth	r2,-31494(gp)

        i16WaitForPllRunningCnt = 0;
   22538:	d0213e0d 	sth	zero,-31496(gp)
    }



    sSyncManOutPar.u16SmEventMissedCounter = 0;
   2253c:	008000f4 	movhi	r2,3
   22540:	10218b0d 	sth	zero,-31188(r2)
    sSyncManOutPar.u8SyncError = 0;
   22544:	008000f4 	movhi	r2,3
   22548:	10219105 	stb	zero,-31164(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   2254c:	008000f4 	movhi	r2,3
   22550:	10217a0d 	sth	zero,-31256(r2)
    sSyncManInPar.u8SyncError = 0;
   22554:	008000f4 	movhi	r2,3
   22558:	10218005 	stb	zero,-31232(r2)
   2255c:	00803fc4 	movi	r2,255


    return result;
}
   22560:	f800283a 	ret

00022564 <StopOutputHandler>:
*////////////////////////////////////////////////////////////////////////////////////////

void StopOutputHandler(void)
{
    /* reset the flags that outputs were received and that the slave is in OP */
    bEcatFirstOutputsReceived = FALSE;
   22564:	d0214205 	stb	zero,-31480(gp)
    bEcatOutputUpdateRunning = FALSE;
   22568:	d0214285 	stb	zero,-31478(gp)
}
   2256c:	f800283a 	ret

00022570 <StopInputHandler>:

*////////////////////////////////////////////////////////////////////////////////////////

void StopInputHandler(void)
{
    if(nPdOutputSize > 0)
   22570:	d0a1370b 	ldhu	r2,-31524(gp)
{
   22574:	deffff04 	addi	sp,sp,-4
   22578:	dfc00015 	stw	ra,0(sp)
    if(nPdOutputSize > 0)
   2257c:	10000226 	beq	r2,zero,22588 <StopInputHandler+0x18>
    {
        /* disable the Sync Manager Channel 2 (outputs) */
        DisableSyncManChannel(PROCESS_DATA_OUT);
   22580:	01000084 	movi	r4,2
   22584:	0021a700 	call	21a70 <DisableSyncManChannel>
    }

    if(nPdInputSize > 0)
   22588:	d0a1378b 	ldhu	r2,-31522(gp)
   2258c:	10000226 	beq	r2,zero,22598 <StopInputHandler+0x28>
    {
        /*disable Sync Manager 3 (inputs) if no outputs available*/
        DisableSyncManChannel(PROCESS_DATA_IN);
   22590:	010000c4 	movi	r4,3
   22594:	0021a700 	call	21a70 <DisableSyncManChannel>
    {
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
        ResetMask |= PROCESS_OUTPUT_EVENT;
        ResetMask |= PROCESS_INPUT_EVENT;

    ResetALEventMask( ~(ResetMask) );
   22598:	013cfcd4 	movui	r4,62451
   2259c:	00219700 	call	21970 <ResetALEventMask>
    Sync1WdValue = 0;
    LatchInputSync0Value = 0;
    LatchInputSync0Counter = 0;


    sSyncManOutPar.u16SmEventMissedCounter = 0;
   225a0:	008000f4 	movhi	r2,3
   225a4:	10218b15 	stw	zero,-31188(r2)
    sSyncManOutPar.u16CycleExceededCounter = 0;
    sSyncManOutPar.u8SyncError = 0;
   225a8:	008000f4 	movhi	r2,3
   225ac:	10219105 	stb	zero,-31164(r2)


    sSyncManInPar.u16SmEventMissedCounter = 0;
   225b0:	008000f4 	movhi	r2,3
   225b4:	10217a15 	stw	zero,-31256(r2)
    sSyncManInPar.u16CycleExceededCounter = 0;
    sSyncManInPar.u8SyncError = 0;
   225b8:	008000f4 	movhi	r2,3
    bEcatFirstOutputsReceived = FALSE;
   225bc:	d0214205 	stb	zero,-31480(gp)
    bEscIntEnabled = FALSE;
   225c0:	d0213a45 	stb	zero,-31511(gp)
    bDcSyncActive = FALSE;
   225c4:	d0214185 	stb	zero,-31482(gp)
    bDcRunning = FALSE;
   225c8:	d0214085 	stb	zero,-31486(gp)
    bSmSyncSequenceValid = FALSE;
   225cc:	d0213f05 	stb	zero,-31492(gp)
    u16SmSync0Value = 0;
   225d0:	d0213f8d 	sth	zero,-31490(gp)
    u16SmSync0Counter = 0;
   225d4:	d021400d 	sth	zero,-31488(gp)
    Sync0WdValue = 0;
   225d8:	d0213d0d 	sth	zero,-31500(gp)
    Sync0WdCounter = 0;
   225dc:	d0213d8d 	sth	zero,-31498(gp)
    Sync1WdCounter = 0;
   225e0:	d0213c8d 	sth	zero,-31502(gp)
    Sync1WdValue = 0;
   225e4:	d0213c0d 	sth	zero,-31504(gp)
    LatchInputSync0Value = 0;
   225e8:	d0213b8d 	sth	zero,-31506(gp)
    LatchInputSync0Counter = 0;
   225ec:	d0213b0d 	sth	zero,-31508(gp)
    sSyncManInPar.u8SyncError = 0;
   225f0:	10218005 	stb	zero,-31232(r2)

    i16WaitForPllRunningTimeout = 0;
   225f4:	d0213e8d 	sth	zero,-31494(gp)

    bWdTrigger = FALSE;
   225f8:	d02141c5 	stb	zero,-31481(gp)
    bEcatInputUpdateRunning = FALSE;
   225fc:	d0214245 	stb	zero,-31479(gp)

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
   22600:	d0214c85 	stb	zero,-31438(gp)
}
   22604:	dfc00017 	ldw	ra,0(sp)
   22608:	dec00104 	addi	sp,sp,4
   2260c:	f800283a 	ret

00022610 <BackToInitTransition>:
*////////////////////////////////////////////////////////////////////////////////////////

void BackToInitTransition(void)
{
    /* Reset indication that the user has written a sync mode*/
    bSyncSetByUser = FALSE;
   22610:	d0214c85 	stb	zero,-31438(gp)
}
   22614:	f800283a 	ret

00022618 <SetALStatus>:
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
    UINT16 Value = alStatusCode;

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
   22618:	d0e135c3 	ldbu	r3,-31529(gp)
{
   2261c:	defffe04 	addi	sp,sp,-8
   22620:	dfc00115 	stw	ra,4(sp)
    UINT16 Value = alStatusCode;
   22624:	d940008d 	sth	r5,2(sp)
    if(nAlStatus != alStatus)
   22628:	20803fcc 	andi	r2,r4,255
   2262c:	18800126 	beq	r3,r2,22634 <SetALStatus+0x1c>
    {
        nAlStatus = alStatus;
   22630:	d12135c5 	stb	r4,-31529(gp)
    }

    /*Handle Explicit Device ID is requested*/
    if(bExplicitDevIdRequested && !(nAlStatus & STATE_CHANGE) && alStatusCode == 0 && ((nAlStatus & STATE_MASK) != STATE_BOOT))
   22634:	d0e13583 	ldbu	r3,-31530(gp)
   22638:	d0a135c3 	ldbu	r2,-31529(gp)
   2263c:	297fffcc 	andi	r5,r5,65535
   22640:	18001126 	beq	r3,zero,22688 <SetALStatus+0x70>
   22644:	10c0040c 	andi	r3,r2,16
   22648:	18000f1e 	bne	r3,zero,22688 <SetALStatus+0x70>
   2264c:	28000e1e 	bne	r5,zero,22688 <SetALStatus+0x70>
   22650:	10c003cc 	andi	r3,r2,15
   22654:	18c000e0 	cmpeqi	r3,r3,3
   22658:	1800091e 	bne	r3,zero,22680 <SetALStatus+0x68>
    {
/*ECATCHANGE_START(V5.13) ECAT2*/
        Value = u16IdValue;
   2265c:	d0e1330b 	ldhu	r3,-31540(gp)
/*ECATCHANGE_END(V5.13) ECAT2*/
        nAlStatus |= STATE_DEVID;
   22660:	10800814 	ori	r2,r2,32
        Value = u16IdValue;
   22664:	d8c0008d 	sth	r3,2(sp)
    }
    else
    {
        nAlStatus &= ~STATE_DEVID;
   22668:	d0a135c5 	stb	r2,-31529(gp)

    if (alStatusCode != 0xFFFF)
    {
        Value = SWAPWORD(Value);

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
   2266c:	01800084 	movi	r6,2
   22670:	01404d04 	movi	r5,308
   22674:	d9000084 	addi	r4,sp,2
   22678:	00207c40 	call	207c4 <HW_EscWrite>
   2267c:	00000606 	br	22698 <SetALStatus+0x80>
        nAlStatus &= ~STATE_DEVID;
   22680:	108037cc 	andi	r2,r2,223
   22684:	003ff806 	br	22668 <SetALStatus+0x50>
   22688:	108037cc 	andi	r2,r2,223
   2268c:	d0a135c5 	stb	r2,-31529(gp)
    if (alStatusCode != 0xFFFF)
   22690:	00bfffd4 	movui	r2,65535
   22694:	28bff51e 	bne	r5,r2,2266c <SetALStatus+0x54>
    }

    Value = nAlStatus;
   22698:	d0a135c3 	ldbu	r2,-31529(gp)
    Value = SWAPWORD(Value);
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   2269c:	01800084 	movi	r6,2
   226a0:	01404c04 	movi	r5,304
   226a4:	d9000084 	addi	r4,sp,2
    Value = nAlStatus;
   226a8:	d880008d 	sth	r2,2(sp)
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
   226ac:	00207c40 	call	207c4 <HW_EscWrite>

}
   226b0:	dfc00117 	ldw	ra,4(sp)
   226b4:	dec00204 	addi	sp,sp,8
   226b8:	f800283a 	ret

000226bc <AL_ControlInd>:
{
    UINT16        result = 0;
    UINT8            bErrAck = 0;
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
   226bc:	00bfffc4 	movi	r2,-1
{
   226c0:	defff704 	addi	sp,sp,-36
    EsmTimeoutCounter = -1;
   226c4:	d0a1410d 	sth	r2,-31484(gp)
    bApplEsmPending = TRUE;
   226c8:	00800044 	movi	r2,1
{
   226cc:	dd800615 	stw	r22,24(sp)
   226d0:	dd400515 	stw	r21,20(sp)
   226d4:	dd000415 	stw	r20,16(sp)
   226d8:	dcc00315 	stw	r19,12(sp)
   226dc:	dc400115 	stw	r17,4(sp)
    bApplEsmPending = TRUE;
   226e0:	d0a138c5 	stb	r2,-31517(gp)
   226e4:	24c003cc 	andi	r19,r4,15
{
   226e8:	dfc00815 	stw	ra,32(sp)
   226ec:	ddc00715 	stw	r23,28(sp)
   226f0:	dc800215 	stw	r18,8(sp)
   226f4:	dc000015 	stw	r16,0(sp)
   226f8:	2080040c 	andi	r2,r4,16

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
    {
        bErrAck = 1;
        nAlStatus &= ~STATE_CHANGE;
   226fc:	d46135c3 	ldbu	r17,-31529(gp)
{
   22700:	2829883a 	mov	r20,r5
   22704:	282d883a 	mov	r22,r5
   22708:	982b883a 	mov	r21,r19
    if ( alControl & STATE_CHANGE )
   2270c:	10005126 	beq	r2,zero,22854 <AL_ControlInd+0x198>
        nAlStatus &= ~STATE_CHANGE;
   22710:	00bffbc4 	movi	r2,-17
   22714:	1462703a 	and	r17,r2,r17
        bErrAck = 1;
   22718:	05c00044 	movi	r23,1
        nAlStatus &= ~STATE_CHANGE;
   2271c:	d46135c5 	stb	r17,-31529(gp)

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
    stateTrans = nAlStatus;
    stateTrans <<= 4;
   22720:	8822913a 	slli	r17,r17,4
    stateTrans += alControl;
   22724:	9c63883a 	add	r17,r19,r17

    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
   22728:	8c803fcc 	andi	r18,r17,255
   2272c:	908010a0 	cmpeqi	r2,r18,66
   22730:	1000931e 	bne	r2,zero,22980 <AL_ControlInd+0x2c4>
   22734:	908010e8 	cmpgeui	r2,r18,67
   22738:	1000551e 	bne	r2,zero,22890 <AL_ControlInd+0x1d4>
   2273c:	90800920 	cmpeqi	r2,r18,36
   22740:	1000ae1e 	bne	r2,zero,229fc <AL_ControlInd+0x340>
   22744:	90800970 	cmpltui	r2,r18,37
   22748:	1000491e 	bne	r2,zero,22870 <AL_ControlInd+0x1b4>
    }

    if ( result == 0 )
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
   2274c:	d021380d 	sth	zero,-31520(gp)
        switch ( stateTrans )
   22750:	8c7ffbc4 	addi	r17,r17,-17
   22754:	8c403fcc 	andi	r17,r17,255
   22758:	88800e28 	cmpgeui	r2,r17,56
   2275c:	10005b1e 	bne	r2,zero,228cc <AL_ControlInd+0x210>
   22760:	882290ba 	slli	r17,r17,2
   22764:	008000b4 	movhi	r2,2
   22768:	8885883a 	add	r2,r17,r2
   2276c:	1089dd17 	ldw	r2,10100(r2)
   22770:	1000683a 	jmp	r2
   22774:	00022d0c 	andi	zero,zero,2228
   22778:	00022a50 	cmplti	zero,zero,2217
   2277c:	00022a3c 	xorhi	zero,zero,2216
   22780:	00022e04 	movi	zero,2232
   22784:	000228cc 	andi	zero,zero,2211
   22788:	000228cc 	andi	zero,zero,2211
   2278c:	000228cc 	andi	zero,zero,2211
   22790:	00022e04 	movi	zero,2232
   22794:	000228cc 	andi	zero,zero,2211
   22798:	000228cc 	andi	zero,zero,2211
   2279c:	000228cc 	andi	zero,zero,2211
   227a0:	000228cc 	andi	zero,zero,2211
   227a4:	000228cc 	andi	zero,zero,2211
   227a8:	000228cc 	andi	zero,zero,2211
   227ac:	000228cc 	andi	zero,zero,2211
   227b0:	000228cc 	andi	zero,zero,2211
   227b4:	00022ce0 	cmpeqi	zero,zero,2227
   227b8:	00022d10 	cmplti	zero,zero,2228
   227bc:	00022e04 	movi	zero,2232
   227c0:	00022b64 	muli	zero,zero,2221
   227c4:	000228cc 	andi	zero,zero,2211
   227c8:	000228cc 	andi	zero,zero,2211
   227cc:	000228cc 	andi	zero,zero,2211
   227d0:	00022e04 	movi	zero,2232
   227d4:	000228cc 	andi	zero,zero,2211
   227d8:	000228cc 	andi	zero,zero,2211
   227dc:	000228cc 	andi	zero,zero,2211
   227e0:	000228cc 	andi	zero,zero,2211
   227e4:	000228cc 	andi	zero,zero,2211
   227e8:	000228cc 	andi	zero,zero,2211
   227ec:	000228cc 	andi	zero,zero,2211
   227f0:	000228cc 	andi	zero,zero,2211
   227f4:	00022a38 	rdprs	zero,zero,2216
   227f8:	00022e04 	movi	zero,2232
   227fc:	000228cc 	andi	zero,zero,2211
   22800:	00022e04 	movi	zero,2232
   22804:	000228cc 	andi	zero,zero,2211
   22808:	000228cc 	andi	zero,zero,2211
   2280c:	000228cc 	andi	zero,zero,2211
   22810:	00022e04 	movi	zero,2232
   22814:	000228cc 	andi	zero,zero,2211
   22818:	000228cc 	andi	zero,zero,2211
   2281c:	000228cc 	andi	zero,zero,2211
   22820:	000228cc 	andi	zero,zero,2211
   22824:	000228cc 	andi	zero,zero,2211
   22828:	000228cc 	andi	zero,zero,2211
   2282c:	000228cc 	andi	zero,zero,2211
   22830:	000228cc 	andi	zero,zero,2211
   22834:	00022cb0 	cmpltui	zero,zero,2226
   22838:	000228cc 	andi	zero,zero,2211
   2283c:	00022e04 	movi	zero,2232
   22840:	00022d10 	cmplti	zero,zero,2228
   22844:	000228cc 	andi	zero,zero,2211
   22848:	000228cc 	andi	zero,zero,2211
   2284c:	000228cc 	andi	zero,zero,2211
   22850:	00022bdc 	xori	zero,zero,2223
   22854:	102f883a 	mov	r23,r2
    else if ((nAlStatus & STATE_CHANGE)
   22858:	8880040c 	andi	r2,r17,16
   2285c:	10000226 	beq	r2,zero,22868 <AL_ControlInd+0x1ac>
        && (alControl & STATE_MASK) != STATE_INIT)
   22860:	98800058 	cmpnei	r2,r19,1
   22864:	1000a11e 	bne	r2,zero,22aec <AL_ControlInd+0x430>
        nAlStatus &= STATE_MASK;
   22868:	8c4003cc 	andi	r17,r17,15
   2286c:	003fab06 	br	2271c <AL_ControlInd+0x60>
    switch ( stateTrans )
   22870:	908004a0 	cmpeqi	r2,r18,18
   22874:	10004b1e 	bne	r2,zero,229a4 <AL_ControlInd+0x2e8>
   22878:	908008a0 	cmpeqi	r2,r18,34
   2287c:	1000491e 	bne	r2,zero,229a4 <AL_ControlInd+0x2e8>
        nEcatStateTrans = 0;
   22880:	d021380d 	sth	zero,-31520(gp)
        switch ( stateTrans )
   22884:	90800468 	cmpgeui	r2,r18,17
   22888:	10001026 	beq	r2,zero,228cc <AL_ControlInd+0x210>
   2288c:	003fb006 	br	22750 <AL_ControlInd+0x94>
    switch ( stateTrans )
   22890:	908020a0 	cmpeqi	r2,r18,130
   22894:	1000281e 	bne	r2,zero,22938 <AL_ControlInd+0x27c>
   22898:	908020e8 	cmpgeui	r2,r18,131
   2289c:	1000101e 	bne	r2,zero,228e0 <AL_ControlInd+0x224>
   228a0:	90801120 	cmpeqi	r2,r18,68
   228a4:	10005b1e 	bne	r2,zero,22a14 <AL_ControlInd+0x358>
   228a8:	90801220 	cmpeqi	r2,r18,72
   228ac:	1000591e 	bne	r2,zero,22a14 <AL_ControlInd+0x358>
        nEcatStateTrans = 0;
   228b0:	d021380d 	sth	zero,-31520(gp)
        switch ( stateTrans )
   228b4:	90801270 	cmpltui	r2,r18,73
   228b8:	103fa51e 	bne	r2,zero,22750 <AL_ControlInd+0x94>
   228bc:	8c401fc4 	addi	r17,r17,127
   228c0:	8c403fcc 	andi	r17,r17,255
   228c4:	8c400228 	cmpgeui	r17,r17,8
   228c8:	8800eb26 	beq	r17,zero,22c78 <AL_ControlInd+0x5bc>
                break;
        }
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
   228cc:	d12135c3 	ldbu	r4,-31529(gp)
   228d0:	208003cc 	andi	r2,r4,15
   228d4:	98806426 	beq	r19,r2,22a68 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
   228d8:	04000484 	movi	r16,18
   228dc:	00009506 	br	22b34 <AL_ControlInd+0x478>
    switch ( stateTrans )
   228e0:	90802120 	cmpeqi	r2,r18,132
   228e4:	10004b1e 	bne	r2,zero,22a14 <AL_ControlInd+0x358>
   228e8:	90802220 	cmpeqi	r2,r18,136
   228ec:	1000491e 	bne	r2,zero,22a14 <AL_ControlInd+0x358>
        nEcatStateTrans = 0;
   228f0:	d021380d 	sth	zero,-31520(gp)
        switch ( stateTrans )
   228f4:	8c401fc4 	addi	r17,r17,127
   228f8:	8c403fcc 	andi	r17,r17,255
   228fc:	88800228 	cmpgeui	r2,r17,8
   22900:	103ff21e 	bne	r2,zero,228cc <AL_ControlInd+0x210>
   22904:	882290ba 	slli	r17,r17,2
   22908:	008000b4 	movhi	r2,2
   2290c:	8885883a 	add	r2,r17,r2
   22910:	108a4617 	ldw	r2,10520(r2)
   22914:	1000683a 	jmp	r2
   22918:	00022c78 	rdprs	zero,zero,2225
   2291c:	00022950 	cmplti	zero,zero,2213
   22920:	00022e04 	movi	zero,2232
   22924:	00022c68 	cmpgeui	zero,zero,2225
   22928:	000228cc 	andi	zero,zero,2211
   2292c:	000228cc 	andi	zero,zero,2211
   22930:	000228cc 	andi	zero,zero,2211
   22934:	00022d10 	cmplti	zero,zero,2228
        result = CheckSmSettings(MAILBOX_READ+1);
   22938:	01000084 	movi	r4,2
   2293c:	0021b2c0 	call	21b2c <CheckSmSettings>
   22940:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22944:	10803fcc 	andi	r2,r2,255
   22948:	10001b1e 	bne	r2,zero,229b8 <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   2294c:	d021380d 	sth	zero,-31520(gp)
            result = APPL_StopOutputHandler();
   22950:	00202100 	call	20210 <APPL_StopOutputHandler>
   22954:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22958:	00225640 	call	22564 <StopOutputHandler>
            if (result != 0)
   2295c:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22960:	d02138c5 	stb	zero,-31517(gp)
            if (result != 0)
   22964:	10000c26 	beq	r2,zero,22998 <AL_ControlInd+0x2dc>
    if ( result == NOERROR_INWORK )
   22968:	10803fd8 	cmpnei	r2,r2,255
   2296c:	10006e1e 	bne	r2,zero,22b28 <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22970:	00800044 	movi	r2,1
   22974:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22978:	00802084 	movi	r2,130
   2297c:	0000c906 	br	22ca4 <AL_ControlInd+0x5e8>
        result = CheckSmSettings(MAILBOX_READ+1);
   22980:	01000084 	movi	r4,2
   22984:	0021b2c0 	call	21b2c <CheckSmSettings>
   22988:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   2298c:	10803fcc 	andi	r2,r2,255
   22990:	1000091e 	bne	r2,zero,229b8 <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   22994:	d021380d 	sth	zero,-31520(gp)
            APPL_StopInputHandler();
   22998:	00202000 	call	20200 <APPL_StopInputHandler>
            StopInputHandler();
   2299c:	00225700 	call	22570 <StopInputHandler>
   229a0:	0000b306 	br	22c70 <AL_ControlInd+0x5b4>
        result = CheckSmSettings(MAILBOX_READ+1);
   229a4:	01000084 	movi	r4,2
   229a8:	0021b2c0 	call	21b2c <CheckSmSettings>
   229ac:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   229b0:	10803fcc 	andi	r2,r2,255
   229b4:	103fb226 	beq	r2,zero,22880 <AL_ControlInd+0x1c4>
        switch (nAlStatus)
   229b8:	d12135c3 	ldbu	r4,-31529(gp)
   229bc:	85ffffcc 	andi	r23,r16,65535
   229c0:	20803fcc 	andi	r2,r4,255
   229c4:	10c00120 	cmpeqi	r3,r2,4
   229c8:	1800e81e 	bne	r3,zero,22d6c <AL_ControlInd+0x6b0>
   229cc:	10c00220 	cmpeqi	r3,r2,8
   229d0:	1800e41e 	bne	r3,zero,22d64 <AL_ControlInd+0x6a8>
   229d4:	10c000a0 	cmpeqi	r3,r2,2
   229d8:	1800e61e 	bne	r3,zero,22d74 <AL_ControlInd+0x6b8>
    if ( result == NOERROR_INWORK )
   229dc:	bdc03fe0 	cmpeqi	r23,r23,255
   229e0:	b800fa1e 	bne	r23,zero,22dcc <AL_ControlInd+0x710>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   229e4:	20c003cc 	andi	r3,r4,15
   229e8:	98c0521e 	bne	r19,r3,22b34 <AL_ControlInd+0x478>
   229ec:	1009883a 	mov	r4,r2
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
   229f0:	d0213885 	stb	zero,-31518(gp)

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
   229f4:	000b883a 	mov	r5,zero
   229f8:	00011a06 	br	22e64 <AL_ControlInd+0x7a8>
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
   229fc:	d1613704 	addi	r5,gp,-31524
   22a00:	d1213784 	addi	r4,gp,-31522
   22a04:	00202180 	call	20218 <APPL_GenerateMapping>
   22a08:	1021883a 	mov	r16,r2
            if (result != 0)
   22a0c:	10bfffcc 	andi	r2,r2,65535
   22a10:	103fe91e 	bne	r2,zero,229b8 <AL_ControlInd+0x2fc>
        result = CheckSmSettings(nMaxSyncMan);
   22a14:	d1213683 	ldbu	r4,-31526(gp)
   22a18:	0021b2c0 	call	21b2c <CheckSmSettings>
   22a1c:	14003fcc 	andi	r16,r2,255
    if ( result == 0 )
   22a20:	10803fcc 	andi	r2,r2,255
   22a24:	103fe41e 	bne	r2,zero,229b8 <AL_ControlInd+0x2fc>
        nEcatStateTrans = 0;
   22a28:	d021380d 	sth	zero,-31520(gp)
        switch ( stateTrans )
   22a2c:	90801268 	cmpgeui	r2,r18,73
   22a30:	103f9426 	beq	r2,zero,22884 <AL_ControlInd+0x1c8>
   22a34:	003faf06 	br	228f4 <AL_ControlInd+0x238>
    bSyncSetByUser = FALSE;
   22a38:	d0214c85 	stb	zero,-31438(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a3c:	d12135c3 	ldbu	r4,-31529(gp)
   22a40:	208003cc 	andi	r2,r4,15
   22a44:	98800826 	beq	r19,r2,22a68 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_BOOTNOTSUPP;
   22a48:	040004c4 	movi	r16,19
   22a4c:	00003906 	br	22b34 <AL_ControlInd+0x478>
           UpdateEEPROMLoadedState();
   22a50:	0021a080 	call	21a08 <UpdateEEPROMLoadedState>
            if (EepromLoaded == FALSE)
   22a54:	d0a13003 	ldbu	r2,-31552(gp)
   22a58:	1000051e 	bne	r2,zero,22a70 <AL_ControlInd+0x3b4>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a5c:	d12135c3 	ldbu	r4,-31529(gp)
   22a60:	208003cc 	andi	r2,r4,15
   22a64:	9880f11e 	bne	r19,r2,22e2c <AL_ControlInd+0x770>
   22a68:	21003fcc 	andi	r4,r4,255
   22a6c:	003fe006 	br	229f0 <AL_ControlInd+0x334>
            result = MBX_StartMailboxHandler();
   22a70:	00239280 	call	23928 <MBX_StartMailboxHandler>
   22a74:	1021883a 	mov	r16,r2
            if (result == 0)
   22a78:	10bfffcc 	andi	r2,r2,65535
   22a7c:	10000e1e 	bne	r2,zero,22ab8 <AL_ControlInd+0x3fc>
                bApplEsmPending = FALSE;
   22a80:	d02138c5 	stb	zero,-31517(gp)
                result = APPL_StartMailboxHandler();
   22a84:	00201e80 	call	201e8 <APPL_StartMailboxHandler>
   22a88:	1021883a 	mov	r16,r2
                if ( result == 0 )
   22a8c:	10bfffcc 	andi	r2,r2,65535
   22a90:	1000091e 	bne	r2,zero,22ab8 <AL_ControlInd+0x3fc>
                    bMbxRunning = TRUE;
   22a94:	00800044 	movi	r2,1
   22a98:	d0a14b45 	stb	r2,-31443(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22a9c:	d12135c3 	ldbu	r4,-31529(gp)
   22aa0:	208003cc 	andi	r2,r4,15
   22aa4:	98bff026 	beq	r19,r2,22a68 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22aa8:	a0bfffcc 	andi	r2,r20,65535
   22aac:	1000e51e 	bne	r2,zero,22e44 <AL_ControlInd+0x788>
   22ab0:	002d883a 	mov	r22,zero
            nAlStatus = alControl;
   22ab4:	0000e706 	br	22e54 <AL_ControlInd+0x798>
            if(result != 0 && result != NOERROR_INWORK)
   22ab8:	80bfffcc 	andi	r2,r16,65535
   22abc:	10803fd8 	cmpnei	r2,r2,255
   22ac0:	1000151e 	bne	r2,zero,22b18 <AL_ControlInd+0x45c>
        bEcatWaitForAlControlRes = TRUE;
   22ac4:	00800044 	movi	r2,1
   22ac8:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22acc:	00800484 	movi	r2,18
   22ad0:	d0a1380d 	sth	r2,-31520(gp)
            break;
   22ad4:	0401f404 	movi	r16,2000
        EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to react before the master runs into a timeout.
   22ad8:	813fffcc 	andi	r4,r16,65535
   22adc:	01400284 	movi	r5,10
   22ae0:	0026ae40 	call	26ae4 <__udivsi3>
   22ae4:	80a1c83a 	sub	r16,r16,r2
   22ae8:	d421410d 	sth	r16,-31484(gp)
    }
    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 state machine from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/

}
   22aec:	dfc00817 	ldw	ra,32(sp)
   22af0:	ddc00717 	ldw	r23,28(sp)
   22af4:	dd800617 	ldw	r22,24(sp)
   22af8:	dd400517 	ldw	r21,20(sp)
   22afc:	dd000417 	ldw	r20,16(sp)
   22b00:	dcc00317 	ldw	r19,12(sp)
   22b04:	dc800217 	ldw	r18,8(sp)
   22b08:	dc400117 	ldw	r17,4(sp)
   22b0c:	dc000017 	ldw	r16,0(sp)
   22b10:	dec00904 	addi	sp,sp,36
   22b14:	f800283a 	ret
                    if (!bApplEsmPending)
   22b18:	d0a138c3 	ldbu	r2,-31517(gp)
   22b1c:	1000011e 	bne	r2,zero,22b24 <AL_ControlInd+0x468>
                        APPL_StopMailboxHandler();
   22b20:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                 MBX_StopMailboxHandler();
   22b24:	00239fc0 	call	239fc <MBX_StopMailboxHandler>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22b28:	d12135c3 	ldbu	r4,-31529(gp)
   22b2c:	208003cc 	andi	r2,r4,15
   22b30:	98bfcd26 	beq	r19,r2,22a68 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22b34:	9908b03a 	or	r4,r19,r4
   22b38:	2100020c 	andi	r4,r4,8
   22b3c:	2000d51e 	bne	r4,zero,22e94 <AL_ControlInd+0x7d8>
                if (nAlStatus == STATE_OP)
   22b40:	d0a135c3 	ldbu	r2,-31529(gp)
   22b44:	10800218 	cmpnei	r2,r2,8
   22b48:	1000021e 	bne	r2,zero,22b54 <AL_ControlInd+0x498>
                    nAlStatus = STATE_SAFEOP;
   22b4c:	00800104 	movi	r2,4
   22b50:	d0a135c5 	stb	r2,-31529(gp)
            nAlStatus |= STATE_CHANGE;
   22b54:	d56135c3 	ldbu	r21,-31529(gp)
   22b58:	802d883a 	mov	r22,r16
   22b5c:	ad400414 	ori	r21,r21,16
   22b60:	0000bc06 	br	22e54 <AL_ControlInd+0x798>
            result = StartInputHandler();
   22b64:	0021d9c0 	call	21d9c <StartInputHandler>
   22b68:	1021883a 	mov	r16,r2
            if ( result == 0 )
   22b6c:	10bfffcc 	andi	r2,r2,65535
   22b70:	10000b1e 	bne	r2,zero,22ba0 <AL_ControlInd+0x4e4>
                result = APPL_StartInputHandler(&u16ALEventMask);
   22b74:	d1213384 	addi	r4,gp,-31538
                bApplEsmPending = FALSE;
   22b78:	d02138c5 	stb	zero,-31517(gp)
                result = APPL_StartInputHandler(&u16ALEventMask);
   22b7c:	00201f80 	call	201f8 <APPL_StartInputHandler>
   22b80:	1021883a 	mov	r16,r2
                if(result == 0)
   22b84:	10bfffcc 	andi	r2,r2,65535
   22b88:	1000051e 	bne	r2,zero,22ba0 <AL_ControlInd+0x4e4>
                    SetALEventMask( u16ALEventMask );
   22b8c:	d121338b 	ldhu	r4,-31538(gp)
   22b90:	00219bc0 	call	219bc <SetALEventMask>
                    bEcatInputUpdateRunning = TRUE;
   22b94:	00800044 	movi	r2,1
   22b98:	d0a14245 	stb	r2,-31479(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22b9c:	003fbf06 	br	22a9c <AL_ControlInd+0x3e0>
            if(result != 0 && result != NOERROR_INWORK)
   22ba0:	80bfffcc 	andi	r2,r16,65535
   22ba4:	10803fd8 	cmpnei	r2,r2,255
   22ba8:	1000061e 	bne	r2,zero,22bc4 <AL_ControlInd+0x508>
        bEcatWaitForAlControlRes = TRUE;
   22bac:	00800044 	movi	r2,1
   22bb0:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22bb4:	00800904 	movi	r2,36
   22bb8:	d0a1380d 	sth	r2,-31520(gp)
                break;
   22bbc:	0408ca04 	movi	r16,9000
   22bc0:	003fc506 	br	22ad8 <AL_ControlInd+0x41c>
                if(!bApplEsmPending)
   22bc4:	d0a138c3 	ldbu	r2,-31517(gp)
   22bc8:	10000226 	beq	r2,zero,22bd4 <AL_ControlInd+0x518>
                StopInputHandler();
   22bcc:	00225700 	call	22570 <StopInputHandler>
   22bd0:	003fd506 	br	22b28 <AL_ControlInd+0x46c>
                    APPL_StopInputHandler();
   22bd4:	00202000 	call	20200 <APPL_StopInputHandler>
   22bd8:	003ffc06 	br	22bcc <AL_ControlInd+0x510>
            if (bErrAck)
   22bdc:	bdc03fcc 	andi	r23,r23,255
   22be0:	b8000426 	beq	r23,zero,22bf4 <AL_ControlInd+0x538>
                if (nPdOutputSize > 0)
   22be4:	d0a1370b 	ldhu	r2,-31524(gp)
   22be8:	10000e26 	beq	r2,zero,22c24 <AL_ControlInd+0x568>
                    EnableSyncManChannel(PROCESS_DATA_OUT);
   22bec:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22bf0:	0021ad00 	call	21ad0 <EnableSyncManChannel>
            result = StartOutputHandler();
   22bf4:	00225080 	call	22508 <StartOutputHandler>
   22bf8:	1021883a 	mov	r16,r2
            if(result == 0)
   22bfc:	10bfffcc 	andi	r2,r2,65535
   22c00:	10000c1e 	bne	r2,zero,22c34 <AL_ControlInd+0x578>
                bApplEsmPending = FALSE;
   22c04:	d02138c5 	stb	zero,-31517(gp)
                result = APPL_StartOutputHandler();
   22c08:	00202080 	call	20208 <APPL_StartOutputHandler>
   22c0c:	1021883a 	mov	r16,r2
                if(result == 0)
   22c10:	10bfffcc 	andi	r2,r2,65535
   22c14:	1000071e 	bne	r2,zero,22c34 <AL_ControlInd+0x578>
                    bEcatOutputUpdateRunning = TRUE;
   22c18:	00800044 	movi	r2,1
   22c1c:	d0a14285 	stb	r2,-31478(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22c20:	003f9e06 	br	22a9c <AL_ControlInd+0x3e0>
                    if (nPdInputSize > 0)
   22c24:	d0a1378b 	ldhu	r2,-31522(gp)
   22c28:	103ff226 	beq	r2,zero,22bf4 <AL_ControlInd+0x538>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22c2c:	010000c4 	movi	r4,3
   22c30:	003fef06 	br	22bf0 <AL_ControlInd+0x534>
            if ( result != 0 && result != NOERROR_INWORK)
   22c34:	80bfffcc 	andi	r2,r16,65535
   22c38:	10803fd8 	cmpnei	r2,r2,255
   22c3c:	1000041e 	bne	r2,zero,22c50 <AL_ControlInd+0x594>
        bEcatWaitForAlControlRes = TRUE;
   22c40:	00800044 	movi	r2,1
   22c44:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22c48:	00801204 	movi	r2,72
   22c4c:	003fda06 	br	22bb8 <AL_ControlInd+0x4fc>
                    if (!bApplEsmPending)
   22c50:	d0a138c3 	ldbu	r2,-31517(gp)
   22c54:	10000226 	beq	r2,zero,22c60 <AL_ControlInd+0x5a4>
                StopOutputHandler();
   22c58:	00225640 	call	22564 <StopOutputHandler>
    if ( result == NOERROR_INWORK )
   22c5c:	003fb206 	br	22b28 <AL_ControlInd+0x46c>
                        APPL_StopOutputHandler();
   22c60:	00202100 	call	20210 <APPL_StopOutputHandler>
   22c64:	003ffc06 	br	22c58 <AL_ControlInd+0x59c>
            APPL_StopOutputHandler();
   22c68:	00202100 	call	20210 <APPL_StopOutputHandler>
            StopOutputHandler();
   22c6c:	00225640 	call	22564 <StopOutputHandler>
            bApplEsmPending = FALSE;
   22c70:	d02138c5 	stb	zero,-31517(gp)
   22c74:	003f8906 	br	22a9c <AL_ControlInd+0x3e0>
            result = APPL_StopOutputHandler();
   22c78:	00202100 	call	20210 <APPL_StopOutputHandler>
   22c7c:	1021883a 	mov	r16,r2
            StopOutputHandler();
   22c80:	00225640 	call	22564 <StopOutputHandler>
            if (result != 0)
   22c84:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22c88:	d02138c5 	stb	zero,-31517(gp)
            if (result != 0)
   22c8c:	10000826 	beq	r2,zero,22cb0 <AL_ControlInd+0x5f4>
    if ( result == NOERROR_INWORK )
   22c90:	10803fd8 	cmpnei	r2,r2,255
   22c94:	103fa41e 	bne	r2,zero,22b28 <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22c98:	00800044 	movi	r2,1
   22c9c:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22ca0:	00802044 	movi	r2,129
   22ca4:	d0a1380d 	sth	r2,-31520(gp)
                break;
   22ca8:	04003204 	movi	r16,200
   22cac:	003f8a06 	br	22ad8 <AL_ControlInd+0x41c>
            result = APPL_StopInputHandler();
   22cb0:	00202000 	call	20200 <APPL_StopInputHandler>
   22cb4:	1021883a 	mov	r16,r2
            StopInputHandler();
   22cb8:	00225700 	call	22570 <StopInputHandler>
            if (result != 0)
   22cbc:	80bfffcc 	andi	r2,r16,65535
            bApplEsmPending = FALSE;
   22cc0:	d02138c5 	stb	zero,-31517(gp)
            if (result != 0)
   22cc4:	10000626 	beq	r2,zero,22ce0 <AL_ControlInd+0x624>
    if ( result == NOERROR_INWORK )
   22cc8:	10803fd8 	cmpnei	r2,r2,255
   22ccc:	103f961e 	bne	r2,zero,22b28 <AL_ControlInd+0x46c>
        bEcatWaitForAlControlRes = TRUE;
   22cd0:	00800044 	movi	r2,1
   22cd4:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22cd8:	00801044 	movi	r2,65
   22cdc:	003ff106 	br	22ca4 <AL_ControlInd+0x5e8>
            MBX_StopMailboxHandler();
   22ce0:	00239fc0 	call	239fc <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
   22ce4:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
   22ce8:	1021883a 	mov	r16,r2
    if ( result == NOERROR_INWORK )
   22cec:	10bfffcc 	andi	r2,r2,65535
    bSyncSetByUser = FALSE;
   22cf0:	d0214c85 	stb	zero,-31438(gp)
    if ( result == NOERROR_INWORK )
   22cf4:	10c03fe0 	cmpeqi	r3,r2,255
   22cf8:	18004726 	beq	r3,zero,22e18 <AL_ControlInd+0x75c>
        bEcatWaitForAlControlRes = TRUE;
   22cfc:	00800044 	movi	r2,1
   22d00:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22d04:	00800844 	movi	r2,33
   22d08:	003fe606 	br	22ca4 <AL_ControlInd+0x5e8>
    bSyncSetByUser = FALSE;
   22d0c:	d0214c85 	stb	zero,-31438(gp)
            if(bErrAck)
   22d10:	bdc03fcc 	andi	r23,r23,255
   22d14:	b8000226 	beq	r23,zero,22d20 <AL_ControlInd+0x664>
                APPL_AckErrorInd(stateTrans);
   22d18:	9009883a 	mov	r4,r18
   22d1c:	00201e40 	call	201e4 <APPL_AckErrorInd>
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
   22d20:	d12135c3 	ldbu	r4,-31529(gp)
   22d24:	9c003fcc 	andi	r16,r19,255
   22d28:	2080030c 	andi	r2,r4,12
   22d2c:	10000526 	beq	r2,zero,22d44 <AL_ControlInd+0x688>
                    if(nPdOutputSize > 0)
   22d30:	d0a1370b 	ldhu	r2,-31524(gp)
   22d34:	10000726 	beq	r2,zero,22d54 <AL_ControlInd+0x698>
                        EnableSyncManChannel(PROCESS_DATA_OUT);
   22d38:	01000084 	movi	r4,2
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22d3c:	0021ad00 	call	21ad0 <EnableSyncManChannel>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d40:	d12135c3 	ldbu	r4,-31529(gp)
   22d44:	208003cc 	andi	r2,r4,15
   22d48:	80bf4726 	beq	r16,r2,22a68 <AL_ControlInd+0x3ac>
            result = NOERROR_NOSTATECHANGE;
   22d4c:	04003f84 	movi	r16,254
   22d50:	003f7806 	br	22b34 <AL_ControlInd+0x478>
                    if(nPdInputSize > 0)
   22d54:	d0a1378b 	ldhu	r2,-31522(gp)
   22d58:	103ffa26 	beq	r2,zero,22d44 <AL_ControlInd+0x688>
                        EnableSyncManChannel(PROCESS_DATA_IN);
   22d5c:	010000c4 	movi	r4,3
   22d60:	003ff606 	br	22d3c <AL_ControlInd+0x680>
            APPL_StopOutputHandler();
   22d64:	00202100 	call	20210 <APPL_StopOutputHandler>
            StopOutputHandler();
   22d68:	00225640 	call	22564 <StopOutputHandler>
            APPL_StopInputHandler();
   22d6c:	00202000 	call	20200 <APPL_StopInputHandler>
            StopInputHandler();
   22d70:	00225700 	call	22570 <StopInputHandler>
            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
   22d74:	b8800598 	cmpnei	r2,r23,22
   22d78:	10000c1e 	bne	r2,zero,22dac <AL_ControlInd+0x6f0>
                MBX_StopMailboxHandler();
   22d7c:	00239fc0 	call	239fc <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
   22d80:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                DisableSyncManChannel(MAILBOX_WRITE);
   22d84:	0009883a 	mov	r4,zero
   22d88:	0021a700 	call	21a70 <DisableSyncManChannel>
                DisableSyncManChannel(MAILBOX_READ);
   22d8c:	01000044 	movi	r4,1
   22d90:	0021a700 	call	21a70 <DisableSyncManChannel>
                nAlStatus = STATE_INIT;
   22d94:	00800044 	movi	r2,1
   22d98:	d0a135c5 	stb	r2,-31529(gp)
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22d9c:	98800058 	cmpnei	r2,r19,1
   22da0:	1000241e 	bne	r2,zero,22e34 <AL_ControlInd+0x778>
   22da4:	01000044 	movi	r4,1
   22da8:	003f1106 	br	229f0 <AL_ControlInd+0x334>
                nAlStatus = STATE_PREOP;
   22dac:	00800084 	movi	r2,2
   22db0:	d0a135c5 	stb	r2,-31529(gp)
    if ( result == NOERROR_INWORK )
   22db4:	bdc03fe0 	cmpeqi	r23,r23,255
   22db8:	b800041e 	bne	r23,zero,22dcc <AL_ControlInd+0x710>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22dbc:	98800098 	cmpnei	r2,r19,2
   22dc0:	10001e1e 	bne	r2,zero,22e3c <AL_ControlInd+0x780>
   22dc4:	01000084 	movi	r4,2
   22dc8:	003f0906 	br	229f0 <AL_ControlInd+0x334>
        bEcatWaitForAlControlRes = TRUE;
   22dcc:	00800044 	movi	r2,1
        nEcatStateTrans = stateTrans;
   22dd0:	8c403fcc 	andi	r17,r17,255
        bEcatWaitForAlControlRes = TRUE;
   22dd4:	d0a13885 	stb	r2,-31518(gp)
        nEcatStateTrans = stateTrans;
   22dd8:	d461380d 	sth	r17,-31520(gp)
        switch(nEcatStateTrans)
   22ddc:	90800528 	cmpgeui	r2,r18,20
   22de0:	1000031e 	bne	r2,zero,22df0 <AL_ControlInd+0x734>
   22de4:	948004a8 	cmpgeui	r18,r18,18
   22de8:	903f3a1e 	bne	r18,zero,22ad4 <AL_ControlInd+0x418>
   22dec:	003fae06 	br	22ca8 <AL_ControlInd+0x5ec>
   22df0:	90800920 	cmpeqi	r2,r18,36
   22df4:	103f711e 	bne	r2,zero,22bbc <AL_ControlInd+0x500>
   22df8:	94801220 	cmpeqi	r18,r18,72
   22dfc:	903f6f1e 	bne	r18,zero,22bbc <AL_ControlInd+0x500>
   22e00:	003fa906 	br	22ca8 <AL_ControlInd+0x5ec>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22e04:	d12135c3 	ldbu	r4,-31529(gp)
   22e08:	208003cc 	andi	r2,r4,15
   22e0c:	98bf1626 	beq	r19,r2,22a68 <AL_ControlInd+0x3ac>
            result = ALSTATUSCODE_INVALIDALCONTROL;
   22e10:	04000444 	movi	r16,17
   22e14:	003f4706 	br	22b34 <AL_ControlInd+0x478>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22e18:	d12135c3 	ldbu	r4,-31529(gp)
   22e1c:	20c003cc 	andi	r3,r4,15
   22e20:	98ff1126 	beq	r19,r3,22a68 <AL_ControlInd+0x3ac>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22e24:	103f2026 	beq	r2,zero,22aa8 <AL_ControlInd+0x3ec>
   22e28:	003f4206 	br	22b34 <AL_ControlInd+0x478>
                result = ALSTATUSCODE_EE_ERROR;
   22e2c:	04001444 	movi	r16,81
   22e30:	003f4006 	br	22b34 <AL_ControlInd+0x478>
    else if ( alControl != (nAlStatus & STATE_MASK) )
   22e34:	01000044 	movi	r4,1
   22e38:	003f3e06 	br	22b34 <AL_ControlInd+0x478>
   22e3c:	01000084 	movi	r4,2
   22e40:	003f3c06 	br	22b34 <AL_ControlInd+0x478>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22e44:	9908b03a 	or	r4,r19,r4
   22e48:	2100020c 	andi	r4,r4,8
   22e4c:	2000101e 	bne	r4,zero,22e90 <AL_ControlInd+0x7d4>
                alControl |= STATE_CHANGE;
   22e50:	9d400414 	ori	r21,r19,16
            nAlStatus |= STATE_CHANGE;
   22e54:	d56135c5 	stb	r21,-31529(gp)
        bEcatWaitForAlControlRes = FALSE;
   22e58:	d0213885 	stb	zero,-31518(gp)
        SetALStatus(nAlStatus, result);
   22e5c:	b17fffcc 	andi	r5,r22,65535
   22e60:	a9003fcc 	andi	r4,r21,255
}
   22e64:	dfc00817 	ldw	ra,32(sp)
   22e68:	ddc00717 	ldw	r23,28(sp)
   22e6c:	dd800617 	ldw	r22,24(sp)
   22e70:	dd400517 	ldw	r21,20(sp)
   22e74:	dd000417 	ldw	r20,16(sp)
   22e78:	dcc00317 	ldw	r19,12(sp)
   22e7c:	dc800217 	ldw	r18,8(sp)
   22e80:	dc400117 	ldw	r17,4(sp)
   22e84:	dc000017 	ldw	r16,0(sp)
   22e88:	dec00904 	addi	sp,sp,36
        SetALStatus(nAlStatus, 0);
   22e8c:	00226181 	jmpi	22618 <SetALStatus>
        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
   22e90:	0021883a 	mov	r16,zero
            if(bEcatOutputUpdateRunning)
   22e94:	d0a14283 	ldbu	r2,-31478(gp)
   22e98:	10000226 	beq	r2,zero,22ea4 <AL_ControlInd+0x7e8>
                APPL_StopOutputHandler();
   22e9c:	00202100 	call	20210 <APPL_StopOutputHandler>
                StopOutputHandler();
   22ea0:	00225640 	call	22564 <StopOutputHandler>
            if(nPdOutputSize > 0)
   22ea4:	d0a1370b 	ldhu	r2,-31524(gp)
   22ea8:	10000726 	beq	r2,zero,22ec8 <AL_ControlInd+0x80c>
                DisableSyncManChannel(PROCESS_DATA_OUT);
   22eac:	01000084 	movi	r4,2
                DisableSyncManChannel(PROCESS_DATA_IN);
   22eb0:	0021a700 	call	21a70 <DisableSyncManChannel>
        if ( result != 0 )
   22eb4:	80bfffcc 	andi	r2,r16,65535
   22eb8:	103f211e 	bne	r2,zero,22b40 <AL_ControlInd+0x484>
            if ( alStatusCode != 0 )
   22ebc:	a53fffcc 	andi	r20,r20,65535
   22ec0:	a03fe31e 	bne	r20,zero,22e50 <AL_ControlInd+0x794>
   22ec4:	003efa06 	br	22ab0 <AL_ControlInd+0x3f4>
                if(nPdInputSize > 0)
   22ec8:	d0a1378b 	ldhu	r2,-31522(gp)
   22ecc:	103ff926 	beq	r2,zero,22eb4 <AL_ControlInd+0x7f8>
                DisableSyncManChannel(PROCESS_DATA_IN);
   22ed0:	010000c4 	movi	r4,3
   22ed4:	003ff606 	br	22eb0 <AL_ControlInd+0x7f4>

00022ed8 <AL_ControlRes>:
 \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the application specific state transition function is called.
 \brief    If the pending state transition is triggered by the application the transition need to be completed by the application (ECAT_StateChange())
  *////////////////////////////////////////////////////////////////////////////////////////
void AL_ControlRes(void)
{
    if(bEcatWaitForAlControlRes)
   22ed8:	d0a13883 	ldbu	r2,-31518(gp)
   22edc:	1000bf26 	beq	r2,zero,231dc <AL_ControlRes+0x304>
        UINT8 Status = 0;
        UINT16 StatusCode = 0;

        if(EsmTimeoutCounter == 0)
        {
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22ee0:	d0a1380b 	ldhu	r2,-31520(gp)
        if(EsmTimeoutCounter == 0)
   22ee4:	d121410f 	ldh	r4,-31484(gp)
{
   22ee8:	defffc04 	addi	sp,sp,-16
   22eec:	dfc00315 	stw	ra,12(sp)
   22ef0:	dc800215 	stw	r18,8(sp)
   22ef4:	dc400115 	stw	r17,4(sp)
   22ef8:	dc000015 	stw	r16,0(sp)
   22efc:	10ffffcc 	andi	r3,r2,65535
        if(EsmTimeoutCounter == 0)
   22f00:	2000551e 	bne	r4,zero,23058 <AL_ControlRes+0x180>
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22f04:	1822d13a 	srli	r17,r3,4

            /* ESM timeout expired*/
            switch(nEcatStateTrans)
   22f08:	19000920 	cmpeqi	r4,r3,36
            Status =  (UINT8)(nEcatStateTrans >> 4);
   22f0c:	8825883a 	mov	r18,r17
            switch(nEcatStateTrans)
   22f10:	2000331e 	bne	r4,zero,22fe0 <AL_ControlRes+0x108>
   22f14:	19000968 	cmpgeui	r4,r3,37
   22f18:	2000091e 	bne	r4,zero,22f40 <AL_ControlRes+0x68>
   22f1c:	10bffb84 	addi	r2,r2,-18
   22f20:	10bfffcc 	andi	r2,r2,65535
   22f24:	108000a8 	cmpgeui	r2,r2,2
   22f28:	10001e26 	beq	r2,zero,22fa4 <AL_ControlRes+0xcc>
                    }             
                break;
            }//Switch - transition
        }

        if(Status != 0)
   22f2c:	8c403fcc 	andi	r17,r17,255
   22f30:	88005126 	beq	r17,zero,23078 <AL_ControlRes+0x1a0>
        {
            /*Pending state transition finished => write AL Status and AL Status Code*/
            bEcatWaitForAlControlRes = FALSE;
   22f34:	d0213885 	stb	zero,-31518(gp)
        UINT16 StatusCode = 0;
   22f38:	0021883a 	mov	r16,zero
   22f3c:	00001106 	br	22f84 <AL_ControlRes+0xac>
            switch(nEcatStateTrans)
   22f40:	18c01220 	cmpeqi	r3,r3,72
   22f44:	183ff926 	beq	r3,zero,22f2c <AL_ControlRes+0x54>
                    if(bDcSyncActive)
   22f48:	d0a14183 	ldbu	r2,-31482(gp)
   22f4c:	10002c26 	beq	r2,zero,23000 <AL_ControlRes+0x128>
                        if(!bDcRunning)
   22f50:	d0a14083 	ldbu	r2,-31486(gp)
   22f54:	10003a26 	beq	r2,zero,23040 <AL_ControlRes+0x168>
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
   22f58:	d0a14203 	ldbu	r2,-31480(gp)
   22f5c:	1000021e 	bne	r2,zero,22f68 <AL_ControlRes+0x90>
   22f60:	d0a1370b 	ldhu	r2,-31524(gp)
   22f64:	1000381e 	bne	r2,zero,23048 <AL_ControlRes+0x170>
                        else if (!bSmSyncSequenceValid)
   22f68:	d0a13f03 	ldbu	r2,-31492(gp)
   22f6c:	10003826 	beq	r2,zero,23050 <AL_ControlRes+0x178>
                            bEcatOutputUpdateRunning = TRUE;
   22f70:	00800044 	movi	r2,1
   22f74:	d0a14285 	stb	r2,-31478(gp)
            bEcatWaitForAlControlRes = FALSE;
   22f78:	d0213885 	stb	zero,-31518(gp)
                            StatusCode = 0;
   22f7c:	0021883a 	mov	r16,zero
                            Status = STATE_OP;
   22f80:	04800204 	movi	r18,8
            if (StatusCode != 0)
            {
                Status |= STATE_CHANGE;
            }

            SetALStatus(Status,StatusCode);
   22f84:	817fffcc 	andi	r5,r16,65535
   22f88:	91003fcc 	andi	r4,r18,255
        }
    }// Pending state transition (bEcatWaitForAlControlRes == true)
}
   22f8c:	dfc00317 	ldw	ra,12(sp)
   22f90:	dc800217 	ldw	r18,8(sp)
   22f94:	dc400117 	ldw	r17,4(sp)
   22f98:	dc000017 	ldw	r16,0(sp)
   22f9c:	dec00404 	addi	sp,sp,16
            SetALStatus(Status,StatusCode);
   22fa0:	00226181 	jmpi	22618 <SetALStatus>
                        if (!bApplEsmPending)
   22fa4:	d0a138c3 	ldbu	r2,-31517(gp)
   22fa8:	1000011e 	bne	r2,zero,22fb0 <AL_ControlRes+0xd8>
                            APPL_StopMailboxHandler();
   22fac:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                    MBX_StopMailboxHandler();
   22fb0:	00239fc0 	call	239fc <MBX_StopMailboxHandler>
                    if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
   22fb4:	d0a13903 	ldbu	r2,-31516(gp)
   22fb8:	108003cc 	andi	r2,r2,15
   22fbc:	10800058 	cmpnei	r2,r2,1
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   22fc0:	1000811e 	bne	r2,zero,231c8 <AL_ControlRes+0x2f0>
        if(Status != 0)
   22fc4:	88803fcc 	andi	r2,r17,255
                        StatusCode = u16LocalErrorCode;
   22fc8:	d421398b 	ldhu	r16,-31514(gp)
        if(Status != 0)
   22fcc:	10002a26 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   22fd0:	d0213885 	stb	zero,-31518(gp)
            if (StatusCode != 0)
   22fd4:	80bfffcc 	andi	r2,r16,65535
   22fd8:	1000171e 	bne	r2,zero,23038 <AL_ControlRes+0x160>
   22fdc:	003fe906 	br	22f84 <AL_ControlRes+0xac>
                        if (!bApplEsmPending)
   22fe0:	d0a138c3 	ldbu	r2,-31517(gp)
   22fe4:	1000011e 	bne	r2,zero,22fec <AL_ControlRes+0x114>
                            APPL_StopInputHandler();
   22fe8:	00202000 	call	20200 <APPL_StopInputHandler>
                    StopInputHandler();
   22fec:	00225700 	call	22570 <StopInputHandler>
                    if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
   22ff0:	d0a13903 	ldbu	r2,-31516(gp)
   22ff4:	108003cc 	andi	r2,r2,15
   22ff8:	10800098 	cmpnei	r2,r2,2
   22ffc:	003ff006 	br	22fc0 <AL_ControlRes+0xe8>
                            if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
   23000:	d0a13903 	ldbu	r2,-31516(gp)
   23004:	108003cc 	andi	r2,r2,15
   23008:	10800118 	cmpnei	r2,r2,4
   2300c:	103fd81e 	bne	r2,zero,22f70 <AL_ControlRes+0x98>
                                StatusCode = u16LocalErrorCode;
   23010:	d421398b 	ldhu	r16,-31514(gp)
                    if(StatusCode != 0)
   23014:	80bfffcc 	andi	r2,r16,65535
   23018:	103fc426 	beq	r2,zero,22f2c <AL_ControlRes+0x54>
                            if (!bApplEsmPending)
   2301c:	d0a138c3 	ldbu	r2,-31517(gp)
   23020:	1000011e 	bne	r2,zero,23028 <AL_ControlRes+0x150>
                                APPL_StopOutputHandler();
   23024:	00202100 	call	20210 <APPL_StopOutputHandler>
                        StopOutputHandler();
   23028:	00225640 	call	22564 <StopOutputHandler>
        if(Status != 0)
   2302c:	88803fcc 	andi	r2,r17,255
   23030:	10001126 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   23034:	d0213885 	stb	zero,-31518(gp)
                Status |= STATE_CHANGE;
   23038:	8c800414 	ori	r18,r17,16
   2303c:	003fd106 	br	22f84 <AL_ControlRes+0xac>
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
   23040:	04000b44 	movi	r16,45
   23044:	003ff506 	br	2301c <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
   23048:	040006c4 	movi	r16,27
   2304c:	003ff306 	br	2301c <AL_ControlRes+0x144>
                            StatusCode = ALSTATUSCODE_SYNCERROR;
   23050:	04000684 	movi	r16,26
   23054:	003ff106 	br	2301c <AL_ControlRes+0x144>
            switch(nEcatStateTrans)
   23058:	19000920 	cmpeqi	r4,r3,36
   2305c:	20003d1e 	bne	r4,zero,23154 <AL_ControlRes+0x27c>
   23060:	19000968 	cmpgeui	r4,r3,37
   23064:	20000a1e 	bne	r4,zero,23090 <AL_ControlRes+0x1b8>
   23068:	10bffb84 	addi	r2,r2,-18
   2306c:	10bfffcc 	andi	r2,r2,65535
   23070:	108000a8 	cmpgeui	r2,r2,2
   23074:	10001f26 	beq	r2,zero,230f4 <AL_ControlRes+0x21c>
}
   23078:	dfc00317 	ldw	ra,12(sp)
   2307c:	dc800217 	ldw	r18,8(sp)
   23080:	dc400117 	ldw	r17,4(sp)
   23084:	dc000017 	ldw	r16,0(sp)
   23088:	dec00404 	addi	sp,sp,16
   2308c:	f800283a 	ret
            switch(nEcatStateTrans)
   23090:	18c01220 	cmpeqi	r3,r3,72
   23094:	183ff826 	beq	r3,zero,23078 <AL_ControlRes+0x1a0>
                   if(bApplEsmPending)
   23098:	d0a138c3 	ldbu	r2,-31517(gp)
   2309c:	103ff626 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
                        if(bDcSyncActive)
   230a0:	d0a14183 	ldbu	r2,-31482(gp)
   230a4:	10004126 	beq	r2,zero,231ac <AL_ControlRes+0x2d4>
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
   230a8:	d0a13e8f 	ldh	r2,-31494(gp)
   230ac:	00bff20e 	bge	zero,r2,23078 <AL_ControlRes+0x1a0>
   230b0:	d0e13e0f 	ldh	r3,-31496(gp)
   230b4:	18bff016 	blt	r3,r2,23078 <AL_ControlRes+0x1a0>
                                i16WaitForPllRunningTimeout = 0;
   230b8:	d0213e8d 	sth	zero,-31494(gp)
                                i16WaitForPllRunningCnt = 0;
   230bc:	d0213e0d 	sth	zero,-31496(gp)
                                bApplEsmPending = FALSE;
   230c0:	d02138c5 	stb	zero,-31517(gp)
                                result = APPL_StartOutputHandler();
   230c4:	00202080 	call	20208 <APPL_StartOutputHandler>
                                if(result == 0)
   230c8:	10bfffcc 	andi	r2,r2,65535
   230cc:	103fa826 	beq	r2,zero,22f70 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   230d0:	10803fe0 	cmpeqi	r2,r2,255
   230d4:	103fe81e 	bne	r2,zero,23078 <AL_ControlRes+0x1a0>
                                        APPL_StopOutputHandler();
   230d8:	00202100 	call	20210 <APPL_StopOutputHandler>
}
   230dc:	dfc00317 	ldw	ra,12(sp)
   230e0:	dc800217 	ldw	r18,8(sp)
   230e4:	dc400117 	ldw	r17,4(sp)
   230e8:	dc000017 	ldw	r16,0(sp)
   230ec:	dec00404 	addi	sp,sp,16
                                        StopOutputHandler();
   230f0:	00225641 	jmpi	22564 <StopOutputHandler>
                    if(bApplEsmPending)
   230f4:	d0a138c3 	ldbu	r2,-31517(gp)
   230f8:	103fdf26 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
                        bApplEsmPending = FALSE;
   230fc:	d02138c5 	stb	zero,-31517(gp)
                        result = APPL_StartMailboxHandler();
   23100:	00201e80 	call	201e8 <APPL_StartMailboxHandler>
   23104:	1021883a 	mov	r16,r2
                        if(result == 0)
   23108:	10bfffcc 	andi	r2,r2,65535
   2310c:	1000081e 	bne	r2,zero,23130 <AL_ControlRes+0x258>
                            bMbxRunning = TRUE;
   23110:	00800044 	movi	r2,1
   23114:	d0a14b45 	stb	r2,-31443(gp)
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   23118:	d0a13803 	ldbu	r2,-31520(gp)
   2311c:	108003cc 	andi	r2,r2,15
   23120:	1025883a 	mov	r18,r2
        if(Status != 0)
   23124:	103fd426 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   23128:	d0213885 	stb	zero,-31518(gp)
            if (StatusCode != 0)
   2312c:	003f9506 	br	22f84 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   23130:	10803fe0 	cmpeqi	r2,r2,255
   23134:	103fd01e 	bne	r2,zero,23078 <AL_ControlRes+0x1a0>
                                APPL_StopMailboxHandler();
   23138:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
}
   2313c:	dfc00317 	ldw	ra,12(sp)
   23140:	dc800217 	ldw	r18,8(sp)
   23144:	dc400117 	ldw	r17,4(sp)
   23148:	dc000017 	ldw	r16,0(sp)
   2314c:	dec00404 	addi	sp,sp,16
                                MBX_StopMailboxHandler();
   23150:	00239fc1 	jmpi	239fc <MBX_StopMailboxHandler>
                    if(bApplEsmPending)
   23154:	d0a138c3 	ldbu	r2,-31517(gp)
   23158:	103fc726 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
                        result = APPL_StartInputHandler(&u16ALEventMask);
   2315c:	d1213384 	addi	r4,gp,-31538
                        bApplEsmPending = FALSE;
   23160:	d02138c5 	stb	zero,-31517(gp)
                        result = APPL_StartInputHandler(&u16ALEventMask);
   23164:	00201f80 	call	201f8 <APPL_StartInputHandler>
   23168:	1021883a 	mov	r16,r2
                        if(result == 0)
   2316c:	10bfffcc 	andi	r2,r2,65535
   23170:	1000051e 	bne	r2,zero,23188 <AL_ControlRes+0x2b0>
                            bEcatInputUpdateRunning = TRUE;
   23174:	00800044 	movi	r2,1
   23178:	d0a14245 	stb	r2,-31479(gp)
            bEcatWaitForAlControlRes = FALSE;
   2317c:	d0213885 	stb	zero,-31518(gp)
                            Status = STATE_SAFEOP;
   23180:	04800104 	movi	r18,4
   23184:	003f7f06 	br	22f84 <AL_ControlRes+0xac>
                            if(result != NOERROR_INWORK)
   23188:	10803fe0 	cmpeqi	r2,r2,255
   2318c:	103fba1e 	bne	r2,zero,23078 <AL_ControlRes+0x1a0>
                                APPL_StopInputHandler();
   23190:	00202000 	call	20200 <APPL_StopInputHandler>
}
   23194:	dfc00317 	ldw	ra,12(sp)
   23198:	dc800217 	ldw	r18,8(sp)
   2319c:	dc400117 	ldw	r17,4(sp)
   231a0:	dc000017 	ldw	r16,0(sp)
   231a4:	dec00404 	addi	sp,sp,16
                                StopInputHandler();
   231a8:	00225701 	jmpi	22570 <StopInputHandler>
                                bApplEsmPending = FALSE;  
   231ac:	d02138c5 	stb	zero,-31517(gp)
                                result = APPL_StartOutputHandler();
   231b0:	00202080 	call	20208 <APPL_StartOutputHandler>
                                if(result == 0)
   231b4:	10bfffcc 	andi	r2,r2,65535
   231b8:	103f6d26 	beq	r2,zero,22f70 <AL_ControlRes+0x98>
                                    if(result != NOERROR_INWORK)
   231bc:	10803fd8 	cmpnei	r2,r2,255
   231c0:	103fad26 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
   231c4:	003fc406 	br	230d8 <AL_ControlRes+0x200>
        if(Status != 0)
   231c8:	88803fcc 	andi	r2,r17,255
   231cc:	103faa26 	beq	r2,zero,23078 <AL_ControlRes+0x1a0>
            bEcatWaitForAlControlRes = FALSE;
   231d0:	d0213885 	stb	zero,-31518(gp)
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
   231d4:	04000044 	movi	r16,1
   231d8:	003f9706 	br	23038 <AL_ControlRes+0x160>
   231dc:	f800283a 	ret

000231e0 <DC_CheckWatchdog>:

*////////////////////////////////////////////////////////////////////////////////////////
void DC_CheckWatchdog(void)
{

    if(bDcSyncActive && bEcatInputUpdateRunning)
   231e0:	d0a14183 	ldbu	r2,-31482(gp)
   231e4:	10002d26 	beq	r2,zero,2329c <DC_CheckWatchdog+0xbc>
   231e8:	d0a14243 	ldbu	r2,-31479(gp)
   231ec:	10002b26 	beq	r2,zero,2329c <DC_CheckWatchdog+0xbc>
    {
        /*If Sync0 watchdog is enabled and expired*/
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
   231f0:	d0e13d0b 	ldhu	r3,-31500(gp)
   231f4:	18000926 	beq	r3,zero,2321c <DC_CheckWatchdog+0x3c>
   231f8:	d0a13d8b 	ldhu	r2,-31498(gp)
   231fc:	113fffcc 	andi	r4,r2,65535
   23200:	20c00436 	bltu	r4,r3,23214 <DC_CheckWatchdog+0x34>
                {
                    i16WaitForPllRunningCnt = 0;
                }
            }
        }
        else if(bSmSyncSequenceValid)
   23204:	d0a13f03 	ldbu	r2,-31492(gp)
                bDcRunning = FALSE;        
   23208:	d0214085 	stb	zero,-31486(gp)
        else if(bSmSyncSequenceValid)
   2320c:	1000211e 	bne	r2,zero,23294 <DC_CheckWatchdog+0xb4>
   23210:	f800283a 	ret
                Sync0WdCounter ++;
   23214:	10800044 	addi	r2,r2,1
   23218:	d0a13d8d 	sth	r2,-31498(gp)
            if(Sync1WdValue > 0)
   2321c:	d0e13c0b 	ldhu	r3,-31504(gp)
            bDcRunning = TRUE;
   23220:	00800044 	movi	r2,1
   23224:	d0a14085 	stb	r2,-31486(gp)
            if(Sync1WdValue > 0)
   23228:	18000526 	beq	r3,zero,23240 <DC_CheckWatchdog+0x60>
                if(Sync1WdCounter < Sync1WdValue)
   2322c:	d0a13c8b 	ldhu	r2,-31502(gp)
   23230:	113fffcc 	andi	r4,r2,65535
   23234:	20fff32e 	bgeu	r4,r3,23204 <DC_CheckWatchdog+0x24>
                    Sync1WdCounter ++;
   23238:	10800044 	addi	r2,r2,1
   2323c:	d0a13c8d 	sth	r2,-31502(gp)
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
   23240:	008000b4 	movhi	r2,2
   23244:	109fbb0b 	ldhu	r2,32492(r2)
   23248:	10000326 	beq	r2,zero,23258 <DC_CheckWatchdog+0x78>
   2324c:	00c000f4 	movhi	r3,3
   23250:	18e18b0b 	ldhu	r3,-31188(r3)
   23254:	1880082e 	bgeu	r3,r2,23278 <DC_CheckWatchdog+0x98>
                bSmSyncSequenceValid = TRUE;
   23258:	00800044 	movi	r2,1
   2325c:	d0a13f05 	stb	r2,-31492(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23260:	d0a13e8f 	ldh	r2,-31494(gp)
   23264:	00800d0e 	bge	zero,r2,2329c <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt++;
   23268:	d0a13e0b 	ldhu	r2,-31496(gp)
   2326c:	10800044 	addi	r2,r2,1
   23270:	d0a13e0d 	sth	r2,-31496(gp)
   23274:	f800283a 	ret
            else if (bSmSyncSequenceValid)
   23278:	d0a13f03 	ldbu	r2,-31492(gp)
   2327c:	10000726 	beq	r2,zero,2329c <DC_CheckWatchdog+0xbc>
                if (i16WaitForPllRunningTimeout > 0)
   23280:	d0a13e8f 	ldh	r2,-31494(gp)
                    bSmSyncSequenceValid = FALSE;
   23284:	d0213f05 	stb	zero,-31492(gp)
                if (i16WaitForPllRunningTimeout > 0)
   23288:	0080040e 	bge	zero,r2,2329c <DC_CheckWatchdog+0xbc>
                    i16WaitForPllRunningCnt = 0;
   2328c:	d0213e0d 	sth	zero,-31496(gp)
   23290:	f800283a 	ret
        {
           bSmSyncSequenceValid = FALSE;
   23294:	d0213f05 	stb	zero,-31492(gp)
        }
    }
}
   23298:	f800283a 	ret
   2329c:	f800283a 	ret

000232a0 <CheckIfEcatError>:
*////////////////////////////////////////////////////////////////////////////////////////
void CheckIfEcatError(void)
{
   /*if the watchdog is enabled check the process data watchdog in the ESC
   and set the AL status code 0x1B if the watchdog expired*/
   if (EcatWdValue != 0)
   232a0:	d0a1350b 	ldhu	r2,-31532(gp)
   232a4:	10002626 	beq	r2,zero,23340 <CheckIfEcatError+0xa0>
{
   232a8:	defffe04 	addi	sp,sp,-8
   {
      /*watchdog time is set => watchdog is active*/
      UINT16 WdStatusOK = 0;

      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   232ac:	01800084 	movi	r6,2
   232b0:	01411004 	movi	r5,1088
   232b4:	d9000084 	addi	r4,sp,2
{
   232b8:	dfc00115 	stw	ra,4(sp)
      UINT16 WdStatusOK = 0;
   232bc:	d800008d 	sth	zero,2(sp)
      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
   232c0:	00207400 	call	20740 <HW_EscRead>
      WdStatusOK = SWAPWORD(WdStatusOK);

      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
   232c4:	d880008b 	ldhu	r2,2(sp)
   232c8:	1080004c 	andi	r2,r2,1
   232cc:	10000d1e 	bne	r2,zero,23304 <CheckIfEcatError+0x64>
   232d0:	d0a1370b 	ldhu	r2,-31524(gp)
   232d4:	10000b26 	beq	r2,zero,23304 <CheckIfEcatError+0x64>
      {
         /*The device is in OP state*/

         if (bEcatOutputUpdateRunning
   232d8:	d0a14283 	ldbu	r2,-31478(gp)
   232dc:	10000826 	beq	r2,zero,23300 <CheckIfEcatError+0x60>
            && bEcatFirstOutputsReceived
   232e0:	d0a14203 	ldbu	r2,-31480(gp)
   232e4:	10000626 	beq	r2,zero,23300 <CheckIfEcatError+0x60>
            )
         {
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
   232e8:	014006c4 	movi	r5,27
   232ec:	01000104 	movi	r4,4
   232f0:	00226bc0 	call	226bc <AL_ControlInd>
               return;
           }
        
       }
   }
}
   232f4:	dfc00117 	ldw	ra,4(sp)
   232f8:	dec00204 	addi	sp,sp,8
   232fc:	f800283a 	ret
            bEcatFirstOutputsReceived = FALSE;
   23300:	d0214205 	stb	zero,-31480(gp)
   if(bDcSyncActive)
   23304:	d0a14183 	ldbu	r2,-31482(gp)
   23308:	103ffa26 	beq	r2,zero,232f4 <CheckIfEcatError+0x54>
       if(bEcatOutputUpdateRunning)
   2330c:	d0a14283 	ldbu	r2,-31478(gp)
   23310:	103ff826 	beq	r2,zero,232f4 <CheckIfEcatError+0x54>
           if(!bDcRunning)
   23314:	d0a14083 	ldbu	r2,-31486(gp)
   23318:	1000051e 	bne	r2,zero,23330 <CheckIfEcatError+0x90>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   2331c:	01400b04 	movi	r5,44
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   23320:	01000104 	movi	r4,4
}
   23324:	dfc00117 	ldw	ra,4(sp)
   23328:	dec00204 	addi	sp,sp,8
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   2332c:	00226bc1 	jmpi	226bc <AL_ControlInd>
           else if(!bSmSyncSequenceValid)
   23330:	d0a13f03 	ldbu	r2,-31492(gp)
   23334:	103fef1e 	bne	r2,zero,232f4 <CheckIfEcatError+0x54>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   23338:	01400684 	movi	r5,26
   2333c:	003ff806 	br	23320 <CheckIfEcatError+0x80>
   if(bDcSyncActive)
   23340:	d0a14183 	ldbu	r2,-31482(gp)
   23344:	10000b26 	beq	r2,zero,23374 <CheckIfEcatError+0xd4>
       if(bEcatOutputUpdateRunning)
   23348:	d0a14283 	ldbu	r2,-31478(gp)
   2334c:	10000926 	beq	r2,zero,23374 <CheckIfEcatError+0xd4>
           if(!bDcRunning)
   23350:	d0a14083 	ldbu	r2,-31486(gp)
   23354:	1000031e 	bne	r2,zero,23364 <CheckIfEcatError+0xc4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
   23358:	01400b04 	movi	r5,44
   2335c:	01000104 	movi	r4,4
   23360:	003ff206 	br	2332c <CheckIfEcatError+0x8c>
           else if(!bSmSyncSequenceValid)
   23364:	d0a13f03 	ldbu	r2,-31492(gp)
   23368:	1000021e 	bne	r2,zero,23374 <CheckIfEcatError+0xd4>
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
   2336c:	01400684 	movi	r5,26
   23370:	003ffa06 	br	2335c <CheckIfEcatError+0xbc>
   23374:	f800283a 	ret

00023378 <ECAT_StateChange>:
 \brief    This function changes the state of the EtherCAT slave if the requested state
             is lower than the actual state, otherwise the error condition will be reset.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
{
   23378:	defffe04 	addi	sp,sp,-8
   2337c:	dc000015 	stw	r16,0(sp)
   23380:	dfc00115 	stw	ra,4(sp)
    UINT8 Status = alStatus;

    /*ECATCHANGE_START(V5.13) ESM1*/
    /*return in case of invalid parameters*/
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23384:	2c3fffcc 	andi	r16,r5,65535
   23388:	8000201e 	bne	r16,zero,2340c <ECAT_StateChange+0x94>
    {
        return;
    }

    /* call the application requested state transition only once*/
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   2338c:	d0a13883 	ldbu	r2,-31518(gp)
   23390:	10000a1e 	bne	r2,zero,233bc <ECAT_StateChange+0x44>
   23394:	d0a13903 	ldbu	r2,-31516(gp)
   23398:	21003fcc 	andi	r4,r4,255
   2339c:	2080021e 	bne	r4,r2,233a8 <ECAT_StateChange+0x30>
   233a0:	d0a1398b 	ldhu	r2,-31514(gp)
   233a4:	10002526 	beq	r2,zero,2343c <ECAT_StateChange+0xc4>
               /* no error pending and the target state is lower than the current one*/
                AL_ControlInd(alStatus, alStatusCode);
            }
        }
        /*ECATCHANGE_START(V5.13) ESM1*/
        else if (u8LocalErrorState != 0)
   233a8:	d0a13903 	ldbu	r2,-31516(gp)
   233ac:	10002326 	beq	r2,zero,2343c <ECAT_StateChange+0xc4>
                u8LocalErrorState = 0;
   233b0:	d0213905 	stb	zero,-31516(gp)
                u16LocalErrorCode = alStatusCode;
   233b4:	d021398d 	sth	zero,-31514(gp)
   233b8:	00002006 	br	2343c <ECAT_StateChange+0xc4>
        if(bApplEsmPending)
   233bc:	d0a138c3 	ldbu	r2,-31517(gp)
   233c0:	103ffb1e 	bne	r2,zero,233b0 <ECAT_StateChange+0x38>
                switch(nEcatStateTrans)
   233c4:	d0a1380b 	ldhu	r2,-31520(gp)
   233c8:	10ffffcc 	andi	r3,r2,65535
   233cc:	19000920 	cmpeqi	r4,r3,36
   233d0:	20004b1e 	bne	r4,zero,23500 <ECAT_StateChange+0x188>
   233d4:	19000968 	cmpgeui	r4,r3,37
   233d8:	2000411e 	bne	r4,zero,234e0 <ECAT_StateChange+0x168>
   233dc:	10bffb84 	addi	r2,r2,-18
   233e0:	10bfffcc 	andi	r2,r2,65535
   233e4:	108000a8 	cmpgeui	r2,r2,2
   233e8:	10004226 	beq	r2,zero,234f4 <ECAT_StateChange+0x17c>
                else if (u8LocalErrorState != 0)
   233ec:	d0a13903 	ldbu	r2,-31516(gp)
                bEcatWaitForAlControlRes = FALSE;
   233f0:	d0213885 	stb	zero,-31518(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   233f4:	d121380b 	ldhu	r4,-31520(gp)
                else if (u8LocalErrorState != 0)
   233f8:	10000226 	beq	r2,zero,23404 <ECAT_StateChange+0x8c>
                    u8LocalErrorState = 0;
   233fc:	d0213905 	stb	zero,-31516(gp)
                    u16LocalErrorCode = 0x00;
   23400:	d021398d 	sth	zero,-31514(gp)
                Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
   23404:	210003cc 	andi	r4,r4,15
   23408:	00002406 	br	2349c <ECAT_StateChange+0x124>
   2340c:	208003cc 	andi	r2,r4,15
    if (alStatusCode != 0 && !STATE_VALID(alStatus))
   23410:	00c04584 	movi	r3,278
   23414:	1886d83a 	srl	r3,r3,r2
   23418:	18c0004c 	andi	r3,r3,1
   2341c:	18000726 	beq	r3,zero,2343c <ECAT_StateChange+0xc4>
    if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == alStatusCode)
   23420:	d0e13883 	ldbu	r3,-31518(gp)
   23424:	1800091e 	bne	r3,zero,2344c <ECAT_StateChange+0xd4>
   23428:	d0e13903 	ldbu	r3,-31516(gp)
   2342c:	21003fcc 	andi	r4,r4,255
   23430:	1900381e 	bne	r3,r4,23514 <ECAT_StateChange+0x19c>
   23434:	d0e1398b 	ldhu	r3,-31514(gp)
   23438:	80c0361e 	bne	r16,r3,23514 <ECAT_StateChange+0x19c>
            u8LocalErrorState = 0;
            u16LocalErrorCode = 0x00;
        }
        /*ECATCHANGE_END(V5.13) ESM1*/
    }
}
   2343c:	dfc00117 	ldw	ra,4(sp)
   23440:	dc000017 	ldw	r16,0(sp)
   23444:	dec00204 	addi	sp,sp,8
   23448:	f800283a 	ret
        if(bApplEsmPending)
   2344c:	d0e138c3 	ldbu	r3,-31517(gp)
                u8LocalErrorState = (alStatus & STATE_MASK);
   23450:	d0a13905 	stb	r2,-31516(gp)
                u16LocalErrorCode = alStatusCode;
   23454:	d161398d 	sth	r5,-31514(gp)
        if(bApplEsmPending)
   23458:	18000226 	beq	r3,zero,23464 <ECAT_StateChange+0xec>
                EsmTimeoutCounter = 0;
   2345c:	d021410d 	sth	zero,-31484(gp)
   23460:	003ff606 	br	2343c <ECAT_StateChange+0xc4>
                switch(nEcatStateTrans)
   23464:	d0a1380b 	ldhu	r2,-31520(gp)
   23468:	10ffffcc 	andi	r3,r2,65535
   2346c:	19000920 	cmpeqi	r4,r3,36
   23470:	2000181e 	bne	r4,zero,234d4 <ECAT_StateChange+0x15c>
   23474:	19000968 	cmpgeui	r4,r3,37
   23478:	20000e1e 	bne	r4,zero,234b4 <ECAT_StateChange+0x13c>
   2347c:	10bffb84 	addi	r2,r2,-18
   23480:	10bfffcc 	andi	r2,r2,65535
   23484:	108000a8 	cmpgeui	r2,r2,2
   23488:	10000f26 	beq	r2,zero,234c8 <ECAT_StateChange+0x150>
                Status =  (UINT8)(nEcatStateTrans >> 4);
   2348c:	d121380b 	ldhu	r4,-31520(gp)
                bEcatWaitForAlControlRes = FALSE;
   23490:	d0213885 	stb	zero,-31518(gp)
                Status =  (UINT8)(nEcatStateTrans >> 4);
   23494:	2008d13a 	srli	r4,r4,4
                    Status |= STATE_CHANGE;
   23498:	21000414 	ori	r4,r4,16
                SetALStatus(Status,alStatusCode);
   2349c:	800b883a 	mov	r5,r16
   234a0:	21003fcc 	andi	r4,r4,255
}
   234a4:	dfc00117 	ldw	ra,4(sp)
   234a8:	dc000017 	ldw	r16,0(sp)
   234ac:	dec00204 	addi	sp,sp,8
                SetALStatus(Status,alStatusCode);
   234b0:	00226181 	jmpi	22618 <SetALStatus>
                switch(nEcatStateTrans)
   234b4:	18c01220 	cmpeqi	r3,r3,72
   234b8:	183ff426 	beq	r3,zero,2348c <ECAT_StateChange+0x114>
                          APPL_StopOutputHandler();
   234bc:	00202100 	call	20210 <APPL_StopOutputHandler>
                          StopOutputHandler();
   234c0:	00225640 	call	22564 <StopOutputHandler>
                    break;
   234c4:	003ff106 	br	2348c <ECAT_StateChange+0x114>
                          APPL_StopMailboxHandler();
   234c8:	00201f00 	call	201f0 <APPL_StopMailboxHandler>
                          MBX_StopMailboxHandler();
   234cc:	00239fc0 	call	239fc <MBX_StopMailboxHandler>
                    break;
   234d0:	003fee06 	br	2348c <ECAT_StateChange+0x114>
                          APPL_StopInputHandler();
   234d4:	00202000 	call	20200 <APPL_StopInputHandler>
                          StopInputHandler();
   234d8:	00225700 	call	22570 <StopInputHandler>
                    break;
   234dc:	003feb06 	br	2348c <ECAT_StateChange+0x114>
                switch(nEcatStateTrans)
   234e0:	18c01220 	cmpeqi	r3,r3,72
   234e4:	183fc126 	beq	r3,zero,233ec <ECAT_StateChange+0x74>
                          bEcatOutputUpdateRunning = TRUE;
   234e8:	00800044 	movi	r2,1
   234ec:	d0a14285 	stb	r2,-31478(gp)
                    break;
   234f0:	003fbe06 	br	233ec <ECAT_StateChange+0x74>
                        bMbxRunning = TRUE;
   234f4:	00800044 	movi	r2,1
   234f8:	d0a14b45 	stb	r2,-31443(gp)
                    break;
   234fc:	003fbb06 	br	233ec <ECAT_StateChange+0x74>
                        SetALEventMask(u16ALEventMask);
   23500:	d121338b 	ldhu	r4,-31538(gp)
   23504:	00219bc0 	call	219bc <SetALEventMask>
                        bEcatInputUpdateRunning = TRUE;
   23508:	00800044 	movi	r2,1
   2350c:	d0a14245 	stb	r2,-31479(gp)
                    break;
   23510:	003fb606 	br	233ec <ECAT_StateChange+0x74>
        if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
   23514:	10c00220 	cmpeqi	r3,r2,8
   23518:	11803fcc 	andi	r6,r2,255
   2351c:	183fa21e 	bne	r3,zero,233a8 <ECAT_StateChange+0x30>
   23520:	00c00584 	movi	r3,22
   23524:	1986d83a 	srl	r3,r3,r6
   23528:	18c0004c 	andi	r3,r3,1
   2352c:	183f9e26 	beq	r3,zero,233a8 <ECAT_StateChange+0x30>
            u8LocalErrorState = (alStatus & STATE_MASK);
   23530:	d0a13905 	stb	r2,-31516(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   23534:	d0a135c3 	ldbu	r2,-31529(gp)
            u16LocalErrorCode = alStatusCode;
   23538:	d161398d 	sth	r5,-31514(gp)
            if ((nAlStatus & STATE_MASK) == STATE_OP)
   2353c:	108003cc 	andi	r2,r2,15
   23540:	10800218 	cmpnei	r2,r2,8
   23544:	103fbd1e 	bne	r2,zero,2343c <ECAT_StateChange+0xc4>
                AL_ControlInd(alStatus, alStatusCode);
   23548:	800b883a 	mov	r5,r16
}
   2354c:	dfc00117 	ldw	ra,4(sp)
   23550:	dc000017 	ldw	r16,0(sp)
   23554:	dec00204 	addi	sp,sp,8
                AL_ControlInd(alStatus, alStatusCode);
   23558:	00226bc1 	jmpi	226bc <AL_ControlInd>

0002355c <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
   2355c:	defffe04 	addi	sp,sp,-8
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23560:	01800044 	movi	r6,1
   23564:	01400144 	movi	r5,5
   23568:	d1213684 	addi	r4,gp,-31526
{
   2356c:	dfc00115 	stw	ra,4(sp)
   23570:	dc000015 	stw	r16,0(sp)
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
   23574:	00207400 	call	20740 <HW_EscRead>

    HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
   23578:	01800084 	movi	r6,2
   2357c:	01400184 	movi	r5,6
   23580:	d1213604 	addi	r4,gp,-31528
   23584:	00207400 	call	20740 <HW_EscRead>
    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23588:	d0a1360b 	ldhu	r2,-31528(gp)

/*ECATCHANGE_START(V5.13) ECAT2*/
    u16IdValue = 0;
   2358c:	d021330d 	sth	zero,-31540(gp)

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
   23590:	0021883a 	mov	r16,zero
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
   23594:	100492ba 	slli	r2,r2,10
   23598:	1083ffc4 	addi	r2,r2,4095
   2359c:	d0a1360d 	sth	r2,-31528(gp)
    UpdateEEPROMLoadedState();
   235a0:	0021a080 	call	21a08 <UpdateEEPROMLoadedState>
    for (i = 0; i < nMaxSyncMan; i++)
   235a4:	d0a13683 	ldbu	r2,-31526(gp)
   235a8:	81003fcc 	andi	r4,r16,255
   235ac:	20802036 	bltu	r4,r2,23630 <ECAT_Init+0xd4>
    {
        DisableSyncManChannel(i);
    }

    /* initialize the mailbox handler */
    MBX_Init();
   235b0:	00238780 	call	23878 <MBX_Init>
    u16ALEventMask = 0;
    nPdOutputSize = 0;
    nPdInputSize = 0;

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
   235b4:	00800044 	movi	r2,1
    SetALStatus(nAlStatus, 0);
   235b8:	000b883a 	mov	r5,zero
   235bc:	01000044 	movi	r4,1
    nAlStatus    = STATE_INIT;
   235c0:	d0a135c5 	stb	r2,-31529(gp)
    bApplEsmPending = FALSE;
   235c4:	d02138c5 	stb	zero,-31517(gp)
    bEcatWaitForAlControlRes = FALSE;
   235c8:	d0213885 	stb	zero,-31518(gp)
    bEcatFirstOutputsReceived = FALSE;
   235cc:	d0214205 	stb	zero,-31480(gp)
     bEcatOutputUpdateRunning = FALSE;
   235d0:	d0214285 	stb	zero,-31478(gp)
     bEcatInputUpdateRunning = FALSE;
   235d4:	d0214245 	stb	zero,-31479(gp)
     bExplicitDevIdRequested = FALSE;
   235d8:	d0213585 	stb	zero,-31530(gp)
    bWdTrigger = FALSE;
   235dc:	d02141c5 	stb	zero,-31481(gp)
    EcatWdValue = 0;
   235e0:	d021350d 	sth	zero,-31532(gp)
    Sync0WdCounter = 0;
   235e4:	d0213d8d 	sth	zero,-31498(gp)
    Sync0WdValue = 0;
   235e8:	d0213d0d 	sth	zero,-31500(gp)
    Sync1WdCounter = 0;
   235ec:	d0213c8d 	sth	zero,-31502(gp)
    Sync1WdValue = 0;
   235f0:	d0213c0d 	sth	zero,-31504(gp)
    bDcSyncActive = FALSE;
   235f4:	d0214185 	stb	zero,-31482(gp)
    u8LocalErrorState = 0;
   235f8:	d0213905 	stb	zero,-31516(gp)
    u16LocalErrorCode = 0x00;
   235fc:	d021398d 	sth	zero,-31514(gp)
    u16ALEventMask = 0;
   23600:	d021338d 	sth	zero,-31538(gp)
    nPdOutputSize = 0;
   23604:	d021370d 	sth	zero,-31524(gp)
    nPdInputSize = 0;
   23608:	d021378d 	sth	zero,-31522(gp)
    SetALStatus(nAlStatus, 0);
   2360c:	00226180 	call	22618 <SetALStatus>
    nEcatStateTrans = 0;
   23610:	d021380d 	sth	zero,-31520(gp)

    bEscIntEnabled = FALSE;
   23614:	d0213a45 	stb	zero,-31511(gp)

    /* initialize the COE part */
    COE_Init();
   23618:	00218b40 	call	218b4 <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
   2361c:	0009883a 	mov	r4,zero
}
   23620:	dfc00117 	ldw	ra,4(sp)
   23624:	dc000017 	ldw	r16,0(sp)
   23628:	dec00204 	addi	sp,sp,8
    ResetALEventMask(0);
   2362c:	00219701 	jmpi	21970 <ResetALEventMask>
        DisableSyncManChannel(i);
   23630:	0021a700 	call	21a70 <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
   23634:	84000044 	addi	r16,r16,1
   23638:	003fda06 	br	235a4 <ECAT_Init+0x48>

0002363c <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
   2363c:	defffc04 	addi	sp,sp,-16
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
/*ECATCHANGE_START(V5.13) MBX1*/
    UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
   23640:	00800044 	movi	r2,1
   23644:	d8800005 	stb	r2,0(sp)
{
   23648:	dfc00315 	stw	ra,12(sp)
   2364c:	dc400215 	stw	r17,8(sp)
   23650:	dc000115 	stw	r16,4(sp)
    UINT16 EscAlControl = 0x0000;
   23654:	d800008d 	sth	zero,2(sp)
    UINT8 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes with invalid CRCs*/
   23658:	d8000045 	stb	zero,1(sp)
/*ECATCHANGE_END(V5.13) MBX1*/


    /* check if services are stored in the mailbox */
    MBX_Main();
   2365c:	002406c0 	call	2406c <MBX_Main>


    if ( bMbxRunning )
   23660:	d0a14b43 	ldbu	r2,-31443(gp)
   23664:	10000826 	beq	r2,zero,23688 <ECAT_Main+0x4c>
    {
        /* Slave is at least in PREOP, Mailbox is running */

/*ECATCHANGE_START(V5.13) MBX1*/
        /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
        HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
   23668:	01800044 	movi	r6,1
   2366c:	01420384 	movi	r5,2062
   23670:	d809883a 	mov	r4,sp
   23674:	00207400 	call	20740 <HW_EscRead>

        HW_EscReadByte(sm1Status, (ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23678:	01800044 	movi	r6,1
   2367c:	01420344 	movi	r5,2061
   23680:	d9000044 	addi	r4,sp,1
   23684:	00207400 	call	20740 <HW_EscRead>
/*ECATCHANGE_END(V5.13) MBX1*/
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
   23688:	00207780 	call	20778 <HW_GetALEventRegister>
   2368c:	1021883a 	mov	r16,r2
    ALEventReg = SWAPWORD(ALEventReg);


    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
   23690:	8080004c 	andi	r2,r16,1
   23694:	10001526 	beq	r2,zero,236ec <ECAT_Main+0xb0>
   23698:	d4613883 	ldbu	r17,-31518(gp)
   2369c:	88803fcc 	andi	r2,r17,255
   236a0:	1000121e 	bne	r2,zero,236ec <ECAT_Main+0xb0>
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */

        HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
   236a4:	01800044 	movi	r6,1
   236a8:	01404804 	movi	r5,288
   236ac:	d9000084 	addi	r4,sp,2
   236b0:	00207400 	call	20740 <HW_EscRead>
        EscAlControl = SWAPWORD(EscAlControl);


            /*ECATCHANGE_START(V5.13) ECAT2*/
                /*Evaluate if register 0x120 Bit5 (Request Explicit DeviceID) is set*/
            if ((EscAlControl & (UINT16)STATE_DEVID) == STATE_DEVID)
   236b4:	d880008b 	ldhu	r2,2(sp)
   236b8:	1080080c 	andi	r2,r2,32
   236bc:	10000526 	beq	r2,zero,236d4 <ECAT_Main+0x98>
            {
                if (bExplicitDevIdRequested == FALSE)
   236c0:	d0a13583 	ldbu	r2,-31530(gp)
   236c4:	1000021e 	bne	r2,zero,236d0 <ECAT_Main+0x94>
                {
                    u16IdValue = APPL_GetDeviceID();
   236c8:	002047c0 	call	2047c <APPL_GetDeviceID>
   236cc:	d0a1330d 	sth	r2,-31540(gp)
                }

                bExplicitDevIdRequested = TRUE;
   236d0:	04400044 	movi	r17,1

        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));

            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   236d4:	d9000083 	ldbu	r4,2(sp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   236d8:	00bffb84 	movi	r2,-18
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   236dc:	000b883a 	mov	r5,zero
                bExplicitDevIdRequested = TRUE;
   236e0:	d4613585 	stb	r17,-31530(gp)
            ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
   236e4:	1420703a 	and	r16,r2,r16
            AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
   236e8:	00226bc0 	call	226bc <AL_ControlInd>

            /* SM-Change-Event was handled too */

    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   236ec:	8400040c 	andi	r16,r16,16
   236f0:	d0a13883 	ldbu	r2,-31518(gp)
   236f4:	80002e26 	beq	r16,zero,237b0 <ECAT_Main+0x174>
   236f8:	10803fcc 	andi	r2,r2,255
   236fc:	10002326 	beq	r2,zero,2378c <ECAT_Main+0x150>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
    }

    if(bEcatWaitForAlControlRes)
    {
        AL_ControlRes();
   23700:	0022ed80 	call	22ed8 <AL_ControlRes>
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
   23704:	d0a14b43 	ldbu	r2,-31443(gp)
   23708:	10001b26 	beq	r2,zero,23778 <ECAT_Main+0x13c>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
            if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
   2370c:	d8800003 	ldbu	r2,0(sp)
   23710:	1080004c 	andi	r2,r2,1
   23714:	1000041e 	bne	r2,zero,23728 <ECAT_Main+0xec>
            {
                AL_ControlInd(nAlStatus & STATE_MASK, 0);
   23718:	d12135c3 	ldbu	r4,-31529(gp)
   2371c:	000b883a 	mov	r5,zero
   23720:	210003cc 	andi	r4,r4,15
   23724:	00226bc0 	call	226bc <AL_ControlInd>
            }

/*ECATCHANGE_START(V5.13) MBX1*/
        if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
   23728:	d8800043 	ldbu	r2,1(sp)
   2372c:	1080020c 	andi	r2,r2,8
   23730:	1000081e 	bne	r2,zero,23754 <ECAT_Main+0x118>
            && bSendMbxIsFull) 
   23734:	d0a14b83 	ldbu	r2,-31442(gp)
   23738:	10000626 	beq	r2,zero,23754 <ECAT_Main+0x118>
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u8dummy = 0;
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   2373c:	d161490b 	ldhu	r5,-31452(gp)
   23740:	01800044 	movi	r6,1
   23744:	d12132c4 	addi	r4,gp,-31541
            u8dummy = 0;
   23748:	d02132c5 	stb	zero,-31541(gp)
            HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
   2374c:	00207c40 	call	207c4 <HW_EscWrite>

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
            MBX_MailboxReadInd();
   23750:	0023c700 	call	23c70 <MBX_MailboxReadInd>
        }

            /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

            if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
   23754:	d8800003 	ldbu	r2,0(sp)
   23758:	d0e14b03 	ldbu	r3,-31444(gp)
   2375c:	1080008c 	andi	r2,r2,2
   23760:	10001626 	beq	r2,zero,237bc <ECAT_Main+0x180>
   23764:	18001626 	beq	r3,zero,237c0 <ECAT_Main+0x184>
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
            }


        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
   23768:	00207780 	call	20778 <HW_GetALEventRegister>
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
   2376c:	1080400c 	andi	r2,r2,256
   23770:	10000126 	beq	r2,zero,23778 <ECAT_Main+0x13c>
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
            MBX_CheckAndCopyMailbox();
   23774:	0023f380 	call	23f38 <MBX_CheckAndCopyMailbox>

        }
    }
}
   23778:	dfc00317 	ldw	ra,12(sp)
   2377c:	dc400217 	ldw	r17,8(sp)
   23780:	dc000117 	ldw	r16,4(sp)
   23784:	dec00404 	addi	sp,sp,16
   23788:	f800283a 	ret
    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
   2378c:	d12135c3 	ldbu	r4,-31529(gp)
   23790:	2080040c 	andi	r2,r4,16
   23794:	103fdb1e 	bne	r2,zero,23704 <ECAT_Main+0xc8>
   23798:	20803bcc 	andi	r2,r4,239
   2379c:	10800060 	cmpeqi	r2,r2,1
   237a0:	103fd81e 	bne	r2,zero,23704 <ECAT_Main+0xc8>
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
   237a4:	000b883a 	mov	r5,zero
   237a8:	210003cc 	andi	r4,r4,15
   237ac:	00226bc0 	call	226bc <AL_ControlInd>
    if(bEcatWaitForAlControlRes)
   237b0:	d0a13883 	ldbu	r2,-31518(gp)
   237b4:	103fd326 	beq	r2,zero,23704 <ECAT_Main+0xc8>
   237b8:	003fd106 	br	23700 <ECAT_Main+0xc4>
                || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
   237bc:	183fea26 	beq	r3,zero,23768 <ECAT_Main+0x12c>
                MBX_MailboxRepeatReq();
   237c0:	0023d100 	call	23d10 <MBX_MailboxRepeatReq>
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   237c4:	d8800003 	ldbu	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   237c8:	01800044 	movi	r6,1
   237cc:	014203c4 	movi	r5,2063
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   237d0:	1080008c 	andi	r2,r2,2
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   237d4:	d809883a 	mov	r4,sp
                sm1Activate &= SM_SETTING_REPEAT_ACK;
   237d8:	d8800005 	stb	r2,0(sp)
                HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   237dc:	00207c40 	call	207c4 <HW_EscWrite>
   237e0:	003fe106 	br	23768 <ECAT_Main+0x12c>

000237e4 <PutInMbxQueue>:
{
    UINT16 lastInQueue;
    ENTER_MBX_CRITICAL;


    lastInQueue = pQueue->lastInQueue+1;
   237e4:	2880008b 	ldhu	r2,2(r5)
    if (lastInQueue == pQueue->maxQueueSize)
   237e8:	29c0010b 	ldhu	r7,4(r5)
    lastInQueue = pQueue->lastInQueue+1;
   237ec:	10c00044 	addi	r3,r2,1
   237f0:	180d883a 	mov	r6,r3
    if (lastInQueue == pQueue->maxQueueSize)
   237f4:	18ffffcc 	andi	r3,r3,65535
   237f8:	38c0011e 	bne	r7,r3,23800 <PutInMbxQueue+0x1c>
    {
        // Umbruch der Queue
        lastInQueue = 0;
   237fc:	000d883a 	mov	r6,zero
    }

    if (pQueue->firstInQueue == lastInQueue)
   23800:	29c0000b 	ldhu	r7,0(r5)
   23804:	30ffffcc 	andi	r3,r6,65535
   23808:	38c00826 	beq	r7,r3,2382c <PutInMbxQueue+0x48>
        // Ueberlauf der Queue -> letztes Element wieder herausnehmen
        LEAVE_MBX_CRITICAL;
        return MBXERR_NOMOREMEMORY;
    }

    pQueue->queue[pQueue->lastInQueue] = pMbx;
   2380c:	10bfffcc 	andi	r2,r2,65535
   23810:	10800084 	addi	r2,r2,2
   23814:	100490ba 	slli	r2,r2,2
   23818:	2885883a 	add	r2,r5,r2
   2381c:	11000015 	stw	r4,0(r2)
    pQueue->lastInQueue = lastInQueue;
   23820:	2980008d 	sth	r6,2(r5)

    LEAVE_MBX_CRITICAL;

    return 0;
   23824:	0005883a 	mov	r2,zero
   23828:	f800283a 	ret
        return MBXERR_NOMOREMEMORY;
   2382c:	008001c4 	movi	r2,7
}
   23830:	f800283a 	ret

00023834 <GetOutOfMbxQueue>:
TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
   23834:	20c0000b 	ldhu	r3,0(r4)
   23838:	2140008b 	ldhu	r5,2(r4)
   2383c:	18bfffcc 	andi	r2,r3,65535
   23840:	11400b26 	beq	r2,r5,23870 <GetOutOfMbxQueue+0x3c>
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
        pMbx = pQueue->queue[firstInQueue];
   23844:	10800084 	addi	r2,r2,2
   23848:	100490ba 	slli	r2,r2,2
        firstInQueue++;
        pQueue->firstInQueue = firstInQueue;
        
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   2384c:	2140010b 	ldhu	r5,4(r4)
        firstInQueue++;
   23850:	18c00044 	addi	r3,r3,1
        pMbx = pQueue->queue[firstInQueue];
   23854:	2085883a 	add	r2,r4,r2
   23858:	10800017 	ldw	r2,0(r2)
        pQueue->firstInQueue = firstInQueue;
   2385c:	20c0000d 	sth	r3,0(r4)
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
   23860:	18ffffcc 	andi	r3,r3,65535
   23864:	28c0031e 	bne	r5,r3,23874 <GetOutOfMbxQueue+0x40>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
   23868:	2000000d 	sth	zero,0(r4)
   2386c:	f800283a 	ret
        }
    }
    else
    {
        pMbx = 0;
   23870:	0005883a 	mov	r2,zero


    LEAVE_MBX_CRITICAL;

    return pMbx;
}
   23874:	f800283a 	ret

00023878 <MBX_Init>:
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
   23878:	00800904 	movi	r2,36
   2387c:	d0a14a0d 	sth	r2,-31448(gp)
    u16SendMbxSize = MAX_MBX_SIZE;
   23880:	00802004 	movi	r2,128
   23884:	d0a14a8d 	sth	r2,-31446(gp)
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
   23888:	00840004 	movi	r2,4096
   2388c:	d0a1498d 	sth	r2,-31450(gp)
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
   23890:	d0a1490d 	sth	r2,-31452(gp)

    sMbxReceiveQueue.firstInQueue    = 0;
   23894:	008000f4 	movhi	r2,3
   23898:	10215615 	stw	zero,-31400(r2)
    sMbxReceiveQueue.lastInQueue     = 0;
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   2389c:	00c000f4 	movhi	r3,3
   238a0:	00800284 	movi	r2,10
{
   238a4:	defffe04 	addi	sp,sp,-8
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
   238a8:	18a1570d 	sth	r2,-31396(r3)
    sMbxSendQueue.firstInQueue        = 0;
   238ac:	00c000f4 	movhi	r3,3

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238b0:	d90000c4 	addi	r4,sp,3
    sMbxSendQueue.firstInQueue        = 0;
   238b4:	18216315 	stw	zero,-31348(r3)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238b8:	01800044 	movi	r6,1
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   238bc:	00c000f4 	movhi	r3,3
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238c0:	014203c4 	movi	r5,2063
{
   238c4:	dfc00115 	stw	ra,4(sp)
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
   238c8:	18a1640d 	sth	r2,-31344(r3)
        UINT8 sm1Activate = 0;
   238cc:	d80000c5 	stb	zero,3(sp)
    psWriteMbx  = NULL;
   238d0:	d0214715 	stw	zero,-31460(gp)
    psRepeatMbx = NULL;
   238d4:	d0214515 	stw	zero,-31468(gp)
    psReadMbx    = NULL;
   238d8:	d0214615 	stw	zero,-31464(gp)
    psStoreMbx    = NULL;
   238dc:	d0214415 	stw	zero,-31472(gp)
    bMbxRepeatToggle    = FALSE;
   238e0:	d0214b05 	stb	zero,-31444(gp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238e4:	00207400 	call	20740 <HW_EscRead>
        sm1Activate &= ~0x02;
   238e8:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238ec:	01800044 	movi	r6,1
   238f0:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   238f4:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   238f8:	d90000c4 	addi	r4,sp,3
        sm1Activate &= ~0x02;
   238fc:	d88000c5 	stb	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23900:	00207c40 	call	207c4 <HW_EscWrite>
    }
    bMbxRunning = FALSE;
   23904:	d0214b45 	stb	zero,-31443(gp)
    bSendMbxIsFull = FALSE;
   23908:	d0214b85 	stb	zero,-31442(gp)
    bReceiveMbxIsLocked = FALSE;
   2390c:	d0214bc5 	stb	zero,-31441(gp)
    u8MailboxSendReqStored    = 0;
   23910:	d0214805 	stb	zero,-31456(gp)
    u8MbxWriteCounter = 0;
   23914:	d0214885 	stb	zero,-31454(gp)
    u8MbxReadCounter    = 0;
   23918:	d0214845 	stb	zero,-31455(gp)
}
   2391c:	dfc00117 	ldw	ra,4(sp)
   23920:	dec00204 	addi	sp,sp,8
   23924:	f800283a 	ret

00023928 <MBX_StartMailboxHandler>:
 \brief     it is checked if the mailbox areas overlaps each other
 \brief     and the Sync Manager channels 0 and 1 are enabled.
 \brief     This function shall only be called if mailbox is supported.
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 MBX_StartMailboxHandler(void)
{
   23928:	defffe04 	addi	sp,sp,-8
    UINT16 result = 0;
    
    /* get address of the receive mailbox sync manager (SM0) */
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   2392c:	0009883a 	mov	r4,zero
{
   23930:	dfc00115 	stw	ra,4(sp)
   23934:	dc000015 	stw	r16,0(sp)
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
   23938:	0021a400 	call	21a40 <GetSyncMan>

    /* store size of the receive mailbox */
    u16ReceiveMbxSize     = pSyncMan->Length;
   2393c:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the receive mailbox */
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   23940:	1080000b 	ldhu	r2,0(r2)

    /* get address of the send mailbox sync manager (SM1) */
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23944:	01000044 	movi	r4,1
    u16ReceiveMbxSize     = pSyncMan->Length;
   23948:	d0e14a0d 	sth	r3,-31448(gp)
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
   2394c:	d0a1498d 	sth	r2,-31450(gp)
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
   23950:	0021a400 	call	21a40 <GetSyncMan>

    /* store the size of the send mailbox */
    u16SendMbxSize = pSyncMan->Length;
   23954:	10c0008b 	ldhu	r3,2(r2)
    /* store the address of the send mailbox */
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;

    // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23958:	d161498b 	ldhu	r5,-31450(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   2395c:	1080000b 	ldhu	r2,0(r2)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   23960:	d1214a0b 	ldhu	r4,-31448(gp)
    u16SendMbxSize = pSyncMan->Length;
   23964:	d0e14a8d 	sth	r3,-31446(gp)
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
   23968:	d0a1490d 	sth	r2,-31452(gp)
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
   2396c:	2149883a 	add	r4,r4,r5
   23970:	10bfffcc 	andi	r2,r2,65535
   23974:	1100030e 	bge	r2,r4,23984 <MBX_StartMailboxHandler+0x5c>
   23978:	18ffffcc 	andi	r3,r3,65535
   2397c:	1887883a 	add	r3,r3,r2
   23980:	28c01c16 	blt	r5,r3,239f4 <MBX_StartMailboxHandler+0xcc>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
    }


    /* enable the receive mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_WRITE);
   23984:	0009883a 	mov	r4,zero
   23988:	0021ad00 	call	21ad0 <EnableSyncManChannel>
    /* enable the send mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_READ);
   2398c:	01000044 	movi	r4,1
   23990:	0021ad00 	call	21ad0 <EnableSyncManChannel>

        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   23994:	d1214a0b 	ldhu	r4,-31448(gp)
   23998:	0026bcc0 	call	26bcc <malloc>
   2399c:	d0a14715 	stw	r2,-31460(gp)
   239a0:	1009883a 	mov	r4,r2
        if(psWriteMbx == NULL)
   239a4:	10000e1e 	bne	r2,zero,239e0 <MBX_StartMailboxHandler+0xb8>
        {
            bNoMbxMemoryAvailable = TRUE;
   239a8:	00800044 	movi	r2,1

            //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   239ac:	01000284 	movi	r4,10
            bNoMbxMemoryAvailable = TRUE;
   239b0:	d0a14305 	stb	r2,-31476(gp)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   239b4:	0026bcc0 	call	26bcc <malloc>
            if(psWriteMbx == NULL)
   239b8:	1021003a 	cmpeq	r16,r2,zero
   239bc:	8020907a 	slli	r16,r16,1
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   239c0:	1009883a 	mov	r4,r2
            {
                result = ALSTATUSCODE_NOMEMORY;
            }

            APPL_FreeMailboxBuffer(psWriteMbx);
   239c4:	0026bdc0 	call	26bdc <free>
            psWriteMbx = NULL;
   239c8:	d0214715 	stw	zero,-31460(gp)
            APPL_FreeMailboxBuffer(psWriteMbx);
            psWriteMbx = NULL;
        }

    return result;
}
   239cc:	8005883a 	mov	r2,r16
   239d0:	dfc00117 	ldw	ra,4(sp)
   239d4:	dc000017 	ldw	r16,0(sp)
   239d8:	dec00204 	addi	sp,sp,8
   239dc:	f800283a 	ret
            bNoMbxMemoryAvailable = FALSE;
   239e0:	d0214305 	stb	zero,-31476(gp)
    UINT16 result = 0;
   239e4:	0021883a 	mov	r16,zero
            APPL_FreeMailboxBuffer(psWriteMbx);
   239e8:	0026bdc0 	call	26bdc <free>
            psWriteMbx = NULL;
   239ec:	d0214715 	stw	zero,-31460(gp)
   239f0:	003ff606 	br	239cc <MBX_StartMailboxHandler+0xa4>
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
   239f4:	04000584 	movi	r16,22
   239f8:	003ff406 	br	239cc <MBX_StartMailboxHandler+0xa4>

000239fc <MBX_StopMailboxHandler>:
 \brief  local management service Stop Mailbox Handler
 \brief  the Sync Manager channels 0 and 1 are disabled
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_StopMailboxHandler(void)
{
   239fc:	defffd04 	addi	sp,sp,-12
    TMBX MBXMEM * pMbx;

    /* mailbox handler is stopped */
    bMbxRunning = FALSE;
    /* disable the receive mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_WRITE);
   23a00:	0009883a 	mov	r4,zero
{
   23a04:	dfc00215 	stw	ra,8(sp)
   23a08:	dc000115 	stw	r16,4(sp)
    bMbxRunning = FALSE;
   23a0c:	d0214b45 	stb	zero,-31443(gp)
    DisableSyncManChannel(MAILBOX_WRITE);
   23a10:	0021a700 	call	21a70 <DisableSyncManChannel>
    /* disable the send mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_READ);
   23a14:	01000044 	movi	r4,1
   23a18:	0021a700 	call	21a70 <DisableSyncManChannel>
    /* initialize variables again */


    if (psRepeatMbx != NULL)
   23a1c:	d1214517 	ldw	r4,-31468(gp)
   23a20:	20000126 	beq	r4,zero,23a28 <MBX_StopMailboxHandler+0x2c>
    {
        APPL_FreeMailboxBuffer(psRepeatMbx);
   23a24:	0026bdc0 	call	26bdc <free>
    }

    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
   23a28:	d1214417 	ldw	r4,-31472(gp)
   23a2c:	20000326 	beq	r4,zero,23a3c <MBX_StopMailboxHandler+0x40>
   23a30:	d0a14517 	ldw	r2,-31468(gp)
   23a34:	20800126 	beq	r4,r2,23a3c <MBX_StopMailboxHandler+0x40>
    {
        APPL_FreeMailboxBuffer(psStoreMbx);
   23a38:	0026bdc0 	call	26bdc <free>
    }

    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
   23a3c:	d1214617 	ldw	r4,-31464(gp)
   23a40:	20000526 	beq	r4,zero,23a58 <MBX_StopMailboxHandler+0x5c>
   23a44:	d0a14517 	ldw	r2,-31468(gp)
   23a48:	20800326 	beq	r4,r2,23a58 <MBX_StopMailboxHandler+0x5c>
   23a4c:	d0a14417 	ldw	r2,-31472(gp)
   23a50:	20800126 	beq	r4,r2,23a58 <MBX_StopMailboxHandler+0x5c>
    {
        APPL_FreeMailboxBuffer(psReadMbx);
   23a54:	0026bdc0 	call	26bdc <free>
    }


    SDOS_ClearPendingResponse();
   23a58:	00261f00 	call	261f0 <SDOS_ClearPendingResponse>

    bMbxRepeatToggle    = FALSE;
    /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
    {
        UINT8 sm1Activate = 0;
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a5c:	01800044 	movi	r6,1
   23a60:	014203c4 	movi	r5,2063
   23a64:	d90000c4 	addi	r4,sp,3
    psWriteMbx = NULL;
   23a68:	d0214715 	stw	zero,-31460(gp)
    psRepeatMbx = NULL;
   23a6c:	d0214515 	stw	zero,-31468(gp)
    psReadMbx = NULL;
   23a70:	d0214615 	stw	zero,-31464(gp)
    psStoreMbx = NULL;
   23a74:	d0214415 	stw	zero,-31472(gp)
    bMbxRepeatToggle    = FALSE;
   23a78:	d0214b05 	stb	zero,-31444(gp)
        UINT8 sm1Activate = 0;
   23a7c:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a80:	00207400 	call	20740 <HW_EscRead>
        sm1Activate &= ~0x02;
   23a84:	d88000c3 	ldbu	r2,3(sp)
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a88:	01800044 	movi	r6,1
   23a8c:	014203c4 	movi	r5,2063
        sm1Activate &= ~0x02;
   23a90:	10803f4c 	andi	r2,r2,253
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23a94:	d90000c4 	addi	r4,sp,3
    u8MbxWriteCounter         = 0;
    u8MbxReadCounter        = 0;

    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23a98:	040000f4 	movhi	r16,3
        sm1Activate &= ~0x02;
   23a9c:	d88000c5 	stb	r2,3(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23aa0:	84215604 	addi	r16,r16,-31400
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
   23aa4:	00207c40 	call	207c4 <HW_EscWrite>
    bSendMbxIsFull         = FALSE;
   23aa8:	d0214b85 	stb	zero,-31442(gp)
    bReceiveMbxIsLocked = FALSE;
   23aac:	d0214bc5 	stb	zero,-31441(gp)
    u8MailboxSendReqStored    = 0;
   23ab0:	d0214805 	stb	zero,-31456(gp)
    u8MbxWriteCounter         = 0;
   23ab4:	d0214885 	stb	zero,-31454(gp)
    u8MbxReadCounter        = 0;
   23ab8:	d0214845 	stb	zero,-31455(gp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   23abc:	8009883a 	mov	r4,r16
   23ac0:	00238340 	call	23834 <GetOutOfMbxQueue>
   23ac4:	1009883a 	mov	r4,r2
        if (pMbx)
   23ac8:	1000081e 	bne	r2,zero,23aec <MBX_StopMailboxHandler+0xf0>
        }
    } while (pMbx != NULL);
    
    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23acc:	040000f4 	movhi	r16,3
   23ad0:	84216304 	addi	r16,r16,-31348
   23ad4:	8009883a 	mov	r4,r16
   23ad8:	00238340 	call	23834 <GetOutOfMbxQueue>
   23adc:	1009883a 	mov	r4,r2
        if (pMbx)
   23ae0:	10000426 	beq	r2,zero,23af4 <MBX_StopMailboxHandler+0xf8>
        {
            APPL_FreeMailboxBuffer(pMbx);
   23ae4:	0026bdc0 	call	26bdc <free>
        }
    } while (pMbx != NULL);
   23ae8:	003ffa06 	br	23ad4 <MBX_StopMailboxHandler+0xd8>
            APPL_FreeMailboxBuffer(pMbx);
   23aec:	0026bdc0 	call	26bdc <free>
    } while (pMbx != NULL);
   23af0:	003ff206 	br	23abc <MBX_StopMailboxHandler+0xc0>

}
   23af4:	dfc00217 	ldw	ra,8(sp)
   23af8:	dc000117 	ldw	r16,4(sp)
   23afc:	dec00304 	addi	sp,sp,12
   23b00:	f800283a 	ret

00023b04 <MailboxServiceInd>:
UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
{
    UINT8 result;


    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
   23b04:	2080010b 	ldhu	r2,4(r4)
   23b08:	1005d23a 	srai	r2,r2,8
   23b0c:	108003cc 	andi	r2,r2,15
   23b10:	108000d8 	cmpnei	r2,r2,3
   23b14:	1000011e 	bne	r2,zero,23b1c <MailboxServiceInd+0x18>
    {
    case MBX_TYPE_COE:
        /* CoE datagram received */
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
   23b18:	00218c01 	jmpi	218c0 <COE_ServiceInd>
        result = MBXERR_UNSUPPORTEDPROTOCOL;
        break;
    }

    return result;
}
   23b1c:	00800084 	movi	r2,2
   23b20:	f800283a 	ret

00023b24 <MBX_CopyToSendMailbox>:
 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23b24:	d0a135c3 	ldbu	r2,-31529(gp)
{
   23b28:	defff804 	addi	sp,sp,-32
   23b2c:	dfc00715 	stw	ra,28(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23b30:	108003cc 	andi	r2,r2,15
{
   23b34:	dd400615 	stw	r21,24(sp)
   23b38:	dd000515 	stw	r20,20(sp)
   23b3c:	dcc00415 	stw	r19,16(sp)
   23b40:	dc800315 	stw	r18,12(sp)
   23b44:	dc400215 	stw	r17,8(sp)
   23b48:	dc000115 	stw	r16,4(sp)
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
   23b4c:	10800060 	cmpeqi	r2,r2,1
   23b50:	1000431e 	bne	r2,zero,23c60 <MBX_CopyToSendMailbox+0x13c>
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }


    if ( !bMbxRunning )
   23b54:	d0a14b43 	ldbu	r2,-31443(gp)
   23b58:	10004126 	beq	r2,zero,23c60 <MBX_CopyToSendMailbox+0x13c>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
    }

    if ( bSendMbxIsFull )
   23b5c:	d4e14b83 	ldbu	r19,-31442(gp)
   23b60:	98803fcc 	andi	r2,r19,255
   23b64:	1000401e 	bne	r2,zero,23c68 <MBX_CopyToSendMailbox+0x144>
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
/*ECATCHANGE_START(V5.13) MBX2*/
        /*Reset the not used mailbox memory*/
        {
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b68:	d421490b 	ldhu	r16,-31452(gp)
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   23b6c:	d5214a8b 	ldhu	r20,-31446(gp)
        UINT16 mbxSize = pMbx->MbxHeader.Length;
   23b70:	2440000b 	ldhu	r17,0(r4)
   23b74:	2025883a 	mov	r18,r4
            UINT16 LastAddrToReset = (u16EscAddrSendMbx + u16SendMbxSize);
   23b78:	a429883a 	add	r20,r20,r16
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b7c:	84000184 	addi	r16,r16,6
            LastAddrToReset = LastAddrToReset - 1;
   23b80:	a53fffc4 	addi	r20,r20,-1
            UINT16 LastUsedAddr = u16EscAddrSendMbx + mbxSize + MBX_HEADER_SIZE;
   23b84:	8461883a 	add	r16,r16,r17
            u8dummy = 0;
   23b88:	d02132c5 	stb	zero,-31541(gp)

            /*clear all unused bytes*/
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   23b8c:	843fffcc 	andi	r16,r16,65535
   23b90:	a53fffcc 	andi	r20,r20,65535
            {
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   23b94:	d56132c4 	addi	r21,gp,-31541
            while (LastUsedAddr < LastAddrToReset) /*reset all bytes until the second last valid address*/
   23b98:	80bfffcc 	andi	r2,r16,65535
   23b9c:	15002a36 	bltu	r2,r20,23c48 <MBX_CopyToSendMailbox+0x124>
                LastUsedAddr = LastUsedAddr + 1;
            }
        }
/*ECATCHANGE_END(V5.13) MBX2*/

        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
   23ba0:	d161490b 	ldhu	r5,-31452(gp)
   23ba4:	89800184 	addi	r6,r17,6
   23ba8:	31bfffcc 	andi	r6,r6,65535
   23bac:	9009883a 	mov	r4,r18
   23bb0:	00207c40 	call	207c4 <HW_EscWrite>


        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT8 smstate = 0x00;
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23bb4:	01800044 	movi	r6,1
   23bb8:	01420344 	movi	r5,2061
   23bbc:	d90000c4 	addi	r4,sp,3
        VARVOLATILE UINT8 smstate = 0x00;
   23bc0:	d80000c5 	stb	zero,3(sp)
        HW_EscReadByte(smstate,(ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
   23bc4:	00207400 	call	20740 <HW_EscRead>

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
   23bc8:	d88000c3 	ldbu	r2,3(sp)
   23bcc:	1080020c 	andi	r2,r2,8
   23bd0:	10000d1e 	bne	r2,zero,23c08 <MBX_CopyToSendMailbox+0xe4>
        {
            UINT16 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
   23bd4:	d0a14a8b 	ldhu	r2,-31446(gp)
   23bd8:	1463c83a 	sub	r17,r2,r17

            /*in case of a slow ESC the buffer status may not indicate 'full' even if the complete buffer was written, trigger an additional write access only if not the complete buffer was written*/
            if (BytesLeft > 0)
   23bdc:	8c7fffcc 	andi	r17,r17,65535
   23be0:	8c4001a0 	cmpeqi	r17,r17,6
   23be4:	8800081e 	bne	r17,zero,23c08 <MBX_CopyToSendMailbox+0xe4>
            {
                /*Write last Byte to trigger mailbox full flag*/
            u8dummy = 0;
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   23be8:	d161490b 	ldhu	r5,-31452(gp)
   23bec:	01800044 	movi	r6,1
   23bf0:	d12132c4 	addi	r4,gp,-31541
   23bf4:	288b883a 	add	r5,r5,r2
   23bf8:	297fffc4 	addi	r5,r5,-1
   23bfc:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   23c00:	d02132c5 	stb	zero,-31541(gp)
            HW_EscWriteByte(u8dummy, (u16EscAddrSendMbx + u16SendMbxSize - 1));
   23c04:	00207c40 	call	207c4 <HW_EscWrite>
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
   23c08:	d0a14617 	ldw	r2,-31464(gp)
   23c0c:	10000126 	beq	r2,zero,23c14 <MBX_CopyToSendMailbox+0xf0>
        {
            psWriteMbx = NULL;
   23c10:	d0214715 	stw	zero,-31460(gp)
        }
        psReadMbx = pMbx;

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
   23c14:	00800044 	movi	r2,1
        psReadMbx = pMbx;
   23c18:	d4a14615 	stw	r18,-31464(gp)
        bSendMbxIsFull = TRUE;
   23c1c:	d0a14b85 	stb	r2,-31442(gp)


        return 0;
    }
}
   23c20:	9805883a 	mov	r2,r19
   23c24:	dfc00717 	ldw	ra,28(sp)
   23c28:	dd400617 	ldw	r21,24(sp)
   23c2c:	dd000517 	ldw	r20,20(sp)
   23c30:	dcc00417 	ldw	r19,16(sp)
   23c34:	dc800317 	ldw	r18,12(sp)
   23c38:	dc400217 	ldw	r17,8(sp)
   23c3c:	dc000117 	ldw	r16,4(sp)
   23c40:	dec00804 	addi	sp,sp,32
   23c44:	f800283a 	ret
                HW_EscWriteByte(u8dummy, LastUsedAddr);
   23c48:	800b883a 	mov	r5,r16
   23c4c:	01800044 	movi	r6,1
   23c50:	a809883a 	mov	r4,r21
   23c54:	00207c40 	call	207c4 <HW_EscWrite>
                LastUsedAddr = LastUsedAddr + 1;
   23c58:	84000044 	addi	r16,r16,1
   23c5c:	003fce06 	br	23b98 <MBX_CopyToSendMailbox+0x74>
        return( ERROR_INVALIDSTATE );
   23c60:	04fffc04 	movi	r19,-16
   23c64:	003fee06 	br	23c20 <MBX_CopyToSendMailbox+0xfc>
        return MBXERR_NOMOREMEMORY;
   23c68:	04c001c4 	movi	r19,7
   23c6c:	003fec06 	br	23c20 <MBX_CopyToSendMailbox+0xfc>

00023c70 <MBX_MailboxReadInd>:
    if (psRepeatMbx && psStoreMbx == NULL)
   23c70:	d1214517 	ldw	r4,-31468(gp)
{
   23c74:	deffff04 	addi	sp,sp,-4
   23c78:	dfc00015 	stw	ra,0(sp)
    bSendMbxIsFull = FALSE;
   23c7c:	d0214b85 	stb	zero,-31442(gp)
    if (psRepeatMbx && psStoreMbx == NULL)
   23c80:	20000526 	beq	r4,zero,23c98 <MBX_MailboxReadInd+0x28>
   23c84:	d0a14417 	ldw	r2,-31472(gp)
   23c88:	1000031e 	bne	r2,zero,23c98 <MBX_MailboxReadInd+0x28>
        if (psReadMbx != psRepeatMbx)
   23c8c:	d0a14617 	ldw	r2,-31464(gp)
   23c90:	20800126 	beq	r4,r2,23c98 <MBX_MailboxReadInd+0x28>
            APPL_FreeMailboxBuffer(psRepeatMbx);
   23c94:	0026bdc0 	call	26bdc <free>
    psRepeatMbx = psReadMbx;
   23c98:	d0a14617 	ldw	r2,-31464(gp)
      if ( psStoreMbx )
   23c9c:	d1214417 	ldw	r4,-31472(gp)
    psRepeatMbx = psReadMbx;
   23ca0:	d0a14515 	stw	r2,-31468(gp)
      if ( psStoreMbx )
   23ca4:	20001326 	beq	r4,zero,23cf4 <MBX_MailboxReadInd+0x84>
        MBX_CopyToSendMailbox(psStoreMbx);
   23ca8:	0023b240 	call	23b24 <MBX_CopyToSendMailbox>
        psStoreMbx = NULL;
   23cac:	d0214415 	stw	zero,-31472(gp)
      if ( u8MailboxSendReqStored )
   23cb0:	d0a14803 	ldbu	r2,-31456(gp)
   23cb4:	10c03fcc 	andi	r3,r2,255
   23cb8:	18000b26 	beq	r3,zero,23ce8 <MBX_MailboxReadInd+0x78>
        if ( u8MailboxSendReqStored & COE_SERVICE )
   23cbc:	10c0008c 	andi	r3,r2,2
   23cc0:	18000926 	beq	r3,zero,23ce8 <MBX_MailboxReadInd+0x78>
            result = COE_ContinueInd(psWriteMbx);
   23cc4:	d1214717 	ldw	r4,-31460(gp)
            u8MailboxSendReqStored &= ~COE_SERVICE;
   23cc8:	10803f4c 	andi	r2,r2,253
   23ccc:	d0a14805 	stb	r2,-31456(gp)
            result = COE_ContinueInd(psWriteMbx);
   23cd0:	00219080 	call	21908 <COE_ContinueInd>
            if (result != 0)
   23cd4:	10803fcc 	andi	r2,r2,255
   23cd8:	10000326 	beq	r2,zero,23ce8 <MBX_MailboxReadInd+0x78>
                u8MailboxSendReqStored |= COE_SERVICE;
   23cdc:	d0a14803 	ldbu	r2,-31456(gp)
   23ce0:	10800094 	ori	r2,r2,2
   23ce4:	d0a14805 	stb	r2,-31456(gp)
}
   23ce8:	dfc00017 	ldw	ra,0(sp)
   23cec:	dec00104 	addi	sp,sp,4
   23cf0:	f800283a 	ret
        TMBX MBXMEM* pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
   23cf4:	010000f4 	movhi	r4,3
   23cf8:	21216304 	addi	r4,r4,-31348
   23cfc:	00238340 	call	23834 <GetOutOfMbxQueue>
   23d00:	1009883a 	mov	r4,r2
        if (pMbx)
   23d04:	103fea26 	beq	r2,zero,23cb0 <MBX_MailboxReadInd+0x40>
            MBX_CopyToSendMailbox(pMbx);
   23d08:	0023b240 	call	23b24 <MBX_CopyToSendMailbox>
   23d0c:	003fe806 	br	23cb0 <MBX_MailboxReadInd+0x40>

00023d10 <MBX_MailboxRepeatReq>:
{
   23d10:	defffe04 	addi	sp,sp,-8
   23d14:	dc000015 	stw	r16,0(sp)
    if (psRepeatMbx)
   23d18:	d4214517 	ldw	r16,-31468(gp)
{
   23d1c:	dfc00115 	stw	ra,4(sp)
    if (psRepeatMbx)
   23d20:	80000e26 	beq	r16,zero,23d5c <MBX_MailboxRepeatReq+0x4c>
       if (bSendMbxIsFull && psStoreMbx == NULL)
   23d24:	d0a14b83 	ldbu	r2,-31442(gp)
   23d28:	10000926 	beq	r2,zero,23d50 <MBX_MailboxRepeatReq+0x40>
   23d2c:	d0a14417 	ldw	r2,-31472(gp)
   23d30:	1000071e 	bne	r2,zero,23d50 <MBX_MailboxRepeatReq+0x40>
            DisableSyncManChannel(MAILBOX_READ);
   23d34:	01000044 	movi	r4,1
   23d38:	0021a700 	call	21a70 <DisableSyncManChannel>
            psStoreMbx = psReadMbx;
   23d3c:	d0a14617 	ldw	r2,-31464(gp)
            EnableSyncManChannel(MAILBOX_READ);
   23d40:	01000044 	movi	r4,1
            psStoreMbx = psReadMbx;
   23d44:	d0a14415 	stw	r2,-31472(gp)
            EnableSyncManChannel(MAILBOX_READ);
   23d48:	0021ad00 	call	21ad0 <EnableSyncManChannel>
            bSendMbxIsFull = FALSE;
   23d4c:	d0214b85 	stb	zero,-31442(gp)
        MBX_CopyToSendMailbox(pMbx);
   23d50:	8009883a 	mov	r4,r16
   23d54:	0023b240 	call	23b24 <MBX_CopyToSendMailbox>
        psRepeatMbx = NULL;
   23d58:	d0214515 	stw	zero,-31468(gp)
    bMbxRepeatToggle = !bMbxRepeatToggle;
   23d5c:	d0a14b03 	ldbu	r2,-31444(gp)
   23d60:	1005003a 	cmpeq	r2,r2,zero
   23d64:	d0a14b05 	stb	r2,-31444(gp)
}
   23d68:	dfc00117 	ldw	ra,4(sp)
   23d6c:	dc000017 	ldw	r16,0(sp)
   23d70:	dec00204 	addi	sp,sp,8
   23d74:	f800283a 	ret

00023d78 <MBX_MailboxSendReq>:
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
   23d78:	d0a135c3 	ldbu	r2,-31529(gp)
   23d7c:	108003cc 	andi	r2,r2,15
   23d80:	10800060 	cmpeqi	r2,r2,1
   23d84:	1000321e 	bne	r2,zero,23e50 <MBX_MailboxSendReq+0xd8>
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23d88:	d0e14843 	ldbu	r3,-31455(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   23d8c:	2080010b 	ldhu	r2,4(r4)
{
   23d90:	defffc04 	addi	sp,sp,-16
   23d94:	dc800215 	stw	r18,8(sp)
   23d98:	dc400115 	stw	r17,4(sp)
   23d9c:	dc000015 	stw	r16,0(sp)
   23da0:	dfc00315 	stw	ra,12(sp)
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23da4:	18c001cc 	andi	r3,r3,7
   23da8:	2025883a 	mov	r18,r4
   23dac:	2823883a 	mov	r17,r5
   23db0:	2821883a 	mov	r16,r5
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
   23db4:	1083ffcc 	andi	r2,r2,4095
    if ( (u8MbxReadCounter & 0x07) == 0 )
   23db8:	1800021e 	bne	r3,zero,23dc4 <MBX_MailboxSendReq+0x4c>
        u8MbxReadCounter = 1;
   23dbc:	00c00044 	movi	r3,1
   23dc0:	d0e14845 	stb	r3,-31455(gp)
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   23dc4:	d0e14843 	ldbu	r3,-31455(gp)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   23dc8:	9009883a 	mov	r4,r18
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
   23dcc:	1806933a 	slli	r3,r3,12
   23dd0:	10c4b03a 	or	r2,r2,r3
   23dd4:	9080010d 	sth	r2,4(r18)
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
   23dd8:	0023b240 	call	23b24 <MBX_CopyToSendMailbox>
   23ddc:	10803fcc 	andi	r2,r2,255
   23de0:	10000d26 	beq	r2,zero,23e18 <MBX_MailboxSendReq+0xa0>
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
   23de4:	014000f4 	movhi	r5,3
   23de8:	29616304 	addi	r5,r5,-31348
   23dec:	9009883a 	mov	r4,r18
   23df0:	00237e40 	call	237e4 <PutInMbxQueue>
        if (result != 0)
   23df4:	10c03fcc 	andi	r3,r2,255
   23df8:	18000726 	beq	r3,zero,23e18 <MBX_MailboxSendReq+0xa0>
            flags |= FRAGMENTS_FOLLOW;
   23dfc:	043fe004 	movi	r16,-128
   23e00:	8c20b03a 	or	r16,r17,r16
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
   23e04:	d0e14803 	ldbu	r3,-31456(gp)
   23e08:	84001fcc 	andi	r16,r16,127
   23e0c:	80e0b03a 	or	r16,r16,r3
   23e10:	d4214805 	stb	r16,-31456(gp)
   23e14:	00000806 	br	23e38 <MBX_MailboxSendReq+0xc0>
        u8MbxReadCounter++;
   23e18:	d0a14843 	ldbu	r2,-31455(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   23e1c:	8c403fcc 	andi	r17,r17,255
   23e20:	8c40201c 	xori	r17,r17,128
        u8MbxReadCounter++;
   23e24:	10800044 	addi	r2,r2,1
   23e28:	d0a14845 	stb	r2,-31455(gp)
    if ( flags & FRAGMENTS_FOLLOW )
   23e2c:	8c7fe004 	addi	r17,r17,-128
   23e30:	0005883a 	mov	r2,zero
   23e34:	883ff316 	blt	r17,zero,23e04 <MBX_MailboxSendReq+0x8c>
}
   23e38:	dfc00317 	ldw	ra,12(sp)
   23e3c:	dc800217 	ldw	r18,8(sp)
   23e40:	dc400117 	ldw	r17,4(sp)
   23e44:	dc000017 	ldw	r16,0(sp)
   23e48:	dec00404 	addi	sp,sp,16
   23e4c:	f800283a 	ret
        return ERROR_INVALIDSTATE;
   23e50:	00bffc04 	movi	r2,-16
}
   23e54:	f800283a 	ret

00023e58 <MBX_MailboxWriteInd>:
    if(MbxLen > MAX_MBX_SIZE)
   23e58:	2080000b 	ldhu	r2,0(r4)
{
   23e5c:	defffd04 	addi	sp,sp,-12
   23e60:	dc400115 	stw	r17,4(sp)
   23e64:	dc000015 	stw	r16,0(sp)
   23e68:	dfc00215 	stw	ra,8(sp)
    if(MbxLen > MAX_MBX_SIZE)
   23e6c:	10802070 	cmpltui	r2,r2,129
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   23e70:	2440010b 	ldhu	r17,4(r4)
{
   23e74:	2021883a 	mov	r16,r4
    if(MbxLen > MAX_MBX_SIZE)
   23e78:	10000e1e 	bne	r2,zero,23eb4 <MBX_MailboxWriteInd+0x5c>
        pMbx->MbxHeader.Length     = 4;
   23e7c:	00800104 	movi	r2,4
   23e80:	2080000d 	sth	r2,0(r4)
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23e84:	00800044 	movi	r2,1
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23e88:	8c7c3fcc 	andi	r17,r17,61695
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23e8c:	2080018d 	sth	r2,6(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   23e90:	00800204 	movi	r2,8
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23e94:	2440010d 	sth	r17,4(r4)
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
   23e98:	2080020d 	sth	r2,8(r4)
        MBX_MailboxSendReq(pMbx, 0);
   23e9c:	000b883a 	mov	r5,zero
}
   23ea0:	dfc00217 	ldw	ra,8(sp)
   23ea4:	dc400117 	ldw	r17,4(sp)
   23ea8:	dc000017 	ldw	r16,0(sp)
   23eac:	dec00304 	addi	sp,sp,12
            MBX_MailboxSendReq(pMbx, 0);
   23eb0:	0023d781 	jmpi	23d78 <MBX_MailboxSendReq>
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
   23eb4:	88bfffcc 	andi	r2,r17,65535
   23eb8:	1006d33a 	srli	r3,r2,12
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
   23ebc:	18000226 	beq	r3,zero,23ec8 <MBX_MailboxWriteInd+0x70>
   23ec0:	d0a14883 	ldbu	r2,-31454(gp)
   23ec4:	10c01226 	beq	r2,r3,23f10 <MBX_MailboxWriteInd+0xb8>
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   23ec8:	014000f4 	movhi	r5,3
   23ecc:	29615604 	addi	r5,r5,-31400
   23ed0:	8009883a 	mov	r4,r16
        u8MbxWriteCounter = mbxCounter;
   23ed4:	d0e14885 	stb	r3,-31454(gp)
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
   23ed8:	00237e40 	call	237e4 <PutInMbxQueue>
        if ( result != 0 )
   23edc:	10c03fcc 	andi	r3,r2,255
   23ee0:	18001026 	beq	r3,zero,23f24 <MBX_MailboxWriteInd+0xcc>
            pMbx->MbxHeader.Length     = 4;
   23ee4:	00c00104 	movi	r3,4
   23ee8:	80c0000d 	sth	r3,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23eec:	8c7c3fcc 	andi	r17,r17,61695
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23ef0:	00c00044 	movi	r3,1
            pMbx->Data[1]                        = SWAPWORD(result);
   23ef4:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
   23ef8:	8440010d 	sth	r17,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23efc:	80c0018d 	sth	r3,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   23f00:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   23f04:	000b883a 	mov	r5,zero
   23f08:	8009883a 	mov	r4,r16
   23f0c:	003fe406 	br	23ea0 <MBX_MailboxWriteInd+0x48>
}
   23f10:	dfc00217 	ldw	ra,8(sp)
   23f14:	dc400117 	ldw	r17,4(sp)
   23f18:	dc000017 	ldw	r16,0(sp)
   23f1c:	dec00304 	addi	sp,sp,12
        APPL_FreeMailboxBuffer(pMbx);
   23f20:	0026bdc1 	jmpi	26bdc <free>
}
   23f24:	dfc00217 	ldw	ra,8(sp)
   23f28:	dc400117 	ldw	r17,4(sp)
   23f2c:	dc000017 	ldw	r16,0(sp)
   23f30:	dec00304 	addi	sp,sp,12
   23f34:	f800283a 	ret

00023f38 <MBX_CheckAndCopyMailbox>:
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f38:	d161498b 	ldhu	r5,-31450(gp)
{
   23f3c:	defffc04 	addi	sp,sp,-16
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f40:	01800084 	movi	r6,2
   23f44:	d9000084 	addi	r4,sp,2
{
   23f48:	dc400215 	stw	r17,8(sp)
   23f4c:	dfc00315 	stw	ra,12(sp)
   23f50:	dc000115 	stw	r16,4(sp)
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
   23f54:	00207400 	call	20740 <HW_EscRead>
    if(bNoMbxMemoryAvailable == TRUE)
   23f58:	d4614303 	ldbu	r17,-31476(gp)
   23f5c:	88800060 	cmpeqi	r2,r17,1
   23f60:	10001226 	beq	r2,zero,23fac <MBX_CheckAndCopyMailbox+0x74>
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
   23f64:	01000284 	movi	r4,10
   23f68:	0026bcc0 	call	26bcc <malloc>
   23f6c:	1021883a 	mov	r16,r2
        if(pMbx != NULL)
   23f70:	10000e26 	beq	r2,zero,23fac <MBX_CheckAndCopyMailbox+0x74>
            HMEMSET(pMbx,0x00,10);
   23f74:	01800204 	movi	r6,8
   23f78:	000b883a 	mov	r5,zero
   23f7c:	11000084 	addi	r4,r2,2
   23f80:	0026efc0 	call	26efc <memset>
            pMbx->MbxHeader.Length     = 4;
   23f84:	00800104 	movi	r2,4
   23f88:	8080000d 	sth	r2,0(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   23f8c:	008001c4 	movi	r2,7
            MBX_MailboxSendReq(pMbx, 0);
   23f90:	8009883a 	mov	r4,r16
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   23f94:	8440018d 	sth	r17,6(r16)
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
   23f98:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   23f9c:	000b883a 	mov	r5,zero
   23fa0:	0023d780 	call	23d78 <MBX_MailboxSendReq>
            APPL_FreeMailboxBuffer(pMbx);
   23fa4:	8009883a 	mov	r4,r16
   23fa8:	0026bdc0 	call	26bdc <free>
    mbxLen += MBX_HEADER_SIZE;
   23fac:	d880008b 	ldhu	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   23fb0:	d0e14b83 	ldbu	r3,-31442(gp)
   23fb4:	d1214803 	ldbu	r4,-31456(gp)
    mbxLen += MBX_HEADER_SIZE;
   23fb8:	10800184 	addi	r2,r2,6
   23fbc:	d880008d 	sth	r2,2(sp)
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
   23fc0:	1906b03a 	or	r3,r3,r4
   23fc4:	18c03fcc 	andi	r3,r3,255
   23fc8:	18000726 	beq	r3,zero,23fe8 <MBX_CheckAndCopyMailbox+0xb0>
            bReceiveMbxIsLocked = TRUE;
   23fcc:	00800044 	movi	r2,1
   23fd0:	d0a14bc5 	stb	r2,-31441(gp)
}
   23fd4:	dfc00317 	ldw	ra,12(sp)
   23fd8:	dc400217 	ldw	r17,8(sp)
   23fdc:	dc000117 	ldw	r16,4(sp)
   23fe0:	dec00404 	addi	sp,sp,16
   23fe4:	f800283a 	ret
        if (mbxLen > u16ReceiveMbxSize)
   23fe8:	d0e14a0b 	ldhu	r3,-31448(gp)
        bReceiveMbxIsLocked = FALSE;
   23fec:	d0214bc5 	stb	zero,-31441(gp)
        if (mbxLen > u16ReceiveMbxSize)
   23ff0:	10bfffcc 	andi	r2,r2,65535
   23ff4:	193fffcc 	andi	r4,r3,65535
   23ff8:	2080012e 	bgeu	r4,r2,24000 <MBX_CheckAndCopyMailbox+0xc8>
            mbxLen = u16ReceiveMbxSize;
   23ffc:	d8c0008d 	sth	r3,2(sp)
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
   24000:	0026bcc0 	call	26bcc <malloc>
   24004:	d0a14715 	stw	r2,-31460(gp)
   24008:	1009883a 	mov	r4,r2
        if (psWriteMbx == NULL)
   2400c:	103fef26 	beq	r2,zero,23fcc <MBX_CheckAndCopyMailbox+0x94>
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
   24010:	d980008b 	ldhu	r6,2(sp)
   24014:	d161498b 	ldhu	r5,-31450(gp)
   24018:	00207400 	call	20740 <HW_EscRead>
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   2401c:	01800044 	movi	r6,1
   24020:	01420144 	movi	r5,2053
   24024:	d9000044 	addi	r4,sp,1
        VARVOLATILE UINT8 smstate = 0x00;
   24028:	d8000045 	stb	zero,1(sp)
        HW_EscReadByte(smstate,ESC_SYNCMAN_STATUS_OFFSET);
   2402c:	00207400 	call	20740 <HW_EscRead>
        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
   24030:	d8800043 	ldbu	r2,1(sp)
   24034:	1080020c 	andi	r2,r2,8
   24038:	10000926 	beq	r2,zero,24060 <MBX_CheckAndCopyMailbox+0x128>
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   2403c:	d161498b 	ldhu	r5,-31450(gp)
   24040:	d0a14a0b 	ldhu	r2,-31448(gp)
   24044:	01800044 	movi	r6,1
   24048:	d12132c4 	addi	r4,gp,-31541
   2404c:	288b883a 	add	r5,r5,r2
   24050:	297fffc4 	addi	r5,r5,-1
   24054:	297fffcc 	andi	r5,r5,65535
            u8dummy = 0;
   24058:	d02132c5 	stb	zero,-31541(gp)
            HW_EscReadByte(u8dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 1));
   2405c:	00207400 	call	20740 <HW_EscRead>
        MBX_MailboxWriteInd( psWriteMbx );
   24060:	d1214717 	ldw	r4,-31460(gp)
   24064:	0023e580 	call	23e58 <MBX_MailboxWriteInd>
   24068:	003fda06 	br	23fd4 <MBX_CheckAndCopyMailbox+0x9c>

0002406c <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
   2406c:	defffa04 	addi	sp,sp,-24
   24070:	dc400115 	stw	r17,4(sp)

    do
    {
        UINT8 result = 0;

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   24074:	044000f4 	movhi	r17,3
{
   24078:	dd000415 	stw	r20,16(sp)
   2407c:	dcc00315 	stw	r19,12(sp)
   24080:	dc800215 	stw	r18,8(sp)
   24084:	dfc00515 	stw	ra,20(sp)
   24088:	dc000015 	stw	r16,0(sp)
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   2408c:	8c615604 	addi	r17,r17,-31400
        }

        if ( result != 0 )
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
   24090:	05000104 	movi	r20,4
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   24094:	04fc3fc4 	movi	r19,-3841
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   24098:	04800044 	movi	r18,1
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
   2409c:	8809883a 	mov	r4,r17
   240a0:	00238340 	call	23834 <GetOutOfMbxQueue>
   240a4:	1021883a 	mov	r16,r2
        if ( pMbx )
   240a8:	10000a1e 	bne	r2,zero,240d4 <MBX_Main+0x68>
        }
    }
    while ( pMbx != NULL );


    if (bReceiveMbxIsLocked)
   240ac:	d0a14bc3 	ldbu	r2,-31441(gp)
   240b0:	10001726 	beq	r2,zero,24110 <MBX_Main+0xa4>
    if (u8MailboxSendReqStored)
    {
        /* there are mailbox services stored to be sent */
    }
/*ECATCHANGE_END(V5.13) EOE1*/
}
   240b4:	dfc00517 	ldw	ra,20(sp)
   240b8:	dd000417 	ldw	r20,16(sp)
   240bc:	dcc00317 	ldw	r19,12(sp)
   240c0:	dc800217 	ldw	r18,8(sp)
   240c4:	dc400117 	ldw	r17,4(sp)
   240c8:	dc000017 	ldw	r16,0(sp)
   240cc:	dec00604 	addi	sp,sp,24
        MBX_CheckAndCopyMailbox();
   240d0:	0023f381 	jmpi	23f38 <MBX_CheckAndCopyMailbox>
            result = MailboxServiceInd(pMbx);
   240d4:	1009883a 	mov	r4,r2
   240d8:	0023b040 	call	23b04 <MailboxServiceInd>
        if ( result != 0 )
   240dc:	10c03fcc 	andi	r3,r2,255
   240e0:	183fee26 	beq	r3,zero,2409c <MBX_Main+0x30>
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   240e4:	80c0010b 	ldhu	r3,4(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   240e8:	10803fcc 	andi	r2,r2,255
            pMbx->MbxHeader.Length     = 4;
   240ec:	8500000d 	sth	r20,0(r16)
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
   240f0:	1cc6703a 	and	r3,r3,r19
   240f4:	80c0010d 	sth	r3,4(r16)
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
   240f8:	8480018d 	sth	r18,6(r16)
            pMbx->Data[1]                        = SWAPWORD(result);
   240fc:	8080020d 	sth	r2,8(r16)
            MBX_MailboxSendReq(pMbx, 0);
   24100:	000b883a 	mov	r5,zero
   24104:	8009883a 	mov	r4,r16
   24108:	0023d780 	call	23d78 <MBX_MailboxSendReq>
   2410c:	003fe306 	br	2409c <MBX_Main+0x30>
}
   24110:	dfc00517 	ldw	ra,20(sp)
   24114:	dd000417 	ldw	r20,16(sp)
   24118:	dcc00317 	ldw	r19,12(sp)
   2411c:	dc800217 	ldw	r18,8(sp)
   24120:	dc400117 	ldw	r17,4(sp)
   24124:	dc000017 	ldw	r16,0(sp)
   24128:	dec00604 	addi	sp,sp,24
   2412c:	f800283a 	ret

00024130 <OBJ_GetObjectHandle>:
             and returns a handle if found.

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
{
   24130:	defffe04 	addi	sp,sp,-8
   24134:	dc000015 	stw	r16,0(sp)
   24138:	2021883a 	mov	r16,r4
   2413c:	dfc00115 	stw	ra,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();

    while (pObjEntry!= NULL)
    {
        
        if (pObjEntry->Index == index)
   24140:	843fffcc 	andi	r16,r16,65535
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24144:	00209a80 	call	209a8 <COE_GetObjectDictionary>
    while (pObjEntry!= NULL)
   24148:	1000041e 	bne	r2,zero,2415c <OBJ_GetObjectHandle+0x2c>
            return pObjEntry;
        }
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
    }
    return 0;
}
   2414c:	dfc00117 	ldw	ra,4(sp)
   24150:	dc000017 	ldw	r16,0(sp)
   24154:	dec00204 	addi	sp,sp,8
   24158:	f800283a 	ret
        if (pObjEntry->Index == index)
   2415c:	10c0020b 	ldhu	r3,8(r2)
   24160:	1c3ffa26 	beq	r3,r16,2414c <OBJ_GetObjectHandle+0x1c>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24164:	10800117 	ldw	r2,4(r2)
   24168:	003ff706 	br	24148 <OBJ_GetObjectHandle+0x18>

0002416c <OBJ_GetObjectLength>:

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2416c:	30c0030b 	ldhu	r3,12(r6)
{
   24170:	defffe04 	addi	sp,sp,-8
   24174:	dc000015 	stw	r16,0(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24178:	1804d23a 	srli	r2,r3,8
{
   2417c:	dfc00115 	stw	ra,4(sp)
    
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
    UINT32 size = 0;

    if ( bCompleteAccess )
   24180:	39c03fcc 	andi	r7,r7,255
{
   24184:	2821883a 	mov	r16,r5
   24188:	108003cc 	andi	r2,r2,15
    if ( bCompleteAccess )
   2418c:	38002026 	beq	r7,zero,24210 <OBJ_GetObjectLength+0xa4>
    {
        if ( objCode == OBJCODE_VAR )
   24190:	110001e0 	cmpeqi	r4,r2,7
   24194:	2000361e 	bne	r4,zero,24270 <OBJ_GetObjectLength+0x104>
        {
            return 0;
        }
        else if ((objCode == OBJCODE_ARR)
   24198:	10800218 	cmpnei	r2,r2,8
   2419c:	1000171e 	bne	r2,zero,241fc <OBJ_GetObjectLength+0x90>
            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   241a0:	30800417 	ldw	r2,16(r6)
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   241a4:	30c00617 	ldw	r3,24(r6)
            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
   241a8:	1100020b 	ldhu	r4,8(r2)
   241ac:	19400003 	ldbu	r5,0(r3)
   241b0:	0026ba40 	call	26ba4 <__mulsi3>
            for (i = 1; i <= maxSubindex; i++)
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
   241b4:	108001c4 	addi	r2,r2,7

            if ( subindex == 0 )
   241b8:	81403fcc 	andi	r5,r16,255
            size = BIT2BYTE(size);
   241bc:	1004d0fa 	srli	r2,r2,3
            if ( subindex == 0 )
   241c0:	2800011e 	bne	r5,zero,241c8 <OBJ_GetObjectLength+0x5c>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
   241c4:	10800084 	addi	r2,r2,2
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
                }
            }
        }
    }
}
   241c8:	dfc00117 	ldw	ra,4(sp)
   241cc:	dc000017 	ldw	r16,0(sp)
   241d0:	dec00204 	addi	sp,sp,8
   241d4:	f800283a 	ret
                size += pObjEntry->pEntryDesc[i].BitLength;
   241d8:	31c00417 	ldw	r7,16(r6)
            for (i = 1; i <= maxSubindex; i++)
   241dc:	21000044 	addi	r4,r4,1
                size += pObjEntry->pEntryDesc[i].BitLength;
   241e0:	394f883a 	add	r7,r7,r5
   241e4:	39c0008b 	ldhu	r7,2(r7)
   241e8:	29400184 	addi	r5,r5,6
   241ec:	11c5883a 	add	r2,r2,r7
            for (i = 1; i <= maxSubindex; i++)
   241f0:	21ffffcc 	andi	r7,r4,65535
   241f4:	19fff82e 	bgeu	r3,r7,241d8 <OBJ_GetObjectLength+0x6c>
   241f8:	003fee06 	br	241b4 <OBJ_GetObjectLength+0x48>
   241fc:	01400184 	movi	r5,6
   24200:	01000044 	movi	r4,1
    UINT32 size = 0;
   24204:	0005883a 	mov	r2,zero
            for (i = 1; i <= maxSubindex; i++)
   24208:	18c03fcc 	andi	r3,r3,255
   2420c:	003ff806 	br	241f0 <OBJ_GetObjectLength+0x84>
        if ( objCode == OBJCODE_VAR )
   24210:	110001d8 	cmpnei	r4,r2,7
   24214:	2000031e 	bne	r4,zero,24224 <OBJ_GetObjectLength+0xb8>
            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
   24218:	30800417 	ldw	r2,16(r6)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   2421c:	1080008b 	ldhu	r2,2(r2)
   24220:	00000606 	br	2423c <OBJ_GetObjectLength+0xd0>
        else if ( subindex == 0 )
   24224:	29403fcc 	andi	r5,r5,255
   24228:	28000f26 	beq	r5,zero,24268 <OBJ_GetObjectLength+0xfc>
        else if((objCode == OBJCODE_ARR)
   2422c:	10800218 	cmpnei	r2,r2,8
   24230:	1000051e 	bne	r2,zero,24248 <OBJ_GetObjectLength+0xdc>
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
   24234:	30800417 	ldw	r2,16(r6)
   24238:	1080020b 	ldhu	r2,8(r2)
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   2423c:	108001c4 	addi	r2,r2,7
   24240:	1005d0fa 	srai	r2,r2,3
   24244:	003fe006 	br	241c8 <OBJ_GetObjectLength+0x5c>
                if (maxSubindex < subindex)
   24248:	18c03fcc 	andi	r3,r3,255
   2424c:	19400836 	bltu	r3,r5,24270 <OBJ_GetObjectLength+0x104>
                    return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
   24250:	2804907a 	slli	r2,r5,1
   24254:	30c00417 	ldw	r3,16(r6)
   24258:	1145883a 	add	r2,r2,r5
   2425c:	1004907a 	slli	r2,r2,1
   24260:	1885883a 	add	r2,r3,r2
   24264:	003fed06 	br	2421c <OBJ_GetObjectLength+0xb0>
            return 1;
   24268:	00800044 	movi	r2,1
   2426c:	003fd606 	br	241c8 <OBJ_GetObjectLength+0x5c>
            return 0;
   24270:	0005883a 	mov	r2,zero
   24274:	003fd406 	br	241c8 <OBJ_GetObjectLength+0x5c>

00024278 <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
   24278:	defffd04 	addi	sp,sp,-12
   2427c:	dc400115 	stw	r17,4(sp)
    UINT8 Modulo;

    pStr[2] = '0';
    pStr[0] += (Number / 100);
   24280:	2c403fcc 	andi	r17,r5,255
{
   24284:	dc000015 	stw	r16,0(sp)
    pStr[0] += (Number / 100);
   24288:	01401904 	movi	r5,100
{
   2428c:	2021883a 	mov	r16,r4
    pStr[0] += (Number / 100);
   24290:	8809883a 	mov	r4,r17
{
   24294:	dfc00215 	stw	ra,8(sp)
    pStr[0] += (Number / 100);
   24298:	0026ae40 	call	26ae4 <__udivsi3>
   2429c:	80c00003 	ldbu	r3,0(r16)
    Modulo = Number % 100;
   242a0:	8809883a 	mov	r4,r17
   242a4:	01401904 	movi	r5,100
    pStr[0] += (Number / 100);
   242a8:	10c5883a 	add	r2,r2,r3
   242ac:	80800005 	stb	r2,0(r16)
    Modulo = Number % 100;
   242b0:	0026b480 	call	26b48 <__umodsi3>
    pStr[1] += (Modulo / 10);
   242b4:	14403fcc 	andi	r17,r2,255
   242b8:	8809883a 	mov	r4,r17
   242bc:	01400284 	movi	r5,10
   242c0:	0026ae40 	call	26ae4 <__udivsi3>
   242c4:	80c00043 	ldbu	r3,1(r16)
    pStr[2] += (Modulo % 10);
   242c8:	01400284 	movi	r5,10
   242cc:	8809883a 	mov	r4,r17
    pStr[1] += (Modulo / 10);
   242d0:	10c5883a 	add	r2,r2,r3
   242d4:	80800045 	stb	r2,1(r16)
    pStr[2] += (Modulo % 10);
   242d8:	0026b480 	call	26b48 <__umodsi3>
   242dc:	10800c04 	addi	r2,r2,48
   242e0:	80800085 	stb	r2,2(r16)
}
   242e4:	dfc00217 	ldw	ra,8(sp)
   242e8:	dc400117 	ldw	r17,4(sp)
   242ec:	dc000017 	ldw	r16,0(sp)
   242f0:	dec00304 	addi	sp,sp,12
   242f4:	f800283a 	ret

000242f8 <OBJ_GetDesc>:
                0xFF                                            <br>
            }
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
{
   242f8:	defff604 	addi	sp,sp,-40
   242fc:	dcc00715 	stw	r19,28(sp)
   24300:	dc800615 	stw	r18,24(sp)
   24304:	dc000415 	stw	r16,16(sp)
   24308:	dfc00915 	stw	ra,36(sp)
   2430c:	dd000815 	stw	r20,32(sp)
   24310:	dc400515 	stw	r17,20(sp)
/* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;



    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24314:	2cc03fcc 	andi	r19,r5,255
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
   24318:	34000517 	ldw	r16,20(r6)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2431c:	3080030b 	ldhu	r2,12(r6)
{
   24320:	3825883a 	mov	r18,r7
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   24324:	98000426 	beq	r19,zero,24338 <OBJ_GetDesc+0x40>
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24328:	1004d23a 	srli	r2,r2,8
    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
   2432c:	108003cc 	andi	r2,r2,15
   24330:	10c001d8 	cmpnei	r3,r2,7
   24334:	1800091e 	bne	r3,zero,2435c <OBJ_GetDesc+0x64>
    {
        // Get object description length
       strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
   24338:	8009883a 	mov	r4,r16
   2433c:	0026f1c0 	call	26f1c <strlen>
   24340:	1023883a 	mov	r17,r2

        // If there is a pointer given, copy data:
        if ( pData )
   24344:	90001a26 	beq	r18,zero,243b0 <OBJ_GetDesc+0xb8>
        {
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
   24348:	11bfffcc 	andi	r6,r2,65535
                if ( i == tmpSubindex )
                {
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
                    if ( pData && strSize )
                    {
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   2434c:	800b883a 	mov	r5,r16
   24350:	9009883a 	mov	r4,r18
   24354:	0026ed40 	call	26ed4 <memcpy>
            }
            }
            }
        }

        if ( strSize == 0 )
   24358:	00001506 	br	243b0 <OBJ_GetDesc+0xb8>
        if ( objCode == OBJCODE_REC )
   2435c:	10800258 	cmpnei	r2,r2,9
   24360:	1000251e 	bne	r2,zero,243f8 <OBJ_GetDesc+0x100>
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   24364:	8009883a 	mov	r4,r16
            UINT16 tmpSubindex = subindex;
   24368:	2c403fcc 	andi	r17,r5,255
            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
   2436c:	0026f1c0 	call	26f1c <strlen>
   24370:	10800044 	addi	r2,r2,1
   24374:	80a1883a 	add	r16,r16,r2
            UINT16 i = 1;
   24378:	05000044 	movi	r20,1
                if ( i == tmpSubindex )
   2437c:	8c7fffcc 	andi	r17,r17,65535
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   24380:	80800003 	ldbu	r2,0(r16)
   24384:	10803fb0 	cmpltui	r2,r2,254
   24388:	10001b26 	beq	r2,zero,243f8 <OBJ_GetDesc+0x100>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   2438c:	8009883a 	mov	r4,r16
   24390:	0026f1c0 	call	26f1c <strlen>
                if ( i == tmpSubindex )
   24394:	a0ffffcc 	andi	r3,r20,65535
   24398:	88c0111e 	bne	r17,r3,243e0 <OBJ_GetDesc+0xe8>
                   strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
   2439c:	1023883a 	mov	r17,r2
                    if ( pData && strSize )
   243a0:	10ffffcc 	andi	r3,r2,65535
   243a4:	90000b1e 	bne	r18,zero,243d4 <OBJ_GetDesc+0xdc>
        if ( strSize == 0 )
   243a8:	1800011e 	bne	r3,zero,243b0 <OBJ_GetDesc+0xb8>
        {
            // no string found for subindex x -> name is Subindex x
            strSize =    12;
   243ac:	04400304 	movi	r17,12
            }
        }
    }

    return strSize;
}
   243b0:	8805883a 	mov	r2,r17
   243b4:	dfc00917 	ldw	ra,36(sp)
   243b8:	dd000817 	ldw	r20,32(sp)
   243bc:	dcc00717 	ldw	r19,28(sp)
   243c0:	dc800617 	ldw	r18,24(sp)
   243c4:	dc400517 	ldw	r17,20(sp)
   243c8:	dc000417 	ldw	r16,16(sp)
   243cc:	dec00a04 	addi	sp,sp,40
   243d0:	f800283a 	ret
                    if ( pData && strSize )
   243d4:	18000926 	beq	r3,zero,243fc <OBJ_GetDesc+0x104>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
   243d8:	11bfffcc 	andi	r6,r2,65535
   243dc:	003fdb06 	br	2434c <OBJ_GetDesc+0x54>
                    i++;
   243e0:	a0c00044 	addi	r3,r20,1
   243e4:	1829883a 	mov	r20,r3
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   243e8:	10800044 	addi	r2,r2,1
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   243ec:	18ffffcc 	andi	r3,r3,65535
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
   243f0:	80a1883a 	add	r16,r16,r2
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
   243f4:	88ffe22e 	bgeu	r17,r3,24380 <OBJ_GetDesc+0x88>
            if ( pData )
   243f8:	903fec26 	beq	r18,zero,243ac <OBJ_GetDesc+0xb4>
                MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
   243fc:	014000b4 	movhi	r5,2
   24400:	01800344 	movi	r6,13
   24404:	d90000c4 	addi	r4,sp,3
   24408:	295fb504 	addi	r5,r5,32468
   2440c:	0026ed40 	call	26ed4 <memcpy>
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
   24410:	980b883a 	mov	r5,r19
   24414:	d9000304 	addi	r4,sp,12
   24418:	00242780 	call	24278 <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
   2441c:	01800344 	movi	r6,13
   24420:	d94000c4 	addi	r5,sp,3
   24424:	9009883a 	mov	r4,r18
   24428:	0026ed40 	call	26ed4 <memcpy>
   2442c:	003fdf06 	br	243ac <OBJ_GetDesc+0xb4>

00024430 <OBJ_GetEntryDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24430:	20c0030b 	ldhu	r3,12(r4)
   24434:	20800417 	ldw	r2,16(r4)
   24438:	29403fcc 	andi	r5,r5,255
   2443c:	1807d23a 	srai	r3,r3,8

    if ((objCode == OBJCODE_ARR)
   24440:	18c003cc 	andi	r3,r3,15
   24444:	18c00218 	cmpnei	r3,r3,8
   24448:	1800031e 	bne	r3,zero,24458 <OBJ_GetEntryDesc+0x28>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
   2444c:	28000626 	beq	r5,zero,24468 <OBJ_GetEntryDesc+0x38>
            pEntry = &pObjEntry->pEntryDesc[0];
        }
        else
        {
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
   24450:	10800184 	addi	r2,r2,6
   24454:	f800283a 	ret
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
   24458:	2806907a 	slli	r3,r5,1
   2445c:	1947883a 	add	r3,r3,r5
   24460:	1806907a 	slli	r3,r3,1
   24464:	10c5883a 	add	r2,r2,r3
        }
    }

    return pEntry;
}
   24468:	f800283a 	ret

0002446c <OBJ_GetNoOfObjects>:
{
   2446c:	defff904 	addi	sp,sp,-28
   24470:	dd000415 	stw	r20,16(sp)
   24474:	dcc00315 	stw	r19,12(sp)
   24478:	2029883a 	mov	r20,r4
    UINT16 listFlags = 0x0020 << listType;
   2447c:	04c00804 	movi	r19,32
   24480:	21003fcc 	andi	r4,r4,255
{
   24484:	dc800215 	stw	r18,8(sp)
   24488:	dc000015 	stw	r16,0(sp)
    UINT16 listFlags = 0x0020 << listType;
   2448c:	9926983a 	sll	r19,r19,r4
{
   24490:	dfc00615 	stw	ra,24(sp)
   24494:	dd400515 	stw	r21,20(sp)
   24498:	dc400115 	stw	r17,4(sp)
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   2449c:	00209a80 	call	209a8 <COE_GetObjectDictionary>
   244a0:	1021883a 	mov	r16,r2
    UINT16 n = 0;
   244a4:	0025883a 	mov	r18,zero
            if ( t )
   244a8:	a5003fcc 	andi	r20,r20,255
    while (pObjEntry != NULL)
   244ac:	80000a1e 	bne	r16,zero,244d8 <OBJ_GetNoOfObjects+0x6c>
}
   244b0:	9005883a 	mov	r2,r18
   244b4:	dfc00617 	ldw	ra,24(sp)
   244b8:	dd400517 	ldw	r21,20(sp)
   244bc:	dd000417 	ldw	r20,16(sp)
   244c0:	dcc00317 	ldw	r19,12(sp)
   244c4:	dc800217 	ldw	r18,8(sp)
   244c8:	dc400117 	ldw	r17,4(sp)
   244cc:	dc000017 	ldw	r16,0(sp)
   244d0:	dec00704 	addi	sp,sp,28
   244d4:	f800283a 	ret
        if ( pObjEntry->Index >= 0x1000 )
   244d8:	8080020b 	ldhu	r2,8(r16)
   244dc:	10840030 	cmpltui	r2,r2,4096
   244e0:	10000c1e 	bne	r2,zero,24514 <OBJ_GetNoOfObjects+0xa8>
            if ( t )
   244e4:	a0000d26 	beq	r20,zero,2451c <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   244e8:	85400303 	ldbu	r21,12(r16)
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   244ec:	0023883a 	mov	r17,zero
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
   244f0:	880b883a 	mov	r5,r17
   244f4:	8009883a 	mov	r4,r16
   244f8:	00244300 	call	24430 <OBJ_GetEntryDesc>
   244fc:	1080010b 	ldhu	r2,4(r2)
   24500:	14c4703a 	and	r2,r2,r19
   24504:	1000051e 	bne	r2,zero,2451c <OBJ_GetNoOfObjects+0xb0>
                while ( t && i <= maxSubindex )
   24508:	8c400044 	addi	r17,r17,1
   2450c:	88bfffcc 	andi	r2,r17,65535
   24510:	a8bff72e 	bgeu	r21,r2,244f0 <OBJ_GetNoOfObjects+0x84>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24514:	84000117 	ldw	r16,4(r16)
   24518:	003fe406 	br	244ac <OBJ_GetNoOfObjects+0x40>
                n++;
   2451c:	94800044 	addi	r18,r18,1
   24520:	003ffc06 	br	24514 <OBJ_GetNoOfObjects+0xa8>

00024524 <OBJ_GetObjectList>:
    if ( pIndex[0] == 0x1000 )
   24524:	2880000b 	ldhu	r2,0(r5)
{
   24528:	defff604 	addi	sp,sp,-40
   2452c:	ddc00715 	stw	r23,28(sp)
   24530:	dd800615 	stw	r22,24(sp)
   24534:	dd400515 	stw	r21,20(sp)
   24538:	dd000415 	stw	r20,16(sp)
   2453c:	dcc00315 	stw	r19,12(sp)
   24540:	dc800215 	stw	r18,8(sp)
   24544:	dc400115 	stw	r17,4(sp)
   24548:	dfc00915 	stw	ra,36(sp)
   2454c:	df000815 	stw	fp,32(sp)
   24550:	dc000015 	stw	r16,0(sp)
    if ( pIndex[0] == 0x1000 )
   24554:	10840018 	cmpnei	r2,r2,4096
{
   24558:	ddc00a17 	ldw	r23,40(sp)
   2455c:	2025883a 	mov	r18,r4
   24560:	2827883a 	mov	r19,r5
   24564:	3023883a 	mov	r17,r6
   24568:	3829883a 	mov	r20,r7
   2456c:	202d883a 	mov	r22,r4
   24570:	302b883a 	mov	r21,r6
    if ( pIndex[0] == 0x1000 )
   24574:	10001c1e 	bne	r2,zero,245e8 <OBJ_GetObjectList+0xc4>
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
   24578:	00209a80 	call	209a8 <COE_GetObjectDictionary>
   2457c:	1021883a 	mov	r16,r2
        if((pObjEntry == NULL) && (pAbort != NULL))
   24580:	10001326 	beq	r2,zero,245d0 <OBJ_GetObjectList+0xac>
        while (pObjEntry != NULL && size > 1 )
   24584:	8c7fffcc 	andi	r17,r17,65535
   24588:	8c4000a8 	cmpgeui	r17,r17,2
   2458c:	8800191e 	bne	r17,zero,245f4 <OBJ_GetObjectList+0xd0>
            pIndex[0] = pObjEntry->Index;
   24590:	8080020b 	ldhu	r2,8(r16)
   24594:	9880000d 	sth	r2,0(r19)
}
   24598:	a805883a 	mov	r2,r21
    pSdoInfoObjEntry = pObjEntry;
   2459c:	d4215415 	stw	r16,-31408(gp)
}
   245a0:	dfc00917 	ldw	ra,36(sp)
   245a4:	df000817 	ldw	fp,32(sp)
   245a8:	ddc00717 	ldw	r23,28(sp)
   245ac:	dd800617 	ldw	r22,24(sp)
   245b0:	dd400517 	ldw	r21,20(sp)
   245b4:	dd000417 	ldw	r20,16(sp)
   245b8:	dcc00317 	ldw	r19,12(sp)
   245bc:	dc800217 	ldw	r18,8(sp)
   245c0:	dc400117 	ldw	r17,4(sp)
   245c4:	dc000017 	ldw	r16,0(sp)
   245c8:	dec00a04 	addi	sp,sp,40
   245cc:	f800283a 	ret
        if((pObjEntry == NULL) && (pAbort != NULL))
   245d0:	b8000226 	beq	r23,zero,245dc <OBJ_GetObjectList+0xb8>
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
   245d4:	008006c4 	movi	r2,27
   245d8:	b8800005 	stb	r2,0(r23)
            pIndex[0] = 0xFFFF;
   245dc:	00bfffc4 	movi	r2,-1
   245e0:	0021883a 	mov	r16,zero
   245e4:	003feb06 	br	24594 <OBJ_GetObjectList+0x70>
        pObjEntry = pSdoInfoObjEntry;
   245e8:	d4215417 	ldw	r16,-31408(gp)
    if ( pObjEntry != NULL )
   245ec:	803fe51e 	bne	r16,zero,24584 <OBJ_GetObjectList+0x60>
   245f0:	003ffa06 	br	245dc <OBJ_GetObjectList+0xb8>
    UINT16 listFlags = 0x0020 << listType;
   245f4:	94bfffcc 	andi	r18,r18,65535
   245f8:	00800804 	movi	r2,32
   245fc:	14a4983a 	sll	r18,r2,r18
                if ( t )
   24600:	b5bfffcc 	andi	r22,r22,65535
            if ( pObjEntry->Index >= 0x1000 )
   24604:	85c0020b 	ldhu	r23,8(r16)
   24608:	b8bfffcc 	andi	r2,r23,65535
   2460c:	10840030 	cmpltui	r2,r2,4096
   24610:	10000c1e 	bne	r2,zero,24644 <OBJ_GetObjectList+0x120>
                if ( t )
   24614:	b0001126 	beq	r22,zero,2465c <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   24618:	87000303 	ldbu	fp,12(r16)
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   2461c:	0023883a 	mov	r17,zero
                        if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
   24620:	880b883a 	mov	r5,r17
   24624:	8009883a 	mov	r4,r16
   24628:	00244300 	call	24430 <OBJ_GetEntryDesc>
   2462c:	1080010b 	ldhu	r2,4(r2)
   24630:	1484703a 	and	r2,r2,r18
   24634:	1000091e 	bne	r2,zero,2465c <OBJ_GetObjectList+0x138>
                    while ( t && i <= maxSubindex )
   24638:	8c400044 	addi	r17,r17,1
   2463c:	88bfffcc 	andi	r2,r17,65535
   24640:	e0bff72e 	bgeu	fp,r2,24620 <OBJ_GetObjectList+0xfc>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
   24644:	84000117 	ldw	r16,4(r16)
        while (pObjEntry != NULL && size > 1 )
   24648:	803fe426 	beq	r16,zero,245dc <OBJ_GetObjectList+0xb8>
   2464c:	a8bfffcc 	andi	r2,r21,65535
   24650:	108000a8 	cmpgeui	r2,r2,2
   24654:	103feb1e 	bne	r2,zero,24604 <OBJ_GetObjectList+0xe0>
   24658:	003fcd06 	br	24590 <OBJ_GetObjectList+0x6c>
                    *pData = SWAPWORD(pObjEntry->Index);
   2465c:	a5c0000d 	sth	r23,0(r20)
                    size -= 2;
   24660:	ad7fff84 	addi	r21,r21,-2
                    pData++;
   24664:	a5000084 	addi	r20,r20,2
                    size -= 2;
   24668:	003ff606 	br	24644 <OBJ_GetObjectList+0x120>

0002466c <OBJ_GetObjDesc>:
*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    return &pObjEntry->ObjDesc;
}
   2466c:	20800284 	addi	r2,r4,10
   24670:	f800283a 	ret

00024674 <OBJ_GetEntryOffset>:
UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
{
    UINT16 i;
    /* bitOffset will be initialized with the bit offset of subindex 1 */
    UINT16 bitOffset = 0;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24674:	28c0030b 	ldhu	r3,12(r5)
   24678:	1807d23a 	srai	r3,r3,8
   2467c:	18c003cc 	andi	r3,r3,15
   24680:	1811883a 	mov	r8,r3
    {
        /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
        bitOffset +=16;
    }

    if (objCode == OBJCODE_VAR)
   24684:	18c001e0 	cmpeqi	r3,r3,7
   24688:	1800531e 	bne	r3,zero,247d8 <OBJ_GetEntryOffset+0x164>
   2468c:	20803fcc 	andi	r2,r4,255
    {
        return 0;
    }

    for (i = 1; i <= subindex; i++)
   24690:	02800044 	movi	r10,1
   24694:	1004c03a 	cmpne	r2,r2,zero
    {
        /* get the entry description */
        if ((objCode == OBJCODE_ARR)
   24698:	42003fcc 	andi	r8,r8,255
        else
        {
            pEntry = &pObjEntry->pEntryDesc[i];
        }

        switch (pEntry->DataType)
   2469c:	02d00074 	movhi	r11,16385
   246a0:	03080034 	movhi	r12,8192
    for (i = 1; i <= subindex; i++)
   246a4:	21003fcc 	andi	r4,r4,255
   246a8:	51bfffcc 	andi	r6,r10,65535
   246ac:	1004913a 	slli	r2,r2,4
   246b0:	02400184 	movi	r9,6
        if ((objCode == OBJCODE_ARR)
   246b4:	42000218 	cmpnei	r8,r8,8
        case    DEFTYPE_ARRAY_OF_INT :

#if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
            /* the 16-bit variables in the structure are word-aligned,
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
   246b8:	03fffc04 	movi	r15,-16
        case    DEFTYPE_ARRAY_OF_DINT :
        case    DEFTYPE_ARRAY_OF_UDINT:
#if OBJ_DWORD_ALIGN
            /* the 32-bit variables in the structure are dword-aligned,
               align the actual bitOffset to a dword */
            bitOffset = (bitOffset+31) & 0xFFE0;
   246bc:	037ff804 	movi	r13,-32
   246c0:	03800044 	movi	r14,1
        switch (pEntry->DataType)
   246c4:	5ae00004 	addi	r11,r11,-32768
   246c8:	63100004 	addi	r12,r12,16384
    for (i = 1; i <= subindex; i++)
   246cc:	2180462e 	bgeu	r4,r6,247e8 <OBJ_GetEntryOffset+0x174>
            break;
        }
    }

    return bitOffset;
}
   246d0:	f800283a 	ret
            pEntry = &pObjEntry->pEntryDesc[i];
   246d4:	3a4f883a 	add	r7,r7,r9
   246d8:	00004906 	br	24800 <OBJ_GetEntryOffset+0x18c>
        switch (pEntry->DataType)
   246dc:	18fffbc4 	addi	r3,r3,-17
   246e0:	18ffffcc 	andi	r3,r3,65535
   246e4:	70c6983a 	sll	r3,r14,r3
   246e8:	1c01044c 	andi	r16,r3,1041
   246ec:	8000341e 	bne	r16,zero,247c0 <OBJ_GetEntryOffset+0x14c>
   246f0:	1ae0703a 	and	r16,r3,r11
   246f4:	80002b1e 	bne	r16,zero,247a4 <OBJ_GetEntryOffset+0x130>
   246f8:	1b06703a 	and	r3,r3,r12
   246fc:	18004a26 	beq	r3,zero,24828 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24700:	108003c4 	addi	r2,r2,15
   24704:	00fffc04 	movi	r3,-16
   24708:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   2470c:	31003436 	bltu	r6,r4,247e0 <OBJ_GetEntryOffset+0x16c>
    for (i = 1; i <= subindex; i++)
   24710:	52800044 	addi	r10,r10,1
   24714:	51bfffcc 	andi	r6,r10,65535
   24718:	4a400184 	addi	r9,r9,6
   2471c:	2180352e 	bgeu	r4,r6,247f4 <OBJ_GetEntryOffset+0x180>
}
   24720:	dfc00117 	ldw	ra,4(sp)
   24724:	dc000017 	ldw	r16,0(sp)
   24728:	dec00204 	addi	sp,sp,8
   2472c:	f800283a 	ret
   24730:	77c6983a 	sll	r3,r14,ra
        switch (pEntry->DataType)
   24734:	1c00640c 	andi	r16,r3,400
   24738:	80001a1e 	bne	r16,zero,247a4 <OBJ_GetEntryOffset+0x130>
   2473c:	18c2120c 	andi	r3,r3,2120
   24740:	18003926 	beq	r3,zero,24828 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24744:	108003c4 	addi	r2,r2,15
   24748:	00fffc04 	movi	r3,-16
   2474c:	10c4703a 	and	r2,r2,r3
            if (i < subindex)
   24750:	313fef2e 	bgeu	r6,r4,24710 <OBJ_GetEntryOffset+0x9c>
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
   24754:	ffc002d8 	cmpnei	ra,ra,11
   24758:	f800211e 	bne	ra,zero,247e0 <OBJ_GetEntryOffset+0x16c>
                bitOffset += pEntry->BitLength;
   2475c:	38c0008b 	ldhu	r3,2(r7)
   24760:	00000b06 	br	24790 <OBJ_GetEntryOffset+0x11c>
        switch (pEntry->DataType)
   24764:	ffc09820 	cmpeqi	ra,ra,608
   24768:	f8000b1e 	bne	ra,zero,24798 <OBJ_GetEntryOffset+0x124>
   2476c:	18ff6784 	addi	r3,r3,-610
   24770:	18ffffcc 	andi	r3,r3,65535
   24774:	18c000a8 	cmpgeui	r3,r3,2
   24778:	18002b1e 	bne	r3,zero,24828 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   2477c:	10c007c4 	addi	r3,r2,31
   24780:	1b46703a 	and	r3,r3,r13
   24784:	1805883a 	mov	r2,r3
            if (i < subindex)
   24788:	313fe12e 	bgeu	r6,r4,24710 <OBJ_GetEntryOffset+0x9c>
                    bitOffset += pEntry->BitLength;
   2478c:	3880008b 	ldhu	r2,2(r7)
                bitOffset += pEntry->BitLength;
   24790:	1885883a 	add	r2,r3,r2
   24794:	003fde06 	br	24710 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset+15) & 0xFFF0;
   24798:	108003c4 	addi	r2,r2,15
   2479c:	13c4703a 	and	r2,r2,r15
            if (i < subindex)
   247a0:	00002106 	br	24828 <OBJ_GetEntryOffset+0x1b4>
            bitOffset = (bitOffset+31) & 0xFFE0;
   247a4:	10c007c4 	addi	r3,r2,31
   247a8:	00bff804 	movi	r2,-32
   247ac:	1886703a 	and	r3,r3,r2
   247b0:	1805883a 	mov	r2,r3
            if (i < subindex)
   247b4:	313fd62e 	bgeu	r6,r4,24710 <OBJ_GetEntryOffset+0x9c>
                   bitOffset += 32;
   247b8:	18800804 	addi	r2,r3,32
   247bc:	003fd406 	br	24710 <OBJ_GetEntryOffset+0x9c>
            bitOffset = (bitOffset + 31) & 0xFFE0;
   247c0:	10c007c4 	addi	r3,r2,31
   247c4:	1b46703a 	and	r3,r3,r13
   247c8:	1805883a 	mov	r2,r3
            if (i < subindex)
   247cc:	313fd02e 	bgeu	r6,r4,24710 <OBJ_GetEntryOffset+0x9c>
                bitOffset += 64;
   247d0:	18801004 	addi	r2,r3,64
   247d4:	003fce06 	br	24710 <OBJ_GetEntryOffset+0x9c>
        return 0;
   247d8:	0005883a 	mov	r2,zero
   247dc:	f800283a 	ret
                    bitOffset += 16;
   247e0:	10800404 	addi	r2,r2,16
   247e4:	003fca06 	br	24710 <OBJ_GetEntryOffset+0x9c>
{
   247e8:	defffe04 	addi	sp,sp,-8
   247ec:	dfc00115 	stw	ra,4(sp)
   247f0:	dc000015 	stw	r16,0(sp)
            pEntry = &pObjEntry->pEntryDesc[1];
   247f4:	29c00417 	ldw	r7,16(r5)
        if ((objCode == OBJCODE_ARR)
   247f8:	403fb61e 	bne	r8,zero,246d4 <OBJ_GetEntryOffset+0x60>
            pEntry = &pObjEntry->pEntryDesc[1];
   247fc:	39c00184 	addi	r7,r7,6
        switch (pEntry->DataType)
   24800:	38c0000b 	ldhu	r3,0(r7)
   24804:	1fffffcc 	andi	ra,r3,65535
   24808:	fc000c28 	cmpgeui	r16,ra,48
   2480c:	803fd51e 	bne	r16,zero,24764 <OBJ_GetEntryOffset+0xf0>
   24810:	fc000468 	cmpgeui	r16,ra,17
   24814:	803fb11e 	bne	r16,zero,246dc <OBJ_GetEntryOffset+0x68>
   24818:	18ffff44 	addi	r3,r3,-3
   2481c:	18ffffcc 	andi	r3,r3,65535
   24820:	18c00268 	cmpgeui	r3,r3,9
   24824:	183fc226 	beq	r3,zero,24730 <OBJ_GetEntryOffset+0xbc>
            if (i < subindex)
   24828:	313fb92e 	bgeu	r6,r4,24710 <OBJ_GetEntryOffset+0x9c>
   2482c:	003fcb06 	br	2475c <OBJ_GetEntryOffset+0xe8>

00024830 <CheckSyncTypeValue>:

 \brief    Checks if the new Sync type value is valid
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
{
    switch (NewSyncType)
   24830:	297fffcc 	andi	r5,r5,65535
   24834:	288000a0 	cmpeqi	r2,r5,2
   24838:	1000281e 	bne	r2,zero,248dc <CheckSyncTypeValue+0xac>
   2483c:	288000e8 	cmpgeui	r2,r5,3
   24840:	1000031e 	bne	r2,zero,24850 <CheckSyncTypeValue+0x20>
   24844:	2800081e 	bne	r5,zero,24868 <CheckSyncTypeValue+0x38>
    {
    case SYNCTYPE_FREERUN:
        return 0; //free run sync mode is always accepted
   24848:	0005883a 	mov	r2,zero
   2484c:	f800283a 	ret
    switch (NewSyncType)
   24850:	288000e0 	cmpeqi	r2,r5,3
   24854:	10002d1e 	bne	r2,zero,2490c <CheckSyncTypeValue+0xdc>
   24858:	294008a0 	cmpeqi	r5,r5,34
   2485c:	2800161e 	bne	r5,zero,248b8 <CheckSyncTypeValue+0x88>
        {
            return 0;
        }
        break;
    } //switch 
    return ABORTIDX_VALUE_EXCEEDED;
   24860:	00800484 	movi	r2,18

}
   24864:	f800283a 	ret
        if ((index == 0x1C32) 
   24868:	213fffcc 	andi	r4,r4,65535
   2486c:	20870c98 	cmpnei	r2,r4,7218
   24870:	1000071e 	bne	r2,zero,24890 <CheckSyncTypeValue+0x60>
            && (nPdOutputSize > 0) 
   24874:	d0a1370b 	ldhu	r2,-31524(gp)
   24878:	103ff926 	beq	r2,zero,24860 <CheckSyncTypeValue+0x30>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
   2487c:	008000f4 	movhi	r2,3
   24880:	10a1840b 	ldhu	r2,-31216(r2)
   24884:	1080008c 	andi	r2,r2,2
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24888:	103ff526 	beq	r2,zero,24860 <CheckSyncTypeValue+0x30>
   2488c:	003fee06 	br	24848 <CheckSyncTypeValue+0x18>
        if ((index == 0x1C33) 
   24890:	21070cd8 	cmpnei	r4,r4,7219
   24894:	203ff21e 	bne	r4,zero,24860 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   24898:	008000f4 	movhi	r2,3
   2489c:	10a1730b 	ldhu	r2,-31284(r2)
   248a0:	1080008c 	andi	r2,r2,2
   248a4:	103fee26 	beq	r2,zero,24860 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize == 0) 
   248a8:	d0a1370b 	ldhu	r2,-31524(gp)
   248ac:	103fec1e 	bne	r2,zero,24860 <CheckSyncTypeValue+0x30>
            && (nPdInputSize > 0))
   248b0:	d0a1378b 	ldhu	r2,-31522(gp)
   248b4:	003ff406 	br	24888 <CheckSyncTypeValue+0x58>
        if ((index == 0x1C33) 
   248b8:	213fffcc 	andi	r4,r4,65535
   248bc:	21070cd8 	cmpnei	r4,r4,7219
   248c0:	203fe71e 	bne	r4,zero,24860 <CheckSyncTypeValue+0x30>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
   248c4:	008000f4 	movhi	r2,3
   248c8:	10a1730b 	ldhu	r2,-31284(r2)
   248cc:	1080008c 	andi	r2,r2,2
   248d0:	103fe326 	beq	r2,zero,24860 <CheckSyncTypeValue+0x30>
            && (nPdOutputSize > 0))
   248d4:	d0a1370b 	ldhu	r2,-31524(gp)
   248d8:	003feb06 	br	24888 <CheckSyncTypeValue+0x58>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   248dc:	213fffcc 	andi	r4,r4,65535
   248e0:	20870c98 	cmpnei	r2,r4,7218
   248e4:	1000041e 	bne	r2,zero,248f8 <CheckSyncTypeValue+0xc8>
   248e8:	008000f4 	movhi	r2,3
   248ec:	10a1840b 	ldhu	r2,-31216(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
   248f0:	1080010c 	andi	r2,r2,4
   248f4:	003fe406 	br	24888 <CheckSyncTypeValue+0x58>
   248f8:	21070cd8 	cmpnei	r4,r4,7219
   248fc:	203fd81e 	bne	r4,zero,24860 <CheckSyncTypeValue+0x30>
   24900:	008000f4 	movhi	r2,3
   24904:	10a1730b 	ldhu	r2,-31284(r2)
   24908:	003ff906 	br	248f0 <CheckSyncTypeValue+0xc0>
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   2490c:	213fffcc 	andi	r4,r4,65535
   24910:	20870c98 	cmpnei	r2,r4,7218
   24914:	1000041e 	bne	r2,zero,24928 <CheckSyncTypeValue+0xf8>
   24918:	008000f4 	movhi	r2,3
   2491c:	10a1840b 	ldhu	r2,-31216(r2)
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
   24920:	1080020c 	andi	r2,r2,8
   24924:	003fd806 	br	24888 <CheckSyncTypeValue+0x58>
   24928:	21070cd8 	cmpnei	r4,r4,7219
   2492c:	203fcc1e 	bne	r4,zero,24860 <CheckSyncTypeValue+0x30>
   24930:	008000f4 	movhi	r2,3
   24934:	10a1730b 	ldhu	r2,-31284(r2)
   24938:	003ff906 	br	24920 <CheckSyncTypeValue+0xf0>

0002493c <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
   2493c:	defff004 	addi	sp,sp,-64
   24940:	dd400b15 	stw	r21,44(sp)
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24944:	3d40030b 	ldhu	r21,12(r7)
{
   24948:	df000e15 	stw	fp,56(sp)
   2494c:	ddc00d15 	stw	r23,52(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24950:	a804d23a 	srli	r2,r21,8
{
   24954:	dd800c15 	stw	r22,48(sp)
   24958:	dd000a15 	stw	r20,40(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2495c:	108003cc 	andi	r2,r2,15
{
   24960:	dcc00915 	stw	r19,36(sp)
   24964:	dc400715 	stw	r17,28(sp)
   24968:	dc000615 	stw	r16,24(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   2496c:	102f883a 	mov	r23,r2
{
   24970:	dfc00f15 	stw	ra,60(sp)
   24974:	dc800815 	stw	r18,32(sp)
   24978:	d9800115 	stw	r6,4(sp)
   2497c:	d900008d 	sth	r4,2(sp)
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   24980:	108001e0 	cmpeqi	r2,r2,7
{
   24984:	dd801017 	ldw	r22,64(sp)
   24988:	dcc01103 	ldbu	r19,68(sp)
   2498c:	2023883a 	mov	r17,r4
   24990:	2839883a 	mov	fp,r5
   24994:	3821883a 	mov	r16,r7
    UINT16 i = subindex;
   24998:	2d003fcc 	andi	r20,r5,255
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   2499c:	ad403fcc 	andi	r21,r21,255
    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
   249a0:	1000191e 	bne	r2,zero,24a08 <OBJ_Read+0xcc>
   249a4:	20bfffcc 	andi	r2,r4,65535
   249a8:	10840030 	cmpltui	r2,r2,4096
   249ac:	1000161e 	bne	r2,zero,24a08 <OBJ_Read+0xcc>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
   249b0:	38800617 	ldw	r2,24(r7)
   249b4:	14800003 	ldbu	r18,0(r2)
   249b8:	902b883a 	mov	r21,r18

    }

    if ( bCompleteAccess )
   249bc:	9800211e 	bne	r19,zero,24a44 <OBJ_Read+0x108>

        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
    }
    else
        if ( subindex > maxSubindex )
   249c0:	a0bfffcc 	andi	r2,r20,65535
   249c4:	a93fffcc 	andi	r4,r21,65535
   249c8:	20815c36 	bltu	r4,r2,24f3c <OBJ_Read+0x600>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   249cc:	8009883a 	mov	r4,r16
   249d0:	e1403fcc 	andi	r5,fp,255
   249d4:	00244300 	call	24430 <OBJ_GetEntryDesc>

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
   249d8:	1100010b 	ldhu	r4,4(r2)
   249dc:	20bfffcc 	andi	r2,r4,65535
   249e0:	10000a26 	beq	r2,zero,24a0c <OBJ_Read+0xd0>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)))
   249e4:	2004907a 	slli	r2,r4,1
   249e8:	d16135c3 	ldbu	r5,-31529(gp)
   249ec:	1144703a 	and	r2,r2,r5
   249f0:	1080038c 	andi	r2,r2,14
   249f4:	1000191e 	bne	r2,zero,24a5c <OBJ_Read+0x120>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   249f8:	210001cc 	andi	r4,r4,7
   249fc:	2001511e 	bne	r4,zero,24f44 <OBJ_Read+0x608>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
   24a00:	07000184 	movi	fp,6
   24a04:	00000206 	br	24a10 <OBJ_Read+0xd4>
    if ( bCompleteAccess )
   24a08:	983fed26 	beq	r19,zero,249c0 <OBJ_Read+0x84>
            return ABORTIDX_UNSUPPORTED_ACCESS;
   24a0c:	07000144 	movi	fp,5
                return result;
            }
        }

    return 0;
}
   24a10:	e005883a 	mov	r2,fp
   24a14:	dfc00f17 	ldw	ra,60(sp)
   24a18:	df000e17 	ldw	fp,56(sp)
   24a1c:	ddc00d17 	ldw	r23,52(sp)
   24a20:	dd800c17 	ldw	r22,48(sp)
   24a24:	dd400b17 	ldw	r21,44(sp)
   24a28:	dd000a17 	ldw	r20,40(sp)
   24a2c:	dcc00917 	ldw	r19,36(sp)
   24a30:	dc800817 	ldw	r18,32(sp)
   24a34:	dc400717 	ldw	r17,28(sp)
   24a38:	dc000617 	ldw	r16,24(sp)
   24a3c:	dec01004 	addi	sp,sp,64
   24a40:	f800283a 	ret
        if (pAPPL_CoeReadInd != NULL)
   24a44:	d0a12d17 	ldw	r2,-31564(gp)
   24a48:	1000071e 	bne	r2,zero,24a68 <OBJ_Read+0x12c>
        if ( pObjEntry->Read != NULL )
   24a4c:	38800717 	ldw	r2,28(r7)
   24a50:	10000b1e 	bne	r2,zero,24a80 <OBJ_Read+0x144>
    UINT16 i = subindex;
   24a54:	a023883a 	mov	r17,r20
   24a58:	00002006 	br	24adc <OBJ_Read+0x1a0>
        if (pAPPL_CoeReadInd != NULL)
   24a5c:	d0a12d17 	ldw	r2,-31564(gp)
    UINT16 lastSubindex = subindex;
   24a60:	a025883a 	mov	r18,r20
        if (pAPPL_CoeReadInd != NULL)
   24a64:	10000426 	beq	r2,zero,24a78 <OBJ_Read+0x13c>
            pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
   24a68:	980d883a 	mov	r6,r19
   24a6c:	e1403fcc 	andi	r5,fp,255
   24a70:	893fffcc 	andi	r4,r17,65535
   24a74:	103ee83a 	callr	r2
        if ( pObjEntry->Read != NULL )
   24a78:	80800717 	ldw	r2,28(r16)
   24a7c:	10001126 	beq	r2,zero,24ac4 <OBJ_Read+0x188>
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24a80:	d9800117 	ldw	r6,4(sp)
   24a84:	b00f883a 	mov	r7,r22
   24a88:	e1403fcc 	andi	r5,fp,255
   24a8c:	893fffcc 	andi	r4,r17,65535
   24a90:	dcc01015 	stw	r19,64(sp)
}
   24a94:	dfc00f17 	ldw	ra,60(sp)
   24a98:	df000e17 	ldw	fp,56(sp)
   24a9c:	ddc00d17 	ldw	r23,52(sp)
   24aa0:	dd800c17 	ldw	r22,48(sp)
   24aa4:	dd400b17 	ldw	r21,44(sp)
   24aa8:	dd000a17 	ldw	r20,40(sp)
   24aac:	dcc00917 	ldw	r19,36(sp)
   24ab0:	dc800817 	ldw	r18,32(sp)
   24ab4:	dc400717 	ldw	r17,28(sp)
   24ab8:	dc000617 	ldw	r16,24(sp)
   24abc:	dec01004 	addi	sp,sp,64
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
   24ac0:	1000683a 	jmp	r2
        else if ( index < 0x1000 && subindex != 0 )
   24ac4:	88ffffcc 	andi	r3,r17,65535
   24ac8:	18c40028 	cmpgeui	r3,r3,4096
   24acc:	183fe11e 	bne	r3,zero,24a54 <OBJ_Read+0x118>
   24ad0:	e7003fcc 	andi	fp,fp,255
   24ad4:	e000111e 	bne	fp,zero,24b1c <OBJ_Read+0x1e0>
            for (i = subindex; i <= lastSubindex; i++)
   24ad8:	0023883a 	mov	r17,zero
                else if ( index >= 0x1000 )
   24adc:	d880008b 	ldhu	r2,2(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24ae0:	bdc03fcc 	andi	r23,r23,255
   24ae4:	8c7fffcc 	andi	r17,r17,65535
                else if ( index >= 0x1000 )
   24ae8:	10840030 	cmpltui	r2,r2,4096
   24aec:	d8800215 	stw	r2,8(sp)
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24af0:	b88001e0 	cmpeqi	r2,r23,7
                            bRead = 1;
   24af4:	0039883a 	mov	fp,zero
   24af8:	000d883a 	mov	r6,zero
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24afc:	d8800315 	stw	r2,12(sp)
            for (i = subindex; i <= lastSubindex; i++)
   24b00:	dc40008d 	sth	r17,2(sp)
   24b04:	88bfffcc 	andi	r2,r17,65535
   24b08:	90ffffcc 	andi	r3,r18,65535
   24b0c:	1880392e 	bgeu	r3,r2,24bf4 <OBJ_Read+0x2b8>
            if(bRead == 0)
   24b10:	30803fcc 	andi	r2,r6,255
   24b14:	1000221e 	bne	r2,zero,24ba0 <OBJ_Read+0x264>
   24b18:	003fbd06 	br	24a10 <OBJ_Read+0xd4>
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24b1c:	e00b883a 	mov	r5,fp
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   24b20:	84400617 	ldw	r17,24(r16)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24b24:	e03890ba 	slli	fp,fp,2
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   24b28:	8009883a 	mov	r4,r16
   24b2c:	00244300 	call	24430 <OBJ_GetEntryDesc>
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24b30:	8f23883a 	add	r17,r17,fp
            size = BIT2BYTE(pEntry->BitLength);
   24b34:	1180008b 	ldhu	r6,2(r2)
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
   24b38:	897fff17 	ldw	r5,-4(r17)
            size = BIT2BYTE(pEntry->BitLength);
   24b3c:	318001c4 	addi	r6,r6,7
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   24b40:	2880004c 	andi	r2,r5,1
            size = BIT2BYTE(pEntry->BitLength);
   24b44:	300dd0fa 	srai	r6,r6,3
            if((((MEM_ADDR)pVarPtr) & 0x1) == 0x1)
   24b48:	10002126 	beq	r2,zero,24bd0 <OBJ_Read+0x294>
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   24b4c:	00bfff84 	movi	r2,-2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b50:	3006d07a 	srli	r3,r6,1
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
   24b54:	288a703a 	and	r5,r5,r2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24b58:	b009883a 	mov	r4,r22
   24b5c:	0011883a 	mov	r8,zero
   24b60:	2d95c83a 	sub	r10,r5,r22
   24b64:	40bfffcc 	andi	r2,r8,65535
   24b68:	2293883a 	add	r9,r4,r10
   24b6c:	18800e1e 	bne	r3,r2,24ba8 <OBJ_Read+0x26c>
                if((size % 2) == 1)
   24b70:	3180004c 	andi	r6,r6,1
   24b74:	30000a26 	beq	r6,zero,24ba0 <OBJ_Read+0x264>
   24b78:	1806907a 	slli	r3,r3,1
   24b7c:	b0cf883a 	add	r7,r22,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   24b80:	3880000b 	ldhu	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   24b84:	28cb883a 	add	r5,r5,r3
                    pData[0] &= 0xFF00; //Clear last Byte
   24b88:	10bfc00c 	andi	r2,r2,65280
   24b8c:	3880000d 	sth	r2,0(r7)
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
   24b90:	28c0000b 	ldhu	r3,0(r5)
   24b94:	1806d23a 	srli	r3,r3,8
   24b98:	10c4b03a 	or	r2,r2,r3
   24b9c:	3880000d 	sth	r2,0(r7)
    return 0;
   24ba0:	0039883a 	mov	fp,zero
   24ba4:	003f9a06 	br	24a10 <OBJ_Read+0xd4>
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   24ba8:	4880000b 	ldhu	r2,0(r9)
                    pData++;
   24bac:	21000084 	addi	r4,r4,2
                for(cnt = 0; cnt < (size / 2);cnt++)
   24bb0:	42000044 	addi	r8,r8,1
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
   24bb4:	1004d23a 	srli	r2,r2,8
   24bb8:	20bfff8d 	sth	r2,-2(r4)
                    pData[0] |= (pVarPtr[1] & 0xFF) << 8;
   24bbc:	4a40008b 	ldhu	r9,2(r9)
   24bc0:	4812923a 	slli	r9,r9,8
   24bc4:	1244b03a 	or	r2,r2,r9
   24bc8:	20bfff8d 	sth	r2,-2(r4)
                for(cnt = 0; cnt < (size / 2);cnt++)
   24bcc:	003fe506 	br	24b64 <OBJ_Read+0x228>
            pData[0] = pVarPtr[0];
   24bd0:	2880000b 	ldhu	r2,0(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24bd4:	31bfff04 	addi	r6,r6,-4
   24bd8:	29400104 	addi	r5,r5,4
            pData[0] = pVarPtr[0];
   24bdc:	b080000d 	sth	r2,0(r22)
            pData[1] = pVarPtr[1];
   24be0:	28bfff8b 	ldhu	r2,-2(r5)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24be4:	b1000104 	addi	r4,r22,4
            pData[1] = pVarPtr[1];
   24be8:	b080008d 	sth	r2,2(r22)
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
   24bec:	0026ed40 	call	26ed4 <memcpy>
   24bf0:	003feb06 	br	24ba0 <OBJ_Read+0x264>
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   24bf4:	80c00617 	ldw	r3,24(r16)
   24bf8:	d8c00115 	stw	r3,4(sp)
                if (i == 0)
   24bfc:	10002226 	beq	r2,zero,24c88 <OBJ_Read+0x34c>
                else if ( index >= 0x1000 )
   24c00:	d8800217 	ldw	r2,8(sp)
   24c04:	1000221e 	bne	r2,zero,24c90 <OBJ_Read+0x354>
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   24c08:	800b883a 	mov	r5,r16
   24c0c:	8809883a 	mov	r4,r17
   24c10:	d9800415 	stw	r6,16(sp)
   24c14:	00246740 	call	24674 <OBJ_GetEntryOffset>
   24c18:	d9800417 	ldw	r6,16(sp)
   24c1c:	1007883a 	mov	r3,r2
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
   24c20:	8009883a 	mov	r4,r16
   24c24:	880b883a 	mov	r5,r17
   24c28:	d8c00515 	stw	r3,20(sp)
   24c2c:	d9800415 	stw	r6,16(sp)
   24c30:	00244300 	call	24430 <OBJ_GetEntryDesc>
   24c34:	102f883a 	mov	r23,r2
                if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MASK)) )
   24c38:	10800103 	ldbu	r2,4(r2)
   24c3c:	d12135c3 	ldbu	r4,-31529(gp)
   24c40:	d9800417 	ldw	r6,16(sp)
   24c44:	1004907a 	slli	r2,r2,1
   24c48:	d8c00517 	ldw	r3,20(sp)
   24c4c:	1104703a 	and	r2,r2,r4
   24c50:	1080038c 	andi	r2,r2,14
   24c54:	10009e26 	beq	r2,zero,24ed0 <OBJ_Read+0x594>
                    if ( i == subindex                                     /* requested entry */
   24c58:	d880008b 	ldhu	r2,2(sp)
   24c5c:	a13fffcc 	andi	r4,r20,65535
   24c60:	11000226 	beq	r2,r4,24c6c <OBJ_Read+0x330>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   24c64:	98000626 	beq	r19,zero,24c80 <OBJ_Read+0x344>
   24c68:	11000536 	bltu	r2,r4,24c80 <OBJ_Read+0x344>
                        if ( i == 0 && objCode != OBJCODE_VAR )
   24c6c:	10000a1e 	bne	r2,zero,24c98 <OBJ_Read+0x35c>
   24c70:	d8800317 	ldw	r2,12(sp)
   24c74:	1000081e 	bne	r2,zero,24c98 <OBJ_Read+0x35c>
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
   24c78:	b540000d 	sth	r21,0(r22)
                            pData++;
   24c7c:	b5800084 	addi	r22,r22,2
            for (i = subindex; i <= lastSubindex; i++)
   24c80:	8c400044 	addi	r17,r17,1
   24c84:	003f9e06 	br	24b00 <OBJ_Read+0x1c4>
                UINT16 bitOffset = 0;
   24c88:	8807883a 	mov	r3,r17
   24c8c:	003fe406 	br	24c20 <OBJ_Read+0x2e4>
   24c90:	0007883a 	mov	r3,zero
   24c94:	003fe206 	br	24c20 <OBJ_Read+0x2e4>
                pVarPtr += (bitOffset >> 4);
   24c98:	180ad0fa 	srli	r5,r3,3
   24c9c:	d8800117 	ldw	r2,4(sp)
                            UINT16 dataType = pEntry->DataType;
   24ca0:	b900000b 	ldhu	r4,0(r23)
                pVarPtr += (bitOffset >> 4);
   24ca4:	2947ff8c 	andi	r5,r5,8190
   24ca8:	114b883a 	add	r5,r2,r5
                            if (pEntry->DataType >= 0x700)
   24cac:	20bfffcc 	andi	r2,r4,65535
   24cb0:	1181c030 	cmpltui	r6,r2,1792
   24cb4:	3000201e 	bne	r6,zero,24d38 <OBJ_Read+0x3fc>
                                if ( pEntry->BitLength <= 8 )
   24cb8:	b900008b 	ldhu	r4,2(r23)
   24cbc:	20bfffcc 	andi	r2,r4,65535
   24cc0:	11800268 	cmpgeui	r6,r2,9
   24cc4:	3000161e 	bne	r6,zero,24d20 <OBJ_Read+0x3e4>
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   24cc8:	21000bc4 	addi	r4,r4,47
                            switch (dataType)
   24ccc:	213ff884 	addi	r4,r4,-30
   24cd0:	213fffcc 	andi	r4,r4,65535
   24cd4:	00800044 	movi	r2,1
   24cd8:	1104983a 	sll	r2,r2,r4
   24cdc:	0100ff74 	movhi	r4,1021
   24ce0:	21200044 	addi	r4,r4,-32767
   24ce4:	1108703a 	and	r4,r2,r4
   24ce8:	2000591e 	bne	r4,zero,24e50 <OBJ_Read+0x514>
   24cec:	010000b4 	movhi	r4,2
   24cf0:	21000104 	addi	r4,r4,4
   24cf4:	1108703a 	and	r4,r2,r4
   24cf8:	20006d1e 	bne	r4,zero,24eb0 <OBJ_Read+0x574>
   24cfc:	01000074 	movhi	r4,1
   24d00:	21000084 	addi	r4,r4,2
   24d04:	1104703a 	and	r2,r2,r4
   24d08:	10000926 	beq	r2,zero,24d30 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24d0c:	18c003cc 	andi	r3,r3,15
   24d10:	183f3e1e 	bne	r3,zero,24a0c <OBJ_Read+0xd0>
                                pData[0] = SWAPWORD(pVarPtr[0]);
   24d14:	2880000b 	ldhu	r2,0(r5)
   24d18:	b080000d 	sth	r2,0(r22)
   24d1c:	00005f06 	br	24e9c <OBJ_Read+0x560>
                                else if ( pEntry->BitLength == 16 )
   24d20:	11000420 	cmpeqi	r4,r2,16
   24d24:	203ff91e 	bne	r4,zero,24d0c <OBJ_Read+0x3d0>
                                else if ( pEntry->BitLength == 32 )
   24d28:	10800820 	cmpeqi	r2,r2,32
   24d2c:	1000601e 	bne	r2,zero,24eb0 <OBJ_Read+0x574>
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   24d30:	07000604 	movi	fp,24
   24d34:	003f3606 	br	24a10 <OBJ_Read+0xd4>
                            switch (dataType)
   24d38:	11800328 	cmpgeui	r6,r2,12
   24d3c:	30000d1e 	bne	r6,zero,24d74 <OBJ_Read+0x438>
   24d40:	110002a8 	cmpgeui	r4,r2,10
   24d44:	2000241e 	bne	r4,zero,24dd8 <OBJ_Read+0x49c>
   24d48:	11000260 	cmpeqi	r4,r2,9
   24d4c:	2000221e 	bne	r4,zero,24dd8 <OBJ_Read+0x49c>
   24d50:	10003126 	beq	r2,zero,24e18 <OBJ_Read+0x4dc>
   24d54:	01000044 	movi	r4,1
   24d58:	2084983a 	sll	r2,r4,r2
   24d5c:	1100640c 	andi	r4,r2,400
   24d60:	2000531e 	bne	r4,zero,24eb0 <OBJ_Read+0x574>
   24d64:	1100098c 	andi	r4,r2,38
   24d68:	2000391e 	bne	r4,zero,24e50 <OBJ_Read+0x514>
   24d6c:	1080120c 	andi	r2,r2,72
   24d70:	003fe506 	br	24d08 <OBJ_Read+0x3cc>
   24d74:	11800e28 	cmpgeui	r6,r2,56
   24d78:	3000131e 	bne	r6,zero,24dc8 <OBJ_Read+0x48c>
   24d7c:	118007a8 	cmpgeui	r6,r2,30
   24d80:	303fd21e 	bne	r6,zero,24ccc <OBJ_Read+0x390>
   24d84:	213ffecc 	andi	r4,r4,65531
   24d88:	21000460 	cmpeqi	r4,r4,17
   24d8c:	2000021e 	bne	r4,zero,24d98 <OBJ_Read+0x45c>
   24d90:	108006e0 	cmpeqi	r2,r2,27
   24d94:	103fe626 	beq	r2,zero,24d30 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24d98:	18c003cc 	andi	r3,r3,15
   24d9c:	183f1b1e 	bne	r3,zero,24a0c <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   24da0:	2880000b 	ldhu	r2,0(r5)
                                pData += 4;
   24da4:	b5800204 	addi	r22,r22,8
                                pData[0] = pVarPtr[0];
   24da8:	b0bffe0d 	sth	r2,-8(r22)
                                pData[1] = pVarPtr[1];
   24dac:	2880008b 	ldhu	r2,2(r5)
   24db0:	b0bffe8d 	sth	r2,-6(r22)
                                pData[2] = pVarPtr[2];
   24db4:	2880010b 	ldhu	r2,4(r5)
   24db8:	b0bfff0d 	sth	r2,-4(r22)
                                pData[3] = pVarPtr[3];
   24dbc:	2880018b 	ldhu	r2,6(r5)
   24dc0:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   24dc4:	00002006 	br	24e48 <OBJ_Read+0x50c>
                            switch (dataType)
   24dc8:	213f6804 	addi	r4,r4,-608
   24dcc:	213fffcc 	andi	r4,r4,65535
   24dd0:	21000128 	cmpgeui	r4,r4,4
   24dd4:	203fd61e 	bne	r4,zero,24d30 <OBJ_Read+0x3f4>
                                if(bitOffset & 0xF)
   24dd8:	18c003cc 	andi	r3,r3,15
   24ddc:	183f0b1e 	bne	r3,zero,24a0c <OBJ_Read+0xd0>
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
   24de0:	b980008b 	ldhu	r6,2(r23)
   24de4:	b009883a 	mov	r4,r22
   24de8:	318001c4 	addi	r6,r6,7
   24dec:	300cd0fa 	srli	r6,r6,3
   24df0:	0026ed40 	call	26ed4 <memcpy>
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   24df4:	b880008b 	ldhu	r2,2(r23)
   24df8:	10fffc0c 	andi	r3,r2,65520
   24dfc:	1806d0fa 	srli	r3,r3,3
                                if((pEntry->BitLength & 0xF) != 0)
   24e00:	108003cc 	andi	r2,r2,15
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
   24e04:	b0ed883a 	add	r22,r22,r3
                                if((pEntry->BitLength & 0xF) != 0)
   24e08:	10000f26 	beq	r2,zero,24e48 <OBJ_Read+0x50c>
                                    *pData &= 0xFF;
   24e0c:	b0800003 	ldbu	r2,0(r22)
   24e10:	b080000d 	sth	r2,0(r22)
   24e14:	00000c06 	br	24e48 <OBJ_Read+0x50c>
                                if(bCompleteAccess)
   24e18:	983fc526 	beq	r19,zero,24d30 <OBJ_Read+0x3f4>
                                    if (((pEntry->BitLength & 0xF) > 0)
   24e1c:	b880008b 	ldhu	r2,2(r23)
   24e20:	114003cc 	andi	r5,r2,15
   24e24:	113fffcc 	andi	r4,r2,65535
   24e28:	28000426 	beq	r5,zero,24e3c <OBJ_Read+0x500>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   24e2c:	10c5883a 	add	r2,r2,r3
   24e30:	108003cc 	andi	r2,r2,15
   24e34:	1000011e 	bne	r2,zero,24e3c <OBJ_Read+0x500>
                                        pData++;
   24e38:	b5800084 	addi	r22,r22,2
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
   24e3c:	2004d0fa 	srli	r2,r4,3
   24e40:	1080078c 	andi	r2,r2,30
   24e44:	b0ad883a 	add	r22,r22,r2
                            bRead = 1;
   24e48:	01800044 	movi	r6,1
   24e4c:	003f8c06 	br	24c80 <OBJ_Read+0x344>
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   24e50:	b900008b 	ldhu	r4,2(r23)
   24e54:	008000b4 	movhi	r2,2
   24e58:	198003cc 	andi	r6,r3,15
   24e5c:	2008907a 	slli	r4,r4,1
                                    TmpValue = SWAPWORD(pVarPtr[0]);
   24e60:	2940000b 	ldhu	r5,0(r5)
                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   24e64:	2085883a 	add	r2,r4,r2
   24e68:	109ec70b 	ldhu	r2,31516(r2)
   24e6c:	1184983a 	sll	r2,r2,r6
                                    if ((bitOffset & 0x0F) == 0) 
   24e70:	3000011e 	bne	r6,zero,24e78 <OBJ_Read+0x53c>
                                        pData[0] = 0;
   24e74:	b000000d 	sth	zero,0(r22)
                                    pData[0] = SWAPWORD(pData[0]);
   24e78:	b100000b 	ldhu	r4,0(r22)
                                        pData[0] |= TmpValue & bitMask;
   24e7c:	1144703a 	and	r2,r2,r5
                                    if (bCompleteAccess) 
   24e80:	98000826 	beq	r19,zero,24ea4 <OBJ_Read+0x568>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   24e84:	1104b03a 	or	r2,r2,r4
                                        pData[0] |= TmpValue & bitMask;
   24e88:	b080000d 	sth	r2,0(r22)
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
   24e8c:	b880008b 	ldhu	r2,2(r23)
   24e90:	10c5883a 	add	r2,r2,r3
   24e94:	108003cc 	andi	r2,r2,15
   24e98:	103feb1e 	bne	r2,zero,24e48 <OBJ_Read+0x50c>
                                pData++;
   24e9c:	b5800084 	addi	r22,r22,2
                                break;
   24ea0:	003fe906 	br	24e48 <OBJ_Read+0x50c>
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
   24ea4:	10bfffcc 	andi	r2,r2,65535
   24ea8:	1185d83a 	sra	r2,r2,r6
   24eac:	003ff506 	br	24e84 <OBJ_Read+0x548>
                                if(bitOffset & 0xF)
   24eb0:	18c003cc 	andi	r3,r3,15
   24eb4:	183ed51e 	bne	r3,zero,24a0c <OBJ_Read+0xd0>
                                pData[0] = pVarPtr[0];
   24eb8:	2880000b 	ldhu	r2,0(r5)
                                pData += 2;
   24ebc:	b5800104 	addi	r22,r22,4
                                pData[0] = pVarPtr[0];
   24ec0:	b0bfff0d 	sth	r2,-4(r22)
                                pData[1] = pVarPtr[1];
   24ec4:	2880008b 	ldhu	r2,2(r5)
   24ec8:	b0bfff8d 	sth	r2,-2(r22)
                                break;
   24ecc:	003fde06 	br	24e48 <OBJ_Read+0x50c>
                    if ((bitOffset & 0x0F) == 0) 
   24ed0:	188003cc 	andi	r2,r3,15
   24ed4:	1000011e 	bne	r2,zero,24edc <OBJ_Read+0x5a0>
                        *pData = 0;
   24ed8:	b000000d 	sth	zero,0(r22)
                    if (((pEntry->BitLength & 0xF) > 0)
   24edc:	b880008b 	ldhu	r2,2(r23)
   24ee0:	110003cc 	andi	r4,r2,15
   24ee4:	20000526 	beq	r4,zero,24efc <OBJ_Read+0x5c0>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   24ee8:	10c5883a 	add	r2,r2,r3
   24eec:	108003cc 	andi	r2,r2,15
   24ef0:	1000021e 	bne	r2,zero,24efc <OBJ_Read+0x5c0>
                        *pData = 0;
   24ef4:	b000008d 	sth	zero,2(r22)
                        pData++;
   24ef8:	b5800084 	addi	r22,r22,2
   24efc:	0007883a 	mov	r3,zero
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   24f00:	b880008b 	ldhu	r2,2(r23)
   24f04:	1005d13a 	srai	r2,r2,4
   24f08:	108003cc 	andi	r2,r2,15
   24f0c:	18800516 	blt	r3,r2,24f24 <OBJ_Read+0x5e8>
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
   24f10:	b880010b 	ldhu	r2,4(r23)
   24f14:	108001cc 	andi	r2,r2,7
   24f18:	1000061e 	bne	r2,zero,24f34 <OBJ_Read+0x5f8>
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
   24f1c:	07000184 	movi	fp,6
   24f20:	003f5706 	br	24c80 <OBJ_Read+0x344>
                        pData++;
   24f24:	b5800084 	addi	r22,r22,2
                        *pData = 0;
   24f28:	18c00044 	addi	r3,r3,1
   24f2c:	b000000d 	sth	zero,0(r22)
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
   24f30:	003ff306 	br	24f00 <OBJ_Read+0x5c4>
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   24f34:	07000684 	movi	fp,26
   24f38:	003f5106 	br	24c80 <OBJ_Read+0x344>
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
   24f3c:	07000444 	movi	fp,17
   24f40:	003eb306 	br	24a10 <OBJ_Read+0xd4>
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   24f44:	07000684 	movi	fp,26
   24f48:	003eb106 	br	24a10 <OBJ_Read+0xd4>

00024f4c <OBJ_Write>:

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
    UINT16 i = subindex;
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f4c:	3880030b 	ldhu	r2,12(r7)
{
   24f50:	deffec04 	addi	sp,sp,-80
   24f54:	ddc01115 	stw	r23,68(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f58:	1006d23a 	srli	r3,r2,8
    UINT16 maxSubindex = 0;
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   24f5c:	10803fcc 	andi	r2,r2,255
{
   24f60:	dd801015 	stw	r22,64(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f64:	18c003cc 	andi	r3,r3,15
{
   24f68:	dd400f15 	stw	r21,60(sp)
   24f6c:	dd000e15 	stw	r20,56(sp)
   24f70:	dc800c15 	stw	r18,48(sp)
   24f74:	dc000a15 	stw	r16,40(sp)
   24f78:	3825883a 	mov	r18,r7
   24f7c:	dfc01315 	stw	ra,76(sp)
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   24f80:	180f883a 	mov	r7,r3
{
   24f84:	df001215 	stw	fp,72(sp)
   24f88:	dcc00d15 	stw	r19,52(sp)
   24f8c:	dc400b15 	stw	r17,44(sp)
   24f90:	d900010d 	sth	r4,4(sp)
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
   24f94:	d880038d 	sth	r2,14(sp)
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
   24f98:	18c001d8 	cmpnei	r3,r3,7
{
   24f9c:	dc001417 	ldw	r16,80(sp)
   24fa0:	dd001503 	ldbu	r20,84(sp)
   24fa4:	202f883a 	mov	r23,r4
   24fa8:	282d883a 	mov	r22,r5
   24fac:	302b883a 	mov	r21,r6
    UINT16 i = subindex;
   24fb0:	2a003fcc 	andi	r8,r5,255
    if ( objCode != OBJCODE_VAR )
   24fb4:	1800271e 	bne	r3,zero,25054 <OBJ_Write+0x108>
            maxSubindex = maxConfiguredSubindex;
        }
    }


    if ( bCompleteAccess )
   24fb8:	a0007e26 	beq	r20,zero,251b4 <OBJ_Write+0x268>
    {
        if ( objCode == OBJCODE_VAR )
        {
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
   24fbc:	07000144 	movi	fp,5
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
    }
    /* ECATCHANGE_END(V5.13) COE4*/

    return 0;
}
   24fc0:	e005883a 	mov	r2,fp
   24fc4:	dfc01317 	ldw	ra,76(sp)
   24fc8:	df001217 	ldw	fp,72(sp)
   24fcc:	ddc01117 	ldw	r23,68(sp)
   24fd0:	dd801017 	ldw	r22,64(sp)
   24fd4:	dd400f17 	ldw	r21,60(sp)
   24fd8:	dd000e17 	ldw	r20,56(sp)
   24fdc:	dcc00d17 	ldw	r19,52(sp)
   24fe0:	dc800c17 	ldw	r18,48(sp)
   24fe4:	dc400b17 	ldw	r17,44(sp)
   24fe8:	dc000a17 	ldw	r16,40(sp)
   24fec:	dec01404 	addi	sp,sp,80
   24ff0:	f800283a 	ret
    if ( bCompleteAccess )
   24ff4:	a001a21e 	bne	r20,zero,25680 <OBJ_Write+0x734>
   24ff8:	d9c00415 	stw	r7,16(sp)
    if (subindex > maxSubindex)
   24ffc:	40bfffcc 	andi	r2,r8,65535
   25000:	da000215 	stw	r8,8(sp)
   25004:	8c7fffcc 	andi	r17,r17,65535
   25008:	88819536 	bltu	r17,r2,25660 <OBJ_Write+0x714>
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
   2500c:	b4403fcc 	andi	r17,r22,255
   25010:	880b883a 	mov	r5,r17
   25014:	9009883a 	mov	r4,r18
   25018:	00244300 	call	24430 <OBJ_GetEntryDesc>
        if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   2501c:	10c0010b 	ldhu	r3,4(r2)
   25020:	d16135c3 	ldbu	r5,-31529(gp)
   25024:	da000217 	ldw	r8,8(sp)
   25028:	193fffcc 	andi	r4,r3,65535
   2502c:	2005d0ba 	srai	r2,r4,2
   25030:	d9c00417 	ldw	r7,16(sp)
   25034:	1144703a 	and	r2,r2,r5
   25038:	1080038c 	andi	r2,r2,14
   2503c:	1000611e 	bne	r2,zero,251c4 <OBJ_Write+0x278>
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
   25040:	18c00e0c 	andi	r3,r3,56
   25044:	1801881e 	bne	r3,zero,25668 <OBJ_Write+0x71c>
                if (pEntry->ObjAccess == 0)
   25048:	203fdc26 	beq	r4,zero,24fbc <OBJ_Write+0x70>
                        return ABORTIDX_READ_ONLY_ENTRY;
   2504c:	070001c4 	movi	fp,7
   25050:	003fdb06 	br	24fc0 <OBJ_Write+0x74>
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
   25054:	90c00617 	ldw	r3,24(r18)
   25058:	18c00003 	ldbu	r3,0(r3)
   2505c:	1823883a 	mov	r17,r3
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   25060:	1800331e 	bne	r3,zero,25130 <OBJ_Write+0x1e4>
   25064:	20f8fc04 	addi	r3,r4,-7184
   25068:	18ffffcc 	andi	r3,r3,65535
   2506c:	18c00830 	cmpltui	r3,r3,32
   25070:	1800081e 	bne	r3,zero,25094 <OBJ_Write+0x148>
   25074:	20fa8004 	addi	r3,r4,-5632
   25078:	18ffffcc 	andi	r3,r3,65535
   2507c:	18c08030 	cmpltui	r3,r3,512
   25080:	1800041e 	bne	r3,zero,25094 <OBJ_Write+0x148>
   25084:	20f98004 	addi	r3,r4,-6656
   25088:	18ffffcc 	andi	r3,r3,65535
   2508c:	18c08028 	cmpgeui	r3,r3,512
   25090:	18001b1e 	bne	r3,zero,25100 <OBJ_Write+0x1b4>
    if ( bCompleteAccess )
   25094:	a0004926 	beq	r20,zero,251bc <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   25098:	b0c03fcc 	andi	r3,r22,255
   2509c:	18002726 	beq	r3,zero,2513c <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   250a0:	1023883a 	mov	r17,r2
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
   250a4:	90800617 	ldw	r2,24(r18)
        if(Subindex0 != 0x00)
   250a8:	14c00003 	ldbu	r19,0(r2)
   250ac:	9826c03a 	cmpne	r19,r19,zero
    if ( pObjEntry->Write != NULL )
   250b0:	90800817 	ldw	r2,32(r18)
   250b4:	10005526 	beq	r2,zero,2520c <OBJ_Write+0x2c0>
        result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
   250b8:	bdffffcc 	andi	r23,r23,65535
   250bc:	b5803fcc 	andi	r22,r22,255
   250c0:	dd000015 	stw	r20,0(sp)
   250c4:	800f883a 	mov	r7,r16
   250c8:	a80d883a 	mov	r6,r21
   250cc:	b00b883a 	mov	r5,r22
   250d0:	b809883a 	mov	r4,r23
   250d4:	103ee83a 	callr	r2
   250d8:	1039883a 	mov	fp,r2
        if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
   250dc:	10803fcc 	andi	r2,r2,255
   250e0:	103fb71e 	bne	r2,zero,24fc0 <OBJ_Write+0x74>
   250e4:	d0a12c17 	ldw	r2,-31568(gp)
   250e8:	10001726 	beq	r2,zero,25148 <OBJ_Write+0x1fc>
            pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   250ec:	a00d883a 	mov	r6,r20
   250f0:	b00b883a 	mov	r5,r22
   250f4:	b809883a 	mov	r4,r23
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   250f8:	103ee83a 	callr	r2
   250fc:	00001206 	br	25148 <OBJ_Write+0x1fc>
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (index == 0xF030)))
   25100:	20ffffcc 	andi	r3,r4,65535
   25104:	013c0c14 	movui	r4,61488
   25108:	193fba1e 	bne	r3,r4,24ff4 <OBJ_Write+0xa8>
    if ( bCompleteAccess )
   2510c:	a0002b26 	beq	r20,zero,251bc <OBJ_Write+0x270>
        if ((subindex == 0) && (dataSize > 0))
   25110:	28c03fcc 	andi	r3,r5,255
   25114:	18000926 	beq	r3,zero,2513c <OBJ_Write+0x1f0>
            maxSubindex = maxConfiguredSubindex;
   25118:	1023883a 	mov	r17,r2
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   2511c:	b8bfffcc 	andi	r2,r23,65535
   25120:	00fc0c14 	movui	r3,61488
   25124:	10ffdf26 	beq	r2,r3,250a4 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   25128:	0027883a 	mov	r19,zero
   2512c:	003fe006 	br	250b0 <OBJ_Write+0x164>
    if ( bCompleteAccess )
   25130:	a03fb126 	beq	r20,zero,24ff8 <OBJ_Write+0xac>
        if ((subindex == 0) && (dataSize > 0))
   25134:	28803fcc 	andi	r2,r5,255
   25138:	1000241e 	bne	r2,zero,251cc <OBJ_Write+0x280>
    if ( pObjEntry->Write != NULL )
   2513c:	90800817 	ldw	r2,32(r18)
        if ((subindex == 0) && (dataSize > 0))
   25140:	a800031e 	bne	r21,zero,25150 <OBJ_Write+0x204>
    if ( pObjEntry->Write != NULL )
   25144:	103fdc1e 	bne	r2,zero,250b8 <OBJ_Write+0x16c>
           return 0; //no error
   25148:	0039883a 	mov	fp,zero
   2514c:	003f9c06 	br	24fc0 <OBJ_Write+0x74>
    if ( pObjEntry->Write != NULL )
   25150:	103fd91e 	bne	r2,zero,250b8 <OBJ_Write+0x16c>
   25154:	84400003 	ldbu	r17,0(r16)
    BOOL bClearSubindex0Required = FALSE;
   25158:	0027883a 	mov	r19,zero
        for (i = subindex; i <= lastSubindex; i++)
   2515c:	88bfffcc 	andi	r2,r17,65535
   25160:	d8800415 	stw	r2,16(sp)
   25164:	40bfffcc 	andi	r2,r8,65535
   25168:	d8800215 	stw	r2,8(sp)
                    if (i == 0 && objCode != OBJCODE_VAR)
   2516c:	38803fcc 	andi	r2,r7,255
   25170:	108001e0 	cmpeqi	r2,r2,7
   25174:	b5403fcc 	andi	r21,r22,255
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
   25178:	070001c4 	movi	fp,7
        UINT8 bWritten = 0;
   2517c:	000d883a 	mov	r6,zero
                    if (i == 0 && objCode != OBJCODE_VAR)
   25180:	d8800515 	stw	r2,20(sp)
        for (i = subindex; i <= lastSubindex; i++)
   25184:	d8800417 	ldw	r2,16(sp)
   25188:	ab7fffcc 	andi	r13,r21,65535
   2518c:	a819883a 	mov	r12,r21
   25190:	1340202e 	bgeu	r2,r13,25214 <OBJ_Write+0x2c8>
        if (bWritten == 0)
   25194:	31803fcc 	andi	r6,r6,255
   25198:	303f8926 	beq	r6,zero,24fc0 <OBJ_Write+0x74>
    if (pAPPL_CoeWriteInd != NULL)
   2519c:	d0a12c17 	ldw	r2,-31568(gp)
   251a0:	103fe926 	beq	r2,zero,25148 <OBJ_Write+0x1fc>
        pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
   251a4:	a00d883a 	mov	r6,r20
   251a8:	b1403fcc 	andi	r5,r22,255
   251ac:	b93fffcc 	andi	r4,r23,65535
   251b0:	003fd106 	br	250f8 <OBJ_Write+0x1ac>
    UINT16 maxSubindex = 0;
   251b4:	0023883a 	mov	r17,zero
   251b8:	003f8f06 	br	24ff8 <OBJ_Write+0xac>
            maxSubindex = maxConfiguredSubindex;
   251bc:	1023883a 	mov	r17,r2
   251c0:	003f8d06 	br	24ff8 <OBJ_Write+0xac>
    if((subindex > 0) &&
   251c4:	88000e26 	beq	r17,zero,25200 <OBJ_Write+0x2b4>
    UINT16 lastSubindex = subindex;
   251c8:	4023883a 	mov	r17,r8
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   251cc:	b8b8fc04 	addi	r2,r23,-7184
    if((subindex > 0) &&
   251d0:	10bfffcc 	andi	r2,r2,65535
   251d4:	10800830 	cmpltui	r2,r2,32
   251d8:	103fb21e 	bne	r2,zero,250a4 <OBJ_Write+0x158>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
   251dc:	b8ba8004 	addi	r2,r23,-5632
   251e0:	10bfffcc 	andi	r2,r2,65535
   251e4:	10808030 	cmpltui	r2,r2,512
   251e8:	103fae1e 	bne	r2,zero,250a4 <OBJ_Write+0x158>
   251ec:	b8b98004 	addi	r2,r23,-6656
   251f0:	10bfffcc 	andi	r2,r2,65535
   251f4:	10808030 	cmpltui	r2,r2,512
   251f8:	103fc826 	beq	r2,zero,2511c <OBJ_Write+0x1d0>
   251fc:	003fa906 	br	250a4 <OBJ_Write+0x158>
    BOOL bClearSubindex0Required = FALSE;
   25200:	b027883a 	mov	r19,r22
    UINT16 lastSubindex = subindex;
   25204:	0023883a 	mov	r17,zero
   25208:	003fa906 	br	250b0 <OBJ_Write+0x164>
        if (dataSize == 0)
   2520c:	a83fd31e 	bne	r21,zero,2515c <OBJ_Write+0x210>
   25210:	003fcd06 	br	25148 <OBJ_Write+0x1fc>
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   25214:	91c00617 	ldw	r7,24(r18)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25218:	a80b883a 	mov	r5,r21
   2521c:	9009883a 	mov	r4,r18
   25220:	db400915 	stw	r13,36(sp)
   25224:	d9800715 	stw	r6,28(sp)
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
   25228:	db000815 	stw	r12,32(sp)
   2522c:	d9c00615 	stw	r7,24(sp)
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   25230:	00244300 	call	24430 <OBJ_GetEntryDesc>
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25234:	900b883a 	mov	r5,r18
   25238:	a809883a 	mov	r4,r21
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
   2523c:	1023883a 	mov	r17,r2
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
   25240:	00246740 	call	24674 <OBJ_GetEntryOffset>
            if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
   25244:	8900010b 	ldhu	r4,4(r17)
   25248:	d16135c3 	ldbu	r5,-31529(gp)
   2524c:	d9800717 	ldw	r6,28(sp)
   25250:	2009d0ba 	srai	r4,r4,2
   25254:	db400917 	ldw	r13,36(sp)
   25258:	2148703a 	and	r4,r4,r5
   2525c:	2100038c 	andi	r4,r4,14
   25260:	2000f026 	beq	r4,zero,25624 <OBJ_Write+0x6d8>
                if (i != 0)
   25264:	d9c00617 	ldw	r7,24(sp)
   25268:	db000817 	ldw	r12,32(sp)
   2526c:	68000926 	beq	r13,zero,25294 <OBJ_Write+0x348>
                    pVarPtr += (bitOffset >> 4);
   25270:	1008d0fa 	srli	r4,r2,3
                if ( i == subindex                                     /* requested entry */
   25274:	d8c00217 	ldw	r3,8(sp)
                    pVarPtr += (bitOffset >> 4);
   25278:	2107ff8c 	andi	r4,r4,8190
   2527c:	390f883a 	add	r7,r7,r4
                if ( i == subindex                                     /* requested entry */
   25280:	1b400f26 	beq	r3,r13,252c0 <OBJ_Write+0x374>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
   25284:	a0000126 	beq	r20,zero,2528c <OBJ_Write+0x340>
   25288:	68c00d2e 	bgeu	r13,r3,252c0 <OBJ_Write+0x374>
        for (i = subindex; i <= lastSubindex; i++)
   2528c:	ad400044 	addi	r21,r21,1
   25290:	003fbc06 	br	25184 <OBJ_Write+0x238>
                if ( i == subindex                                     /* requested entry */
   25294:	d8c00217 	ldw	r3,8(sp)
   25298:	183ffc1e 	bne	r3,zero,2528c <OBJ_Write+0x340>
                    if (i == 0 && objCode != OBJCODE_VAR)
   2529c:	d8c00517 	ldw	r3,20(sp)
   252a0:	1800071e 	bne	r3,zero,252c0 <OBJ_Write+0x374>
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   252a4:	8100000b 	ldhu	r4,0(r16)
                        if(maxConfiguredSubindex < NewSubindex0)
   252a8:	d880038b 	ldhu	r2,14(sp)
   252ac:	21403fcc 	andi	r5,r4,255
   252b0:	1140ef36 	bltu	r2,r5,25670 <OBJ_Write+0x724>
                        pVarPtr[0] = SWAPWORD(pData[0]);
   252b4:	3900000d 	sth	r4,0(r7)
                            pData++;
   252b8:	84000084 	addi	r16,r16,2
                            break;
   252bc:	00008d06 	br	254f4 <OBJ_Write+0x5a8>
                        UINT16 dataType = pEntry->DataType;
   252c0:	8980000b 	ldhu	r6,0(r17)
                        if (pEntry->DataType >= 0x700)
   252c4:	313fffcc 	andi	r4,r6,65535
   252c8:	2141c030 	cmpltui	r5,r4,1792
   252cc:	2800341e 	bne	r5,zero,253a0 <OBJ_Write+0x454>
                            if ( pEntry->BitLength <= 8 )
   252d0:	8980008b 	ldhu	r6,2(r17)
   252d4:	313fffcc 	andi	r4,r6,65535
   252d8:	21400268 	cmpgeui	r5,r4,9
   252dc:	28002a1e 	bne	r5,zero,25388 <OBJ_Write+0x43c>
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
   252e0:	31800bc4 	addi	r6,r6,47
                        switch (dataType)
   252e4:	31bff884 	addi	r6,r6,-30
   252e8:	31bfffcc 	andi	r6,r6,65535
   252ec:	01000044 	movi	r4,1
   252f0:	2188983a 	sll	r4,r4,r6
   252f4:	0140ff74 	movhi	r5,1021
   252f8:	29600044 	addi	r5,r5,-32767
   252fc:	214a703a 	and	r5,r4,r5
   25300:	2800681e 	bne	r5,zero,254a4 <OBJ_Write+0x558>
   25304:	014000b4 	movhi	r5,2
   25308:	29400104 	addi	r5,r5,4
   2530c:	214a703a 	and	r5,r4,r5
   25310:	2800b41e 	bne	r5,zero,255e4 <OBJ_Write+0x698>
   25314:	01400074 	movhi	r5,1
   25318:	29400084 	addi	r5,r5,2
   2531c:	2148703a 	and	r4,r4,r5
   25320:	20001d26 	beq	r4,zero,25398 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25324:	108003cc 	andi	r2,r2,15
   25328:	103f241e 	bne	r2,zero,24fbc <OBJ_Write+0x70>
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   2532c:	98803fcc 	andi	r2,r19,255
                            UINT16 u16NewData = SWAPWORD(pData[0]);
   25330:	8440000b 	ldhu	r17,0(r16)
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
   25334:	10000326 	beq	r2,zero,25344 <OBJ_Write+0x3f8>
   25338:	3900000b 	ldhu	r4,0(r7)
   2533c:	88bfffcc 	andi	r2,r17,65535
   25340:	2080cd1e 	bne	r4,r2,25678 <OBJ_Write+0x72c>
                            if(IS_PDO_ASSIGN(index))  //PDO assign
   25344:	d8800117 	ldw	r2,4(sp)
   25348:	10b8fc04 	addi	r2,r2,-7184
   2534c:	10bfffcc 	andi	r2,r2,65535
   25350:	10800828 	cmpgeui	r2,r2,32
   25354:	1000721e 	bne	r2,zero,25520 <OBJ_Write+0x5d4>
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
   25358:	88ba8004 	addi	r2,r17,-5632
   2535c:	10bfffcc 	andi	r2,r2,65535
   25360:	10808030 	cmpltui	r2,r2,512
   25364:	1000821e 	bne	r2,zero,25570 <OBJ_Write+0x624>
   25368:	88b98004 	addi	r2,r17,-6656
   2536c:	10bfffcc 	andi	r2,r2,65535
   25370:	10808030 	cmpltui	r2,r2,512
   25374:	10007e1e 	bne	r2,zero,25570 <OBJ_Write+0x624>
   25378:	88bfffcc 	andi	r2,r17,65535
   2537c:	10007c26 	beq	r2,zero,25570 <OBJ_Write+0x624>
                                    return ABORTIDX_VALUE_EXCEEDED;
   25380:	07000484 	movi	fp,18
   25384:	003f0e06 	br	24fc0 <OBJ_Write+0x74>
                            else if ( pEntry->BitLength == 16 )
   25388:	21400420 	cmpeqi	r5,r4,16
   2538c:	283fe51e 	bne	r5,zero,25324 <OBJ_Write+0x3d8>
                            else if ( pEntry->BitLength == 32 )
   25390:	21000820 	cmpeqi	r4,r4,32
   25394:	2000931e 	bne	r4,zero,255e4 <OBJ_Write+0x698>
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   25398:	07000604 	movi	fp,24
   2539c:	003f0806 	br	24fc0 <OBJ_Write+0x74>
                        switch (dataType)
   253a0:	21400328 	cmpgeui	r5,r4,12
   253a4:	28000d1e 	bne	r5,zero,253dc <OBJ_Write+0x490>
   253a8:	214002a8 	cmpgeui	r5,r4,10
   253ac:	2800241e 	bne	r5,zero,25440 <OBJ_Write+0x4f4>
   253b0:	21400260 	cmpeqi	r5,r4,9
   253b4:	2800221e 	bne	r5,zero,25440 <OBJ_Write+0x4f4>
   253b8:	20002d26 	beq	r4,zero,25470 <OBJ_Write+0x524>
   253bc:	01400044 	movi	r5,1
   253c0:	2908983a 	sll	r4,r5,r4
   253c4:	2140640c 	andi	r5,r4,400
   253c8:	2800861e 	bne	r5,zero,255e4 <OBJ_Write+0x698>
   253cc:	2140098c 	andi	r5,r4,38
   253d0:	2800341e 	bne	r5,zero,254a4 <OBJ_Write+0x558>
   253d4:	2100120c 	andi	r4,r4,72
   253d8:	003fd106 	br	25320 <OBJ_Write+0x3d4>
   253dc:	21400e28 	cmpgeui	r5,r4,56
   253e0:	2800131e 	bne	r5,zero,25430 <OBJ_Write+0x4e4>
   253e4:	214007a8 	cmpgeui	r5,r4,30
   253e8:	283fbe1e 	bne	r5,zero,252e4 <OBJ_Write+0x398>
   253ec:	31bffecc 	andi	r6,r6,65531
   253f0:	31800460 	cmpeqi	r6,r6,17
   253f4:	3000021e 	bne	r6,zero,25400 <OBJ_Write+0x4b4>
   253f8:	210006e0 	cmpeqi	r4,r4,27
   253fc:	203fe626 	beq	r4,zero,25398 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25400:	108003cc 	andi	r2,r2,15
   25404:	103eed1e 	bne	r2,zero,24fbc <OBJ_Write+0x70>
                            pVarPtr[0] = pData[0];
   25408:	8080000b 	ldhu	r2,0(r16)
                            pData += 4;
   2540c:	84000204 	addi	r16,r16,8
                            pVarPtr[0] = pData[0];
   25410:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   25414:	80bffe8b 	ldhu	r2,-6(r16)
   25418:	3880008d 	sth	r2,2(r7)
                            pVarPtr[2] = pData[2];
   2541c:	80bfff0b 	ldhu	r2,-4(r16)
   25420:	3880010d 	sth	r2,4(r7)
                            pVarPtr[3] = pData[3];
   25424:	80bfff8b 	ldhu	r2,-2(r16)
   25428:	3880018d 	sth	r2,6(r7)
                            break;
   2542c:	00003106 	br	254f4 <OBJ_Write+0x5a8>
                        switch (dataType)
   25430:	31bf6804 	addi	r6,r6,-608
   25434:	31bfffcc 	andi	r6,r6,65535
   25438:	31800128 	cmpgeui	r6,r6,4
   2543c:	303fd61e 	bne	r6,zero,25398 <OBJ_Write+0x44c>
                            if(bitOffset & 0xF)
   25440:	108003cc 	andi	r2,r2,15
   25444:	103edd1e 	bne	r2,zero,24fbc <OBJ_Write+0x70>
                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
   25448:	8980008b 	ldhu	r6,2(r17)
   2544c:	800b883a 	mov	r5,r16
   25450:	3809883a 	mov	r4,r7
   25454:	318001c4 	addi	r6,r6,7
   25458:	300cd0fa 	srli	r6,r6,3
   2545c:	0026ed40 	call	26ed4 <memcpy>
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   25460:	8880008b 	ldhu	r2,2(r17)
   25464:	1004d13a 	srli	r2,r2,4
   25468:	1004907a 	slli	r2,r2,1
   2546c:	00000b06 	br	2549c <OBJ_Write+0x550>
                            if(bCompleteAccess)
   25470:	a03fc926 	beq	r20,zero,25398 <OBJ_Write+0x44c>
                                if (((pEntry->BitLength & 0xF) > 0)
   25474:	8900008b 	ldhu	r4,2(r17)
   25478:	218003cc 	andi	r6,r4,15
   2547c:	217fffcc 	andi	r5,r4,65535
   25480:	30000426 	beq	r6,zero,25494 <OBJ_Write+0x548>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25484:	2089883a 	add	r4,r4,r2
   25488:	210003cc 	andi	r4,r4,15
   2548c:	2000011e 	bne	r4,zero,25494 <OBJ_Write+0x548>
                                    pData++;
   25490:	84000084 	addi	r16,r16,2
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
   25494:	2804d0fa 	srli	r2,r5,3
   25498:	1080078c 	andi	r2,r2,30
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
   2549c:	80a1883a 	add	r16,r16,r2
                            break;
   254a0:	00001406 	br	254f4 <OBJ_Write+0x5a8>
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   254a4:	8940008b 	ldhu	r5,2(r17)
   254a8:	010000b4 	movhi	r4,2
   254ac:	130003cc 	andi	r12,r2,15
   254b0:	280a907a 	slli	r5,r5,1
                            TmpValue &= ~bitMask;
   254b4:	3b80000b 	ldhu	r14,0(r7)
                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
   254b8:	2909883a 	add	r4,r5,r4
   254bc:	211ec70b 	ldhu	r4,31516(r4)
   254c0:	217fffcc 	andi	r5,r4,65535
   254c4:	2b1a983a 	sll	r13,r5,r12
                            TmpValue &= ~bitMask;
   254c8:	034c303a 	nor	r6,zero,r13
   254cc:	338c703a 	and	r6,r6,r14
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   254d0:	8380000b 	ldhu	r14,0(r16)
                            if (bCompleteAccess) 
   254d4:	a0000926 	beq	r20,zero,254fc <OBJ_Write+0x5b0>
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
   254d8:	6b9a703a 	and	r13,r13,r14
   254dc:	3348b03a 	or	r4,r6,r13
                            pVarPtr[0] = SWAPWORD(TmpValue);
   254e0:	3900000d 	sth	r4,0(r7)
                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
   254e4:	8900008b 	ldhu	r4,2(r17)
   254e8:	2085883a 	add	r2,r4,r2
   254ec:	108003cc 	andi	r2,r2,15
   254f0:	103f7126 	beq	r2,zero,252b8 <OBJ_Write+0x36c>
                    bWritten = 1;
   254f4:	01800044 	movi	r6,1
   254f8:	003f6406 	br	2528c <OBJ_Write+0x340>
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
   254fc:	014a303a 	nor	r5,zero,r5
   25500:	737fffcc 	andi	r13,r14,65535
   25504:	2b4a703a 	and	r5,r5,r13
   25508:	283f9d1e 	bne	r5,zero,25380 <OBJ_Write+0x434>
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
   2550c:	2388703a 	and	r4,r4,r14
   25510:	213fffcc 	andi	r4,r4,65535
   25514:	2308983a 	sll	r4,r4,r12
   25518:	3108b03a 	or	r4,r6,r4
   2551c:	003ff006 	br	254e0 <OBJ_Write+0x594>
                            if(index == 0x1C32 || index == 0x1C33)
   25520:	d8800117 	ldw	r2,4(sp)
   25524:	10b8f384 	addi	r2,r2,-7218
   25528:	10bfffcc 	andi	r2,r2,65535
   2552c:	108000b0 	cmpltui	r2,r2,2
   25530:	10000f26 	beq	r2,zero,25570 <OBJ_Write+0x624>
                               if (i == 1) /* "Synchronisation type" written */
   25534:	633fffcc 	andi	r12,r12,65535
   25538:	60800058 	cmpnei	r2,r12,1
   2553c:	10000e1e 	bne	r2,zero,25578 <OBJ_Write+0x62c>
                                  if (pVarPtr[0] != u16NewData)
   25540:	3880000b 	ldhu	r2,0(r7)
   25544:	897fffcc 	andi	r5,r17,65535
   25548:	11400726 	beq	r2,r5,25568 <OBJ_Write+0x61c>
                                     result = CheckSyncTypeValue(index, u16NewData);
   2554c:	d900010b 	ldhu	r4,4(sp)
   25550:	d9c00615 	stw	r7,24(sp)
   25554:	00248300 	call	24830 <CheckSyncTypeValue>
   25558:	1039883a 	mov	fp,r2
                                     if (result != 0)
   2555c:	10803fcc 	andi	r2,r2,255
   25560:	d9c00617 	ldw	r7,24(sp)
   25564:	103e961e 	bne	r2,zero,24fc0 <OBJ_Write+0x74>
                                  bSyncSetByUser = TRUE;
   25568:	00800044 	movi	r2,1
   2556c:	d0a14c85 	stb	r2,-31438(gp)
                            pVarPtr[0] = u16NewData;
   25570:	3c40000d 	sth	r17,0(r7)
   25574:	003f5006 	br	252b8 <OBJ_Write+0x36c>
                               if (i == 8) /* "Get Cycle Time" written*/
   25578:	63000218 	cmpnei	r12,r12,8
   2557c:	603ffc1e 	bne	r12,zero,25570 <OBJ_Write+0x624>
                                   sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
   25580:	008000f4 	movhi	r2,3
   25584:	10218615 	stw	zero,-31208(r2)
                                   sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   25588:	008000b4 	movhi	r2,2
   2558c:	10a1a804 	addi	r2,r2,-31072
   25590:	010000f4 	movhi	r4,3
   25594:	20a18515 	stw	r2,-31212(r4)
                                   sSyncManOutPar.u32CycleTime = 0;
   25598:	010000f4 	movhi	r4,3
   2559c:	20218215 	stw	zero,-31224(r4)
                                   sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
   255a0:	010000f4 	movhi	r4,3
   255a4:	20217515 	stw	zero,-31276(r4)
                                   sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
   255a8:	010000f4 	movhi	r4,3
   255ac:	20a17415 	stw	r2,-31280(r4)
                                   sSyncManInPar.u32CycleTime = 0;
   255b0:	008000f4 	movhi	r2,3
   255b4:	10217115 	stw	zero,-31292(r2)
                                  if ((u16NewData & 0x2) == 0x2)
   255b8:	8880008c 	andi	r2,r17,2
   255bc:	103fec26 	beq	r2,zero,25570 <OBJ_Write+0x624>
                                     sSyncManOutPar.u16SmEventMissedCounter = 0;
   255c0:	008000f4 	movhi	r2,3
   255c4:	10218b15 	stw	zero,-31188(r2)
                                     sSyncManOutPar.u8SyncError = 0;
   255c8:	008000f4 	movhi	r2,3
   255cc:	10219105 	stb	zero,-31164(r2)
                                     sSyncManInPar.u16SmEventMissedCounter = 0;
   255d0:	008000f4 	movhi	r2,3
   255d4:	10217a15 	stw	zero,-31256(r2)
                                     sSyncManInPar.u8SyncError = 0;
   255d8:	008000f4 	movhi	r2,3
   255dc:	10218005 	stb	zero,-31232(r2)
   255e0:	003fe306 	br	25570 <OBJ_Write+0x624>
                            if(bitOffset & 0xF)
   255e4:	108003cc 	andi	r2,r2,15
   255e8:	103e741e 	bne	r2,zero,24fbc <OBJ_Write+0x70>
                            if(bClearSubindex0Required && 
   255ec:	99003fcc 	andi	r4,r19,255
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
   255f0:	8080000b 	ldhu	r2,0(r16)
                            if(bClearSubindex0Required && 
   255f4:	20000626 	beq	r4,zero,25610 <OBJ_Write+0x6c4>
   255f8:	3940000b 	ldhu	r5,0(r7)
   255fc:	113fffcc 	andi	r4,r2,65535
   25600:	29001d1e 	bne	r5,r4,25678 <OBJ_Write+0x72c>
                                || (pVarPtr[1] != pData[1])))
   25604:	3940008b 	ldhu	r5,2(r7)
   25608:	8100008b 	ldhu	r4,2(r16)
   2560c:	29001a1e 	bne	r5,r4,25678 <OBJ_Write+0x72c>
                            pVarPtr[0] = pData[0];
   25610:	3880000d 	sth	r2,0(r7)
                            pVarPtr[1] = pData[1];
   25614:	8080008b 	ldhu	r2,2(r16)
                            pData += 2;
   25618:	84000104 	addi	r16,r16,4
                            pVarPtr[1] = pData[1];
   2561c:	3880008d 	sth	r2,2(r7)
                            break;
   25620:	003fb406 	br	254f4 <OBJ_Write+0x5a8>
                if(i == 0)
   25624:	6800031e 	bne	r13,zero,25634 <OBJ_Write+0x6e8>
                    pData++;
   25628:	84000084 	addi	r16,r16,2
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
   2562c:	07000604 	movi	fp,24
   25630:	003f1606 	br	2528c <OBJ_Write+0x340>
                    if (((pEntry->BitLength & 0xF) > 0)
   25634:	88c0008b 	ldhu	r3,2(r17)
   25638:	190003cc 	andi	r4,r3,15
   2563c:	20000426 	beq	r4,zero,25650 <OBJ_Write+0x704>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
   25640:	1885883a 	add	r2,r3,r2
   25644:	108003cc 	andi	r2,r2,15
   25648:	1000011e 	bne	r2,zero,25650 <OBJ_Write+0x704>
                        pData++;
   2564c:	84000084 	addi	r16,r16,2
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
   25650:	1806d0fa 	srli	r3,r3,3
   25654:	18c7ff8c 	andi	r3,r3,8190
   25658:	80e1883a 	add	r16,r16,r3
   2565c:	003ff306 	br	2562c <OBJ_Write+0x6e0>
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
   25660:	07000444 	movi	fp,17
   25664:	003e5606 	br	24fc0 <OBJ_Write+0x74>
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
   25668:	07000684 	movi	fp,26
   2566c:	003e5406 	br	24fc0 <OBJ_Write+0x74>
                            return ABORTIDX_VALUE_TOO_GREAT;
   25670:	070004c4 	movi	fp,19
   25674:	003e5206 	br	24fc0 <OBJ_Write+0x74>
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
   25678:	07000704 	movi	fp,28
   2567c:	003e5006 	br	24fc0 <OBJ_Write+0x74>
        if ((subindex == 0) && (dataSize > 0))
   25680:	b0803fcc 	andi	r2,r22,255
   25684:	103ead26 	beq	r2,zero,2513c <OBJ_Write+0x1f0>
   25688:	003ea706 	br	25128 <OBJ_Write+0x1dc>

0002568c <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
   2568c:	defffe04 	addi	sp,sp,-8
   25690:	dc000015 	stw	r16,0(sp)
   25694:	dc000317 	ldw	r16,12(sp)
	/* for an upload segment response the toggle bit was overwritten */
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   25698:	29403fcc 	andi	r5,r5,255
{
   2569c:	dfc00115 	stw	ra,4(sp)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
	}
	if (abort == 0)
	{
		/* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   256a0:	8080018b 	ldhu	r2,6(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   256a4:	28c01818 	cmpnei	r3,r5,96
{
   256a8:	da000217 	ldw	r8,8(sp)
		pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   256ac:	1083ffcc 	andi	r2,r2,4095
   256b0:	21003fcc 	andi	r4,r4,255
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   256b4:	18000d1e 	bne	r3,zero,256ec <SdoRes+0x60>
	if (abort == 0)
   256b8:	20003f1e 	bne	r4,zero,257b8 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   256bc:	108c0014 	ori	r2,r2,12288
   256c0:	8080018d 	sth	r2,6(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
	}

	// HBu 02.05.06: if the CoE-response could not be sent because the
	//               send mailbox is full it should be stored
	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
   256c4:	01400084 	movi	r5,2
   256c8:	8009883a 	mov	r4,r16
   256cc:	0023d780 	call	23d78 <MBX_MailboxSendReq>
   256d0:	10803fcc 	andi	r2,r2,255
   256d4:	10000126 	beq	r2,zero,256dc <SdoRes+0x50>
	{
		/* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
		pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
   256d8:	d4212f15 	stw	r16,-31556(gp)
	}
}
   256dc:	dfc00117 	ldw	ra,4(sp)
   256e0:	dc000017 	ldw	r16,0(sp)
   256e4:	dec00204 	addi	sp,sp,8
   256e8:	f800283a 	ret
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   256ec:	80c0020b 	ldhu	r3,8(r16)
	if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
   256f0:	2800081e 	bne	r5,zero,25714 <SdoRes+0x88>
	if (abort == 0)
   256f4:	2000301e 	bne	r4,zero,257b8 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   256f8:	108c0014 	ori	r2,r2,12288
   256fc:	8080018d 	sth	r2,6(r16)
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   25700:	00800284 	movi	r2,10
   25704:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES);
   25708:	18c00814 	ori	r3,r3,32
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   2570c:	80c0020d 	sth	r3,8(r16)
   25710:	003fec06 	br	256c4 <SdoRes+0x38>
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
   25714:	027fc004 	movi	r9,-256
   25718:	1a46703a 	and	r3,r3,r9
   2571c:	80c0020d 	sth	r3,8(r16)
	if (abort == 0)
   25720:	2000251e 	bne	r4,zero,257b8 <SdoRes+0x12c>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25724:	108c0014 	ori	r2,r2,12288
   25728:	8080018d 	sth	r2,6(r16)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   2572c:	29401018 	cmpnei	r5,r5,64
   25730:	28001d1e 	bne	r5,zero,257a8 <SdoRes+0x11c>
			if ((objLength <= 4) && (objLength > 0))
   25734:	40bfffc4 	addi	r2,r8,-1
   25738:	10800128 	cmpgeui	r2,r2,4
   2573c:	10000c1e 	bne	r2,zero,25770 <SdoRes+0xe4>
				pSdoRes->MbxHeader.Length = EXPEDITED_FRAME_SIZE;
   25740:	00800284 	movi	r2,10
   25744:	8080000d 	sth	r2,0(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25748:	00800104 	movi	r2,4
   2574c:	1205c83a 	sub	r2,r2,r8
   25750:	100490ba 	slli	r2,r2,2
   25754:	318000d4 	ori	r6,r6,3
   25758:	31803fcc 	andi	r6,r6,255
   2575c:	1184b03a 	or	r2,r2,r6
   25760:	1884b03a 	or	r2,r3,r2
   25764:	10801014 	ori	r2,r2,64
   25768:	8080020d 	sth	r2,8(r16)
   2576c:	003fd506 	br	256c4 <SdoRes+0x38>
				if (dataSize < objLength)
   25770:	38bfffcc 	andi	r2,r7,65535
   25774:	12000a2e 	bgeu	r2,r8,257a0 <SdoRes+0x114>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25778:	39c00284 	addi	r7,r7,10
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
   2577c:	8200030d 	sth	r8,12(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25780:	31801054 	ori	r6,r6,65
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25784:	4010d43a 	srli	r8,r8,16
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25788:	31803fcc 	andi	r6,r6,255
   2578c:	198cb03a 	or	r6,r3,r6
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + dataSize;
   25790:	81c0000d 	sth	r7,0(r16)
				((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength >> 16));
   25794:	8200038d 	sth	r8,14(r16)
				pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOHEADER_SIZEINDICATOR |
   25798:	8180020d 	sth	r6,8(r16)
   2579c:	003fc906 	br	256c4 <SdoRes+0x38>
					pSdoRes->MbxHeader.Length = UPLOAD_NORM_RES_SIZE + ((UINT16)objLength);
   257a0:	41c00284 	addi	r7,r8,10
   257a4:	003ff506 	br	2577c <SdoRes+0xf0>
			pSdoRes->MbxHeader.Length = DOWNLOAD_NORM_RES_SIZE;
   257a8:	00800284 	movi	r2,10
   257ac:	8080000d 	sth	r2,0(r16)
			pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_INITIATEDOWNLOADRES);
   257b0:	18c01814 	ori	r3,r3,96
   257b4:	003fd506 	br	2570c <SdoRes+0x80>
		pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
   257b8:	10880014 	ori	r2,r2,8192
   257bc:	8080018d 	sth	r2,6(r16)
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   257c0:	8080020b 	ldhu	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   257c4:	200890ba 	slli	r4,r4,2
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   257c8:	00c00284 	movi	r3,10
		pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= SWAPWORD(SDOSERVICE_ABORTTRANSFER);
   257cc:	10802014 	ori	r2,r2,128
   257d0:	8080020d 	sth	r2,8(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   257d4:	008000b4 	movhi	r2,2
   257d8:	2085883a 	add	r2,r4,r2
   257dc:	109ecf17 	ldw	r2,31548(r2)
		pSdoRes->MbxHeader.Length = ABORT_NORM_RES_SIZE;
   257e0:	80c0000d 	sth	r3,0(r16)
		((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
   257e4:	80800315 	stw	r2,12(r16)
   257e8:	003fb606 	br	256c4 <SdoRes+0x38>

000257ec <SDOS_SdoInd>:
			is received from the master and calls depending from
			the command the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
{
   257ec:	defff004 	addi	sp,sp,-64
   257f0:	dd000a15 	stw	r20,40(sp)
	/* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
	UINT8 bCompleteAccess = 0;
	UINT32 objLength = 0;
	UINT32 dataSize = 0;

	if (bSdoInWork)
   257f4:	d52152c3 	ldbu	r20,-31413(gp)
{
   257f8:	dd400b15 	stw	r21,44(sp)
	UINT8 sdoHeader = (pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK) >> SDOHEADER_COMMANDSHIFT;
   257fc:	2540020b 	ldhu	r21,8(r4)
{
   25800:	dc800815 	stw	r18,32(sp)
   25804:	dfc00f15 	stw	ra,60(sp)
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   25808:	04bff804 	movi	r18,-32
{
   2580c:	df000e15 	stw	fp,56(sp)
   25810:	ddc00d15 	stw	r23,52(sp)
   25814:	dd800c15 	stw	r22,48(sp)
   25818:	dcc00915 	stw	r19,36(sp)
   2581c:	dc400715 	stw	r17,28(sp)
   25820:	dc000615 	stw	r16,24(sp)
	if (bSdoInWork)
   25824:	a0803fcc 	andi	r2,r20,255
	UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
   25828:	9564703a 	and	r18,r18,r21
	if (bSdoInWork)
   2582c:	1002021e 	bne	r2,zero,26038 <SDOS_SdoInd+0x84c>
   25830:	a880040c 	andi	r2,r21,16
	{
		bCompleteAccess = 1;
	}
/* ECATCHANGE_END(V5.13) COE5*/

	switch (command)
   25834:	94803fcc 	andi	r18,r18,255
	UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
   25838:	2440000b 	ldhu	r17,0(r4)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   2583c:	2021883a 	mov	r16,r4
   25840:	d8800315 	stw	r2,12(sp)
	switch (command)
   25844:	91001020 	cmpeqi	r4,r18,64
   25848:	2000161e 	bne	r4,zero,258a4 <SDOS_SdoInd+0xb8>
   2584c:	91001068 	cmpgeui	r4,r18,65
   25850:	2000071e 	bne	r4,zero,25870 <SDOS_SdoInd+0x84>
   25854:	9000fe26 	beq	r18,zero,25c50 <SDOS_SdoInd+0x464>
   25858:	90800820 	cmpeqi	r2,r18,32
   2585c:	1000111e 	bne	r2,zero,258a4 <SDOS_SdoInd+0xb8>
		}
		break;

	case SDOSERVICE_DOWNLOADSEGMENTREQ:
	case SDOSERVICE_UPLOADSEGMENTREQ:
		if (command == nSdoSegService)
   25860:	0013883a 	mov	r9,zero
   25864:	0039883a 	mov	fp,zero
   25868:	044000c4 	movi	r17,3
   2586c:	00008206 	br	25a78 <SDOS_SdoInd+0x28c>
	switch (command)
   25870:	90801820 	cmpeqi	r2,r18,96
   25874:	103ffa26 	beq	r2,zero,25860 <SDOS_SdoInd+0x74>
		if (command == nSdoSegService)
   25878:	d0a15283 	ldbu	r2,-31414(gp)
   2587c:	10801818 	cmpnei	r2,r2,96
   25880:	103ff71e 	bne	r2,zero,25860 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25884:	80800203 	ldbu	r2,8(r16)
   25888:	d1214f03 	ldbu	r4,-31428(gp)
   2588c:	15c0040c 	andi	r23,r2,16
   25890:	25c1801e 	bne	r4,r23,25e94 <SDOS_SdoInd+0x6a8>
	UINT32 dataSize = 0;
   25894:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25898:	0039883a 	mov	fp,zero
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   2589c:	04400044 	movi	r17,1
   258a0:	00007506 	br	25a78 <SDOS_SdoInd+0x28c>
		index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
   258a4:	8580028b 	ldhu	r22,10(r16)
		index += (pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT) & SDOHEADER_INDEXLOMASK;
   258a8:	acffffcc 	andi	r19,r21,65535
   258ac:	9826d23a 	srli	r19,r19,8
   258b0:	b004923a 	slli	r2,r22,8
   258b4:	98a7883a 	add	r19,r19,r2
		pObjEntry = OBJ_GetObjectHandle(index);
   258b8:	98bfffcc 	andi	r2,r19,65535
   258bc:	1009883a 	mov	r4,r2
   258c0:	d8800215 	stw	r2,8(sp)
   258c4:	00241300 	call	24130 <OBJ_GetObjectHandle>
   258c8:	102f883a 	mov	r23,r2
		if (pObjEntry)
   258cc:	1001d226 	beq	r2,zero,26018 <SDOS_SdoInd+0x82c>
		subindex = (pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT) & SDOHEADER_SUBINDEXMASK;
   258d0:	b0bfffcc 	andi	r2,r22,65535
   258d4:	102cd23a 	srli	r22,r2,8
				if (subindex > maxSubindex)
   258d8:	b9000303 	ldbu	r4,12(r23)
   258dc:	2581d236 	bltu	r4,r22,26028 <SDOS_SdoInd+0x83c>
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258e0:	a880040c 	andi	r2,r21,16
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   258e4:	b17fffcc 	andi	r5,r22,65535
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258e8:	1004c03a 	cmpne	r2,r2,zero
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   258ec:	a9c0040c 	andi	r7,r21,16
   258f0:	b80d883a 	mov	r6,r23
   258f4:	993fffcc 	andi	r4,r19,65535
   258f8:	d9400415 	stw	r5,16(sp)
	if (sdoHeader & SDOHEADER_COMPLETEACCESS)
   258fc:	d8800215 	stw	r2,8(sp)
					dataSize = objLength = OBJ_GetObjectLength(index, subindex, pObjEntry, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS));
   25900:	002416c0 	call	2416c <OBJ_GetObjectLength>
   25904:	1039883a 	mov	fp,r2
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25908:	90801018 	cmpnei	r2,r18,64
   2590c:	d9400417 	ldw	r5,16(sp)
   25910:	8c7fffcc 	andi	r17,r17,65535
   25914:	1000151e 	bne	r2,zero,2596c <SDOS_SdoInd+0x180>
						if (mbxSize != EXPEDITED_FRAME_SIZE)
   25918:	88800298 	cmpnei	r2,r17,10
   2591c:	1001c81e 	bne	r2,zero,26040 <SDOS_SdoInd+0x854>
						if ((objLength <= MAX_EXPEDITED_DATA) && objLength != 0)
   25920:	e0bfffc4 	addi	r2,fp,-1
   25924:	10800128 	cmpgeui	r2,r2,4
   25928:	1000081e 	bne	r2,zero,2594c <SDOS_SdoInd+0x160>
							pData[0] = 0;
   2592c:	8000030d 	sth	zero,12(r16)
							pData[1] = 0;
   25930:	8000038d 	sth	zero,14(r16)
			if ((abort == 0) && (bCompleteAccess == 1))
   25934:	a880040c 	andi	r2,r21,16
   25938:	1001e626 	beq	r2,zero,260d4 <SDOS_SdoInd+0x8e8>
				if (subindex > 1)
   2593c:	288000a8 	cmpgeui	r2,r5,2
   25940:	1001e426 	beq	r2,zero,260d4 <SDOS_SdoInd+0x8e8>
   25944:	e013883a 	mov	r9,fp
   25948:	0001e006 	br	260cc <SDOS_SdoInd+0x8e0>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   2594c:	d2a14a8b 	ldhu	r10,-31446(gp)
   25950:	52bffc04 	addi	r10,r10,-16
							if (dataSize < objLength)
   25954:	57007336 	bltu	r10,fp,25b24 <SDOS_SdoInd+0x338>
			if ((abort == 0) && (bCompleteAccess == 1))
   25958:	a880040c 	andi	r2,r21,16
								pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
   2595c:	83000404 	addi	r12,r16,16
			if ((abort == 0) && (bCompleteAccess == 1))
   25960:	10004f26 	beq	r2,zero,25aa0 <SDOS_SdoInd+0x2b4>
   25964:	5013883a 	mov	r9,r10
   25968:	00000b06 	br	25998 <SDOS_SdoInd+0x1ac>
				if (bTransferType)
   2596c:	a880008c 	andi	r2,r21,2
   25970:	10001226 	beq	r2,zero,259bc <SDOS_SdoInd+0x1d0>
					if (mbxSize != EXPEDITED_FRAME_SIZE)
   25974:	8c400298 	cmpnei	r17,r17,10
   25978:	8801b11e 	bne	r17,zero,26040 <SDOS_SdoInd+0x854>
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   2597c:	a804d0ba 	srli	r2,r21,2
   25980:	02400104 	movi	r9,4
					pData = (UINT16 MBXMEM *) &pSdoInd[1];
   25984:	83000304 	addi	r12,r16,12
					dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
   25988:	108000cc 	andi	r2,r2,3
   2598c:	4893c83a 	sub	r9,r9,r2
			if ((abort == 0) && (bCompleteAccess == 1))
   25990:	a880040c 	andi	r2,r21,16
   25994:	1001ac26 	beq	r2,zero,26048 <SDOS_SdoInd+0x85c>
				if (subindex > 1)
   25998:	288000a8 	cmpgeui	r2,r5,2
   2599c:	1001cb1e 	bne	r2,zero,260cc <SDOS_SdoInd+0x8e0>
					if (objLength == 0)
   259a0:	e000031e 	bne	fp,zero,259b0 <SDOS_SdoInd+0x1c4>
						nSdoSegIndex = index;
   259a4:	d4e1518d 	sth	r19,-31418(gp)
						nSdoSegSubindex = subindex;
   259a8:	d5a15105 	stb	r22,-31420(gp)
						pSdoSegObjEntry = pObjEntry;
   259ac:	d5e14d15 	stw	r23,-31436(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   259b0:	90801018 	cmpnei	r2,r18,64
   259b4:	1001a81e 	bne	r2,zero,26058 <SDOS_SdoInd+0x86c>
   259b8:	00003b06 	br	25aa8 <SDOS_SdoInd+0x2bc>
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   259bc:	8280038b 	ldhu	r10,14(r16)
   259c0:	8080030b 	ldhu	r2,12(r16)
   259c4:	5014943a 	slli	r10,r10,16
   259c8:	5094b03a 	or	r10,r10,r2
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   259cc:	d0a14a0b 	ldhu	r2,-31448(gp)
   259d0:	51000404 	addi	r4,r10,16
					UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1])) << 16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
   259d4:	5013883a 	mov	r9,r10
					if ((MBX_HEADER_SIZE + EXPEDITED_FRAME_SIZE + downloadSize) > u16ReceiveMbxSize)
   259d8:	11002f2e 	bgeu	r2,r4,25a98 <SDOS_SdoInd+0x2ac>
						if (mbxSize != (u16ReceiveMbxSize - MBX_HEADER_SIZE))
   259dc:	10bffe84 	addi	r2,r2,-6
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   259e0:	8881971e 	bne	r17,r2,26040 <SDOS_SdoInd+0x854>
					if (dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE))
   259e4:	88bffd84 	addi	r2,r17,-10
   259e8:	1280522e 	bgeu	r2,r10,25b34 <SDOS_SdoInd+0x348>
			if ((abort == 0) && (bCompleteAccess == 1))
   259ec:	a880040c 	andi	r2,r21,16
   259f0:	10000226 	beq	r2,zero,259fc <SDOS_SdoInd+0x210>
				if (subindex > 1)
   259f4:	288000a8 	cmpgeui	r2,r5,2
   259f8:	1001b41e 	bne	r2,zero,260cc <SDOS_SdoInd+0x8e0>
					bSdoSegFollows = TRUE;
   259fc:	00800044 	movi	r2,1
   25a00:	d0a15245 	stb	r2,-31415(gp)
					bSdoSegLastToggle = 1;
   25a04:	d0a14f05 	stb	r2,-31428(gp)
					bSdoSegAccess = bCompleteAccess;
   25a08:	d8800217 	ldw	r2,8(sp)
					if (pSdoSegData != NULL)
   25a0c:	d1215617 	ldw	r4,-31400(gp)
					nSdoSegIndex = index;
   25a10:	d4e1518d 	sth	r19,-31418(gp)
					bSdoSegAccess = bCompleteAccess;
   25a14:	d0a15205 	stb	r2,-31416(gp)
					nSdoSegSubindex = subindex;
   25a18:	d5a15105 	stb	r22,-31420(gp)
					pSdoSegObjEntry = pObjEntry;
   25a1c:	d5e14d15 	stw	r23,-31436(gp)
						nSdoSegCompleteSize = objLength;
   25a20:	d2614e15 	stw	r9,-31432(gp)
					if (pSdoSegData != NULL)
   25a24:	20000526 	beq	r4,zero,25a3c <SDOS_SdoInd+0x250>
   25a28:	da800515 	stw	r10,20(sp)
   25a2c:	d9400415 	stw	r5,16(sp)
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25a30:	0026bdc0 	call	26bdc <free>
   25a34:	da800517 	ldw	r10,20(sp)
   25a38:	d9400417 	ldw	r5,16(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25a3c:	d0a14e17 	ldw	r2,-31432(gp)
   25a40:	013fff84 	movi	r4,-2
   25a44:	da800515 	stw	r10,20(sp)
   25a48:	10800044 	addi	r2,r2,1
   25a4c:	1108703a 	and	r4,r2,r4
   25a50:	d9400415 	stw	r5,16(sp)
   25a54:	0026bcc0 	call	26bcc <malloc>
   25a58:	d0a15615 	stw	r2,-31400(gp)
					if (pSdoSegData == NULL)
   25a5c:	d9400417 	ldw	r5,16(sp)
   25a60:	da800517 	ldw	r10,20(sp)
					pSdoSegData = (UINT16 VARMEM *) ALLOCMEM(ROUNDUPBYTE2WORD(nSdoSegCompleteSize));
   25a64:	1009883a 	mov	r4,r2
					if (pSdoSegData == NULL)
   25a68:	1000341e 	bne	r2,zero,25b3c <SDOS_SdoInd+0x350>
						if (bCompleteAccess)
   25a6c:	d8800217 	ldw	r2,8(sp)
   25a70:	14400104 	addi	r17,r2,4
						nSdoSegBytesToHandle = dataSize;
   25a74:	5013883a 	mov	r9,r10
	}

	if (abort != ABORTIDX_WORKING)
	{
		/*  type cast was added because of warning */
		SdoRes(abort, command, (UINT8)(sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16)dataSize, objLength, pSdoInd);
   25a78:	d9800317 	ldw	r6,12(sp)
   25a7c:	dc000115 	stw	r16,4(sp)
   25a80:	df000015 	stw	fp,0(sp)
   25a84:	49ffffcc 	andi	r7,r9,65535
   25a88:	900b883a 	mov	r5,r18
   25a8c:	89003fcc 	andi	r4,r17,255
   25a90:	002568c0 	call	2568c <SdoRes>
   25a94:	00005506 	br	25bec <SDOS_SdoInd+0x400>
						if (mbxSize != (EXPEDITED_FRAME_SIZE + downloadSize))
   25a98:	50800284 	addi	r2,r10,10
   25a9c:	003fd006 	br	259e0 <SDOS_SdoInd+0x1f4>
					if (objLength == 0)
   25aa0:	e0006726 	beq	fp,zero,25c40 <SDOS_SdoInd+0x454>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25aa4:	5013883a 	mov	r9,r10
						abort = OBJ_Read(index, subindex, objLength, pObjEntry, pData, bCompleteAccess);
   25aa8:	d8800217 	ldw	r2,8(sp)
   25aac:	db000015 	stw	r12,0(sp)
   25ab0:	b80f883a 	mov	r7,r23
   25ab4:	d8800115 	stw	r2,4(sp)
   25ab8:	e00d883a 	mov	r6,fp
   25abc:	993fffcc 	andi	r4,r19,65535
   25ac0:	da400515 	stw	r9,20(sp)
   25ac4:	db000415 	stw	r12,16(sp)
   25ac8:	002493c0 	call	2493c <OBJ_Read>
   25acc:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   25ad0:	10803fcc 	andi	r2,r2,255
   25ad4:	10803fd8 	cmpnei	r2,r2,255
   25ad8:	db000417 	ldw	r12,16(sp)
   25adc:	da400517 	ldw	r9,20(sp)
   25ae0:	103fe51e 	bne	r2,zero,25a78 <SDOS_SdoInd+0x28c>
							u8PendingSdo = SDO_PENDING_READ;
   25ae4:	008000c4 	movi	r2,3
   25ae8:	d0a15b05 	stb	r2,-31380(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25aec:	d8800217 	ldw	r2,8(sp)
							u8StoreSubindex = subindex;
   25af0:	d5a15a85 	stb	r22,-31382(gp)
							u16StoreIndex = index;
   25af4:	d4e15a0d 	sth	r19,-31384(gp)
							bStoreCompleteAccess = bCompleteAccess;
   25af8:	d0a15ac5 	stb	r2,-31381(gp)
							pSdoPendFunc = pObjEntry->Read;
   25afc:	b8800717 	ldw	r2,28(r23)
							u32StoreDataSize = objLength;
   25b00:	d7215915 	stw	fp,-31388(gp)
							pStoreData = pData;
   25b04:	d3215815 	stw	r12,-31392(gp)
							pSdoPendFunc = pObjEntry->Read;
   25b08:	d0a15715 	stw	r2,-31396(gp)
							bSdoInWork = TRUE;
   25b0c:	00800044 	movi	r2,1
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25b10:	a8c03c0c 	andi	r3,r21,240
							bSdoInWork = TRUE;
   25b14:	d0a152c5 	stb	r2,-31413(gp)
							pSdoResStored = pSdoInd;
   25b18:	d4215315 	stw	r16,-31412(gp)
							pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25b1c:	80c00205 	stb	r3,8(r16)
							return 0;
   25b20:	00003206 	br	25bec <SDOS_SdoInd+0x400>
			if ((abort == 0) && (bCompleteAccess == 1))
   25b24:	a880040c 	andi	r2,r21,16
   25b28:	1001651e 	bne	r2,zero,260c0 <SDOS_SdoInd+0x8d4>
				if (subindex > 1)
   25b2c:	e013883a 	mov	r9,fp
   25b30:	003fb206 	br	259fc <SDOS_SdoInd+0x210>
					pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
   25b34:	83000404 	addi	r12,r16,16
   25b38:	003f9506 	br	25990 <SDOS_SdoInd+0x1a4>
						if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25b3c:	90801018 	cmpnei	r2,r18,64
   25b40:	1000371e 	bne	r2,zero,25c20 <SDOS_SdoInd+0x434>
							abort = OBJ_Read(index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess);
   25b44:	d8800217 	ldw	r2,8(sp)
   25b48:	d9000015 	stw	r4,0(sp)
   25b4c:	b80f883a 	mov	r7,r23
   25b50:	d8800115 	stw	r2,4(sp)
   25b54:	e00d883a 	mov	r6,fp
   25b58:	993fffcc 	andi	r4,r19,65535
   25b5c:	da800415 	stw	r10,16(sp)
   25b60:	002493c0 	call	2493c <OBJ_Read>
   25b64:	1023883a 	mov	r17,r2
							if (abort == 0)
   25b68:	10803fcc 	andi	r2,r2,255
   25b6c:	da800417 	ldw	r10,16(sp)
   25b70:	10000a1e 	bne	r2,zero,25b9c <SDOS_SdoInd+0x3b0>
								MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize);
   25b74:	d1615617 	ldw	r5,-31400(gp)
   25b78:	500d883a 	mov	r6,r10
   25b7c:	81000404 	addi	r4,r16,16
   25b80:	da800215 	stw	r10,8(sp)
   25b84:	0026ed40 	call	26ed4 <memcpy>
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   25b88:	00801804 	movi	r2,96
   25b8c:	d0a15285 	stb	r2,-31414(gp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25b90:	da800217 	ldw	r10,8(sp)
						nSdoSegBytesToHandle = dataSize;
   25b94:	d2a15015 	stw	r10,-31424(gp)
   25b98:	003fb606 	br	25a74 <SDOS_SdoInd+0x288>
							else if (abort == ABORTIDX_WORKING)
   25b9c:	10803fd8 	cmpnei	r2,r2,255
   25ba0:	103ffc1e 	bne	r2,zero,25b94 <SDOS_SdoInd+0x3a8>
								u8PendingSdo = SDO_PENDING_SEG_READ;
   25ba4:	00800104 	movi	r2,4
   25ba8:	d0a15b05 	stb	r2,-31380(gp)
								bStoreCompleteAccess = bCompleteAccess;
   25bac:	d8800217 	ldw	r2,8(sp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25bb0:	a8c03c0c 	andi	r3,r21,240
								u8StoreSubindex = subindex;
   25bb4:	d5a15a85 	stb	r22,-31382(gp)
								bStoreCompleteAccess = bCompleteAccess;
   25bb8:	d0a15ac5 	stb	r2,-31381(gp)
								pStoreData = pSdoSegData;
   25bbc:	d0a15617 	ldw	r2,-31400(gp)
								u16StoreIndex = index;
   25bc0:	d4e15a0d 	sth	r19,-31384(gp)
								u32StoreDataSize = objLength;
   25bc4:	d7215915 	stw	fp,-31388(gp)
								pStoreData = pSdoSegData;
   25bc8:	d0a15815 	stw	r2,-31392(gp)
								pSdoPendFunc = pObjEntry->Read;
   25bcc:	b8800717 	ldw	r2,28(r23)
								pSdoResStored = pSdoInd;
   25bd0:	d4215315 	stw	r16,-31412(gp)
								pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
   25bd4:	80c00205 	stb	r3,8(r16)
								pSdoPendFunc = pObjEntry->Read;
   25bd8:	d0a15715 	stw	r2,-31396(gp)
								bSdoInWork = TRUE;
   25bdc:	00800044 	movi	r2,1
   25be0:	d0a152c5 	stb	r2,-31413(gp)
								nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   25be4:	00801804 	movi	r2,96
   25be8:	d0a15285 	stb	r2,-31414(gp)
	}

	return 0;
}
   25bec:	a005883a 	mov	r2,r20
   25bf0:	dfc00f17 	ldw	ra,60(sp)
   25bf4:	df000e17 	ldw	fp,56(sp)
   25bf8:	ddc00d17 	ldw	r23,52(sp)
   25bfc:	dd800c17 	ldw	r22,48(sp)
   25c00:	dd400b17 	ldw	r21,44(sp)
   25c04:	dd000a17 	ldw	r20,40(sp)
   25c08:	dcc00917 	ldw	r19,36(sp)
   25c0c:	dc800817 	ldw	r18,32(sp)
   25c10:	dc400717 	ldw	r17,28(sp)
   25c14:	dc000617 	ldw	r16,24(sp)
   25c18:	dec01004 	addi	sp,sp,64
   25c1c:	f800283a 	ret
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25c20:	8abffd84 	addi	r10,r17,-10
   25c24:	500d883a 	mov	r6,r10
   25c28:	81400404 	addi	r5,r16,16
   25c2c:	da800215 	stw	r10,8(sp)
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25c30:	a023883a 	mov	r17,r20
							MBXMEMCPY(pSdoSegData, (UINT16 *)((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25c34:	0026ed40 	call	26ed4 <memcpy>
							nSdoSegService = SDOSERVICE_DOWNLOADSEGMENTREQ;
   25c38:	d0215285 	stb	zero,-31414(gp)
							dataSize = (mbxSize - DOWNLOAD_NORM_REQ_SIZE);
   25c3c:	003fd406 	br	25b90 <SDOS_SdoInd+0x3a4>
						nSdoSegIndex = index;
   25c40:	d4e1518d 	sth	r19,-31418(gp)
						nSdoSegSubindex = subindex;
   25c44:	d5a15105 	stb	r22,-31420(gp)
						pSdoSegObjEntry = pObjEntry;
   25c48:	d5e14d15 	stw	r23,-31436(gp)
					if (command == SDOSERVICE_INITIATEUPLOADREQ)
   25c4c:	003f9506 	br	25aa4 <SDOS_SdoInd+0x2b8>
		if (command == nSdoSegService)
   25c50:	d1215283 	ldbu	r4,-31414(gp)
   25c54:	203f021e 	bne	r4,zero,25860 <SDOS_SdoInd+0x74>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c58:	d1614f03 	ldbu	r5,-31428(gp)
		if (pSdoSegData)
   25c5c:	d1215617 	ldw	r4,-31400(gp)
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25c60:	28808826 	beq	r5,r2,25e84 <SDOS_SdoInd+0x698>
		bSdoSegLastToggle = SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE);
   25c64:	d0a14f05 	stb	r2,-31428(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25c68:	d4e14a0b 	ldhu	r19,-31448(gp)
		if (pSdoSegData)
   25c6c:	20008726 	beq	r4,zero,25e8c <SDOS_SdoInd+0x6a0>
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25c70:	d0a15017 	ldw	r2,-31424(gp)
   25c74:	d1614e17 	ldw	r5,-31432(gp)
		UINT16 maxData = u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25c78:	9cfffdc4 	addi	r19,r19,-9
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   25c7c:	a980004c 	andi	r6,r21,1
			bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25c80:	288bc83a 	sub	r5,r5,r2
				if (bytesToSave <= maxData)
   25c84:	9cffffcc 	andi	r19,r19,65535
			if (pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS)
   25c88:	30003d26 	beq	r6,zero,25d80 <SDOS_SdoInd+0x594>
				if (bytesToSave <= maxData)
   25c8c:	9940092e 	bgeu	r19,r5,25cb4 <SDOS_SdoInd+0x4c8>
					abort = ABORTIDX_PARAM_LENGTH_ERROR;
   25c90:	04400384 	movi	r17,14
		if (pSdoSegData)
   25c94:	d1215617 	ldw	r4,-31400(gp)
		bSdoSegFollows = FALSE;
   25c98:	d0215245 	stb	zero,-31415(gp)
		nSdoSegService = 0;
   25c9c:	d0215285 	stb	zero,-31414(gp)
		if (pSdoSegData)
   25ca0:	20000226 	beq	r4,zero,25cac <SDOS_SdoInd+0x4c0>
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25ca4:	0026bdc0 	call	26bdc <free>
			pSdoSegData = NULL;
   25ca8:	d0215615 	stw	zero,-31400(gp)
		nSdoSegBytesToHandle = 0;
   25cac:	d0215015 	stw	zero,-31424(gp)
   25cb0:	00003006 	br	25d74 <SDOS_SdoInd+0x588>
					if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   25cb4:	8c7fffcc 	andi	r17,r17,65535
   25cb8:	8c7fff44 	addi	r17,r17,-3
   25cbc:	897ff436 	bltu	r17,r5,25c90 <SDOS_SdoInd+0x4a4>
	if (SWAPWORD(pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle)
   25cc0:	a9bfffcc 	andi	r6,r21,65535
						&& (bytesToSave == ((UINT16)(MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))))
   25cc4:	300dd07a 	srai	r6,r6,1
   25cc8:	018c303a 	nor	r6,zero,r6
   25ccc:	318001cc 	andi	r6,r6,7
   25cd0:	29800326 	beq	r5,r6,25ce0 <SDOS_SdoInd+0x4f4>
						|| ((bytesToSave > MIN_SEGMENTED_DATA)
   25cd4:	29800230 	cmpltui	r6,r5,8
   25cd8:	303fed1e 	bne	r6,zero,25c90 <SDOS_SdoInd+0x4a4>
							&& (bytesToSave == (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
   25cdc:	2c7fec1e 	bne	r5,r17,25c90 <SDOS_SdoInd+0x4a4>
						bSdoSegFollows = FALSE;
   25ce0:	d0215245 	stb	zero,-31415(gp)
   25ce4:	2827883a 	mov	r19,r5
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ce8:	11c0004c 	andi	r7,r2,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25cec:	1004d07a 	srli	r2,r2,1
   25cf0:	81400284 	addi	r5,r16,10
   25cf4:	1004907a 	slli	r2,r2,1
   25cf8:	208d883a 	add	r6,r4,r2
				if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25cfc:	38002426 	beq	r7,zero,25d90 <SDOS_SdoInd+0x5a4>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25d00:	30c00003 	ldbu	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   25d04:	10800084 	addi	r2,r2,2
   25d08:	2089883a 	add	r4,r4,r2
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
   25d0c:	30c0000d 	sth	r3,0(r6)
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
   25d10:	81c0020b 	ldhu	r7,8(r16)
   25d14:	39ffc00c 	andi	r7,r7,65280
   25d18:	19c6b03a 	or	r3,r3,r7
   25d1c:	30c0000d 	sth	r3,0(r6)
					MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], pSdoInd->SdoHeader.Data, bytesToSave - 1);
   25d20:	99bfffc4 	addi	r6,r19,-1
   25d24:	0026ed40 	call	26ed4 <memcpy>
				if (bSdoSegFollows == FALSE)
   25d28:	d0a15243 	ldbu	r2,-31415(gp)
   25d2c:	10002b26 	beq	r2,zero,25ddc <SDOS_SdoInd+0x5f0>
		pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25d30:	00800284 	movi	r2,10
   25d34:	8080000d 	sth	r2,0(r16)
		pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25d38:	8080018b 	ldhu	r2,6(r16)
   25d3c:	1083ffcc 	andi	r2,r2,4095
		pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25d40:	108c0014 	ori	r2,r2,12288
   25d44:	8080018d 	sth	r2,6(r16)
		if (bSdoSegLastToggle)
   25d48:	d0a14f03 	ldbu	r2,-31428(gp)
   25d4c:	10004b1e 	bne	r2,zero,25e7c <SDOS_SdoInd+0x690>
   25d50:	00800804 	movi	r2,32
			pSdoInd->SdoHeader.SegHeader = SWAPWORD(SDOSERVICE_DOWNLOADSEGMENTRES | SEGHEADER_TOGGLE);
   25d54:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   25d58:	d0a15243 	ldbu	r2,-31415(gp)
   25d5c:	10800058 	cmpnei	r2,r2,1
   25d60:	1000981e 	bne	r2,zero,25fc4 <SDOS_SdoInd+0x7d8>
			nSdoSegBytesToHandle += bytesToSave;
   25d64:	d0a15017 	ldw	r2,-31424(gp)
   25d68:	14c5883a 	add	r2,r2,r19
   25d6c:	d0a15015 	stw	r2,-31424(gp)
	if (abort != ABORTIDX_WORKING)
   25d70:	a023883a 	mov	r17,r20
	UINT32 dataSize = 0;
   25d74:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   25d78:	0039883a 	mov	fp,zero
   25d7c:	003f3e06 	br	25a78 <SDOS_SdoInd+0x28c>
				bSdoSegFollows = TRUE;
   25d80:	01800044 	movi	r6,1
   25d84:	d1a15245 	stb	r6,-31415(gp)
				if (bytesToSave <= maxData)
   25d88:	997fc12e 	bgeu	r19,r5,25c90 <SDOS_SdoInd+0x4a4>
   25d8c:	003fd606 	br	25ce8 <SDOS_SdoInd+0x4fc>
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   25d90:	8080028b 	ldhu	r2,10(r16)
   25d94:	a8ffffcc 	andi	r3,r21,65535
   25d98:	1806d23a 	srli	r3,r3,8
   25d9c:	1004923a 	slli	r2,r2,8
   25da0:	10c4b03a 	or	r2,r2,r3
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25da4:	98c00044 	addi	r3,r19,1
   25da8:	1806d07a 	srli	r3,r3,1
					pSdoSegData[(nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
   25dac:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25db0:	39c00044 	addi	r7,r7,1
   25db4:	29400084 	addi	r5,r5,2
   25db8:	31800084 	addi	r6,r6,2
   25dbc:	38ffda2e 	bgeu	r7,r3,25d28 <SDOS_SdoInd+0x53c>
						pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
   25dc0:	28bfff8b 	ldhu	r2,-2(r5)
   25dc4:	2900000b 	ldhu	r4,0(r5)
   25dc8:	1004d23a 	srli	r2,r2,8
   25dcc:	2008923a 	slli	r4,r4,8
   25dd0:	1104b03a 	or	r2,r2,r4
   25dd4:	3080000d 	sth	r2,0(r6)
					for (i = 1; i < ((bytesToSave + 1) >> 1); i++)
   25dd8:	003ff506 	br	25db0 <SDOS_SdoInd+0x5c4>
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   25ddc:	d0a15203 	ldbu	r2,-31416(gp)
   25de0:	d1e14d17 	ldw	r7,-31436(gp)
   25de4:	d1a14e17 	ldw	r6,-31432(gp)
   25de8:	d8800115 	stw	r2,4(sp)
   25dec:	d0a15617 	ldw	r2,-31400(gp)
   25df0:	d1615103 	ldbu	r5,-31420(gp)
   25df4:	d121518b 	ldhu	r4,-31418(gp)
   25df8:	d8800015 	stw	r2,0(sp)
   25dfc:	0024f4c0 	call	24f4c <OBJ_Write>
					if (abort == ABORTIDX_WORKING)
   25e00:	15803fcc 	andi	r22,r2,255
					abort = OBJ_Write(nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess);
   25e04:	1023883a 	mov	r17,r2
					if (abort == ABORTIDX_WORKING)
   25e08:	b0803fd8 	cmpnei	r2,r22,255
   25e0c:	1000161e 	bne	r2,zero,25e68 <SDOS_SdoInd+0x67c>
						u8PendingSdo = SDO_PENDING_SEG_WRITE;
   25e10:	00800084 	movi	r2,2
   25e14:	d0a15b05 	stb	r2,-31380(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   25e18:	d0a15203 	ldbu	r2,-31416(gp)
						pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
   25e1c:	d4215315 	stw	r16,-31412(gp)
						bSdoSegFollows = FALSE;
   25e20:	d0215245 	stb	zero,-31415(gp)
						bStoreCompleteAccess = bSdoSegAccess;
   25e24:	d0a15ac5 	stb	r2,-31381(gp)
						u8StoreSubindex = nSdoSegSubindex;
   25e28:	d0a15103 	ldbu	r2,-31420(gp)
						nSdoSegService = 0;
   25e2c:	d0215285 	stb	zero,-31414(gp)
						nSdoSegBytesToHandle = 0;
   25e30:	d0215015 	stw	zero,-31424(gp)
						u8StoreSubindex = nSdoSegSubindex;
   25e34:	d0a15a85 	stb	r2,-31382(gp)
						u16StoreIndex = nSdoSegIndex;
   25e38:	d0a1518b 	ldhu	r2,-31418(gp)
   25e3c:	d0a15a0d 	sth	r2,-31384(gp)
						u32StoreDataSize = nSdoSegCompleteSize;
   25e40:	d0a14e17 	ldw	r2,-31432(gp)
   25e44:	d0a15915 	stw	r2,-31388(gp)
						pStoreData = pSdoSegData;
   25e48:	d0a15617 	ldw	r2,-31400(gp)
   25e4c:	d0a15815 	stw	r2,-31392(gp)
						pSdoPendFunc = pSdoSegObjEntry->Write;
   25e50:	d0a14d17 	ldw	r2,-31436(gp)
   25e54:	10800817 	ldw	r2,32(r2)
   25e58:	d0a15715 	stw	r2,-31396(gp)
						bSdoInWork = TRUE;
   25e5c:	00800044 	movi	r2,1
   25e60:	d0a152c5 	stb	r2,-31413(gp)
	if (abort != ABORTIDX_WORKING)
   25e64:	003f6106 	br	25bec <SDOS_SdoInd+0x400>
						FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25e68:	d1215617 	ldw	r4,-31400(gp)
   25e6c:	0026bdc0 	call	26bdc <free>
						pSdoSegData = NULL;
   25e70:	d0215615 	stw	zero,-31400(gp)
	if (abort == 0)
   25e74:	b03fae26 	beq	r22,zero,25d30 <SDOS_SdoInd+0x544>
   25e78:	003f8606 	br	25c94 <SDOS_SdoInd+0x4a8>
   25e7c:	00800c04 	movi	r2,48
   25e80:	003fb406 	br	25d54 <SDOS_SdoInd+0x568>
		abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
   25e84:	04400044 	movi	r17,1
   25e88:	003f8206 	br	25c94 <SDOS_SdoInd+0x4a8>
			abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   25e8c:	044000c4 	movi	r17,3
   25e90:	003f8006 	br	25c94 <SDOS_SdoInd+0x4a8>
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25e94:	d4614a8b 	ldhu	r17,-31446(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25e98:	d4e15017 	ldw	r19,-31424(gp)
   25e9c:	d0a14e17 	ldw	r2,-31432(gp)
			maxData = u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
   25ea0:	8c7ffdc4 	addi	r17,r17,-9
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25ea4:	8c7fffcc 	andi	r17,r17,65535
		bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
   25ea8:	d5e14f05 	stb	r23,-31428(gp)
		if (nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData))
   25eac:	8cc9883a 	add	r4,r17,r19
   25eb0:	1100242e 	bgeu	r2,r4,25f44 <SDOS_SdoInd+0x758>
			size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
   25eb4:	14e3c83a 	sub	r17,r2,r19
			bSdoSegFollows = FALSE;
   25eb8:	a039883a 	mov	fp,r20
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ebc:	980cd07a 	srli	r6,r19,1
   25ec0:	d5a15617 	ldw	r22,-31400(gp)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   25ec4:	a8c03fcc 	andi	r3,r21,255
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ec8:	300a907a 	slli	r5,r6,1
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
   25ecc:	80c0020d 	sth	r3,8(r16)
			bSdoSegFollows = FALSE;
   25ed0:	d7215245 	stb	fp,-31415(gp)
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ed4:	b145883a 	add	r2,r22,r5
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ed8:	9900004c 	andi	r4,r19,1
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25edc:	1080000b 	ldhu	r2,0(r2)
		if ((nSdoSegBytesToHandle & 0x1) == 0x01)
   25ee0:	20001a26 	beq	r4,zero,25f4c <SDOS_SdoInd+0x760>
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ee4:	10bfc00c 	andi	r2,r2,65280
   25ee8:	1886b03a 	or	r3,r3,r2
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   25eec:	29400084 	addi	r5,r5,2
			pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
   25ef0:	80c0020d 	sth	r3,8(r16)
			MBXMEMCPY(pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
   25ef4:	89bfffc4 	addi	r6,r17,-1
   25ef8:	b14b883a 	add	r5,r22,r5
   25efc:	81000284 	addi	r4,r16,10
   25f00:	0026ed40 	call	26ed4 <memcpy>
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25f04:	8080018b 	ldhu	r2,6(r16)
		if (bSdoSegFollows)
   25f08:	e7003fcc 	andi	fp,fp,255
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25f0c:	8807883a 	mov	r3,r17
		pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
   25f10:	1083ffcc 	andi	r2,r2,4095
		pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
   25f14:	108c0014 	ori	r2,r2,12288
   25f18:	8080018d 	sth	r2,6(r16)
		pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
   25f1c:	8080020b 	ldhu	r2,8(r16)
   25f20:	890001f0 	cmpltui	r4,r17,7
   25f24:	10bfc00c 	andi	r2,r2,65280
		if (bSdoSegFollows)
   25f28:	e0001d26 	beq	fp,zero,25fa0 <SDOS_SdoInd+0x7b4>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle);
   25f2c:	15c4b03a 	or	r2,r2,r23
   25f30:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   25f34:	20002e1e 	bne	r4,zero,25ff0 <SDOS_SdoInd+0x804>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25f38:	18c000c4 	addi	r3,r3,3
   25f3c:	80c0000d 	sth	r3,0(r16)
		if (bSdoSegFollows == TRUE)
   25f40:	00003206 	br	2600c <SDOS_SdoInd+0x820>
   25f44:	07000044 	movi	fp,1
   25f48:	003fdc06 	br	25ebc <SDOS_SdoInd+0x6d0>
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   25f4c:	1004923a 	slli	r2,r2,8
			for (i = 0; i < (size >> 1); i++)
   25f50:	880ed07a 	srli	r7,r17,1
   25f54:	000b883a 	mov	r5,zero
			pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
   25f58:	1886b03a 	or	r3,r3,r2
   25f5c:	80c0020d 	sth	r3,8(r16)
			for (i = 0; i < (size >> 1); i++)
   25f60:	28bfffcc 	andi	r2,r5,65535
   25f64:	11ffe72e 	bgeu	r2,r7,25f04 <SDOS_SdoInd+0x718>
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   25f68:	1187883a 	add	r3,r2,r6
   25f6c:	1806907a 	slli	r3,r3,1
   25f70:	10800104 	addi	r2,r2,4
   25f74:	1004907a 	slli	r2,r2,1
   25f78:	b0c7883a 	add	r3,r22,r3
   25f7c:	1900008b 	ldhu	r4,2(r3)
   25f80:	18c0000b 	ldhu	r3,0(r3)
   25f84:	8085883a 	add	r2,r16,r2
   25f88:	2008923a 	slli	r4,r4,8
   25f8c:	1806d23a 	srli	r3,r3,8
			for (i = 0; i < (size >> 1); i++)
   25f90:	29400044 	addi	r5,r5,1
				pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
   25f94:	20c6b03a 	or	r3,r4,r3
   25f98:	10c0008d 	sth	r3,2(r2)
			for (i = 0; i < (size >> 1); i++)
   25f9c:	003ff006 	br	25f60 <SDOS_SdoInd+0x774>
			pSdoSegRes->SdoHeader.SegHeader |= SWAPWORD(SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS);
   25fa0:	bdc00054 	ori	r23,r23,1
   25fa4:	15c4b03a 	or	r2,r2,r23
   25fa8:	8080020d 	sth	r2,8(r16)
		if (size < MIN_SEGMENTED_DATA)
   25fac:	2000081e 	bne	r4,zero,25fd0 <SDOS_SdoInd+0x7e4>
			pSdoSegRes->MbxHeader.Length = ((UINT16)size) + SEGMENT_NORM_HEADER_SIZE;
   25fb0:	18c000c4 	addi	r3,r3,3
   25fb4:	80c0000d 	sth	r3,0(r16)
			FREEMEM((UINT16 VARMEM *) pSdoSegData);
   25fb8:	b009883a 	mov	r4,r22
   25fbc:	0026bdc0 	call	26bdc <free>
			pSdoSegData = NULL;
   25fc0:	d0215615 	stw	zero,-31400(gp)
			nSdoSegBytesToHandle = 0;
   25fc4:	d0215015 	stw	zero,-31424(gp)
			nSdoSegService = 0;
   25fc8:	d0215285 	stb	zero,-31414(gp)
	if (abort != ABORTIDX_WORKING)
   25fcc:	003f6806 	br	25d70 <SDOS_SdoInd+0x584>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25fd0:	01000284 	movi	r4,10
   25fd4:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   25fd8:	010001c4 	movi	r4,7
   25fdc:	20c7c83a 	sub	r3,r4,r3
   25fe0:	1806907a 	slli	r3,r3,1
   25fe4:	1884b03a 	or	r2,r3,r2
   25fe8:	8080020d 	sth	r2,8(r16)
		if (bSdoSegFollows == TRUE)
   25fec:	003ff206 	br	25fb8 <SDOS_SdoInd+0x7cc>
			pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
   25ff0:	01000284 	movi	r4,10
   25ff4:	8100000d 	sth	r4,0(r16)
			pSdoSegRes->SdoHeader.SegHeader |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
   25ff8:	010001c4 	movi	r4,7
   25ffc:	20c7c83a 	sub	r3,r4,r3
   26000:	1806907a 	slli	r3,r3,1
   26004:	1884b03a 	or	r2,r3,r2
   26008:	8080020d 	sth	r2,8(r16)
			nSdoSegBytesToHandle += size;
   2600c:	9c67883a 	add	r19,r19,r17
   26010:	d4e15015 	stw	r19,-31424(gp)
	if (abort != ABORTIDX_WORKING)
   26014:	003f5606 	br	25d70 <SDOS_SdoInd+0x584>
	UINT32 dataSize = 0;
   26018:	0013883a 	mov	r9,zero
	UINT32 objLength = 0;
   2601c:	0039883a 	mov	fp,zero
			abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26020:	04400204 	movi	r17,8
   26024:	003e9406 	br	25a78 <SDOS_SdoInd+0x28c>
   26028:	0013883a 	mov	r9,zero
   2602c:	0039883a 	mov	fp,zero
   26030:	04400444 	movi	r17,17
   26034:	003e9006 	br	25a78 <SDOS_SdoInd+0x28c>
		return MBXERR_SERVICEINWORK;
   26038:	05000244 	movi	r20,9
   2603c:	003eeb06 	br	25bec <SDOS_SdoInd+0x400>
							return MBXERR_INVALIDSIZE;
   26040:	05000204 	movi	r20,8
   26044:	003ee906 	br	25bec <SDOS_SdoInd+0x400>
					if (objLength == 0)
   26048:	e000031e 	bne	fp,zero,26058 <SDOS_SdoInd+0x86c>
						nSdoSegIndex = index;
   2604c:	d4e1518d 	sth	r19,-31418(gp)
						nSdoSegSubindex = subindex;
   26050:	d5a15105 	stb	r22,-31420(gp)
						pSdoSegObjEntry = pObjEntry;
   26054:	d5e14d15 	stw	r23,-31436(gp)
						abort = OBJ_Write(index, subindex, dataSize, pObjEntry, pData, bCompleteAccess);
   26058:	d8800217 	ldw	r2,8(sp)
   2605c:	db000015 	stw	r12,0(sp)
   26060:	480d883a 	mov	r6,r9
   26064:	d8800115 	stw	r2,4(sp)
   26068:	b80f883a 	mov	r7,r23
   2606c:	993fffcc 	andi	r4,r19,65535
   26070:	db000515 	stw	r12,20(sp)
   26074:	da400415 	stw	r9,16(sp)
   26078:	0024f4c0 	call	24f4c <OBJ_Write>
   2607c:	1023883a 	mov	r17,r2
						if (abort == ABORTIDX_WORKING)
   26080:	10803fcc 	andi	r2,r2,255
   26084:	10803fd8 	cmpnei	r2,r2,255
   26088:	da400417 	ldw	r9,16(sp)
   2608c:	db000517 	ldw	r12,20(sp)
   26090:	103e791e 	bne	r2,zero,25a78 <SDOS_SdoInd+0x28c>
							bStoreCompleteAccess = bCompleteAccess;
   26094:	d8c00217 	ldw	r3,8(sp)
							pSdoPendFunc = pObjEntry->Write;
   26098:	b9000817 	ldw	r4,32(r23)
							u8PendingSdo = SDO_PENDING_WRITE;
   2609c:	00800044 	movi	r2,1
   260a0:	d0a15b05 	stb	r2,-31380(gp)
							bStoreCompleteAccess = bCompleteAccess;
   260a4:	d0e15ac5 	stb	r3,-31381(gp)
							u8StoreSubindex = subindex;
   260a8:	d5a15a85 	stb	r22,-31382(gp)
							u16StoreIndex = index;
   260ac:	d4e15a0d 	sth	r19,-31384(gp)
							u32StoreDataSize = dataSize;
   260b0:	d2615915 	stw	r9,-31388(gp)
							pStoreData = pData;
   260b4:	d3215815 	stw	r12,-31392(gp)
							pSdoPendFunc = pObjEntry->Write;
   260b8:	d1215715 	stw	r4,-31396(gp)
   260bc:	003e9406 	br	25b10 <SDOS_SdoInd+0x324>
				if (subindex > 1)
   260c0:	288000a8 	cmpgeui	r2,r5,2
   260c4:	103e9926 	beq	r2,zero,25b2c <SDOS_SdoInd+0x340>
							dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   260c8:	5013883a 	mov	r9,r10
							abort = ABORTIDX_UNSUPPORTED_ACCESS;
   260cc:	04400144 	movi	r17,5
   260d0:	003e6906 	br	25a78 <SDOS_SdoInd+0x28c>
							pData = (UINT16 MBXMEM *) ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
   260d4:	83000304 	addi	r12,r16,12
   260d8:	e013883a 	mov	r9,fp
   260dc:	003e7206 	br	25aa8 <SDOS_SdoInd+0x2bc>

000260e0 <SDOS_SdoRes>:

void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
{
	UINT16 dataSize = 0;

	if (bSdoInWork)
   260e0:	d0a152c3 	ldbu	r2,-31413(gp)
   260e4:	10004126 	beq	r2,zero,261ec <SDOS_SdoRes+0x10c>
{
   260e8:	defff604 	addi	sp,sp,-40
   260ec:	dcc00515 	stw	r19,20(sp)
	{
		/* SDO-Response is expected */
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   260f0:	d4e15317 	ldw	r19,-31412(gp)
{
   260f4:	dc800415 	stw	r18,16(sp)
   260f8:	dd400715 	stw	r21,28(sp)
		UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
   260fc:	9c800203 	ldbu	r18,8(r19)
{
   26100:	dd000615 	stw	r20,24(sp)
   26104:	dc000215 	stw	r16,8(sp)
		UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
   26108:	9540040c 	andi	r21,r18,16

		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   2610c:	9480380c 	andi	r18,r18,224
{
   26110:	dfc00915 	stw	ra,36(sp)
   26114:	dd800815 	stw	r22,32(sp)
   26118:	dc400315 	stw	r17,12(sp)
		if (command == SDOSERVICE_INITIATEUPLOADREQ)
   2611c:	90801018 	cmpnei	r2,r18,64
   26120:	2029883a 	mov	r20,r4
   26124:	2821883a 	mov	r16,r5
   26128:	10002e1e 	bne	r2,zero,261e4 <SDOS_SdoRes+0x104>
		{
			/* dataSize contains the available size in one mailbox */
			dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
   2612c:	d4614a8b 	ldhu	r17,-31446(gp)
   26130:	300b883a 	mov	r5,r6
   26134:	8c7ffc04 	addi	r17,r17,-16
   26138:	882d883a 	mov	r22,r17
			if (dataSize < objLength)
   2613c:	8c7fffcc 	andi	r17,r17,65535
   26140:	8c001e2e 	bgeu	r17,r16,261bc <SDOS_SdoRes+0xdc>
			{
				/* Segmented Upload, the variables for the segmented transfer should be initialized */
				bSdoSegFollows = TRUE;
   26144:	00800044 	movi	r2,1
   26148:	d0a15245 	stb	r2,-31415(gp)
				bSdoSegLastToggle = 1;
   2614c:	d0a14f05 	stb	r2,-31428(gp)
				bSdoSegAccess = completeAccess;
				nSdoSegCompleteSize = objLength;
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
				pSdoSegData = (UINT16 VARMEM *) pData;
   26150:	d1a15615 	stw	r6,-31400(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26154:	00801804 	movi	r2,96
				/* the first segment shall be copied */
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   26158:	880d883a 	mov	r6,r17
   2615c:	99000404 	addi	r4,r19,16
				bSdoSegAccess = completeAccess;
   26160:	d5615205 	stb	r21,-31416(gp)
				nSdoSegCompleteSize = objLength;
   26164:	d4214e15 	stw	r16,-31432(gp)
				nSdoSegService = SDOSERVICE_UPLOADSEGMENTREQ;
   26168:	d0a15285 	stb	r2,-31414(gp)
				MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
   2616c:	0026ed40 	call	26ed4 <memcpy>
				nSdoSegBytesToHandle = dataSize;
   26170:	d4615015 	stw	r17,-31424(gp)
				}
		}

		/* SDO access is finished, send the response */
		bSdoInWork = FALSE;
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26174:	dcc00115 	stw	r19,4(sp)
   26178:	dc000015 	stw	r16,0(sp)
   2617c:	b1ffffcc 	andi	r7,r22,65535
   26180:	a80d883a 	mov	r6,r21
   26184:	900b883a 	mov	r5,r18
   26188:	a1003fcc 	andi	r4,r20,255
		bSdoInWork = FALSE;
   2618c:	d02152c5 	stb	zero,-31413(gp)
		SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
   26190:	002568c0 	call	2568c <SdoRes>
	}
}
   26194:	dfc00917 	ldw	ra,36(sp)
   26198:	dd800817 	ldw	r22,32(sp)
   2619c:	dd400717 	ldw	r21,28(sp)
   261a0:	dd000617 	ldw	r20,24(sp)
   261a4:	dcc00517 	ldw	r19,20(sp)
   261a8:	dc800417 	ldw	r18,16(sp)
   261ac:	dc400317 	ldw	r17,12(sp)
   261b0:	dc000217 	ldw	r16,8(sp)
   261b4:	dec00a04 	addi	sp,sp,40
   261b8:	f800283a 	ret
				if ((objLength <= 4) && (objLength > 0))
   261bc:	80bfffc4 	addi	r2,r16,-1
   261c0:	10800128 	cmpgeui	r2,r2,4
   261c4:	1000051e 	bne	r2,zero,261dc <SDOS_SdoRes+0xfc>
					if (pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data)
   261c8:	99000304 	addi	r4,r19,12
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   261cc:	217fe926 	beq	r4,r5,26174 <SDOS_SdoRes+0x94>
						MBXMEMCPY((UINT16 *)((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
   261d0:	800d883a 	mov	r6,r16
   261d4:	0026ed40 	call	26ed4 <memcpy>
   261d8:	003fe606 	br	26174 <SDOS_SdoRes+0x94>
					if (pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data)
   261dc:	99000404 	addi	r4,r19,16
   261e0:	003ffa06 	br	261cc <SDOS_SdoRes+0xec>
	UINT16 dataSize = 0;
   261e4:	002d883a 	mov	r22,zero
   261e8:	003fe206 	br	26174 <SDOS_SdoRes+0x94>
   261ec:	f800283a 	ret

000261f0 <SDOS_ClearPendingResponse>:
		   This function shall be called before the other mailbox data pointer are set to NULL
*////////////////////////////////////////////////////////////////////////////////////////

void  SDOS_ClearPendingResponse(void)
{
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   261f0:	d0a152c3 	ldbu	r2,-31413(gp)
{
   261f4:	deffff04 	addi	sp,sp,-4
   261f8:	dfc00015 	stw	ra,0(sp)
	if ((bSdoInWork == TRUE) && (pSdoResStored != NULL) && (((TMBX MBXMEM *)pSdoResStored) != psRepeatMbx) && (((TMBX MBXMEM *)pSdoResStored) != psStoreMbx))
   261fc:	10800058 	cmpnei	r2,r2,1
   26200:	1000081e 	bne	r2,zero,26224 <SDOS_ClearPendingResponse+0x34>
   26204:	d1215317 	ldw	r4,-31412(gp)
   26208:	20000626 	beq	r4,zero,26224 <SDOS_ClearPendingResponse+0x34>
   2620c:	d0a14517 	ldw	r2,-31468(gp)
   26210:	20800426 	beq	r4,r2,26224 <SDOS_ClearPendingResponse+0x34>
   26214:	d0a14417 	ldw	r2,-31472(gp)
   26218:	20800226 	beq	r4,r2,26224 <SDOS_ClearPendingResponse+0x34>
	{
		APPL_FreeMailboxBuffer(pSdoResStored);
   2621c:	0026bdc0 	call	26bdc <free>
		pSdoResStored = NULL;
   26220:	d0215315 	stw	zero,-31412(gp)
	u32StoreDataSize = 0;
	pStoreData = NULL;
	pSdoPendFunc = NULL;
	bSdoInWork = FALSE;

	if (pSdoSegData != NULL)
   26224:	d1215617 	ldw	r4,-31400(gp)
	u8PendingSdo = 0;
   26228:	d0215b05 	stb	zero,-31380(gp)
	bStoreCompleteAccess = FALSE;
   2622c:	d0215ac5 	stb	zero,-31381(gp)
	u16StoreIndex = 0;
   26230:	d0215a0d 	sth	zero,-31384(gp)
	u8StoreSubindex = 0;
   26234:	d0215a85 	stb	zero,-31382(gp)
	u32StoreDataSize = 0;
   26238:	d0215915 	stw	zero,-31388(gp)
	pStoreData = NULL;
   2623c:	d0215815 	stw	zero,-31392(gp)
	pSdoPendFunc = NULL;
   26240:	d0215715 	stw	zero,-31396(gp)
	bSdoInWork = FALSE;
   26244:	d02152c5 	stb	zero,-31413(gp)
	if (pSdoSegData != NULL)
   26248:	20000226 	beq	r4,zero,26254 <SDOS_ClearPendingResponse+0x64>
	{
		FREEMEM((UINT16 VARMEM *) pSdoSegData);
   2624c:	0026bdc0 	call	26bdc <free>
		pSdoSegData = NULL;
   26250:	d0215615 	stw	zero,-31400(gp)
	}

	nSdoSegBytesToHandle = 0;
   26254:	d0215015 	stw	zero,-31424(gp)
	nSdoSegService = 0;
   26258:	d0215285 	stb	zero,-31414(gp)

}
   2625c:	dfc00017 	ldw	ra,0(sp)
   26260:	dec00104 	addi	sp,sp,4
   26264:	f800283a 	ret

00026268 <SDOS_SdoInfoInd>:
			is received from the master and calls depending from
			the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd(TSDOINFORMATION MBXMEM *pSdoInfoInd)
{
   26268:	defff804 	addi	sp,sp,-32
   2626c:	dcc00515 	stw	r19,20(sp)
	UINT8 abort = 0;
	/* the variable opCode contains the requested SDO Information type */
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   26270:	24c00203 	ldbu	r19,8(r4)
{
   26274:	dc800415 	stw	r18,16(sp)
   26278:	dc000215 	stw	r16,8(sp)
	UINT8 opCode = (UINT8)((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
   2627c:	9c801fcc 	andi	r18,r19,127
{
   26280:	dfc00715 	stw	ra,28(sp)
   26284:	dd000615 	stw	r20,24(sp)
   26288:	dc400315 	stw	r17,12(sp)
	UINT8 abort = 0;
   2628c:	d8000145 	stb	zero,5(sp)
	UINT16 index;
	UINT8 flags = COE_SERVICE;

	/* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
	   great enough for the service header of the requested SDO Information type */
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   26290:	90c00158 	cmpnei	r3,r18,5
   26294:	2080000b 	ldhu	r2,0(r4)
{
   26298:	2021883a 	mov	r16,r4
	if (opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q)
   2629c:	9027883a 	mov	r19,r18
   262a0:	1800041e 	bne	r3,zero,262b4 <SDOS_SdoInfoInd+0x4c>
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT)
   262a4:	108002b0 	cmpltui	r2,r2,10
   262a8:	10000926 	beq	r2,zero,262d0 <SDOS_SdoInfoInd+0x68>
		{
			return MBXERR_SIZETOOSHORT;
   262ac:	00800184 	movi	r2,6
   262b0:	00004b06 	br	263e0 <SDOS_SdoInfoInd+0x178>
		}
	}
	else
	{
		if (pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT)
   262b4:	10800230 	cmpltui	r2,r2,8
   262b8:	103ffc1e 	bne	r2,zero,262ac <SDOS_SdoInfoInd+0x44>
		{
			return MBXERR_SIZETOOSHORT;
		}
	}

	switch (opCode)
   262bc:	90800060 	cmpeqi	r2,r18,1
   262c0:	10000b1e 	bne	r2,zero,262f0 <SDOS_SdoInfoInd+0x88>
   262c4:	9000dc26 	beq	r18,zero,26638 <SDOS_SdoInfoInd+0x3d0>
   262c8:	908000e0 	cmpeqi	r2,r18,3
   262cc:	1000da26 	beq	r2,zero,26638 <SDOS_SdoInfoInd+0x3d0>
		break;

	case SDOINFOSERVICE_OBJDESCRIPTION_Q:
	case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
		/* get the requested index */
		index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
   262d0:	8100030b 	ldhu	r4,12(r16)
   262d4:	d900018d 	sth	r4,6(sp)



		if (index < 0x1000)
   262d8:	213fffcc 	andi	r4,r4,65535
   262dc:	20840028 	cmpgeui	r2,r4,4096
   262e0:	1000741e 	bne	r2,zero,264b4 <SDOS_SdoInfoInd+0x24c>
		{
			/*SDO Info access is only allowed for objects >= 0x1000*/
			abort = ABORTIDX_UNSUPPORTED_ACCESS;
   262e4:	00800144 	movi	r2,5
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
			}
		}
		break;
	default:
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   262e8:	d8800145 	stb	r2,5(sp)
   262ec:	00009506 	br	26544 <SDOS_SdoInfoInd+0x2dc>
		if (SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX)
   262f0:	2440030b 	ldhu	r17,12(r4)
   262f4:	8cbfffcc 	andi	r18,r17,65535
   262f8:	908001b0 	cmpltui	r2,r18,6
   262fc:	10009126 	beq	r2,zero,26544 <SDOS_SdoInfoInd+0x2dc>
			MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
   26300:	200b883a 	mov	r5,r4
   26304:	010000f4 	movhi	r4,3
   26308:	01800384 	movi	r6,14
   2630c:	21219204 	addi	r4,r4,-31160
   26310:	0026ed40 	call	26ed4 <memcpy>
			if (listType-- == 0)
   26314:	90003a1e 	bne	r18,zero,26400 <SDOS_SdoInfoInd+0x198>
				nSdoInfoFragmentsLeft = 0;
   26318:	d021558d 	sth	zero,-31402(gp)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   2631c:	84800384 	addi	r18,r16,14
				nSdoInfoFragmentsLeft = 0;
   26320:	0023883a 	mov	r17,zero
					UINT16 n = OBJ_GetNoOfObjects(i);
   26324:	8809883a 	mov	r4,r17
   26328:	002446c0 	call	2446c <OBJ_GetNoOfObjects>
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   2632c:	8c400044 	addi	r17,r17,1
					((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT >> 1) + i] = SWAPWORD(n);
   26330:	9080000d 	sth	r2,0(r18)
				for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
   26334:	88800158 	cmpnei	r2,r17,5
   26338:	94800084 	addi	r18,r18,2
   2633c:	103ff91e 	bne	r2,zero,26324 <SDOS_SdoInfoInd+0xbc>
				size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
   26340:	00800484 	movi	r2,18
			pSdoInfoInd->MbxHeader.Length = size;
   26344:	8080000d 	sth	r2,0(r16)
			if (abort == 0)
   26348:	d8800143 	ldbu	r2,5(sp)
   2634c:	10007d1e 	bne	r2,zero,26544 <SDOS_SdoInfoInd+0x2dc>
				pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26350:	8080020b 	ldhu	r2,8(r16)
   26354:	00ffe004 	movi	r3,-128
   26358:	10c6703a 	and	r3,r2,r3
				pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
   2635c:	18c00094 	ori	r3,r3,2
   26360:	80c0020d 	sth	r3,8(r16)
				pSdoInfoInd->SdoHeader.FragmentsLeft = SWAPWORD(nSdoInfoFragmentsLeft);
   26364:	d0e1558b 	ldhu	r3,-31402(gp)
   26368:	80c0028d 	sth	r3,10(r16)
				if (nSdoInfoFragmentsLeft)
   2636c:	18ffffcc 	andi	r3,r3,65535
   26370:	18007426 	beq	r3,zero,26544 <SDOS_SdoInfoInd+0x2dc>
					pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)(SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
   26374:	00ffc004 	movi	r3,-256
   26378:	10c4703a 	and	r2,r2,r3
   2637c:	10802094 	ori	r2,r2,130
   26380:	8080020d 	sth	r2,8(r16)
					flags = FRAGMENTS_FOLLOW | COE_SERVICE;
   26384:	017fe084 	movi	r5,-126
	}

	if (abort)
   26388:	d8c00143 	ldbu	r3,5(sp)
   2638c:	18000d26 	beq	r3,zero,263c4 <SDOS_SdoInfoInd+0x15c>
	{
		/* send a SDO Information Error response */
		pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
   26390:	00800284 	movi	r2,10
   26394:	8080000d 	sth	r2,0(r16)

		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26398:	8080020b 	ldhu	r2,8(r16)
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);

		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   2639c:	180690ba 	slli	r3,r3,2
		pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   263a0:	8000028d 	sth	zero,10(r16)
		pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   263a4:	10bfe00c 	andi	r2,r2,65408
		pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
   263a8:	108001d4 	ori	r2,r2,7
   263ac:	8080020d 	sth	r2,8(r16)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   263b0:	008000b4 	movhi	r2,2
   263b4:	1885883a 	add	r2,r3,r2
   263b8:	109ecf17 	ldw	r2,31548(r2)

		nSdoInfoFragmentsLeft = 0;
   263bc:	d021558d 	sth	zero,-31402(gp)
		pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
   263c0:	80800315 	stw	r2,12(r16)
	}

	if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
   263c4:	29403fcc 	andi	r5,r5,255
   263c8:	8009883a 	mov	r4,r16
   263cc:	0023d780 	call	23d78 <MBX_MailboxSendReq>
   263d0:	10803fcc 	andi	r2,r2,255
   263d4:	10000126 	beq	r2,zero,263dc <SDOS_SdoInfoInd+0x174>
	{
		/* if the mailbox response could not be sent (or stored), the response will be
		   stored in the variable pCoeSendStored and will be sent automatically
			from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
			the next time from the master */
		pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
   263d8:	d4212f15 	stw	r16,-31556(gp)
	}

	return 0;
   263dc:	0005883a 	mov	r2,zero
}
   263e0:	dfc00717 	ldw	ra,28(sp)
   263e4:	dd000617 	ldw	r20,24(sp)
   263e8:	dcc00517 	ldw	r19,20(sp)
   263ec:	dc800417 	ldw	r18,16(sp)
   263f0:	dc400317 	ldw	r17,12(sp)
   263f4:	dc000217 	ldw	r16,8(sp)
   263f8:	dec00804 	addi	sp,sp,32
   263fc:	f800283a 	ret
				if (nSdoInfoFragmentsLeft)
   26400:	d4a1558b 	ldhu	r18,-31402(gp)
			if (listType-- == 0)
   26404:	8c7fffc4 	addi	r17,r17,-1
					n = OBJ_GetNoOfObjects(listType);
   26408:	8c403fcc 	andi	r17,r17,255
				if (nSdoInfoFragmentsLeft)
   2640c:	90bfffcc 	andi	r2,r18,65535
   26410:	10001426 	beq	r2,zero,26464 <SDOS_SdoInfoInd+0x1fc>
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   26414:	d4e14a8b 	ldhu	r19,-31446(gp)
					index = nSdoInfoIndex;
   26418:	d0a1550b 	ldhu	r2,-31404(gp)
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO >> 1];
   2641c:	85000304 	addi	r20,r16,12
						size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
   26420:	9cfffd04 	addi	r19,r19,-12
					index = nSdoInfoIndex;
   26424:	d880018d 	sth	r2,6(sp)
					nSdoInfoFragmentsLeft--;
   26428:	94bfffc4 	addi	r18,r18,-1
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   2642c:	d8800144 	addi	r2,sp,5
   26430:	d8800015 	stw	r2,0(sp)
   26434:	a00f883a 	mov	r7,r20
   26438:	99bfffcc 	andi	r6,r19,65535
   2643c:	d9400184 	addi	r5,sp,6
   26440:	8809883a 	mov	r4,r17
					nSdoInfoFragmentsLeft--;
   26444:	d4a1558d 	sth	r18,-31402(gp)
				size = OBJ_GetObjectList(listType, &index, size, pData, &abort);
   26448:	00245240 	call	24524 <OBJ_GetObjectList>
				nSdoInfoIndex = index;
   2644c:	d8c0018b 	ldhu	r3,6(sp)
   26450:	d0e1550d 	sth	r3,-31404(gp)
					size = u16SendMbxSize - size - MBX_HEADER_SIZE;
   26454:	d0e14a8b 	ldhu	r3,-31446(gp)
   26458:	18fffe84 	addi	r3,r3,-6
   2645c:	1885c83a 	sub	r2,r3,r2
   26460:	003fb806 	br	26344 <SDOS_SdoInfoInd+0xdc>
					n = OBJ_GetNoOfObjects(listType);
   26464:	8809883a 	mov	r4,r17
   26468:	002446c0 	call	2446c <OBJ_GetNoOfObjects>
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   2646c:	d1614a8b 	ldhu	r5,-31446(gp)
					if ((n << 1) > size)
   26470:	113fffcc 	andi	r4,r2,65535
					index = 0x1000;
   26474:	00c40004 	movi	r3,4096
					if ((n << 1) > size)
   26478:	2008907a 	slli	r4,r4,1
					index = 0x1000;
   2647c:	d8c0018d 	sth	r3,6(sp)
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26480:	28fffc84 	addi	r3,r5,-14
					if ((n << 1) > size)
   26484:	18bfffcc 	andi	r2,r3,65535
						size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
   26488:	1827883a 	mov	r19,r3
					pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT >> 1];
   2648c:	85000384 	addi	r20,r16,14
					if ((n << 1) > size)
   26490:	113fe60e 	bge	r2,r4,2642c <SDOS_SdoInfoInd+0x1c4>
						UINT16 Fragsize = size + 2;
   26494:	297ffd04 	addi	r5,r5,-12
						nSdoInfoFragmentsLeft = (((n << 1) - size + (Fragsize - 1)) / Fragsize);
   26498:	297fffcc 	andi	r5,r5,65535
   2649c:	2089c83a 	sub	r4,r4,r2
   264a0:	28bfffc4 	addi	r2,r5,-1
   264a4:	2089883a 	add	r4,r4,r2
   264a8:	00269f00 	call	269f0 <__divsi3>
   264ac:	1025883a 	mov	r18,r2
   264b0:	003fde06 	br	2642c <SDOS_SdoInfoInd+0x1c4>
			pObjEntry = OBJ_GetObjectHandle(index);
   264b4:	00241300 	call	24130 <OBJ_GetObjectHandle>
   264b8:	1023883a 	mov	r17,r2
			if (pObjEntry)
   264bc:	10005c26 	beq	r2,zero,26630 <SDOS_SdoInfoInd+0x3c8>
				if (opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q)
   264c0:	9cc000d8 	cmpnei	r19,r19,3
   264c4:	9800211e 	bne	r19,zero,2654c <SDOS_SdoInfoInd+0x2e4>
					OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
   264c8:	1009883a 	mov	r4,r2
   264cc:	002466c0 	call	2466c <OBJ_GetObjDesc>
   264d0:	01800104 	movi	r6,4
   264d4:	100b883a 	mov	r5,r2
   264d8:	81000384 	addi	r4,r16,14
   264dc:	0026ed40 	call	26ed4 <memcpy>
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   264e0:	d900018b 	ldhu	r4,6(sp)
   264e4:	000f883a 	mov	r7,zero
   264e8:	880d883a 	mov	r6,r17
   264ec:	000b883a 	mov	r5,zero
   264f0:	00242f80 	call	242f8 <OBJ_GetDesc>
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   264f4:	d0e14a8b 	ldhu	r3,-31446(gp)
					size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
   264f8:	10800304 	addi	r2,r2,12
					if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   264fc:	10bfffcc 	andi	r2,r2,65535
   26500:	18fffec4 	addi	r3,r3,-5
   26504:	10c0460e 	bge	r2,r3,26620 <SDOS_SdoInfoInd+0x3b8>
						size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
   26508:	d900018b 	ldhu	r4,6(sp)
   2650c:	81c00484 	addi	r7,r16,18
   26510:	880d883a 	mov	r6,r17
   26514:	000b883a 	mov	r5,zero
   26518:	00242f80 	call	242f8 <OBJ_GetDesc>
   2651c:	10800304 	addi	r2,r2,12
				if (abort == 0)
   26520:	d8c00143 	ldbu	r3,5(sp)
   26524:	1800071e 	bne	r3,zero,26544 <SDOS_SdoInfoInd+0x2dc>
						pSdoInfoInd->MbxHeader.Length = size;
   26528:	8080000d 	sth	r2,0(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   2652c:	8080020b 	ldhu	r2,8(r16)
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   26530:	94800044 	addi	r18,r18,1
						pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
   26534:	8000028d 	sth	zero,10(r16)
						pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
   26538:	10bfe00c 	andi	r2,r2,65408
						pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
   2653c:	14a4b03a 	or	r18,r2,r18
   26540:	8480020d 	sth	r18,8(r16)
	UINT8 flags = COE_SERVICE;
   26544:	01400084 	movi	r5,2
   26548:	003f8f06 	br	26388 <SDOS_SdoInfoInd+0x120>
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   2654c:	1009883a 	mov	r4,r2
					UINT8 subindex = (UINT8)((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
   26550:	84c00383 	ldbu	r19,14(r16)
					UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
   26554:	002466c0 	call	2466c <OBJ_GetObjDesc>
					if (subindex <= maxSubindex)
   26558:	10800083 	ldbu	r2,2(r2)
   2655c:	9cc03fcc 	andi	r19,r19,255
   26560:	14c02b36 	bltu	r2,r19,26610 <SDOS_SdoInfoInd+0x3a8>
						OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
   26564:	980b883a 	mov	r5,r19
   26568:	8809883a 	mov	r4,r17
   2656c:	00244300 	call	24430 <OBJ_GetEntryDesc>
   26570:	01800184 	movi	r6,6
   26574:	100b883a 	mov	r5,r2
   26578:	81000404 	addi	r4,r16,16
   2657c:	0026ed40 	call	26ed4 <memcpy>
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26580:	80800383 	ldbu	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   26584:	8809883a 	mov	r4,r17
						pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
   26588:	8080038d 	sth	r2,14(r16)
						ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
   2658c:	002466c0 	call	2466c <OBJ_GetObjDesc>
						ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
   26590:	1080008b 	ldhu	r2,2(r2)
   26594:	1005d23a 	srai	r2,r2,8
   26598:	108003cc 	andi	r2,r2,15
						if (((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0))
   2659c:	10bffe04 	addi	r2,r2,-8
   265a0:	10bfffcc 	andi	r2,r2,65535
   265a4:	108000a8 	cmpgeui	r2,r2,2
   265a8:	1000081e 	bne	r2,zero,265cc <SDOS_SdoInfoInd+0x364>
   265ac:	9800071e 	bne	r19,zero,265cc <SDOS_SdoInfoInd+0x364>
							OBJTOMBXSTRCPY(((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc));
   265b0:	014000b4 	movhi	r5,2
   265b4:	01800344 	movi	r6,13
   265b8:	295fb504 	addi	r5,r5,32468
   265bc:	81000584 	addi	r4,r16,22
   265c0:	0026ed40 	call	26ed4 <memcpy>
							size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
   265c4:	00800704 	movi	r2,28
   265c8:	003fd506 	br	26520 <SDOS_SdoInfoInd+0x2b8>
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265cc:	d900018b 	ldhu	r4,6(sp)
   265d0:	000f883a 	mov	r7,zero
   265d4:	880d883a 	mov	r6,r17
   265d8:	980b883a 	mov	r5,r19
   265dc:	00242f80 	call	242f8 <OBJ_GetDesc>
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   265e0:	d0e14a8b 	ldhu	r3,-31446(gp)
							size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265e4:	10800404 	addi	r2,r2,16
							if (size > (u16SendMbxSize - MBX_HEADER_SIZE))
   265e8:	10bfffcc 	andi	r2,r2,65535
   265ec:	18fffec4 	addi	r3,r3,-5
   265f0:	10c00d0e 	bge	r2,r3,26628 <SDOS_SdoInfoInd+0x3c0>
								size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   265f4:	d900018b 	ldhu	r4,6(sp)
   265f8:	81c00584 	addi	r7,r16,22
   265fc:	880d883a 	mov	r6,r17
   26600:	980b883a 	mov	r5,r19
   26604:	00242f80 	call	242f8 <OBJ_GetDesc>
   26608:	10800404 	addi	r2,r2,16
   2660c:	003fc406 	br	26520 <SDOS_SdoInfoInd+0x2b8>
						abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
   26610:	00800444 	movi	r2,17
   26614:	d8800145 	stb	r2,5(sp)
				UINT16 size = 0;
   26618:	0005883a 	mov	r2,zero
   2661c:	003fc006 	br	26520 <SDOS_SdoInfoInd+0x2b8>
						size = SIZEOF_SDOINFOOBJSTRUCT;
   26620:	00800304 	movi	r2,12
   26624:	003fbe06 	br	26520 <SDOS_SdoInfoInd+0x2b8>
								size = SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
   26628:	00800404 	movi	r2,16
   2662c:	003fbc06 	br	26520 <SDOS_SdoInfoInd+0x2b8>
				abort = ABORTIDX_OBJECT_NOT_EXISTING;
   26630:	00800204 	movi	r2,8
   26634:	003f2c06 	br	262e8 <SDOS_SdoInfoInd+0x80>
		abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
   26638:	008000c4 	movi	r2,3
   2663c:	003f2a06 	br	262e8 <SDOS_SdoInfoInd+0x80>

00026640 <exti0_isr>:

volatile int edge_capture;

//ISR routine
void exti0_isr (void * context)
{
   26640:	deffff04 	addi	sp,sp,-4
   26644:	dfc00015 	stw	ra,0(sp)
	 //IOWR_32DIRECT(USER_HANDLER_0_BASE, 0x204, 1); //DC SYNC
	 PDI_Isr();
   26648:	00213580 	call	21358 <PDI_Isr>
	 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0);
   2664c:	00800134 	movhi	r2,4
   26650:	10040b35 	stwio	zero,4140(r2)
	 IORD_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE);
   26654:	10840b37 	ldwio	r2,4140(r2)
	 // for debugging
	 //printf("Called ISR!\n");
}
   26658:	dfc00017 	ldw	ra,0(sp)
   2665c:	dec00104 	addi	sp,sp,4
   26660:	f800283a 	ret

00026664 <init_exti0_it>:

void init_exti0_it (void)
{
   26664:	defffe04 	addi	sp,sp,-8
   26668:	dfc00115 	stw	ra,4(sp)
	 void* edge_capture_ptr = (void*) &edge_capture;
	 IOWR_ALTERA_AVALON_PIO_IRQ_MASK(ESC_SPI_SINT_BASE, 0x1);
   2666c:	00c00044 	movi	r3,1
   26670:	00800134 	movhi	r2,4
   26674:	10c40a35 	stwio	r3,4136(r2)
	 IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0x0);
   26678:	10040b35 	stwio	zero,4140(r2)
	 alt_ic_isr_register(ESC_SPI_SINT_IRQ_INTERRUPT_CONTROLLER_ID, ESC_SPI_SINT_IRQ, exti0_isr, edge_capture_ptr, 0x0);
   2667c:	018000b4 	movhi	r6,2
   26680:	d8000015 	stw	zero,0(sp)
   26684:	d1e15c04 	addi	r7,gp,-31376
   26688:	31999004 	addi	r6,r6,26176
   2668c:	01400084 	movi	r5,2
   26690:	0009883a 	mov	r4,zero
   26694:	00271780 	call	27178 <alt_ic_isr_register>
	 IORD_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE);
   26698:	00800134 	movhi	r2,4
   2669c:	10840b37 	ldwio	r2,4140(r2)
	 //IOWR_ALTERA_AVALON_PIO_EDGE_CAP(ESC_SPI_SINT_BASE, 0x0);
}
   266a0:	dfc00117 	ldw	ra,4(sp)
   266a4:	dec00204 	addi	sp,sp,8
   266a8:	f800283a 	ret

000266ac <delay_ms>:
#include "system.h"
#include "stdint.h"

// Delay function
// No Parameters
void delay_ms(int milliseconds) {
   266ac:	deffff04 	addi	sp,sp,-4
    usleep(milliseconds * 1000);  // Convert to microseconds
   266b0:	0140fa04 	movi	r5,1000
void delay_ms(int milliseconds) {
   266b4:	dfc00015 	stw	ra,0(sp)
    usleep(milliseconds * 1000);  // Convert to microseconds
   266b8:	0026ba40 	call	26ba4 <__mulsi3>
   266bc:	1009883a 	mov	r4,r2
}
   266c0:	dfc00017 	ldw	ra,0(sp)
   266c4:	dec00104 	addi	sp,sp,4
    usleep(milliseconds * 1000);  // Convert to microseconds
   266c8:	00273701 	jmpi	27370 <usleep>

000266cc <adc_init>:
// Parameter 2: Base address for SPI Chip Select Manual
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){

	int spi_check = -1;
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   266cc:	008100f4 	movhi	r2,1027
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   266d0:	defff404 	addi	sp,sp,-48
	alt_u8 opcode_null_receive[4] = {0x01, 0x01, 0x03, 0x04};
   266d4:	10804044 	addi	r2,r2,257
   266d8:	d8800415 	stw	r2,16(sp)
	alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   266dc:	00954184 	movi	r2,21766
   266e0:	d8800515 	stw	r2,20(sp)
	alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
   266e4:	008201f4 	movhi	r2,2055
   266e8:	10818144 	addi	r2,r2,1541
   266ec:	d8800615 	stw	r2,24(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   266f0:	00954144 	movi	r2,21765
void adc_init(alt_u32 base, alt_u32 spi_manual_cs){
   266f4:	dc400a15 	stw	r17,40(sp)
   266f8:	dc000915 	stw	r16,36(sp)
   266fc:	dfc00b15 	stw	ra,44(sp)
   26700:	2021883a 	mov	r16,r4
   26704:	2823883a 	mov	r17,r5
	alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26708:	d8000315 	stw	zero,12(sp)
	uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   2670c:	d8800715 	stw	r2,28(sp)
	uint8_t opcode_lock_receive[4] = {0x00, 0x00, 0x00, 0x00};
   26710:	d8000815 	stw	zero,32(sp)

	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26714:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26718:	0104e204 	movi	r4,5000
   2671c:	00273700 	call	27370 <usleep>
	delay_ms(5);
	IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   26720:	00800044 	movi	r2,1
   26724:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26728:	01138804 	movi	r4,20000
   2672c:	00273700 	call	27370 <usleep>
	delay_ms(20);

	spi_check = alt_avalon_spi_command(base,
   26730:	d9c00304 	addi	r7,sp,12
   26734:	01800104 	movi	r6,4
   26738:	000b883a 	mov	r5,zero
   2673c:	8009883a 	mov	r4,r16
   26740:	d8000215 	stw	zero,8(sp)
   26744:	d8000115 	stw	zero,4(sp)
   26748:	d8000015 	stw	zero,0(sp)
   2674c:	00274240 	call	27424 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26750:	0130d414 	movui	r4,50000
   26754:	00273700 	call	27370 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   26758:	04400104 	movi	r17,4
   2675c:	d8800404 	addi	r2,sp,16
   26760:	8009883a 	mov	r4,r16
   26764:	d8000215 	stw	zero,8(sp)
   26768:	d8800115 	stw	r2,4(sp)
   2676c:	dc400015 	stw	r17,0(sp)
   26770:	000f883a 	mov	r7,zero
   26774:	000d883a 	mov	r6,zero
   26778:	000b883a 	mov	r5,zero
   2677c:	00274240 	call	27424 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_null_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   26780:	d9c00504 	addi	r7,sp,20
   26784:	01800104 	movi	r6,4
   26788:	000b883a 	mov	r5,zero
   2678c:	8009883a 	mov	r4,r16
   26790:	d8000215 	stw	zero,8(sp)
   26794:	d8000115 	stw	zero,4(sp)
   26798:	d8000015 	stw	zero,0(sp)
   2679c:	00274240 	call	27424 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   267a0:	0130d414 	movui	r4,50000
   267a4:	00273700 	call	27370 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   267a8:	d8800604 	addi	r2,sp,24
   267ac:	8009883a 	mov	r4,r16
   267b0:	d8000215 	stw	zero,8(sp)
   267b4:	d8800115 	stw	r2,4(sp)
   267b8:	dc400015 	stw	r17,0(sp)
   267bc:	000f883a 	mov	r7,zero
   267c0:	000d883a 	mov	r6,zero
   267c4:	000b883a 	mov	r5,zero
   267c8:	00274240 	call	27424 <alt_avalon_spi_command>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 spi_check = alt_avalon_spi_command(base,
   267cc:	d9c00704 	addi	r7,sp,28
   267d0:	01800104 	movi	r6,4
   267d4:	000b883a 	mov	r5,zero
   267d8:	8009883a 	mov	r4,r16
   267dc:	d8000215 	stw	zero,8(sp)
   267e0:	d8000115 	stw	zero,4(sp)
   267e4:	d8000015 	stw	zero,0(sp)
   267e8:	00274240 	call	27424 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   267ec:	0130d414 	movui	r4,50000
   267f0:	00273700 	call	27370 <usleep>
										0,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);

	 delay_ms(50);
	 spi_check = alt_avalon_spi_command(base,
   267f4:	d8800804 	addi	r2,sp,32
   267f8:	000f883a 	mov	r7,zero
   267fc:	000d883a 	mov	r6,zero
   26800:	000b883a 	mov	r5,zero
   26804:	8009883a 	mov	r4,r16
   26808:	d8000215 	stw	zero,8(sp)
   2680c:	d8800115 	stw	r2,4(sp)
   26810:	dc400015 	stw	r17,0(sp)
   26814:	00274240 	call	27424 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26818:	0130d414 	movui	r4,50000
   2681c:	00273700 	call	27370 <usleep>
										4,							// The number of bytes to read from the SPI slave, '0' if only writing
										opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
										0							// Special control flags for the SPI command
										);
	 delay_ms(50);
}
   26820:	dfc00b17 	ldw	ra,44(sp)
   26824:	dc400a17 	ldw	r17,40(sp)
   26828:	dc000917 	ldw	r16,36(sp)
   2682c:	dec00c04 	addi	sp,sp,48
   26830:	f800283a 	ret

00026834 <spi_transmit_receive>:
    alt_u8 *rx_ptr = rx_buf;
    const alt_u8 *tx_end = tx_buf ? (tx_buf + length) : NULL;
    alt_u8 dummy_tx = 0xFF;

    // 1. Select slave
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26834:	00c00044 	movi	r3,1
{
   26838:	d8800017 	ldw	r2,0(sp)
   2683c:	da000117 	ldw	r8,4(sp)
    IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   26840:	1946983a 	sll	r3,r3,r5
   26844:	20c00535 	stwio	r3,20(r4)

    // 2. Assert CS unless toggle flag is set
    if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   26848:	40c0008c 	andi	r3,r8,2
   2684c:	1800021e 	bne	r3,zero,26858 <spi_transmit_receive+0x24>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   26850:	00c10004 	movi	r3,1024
   26854:	20c00335 	stwio	r3,12(r4)
    }

    // 3. Clear stale RX
    IORD_ALTERA_AVALON_SPI_RXDATA(base);
   26858:	20c00037 	ldwio	r3,0(r4)
    alt_32 credits = 1;
   2685c:	00c00044 	movi	r3,1
    alt_u8 *rx_ptr = rx_buf;
   26860:	3813883a 	mov	r9,r7

    while ((rx_ptr - rx_buf) < length)
   26864:	49cbc83a 	sub	r5,r9,r7
   26868:	22800204 	addi	r10,r4,8
   2686c:	28800736 	bltu	r5,r2,2688c <spi_transmit_receive+0x58>
        }
    }

    // Wait until TX FIFO is empty (transmit complete)
    do {
        status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   26870:	50c00037 	ldwio	r3,0(r10)
    } while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   26874:	18c0080c 	andi	r3,r3,32
   26878:	183ffd26 	beq	r3,zero,26870 <spi_transmit_receive+0x3c>

    // Release chip select unless merging
    if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0) {
   2687c:	4200004c 	andi	r8,r8,1
   26880:	4000011e 	bne	r8,zero,26888 <spi_transmit_receive+0x54>
        IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   26884:	20000335 	stwio	zero,12(r4)
    }

    return length;
}
   26888:	f800283a 	ret
            status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   2688c:	51400037 	ldwio	r5,0(r10)
        } while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   26890:	2ac0100c 	andi	r11,r5,64
   26894:	2940200c 	andi	r5,r5,128
   26898:	58000126 	beq	r11,zero,268a0 <spi_transmit_receive+0x6c>
   2689c:	1800031e 	bne	r3,zero,268ac <spi_transmit_receive+0x78>
   268a0:	283ffa26 	beq	r5,zero,2688c <spi_transmit_receive+0x58>
        if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) && credits > 0) {
   268a4:	58000726 	beq	r11,zero,268c4 <spi_transmit_receive+0x90>
   268a8:	18000626 	beq	r3,zero,268c4 <spi_transmit_receive+0x90>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   268ac:	30000b26 	beq	r6,zero,268dc <spi_transmit_receive+0xa8>
   268b0:	32800003 	ldbu	r10,0(r6)
   268b4:	31800044 	addi	r6,r6,1
            IOWR_ALTERA_AVALON_SPI_TXDATA(base, tx_data);
   268b8:	52803fcc 	andi	r10,r10,255
   268bc:	22800135 	stwio	r10,4(r4)
            credits--;
   268c0:	18ffffc4 	addi	r3,r3,-1
        if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK)) {
   268c4:	283fe726 	beq	r5,zero,26864 <spi_transmit_receive+0x30>
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   268c8:	21400037 	ldwio	r5,0(r4)
   268cc:	49400005 	stb	r5,0(r9)
            credits++;
   268d0:	18c00044 	addi	r3,r3,1
            *rx_ptr++ = (alt_u8)IORD_ALTERA_AVALON_SPI_RXDATA(base);
   268d4:	4a400044 	addi	r9,r9,1
   268d8:	003fe206 	br	26864 <spi_transmit_receive+0x30>
            alt_u8 tx_data = tx_ptr ? *tx_ptr++ : dummy_tx;
   268dc:	02bfffc4 	movi	r10,-1
   268e0:	003ff506 	br	268b8 <spi_transmit_receive+0x84>

000268e4 <adc_init_spi_transmit_receive>:

// ADC Initialization Using Full-Duplex SPI
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   268e4:	defff304 	addi	sp,sp,-52
	int spi_check = -1;
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
		alt_u8 opcode_null_receive[4] = {0x01, 0x02, 0x03, 0x04};
		alt_u8 opcode_ready[4] = {0x06, 0x55, 0x00, 0x00};
   268e8:	00954184 	movi	r2,21766
   268ec:	d8800515 	stw	r2,20(sp)
		alt_u8 opcode_ready_receive[4] = {0x05, 0x06, 0x07, 0x08};
		uint8_t opcode_lock[4] = {0x05, 0x55, 0x00, 0x00};
   268f0:	00954144 	movi	r2,21765
   268f4:	d8800715 	stw	r2,28(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   268f8:	00824274 	movhi	r2,2313
   268fc:	108201c4 	addi	r2,r2,2055
void adc_init_spi_transmit_receive(alt_u32 base, alt_u32 spi_manual_cs){
   26900:	dc400a15 	stw	r17,40(sp)
   26904:	dc000915 	stw	r16,36(sp)
   26908:	dfc00c15 	stw	ra,48(sp)
   2690c:	dc800b15 	stw	r18,44(sp)
   26910:	2021883a 	mov	r16,r4
   26914:	2823883a 	mov	r17,r5
		alt_u8 opcode_null[4] = {0x00,0x00,0x00,0x00};
   26918:	d8000315 	stw	zero,12(sp)
		uint8_t opcode_lock_receive[4] = {0x07, 0x08, 0x09, 0x09};
   2691c:	d8800815 	stw	r2,32(sp)

		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000000);
   26920:	28000035 	stwio	zero,0(r5)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26924:	0104e204 	movi	r4,5000
   26928:	00273700 	call	27370 <usleep>
		delay_ms(5);
		IOWR_ALTERA_AVALON_PIO_DATA(spi_manual_cs, 0b00000001);
   2692c:	00800044 	movi	r2,1
   26930:	88800035 	stwio	r2,0(r17)
    usleep(milliseconds * 1000);  // Convert to microseconds
   26934:	01138804 	movi	r4,20000
   26938:	00273700 	call	27370 <usleep>
		delay_ms(20);

		spi_check = spi_transmit_receive(	base,
   2693c:	04400104 	movi	r17,4
   26940:	d9c00404 	addi	r7,sp,16
   26944:	d9800304 	addi	r6,sp,12
   26948:	000b883a 	mov	r5,zero
   2694c:	8009883a 	mov	r4,r16
   26950:	d8000115 	stw	zero,4(sp)
   26954:	dc400015 	stw	r17,0(sp)
   26958:	00268340 	call	26834 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   2695c:	0100fa04 	movi	r4,1000
   26960:	00273700 	call	27370 <usleep>
											4,
											0							// Special control flags for the SPI command
											);

				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26964:	d9c00604 	addi	r7,sp,24
   26968:	d9800504 	addi	r6,sp,20
   2696c:	000b883a 	mov	r5,zero
   26970:	8009883a 	mov	r4,r16
   26974:	d8000115 	stw	zero,4(sp)
   26978:	dc400015 	stw	r17,0(sp)
   2697c:	00268340 	call	26834 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   26980:	0100fa04 	movi	r4,1000
   26984:	00273700 	call	27370 <usleep>
											opcode_ready_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = spi_transmit_receive(	base,
   26988:	dc800804 	addi	r18,sp,32
   2698c:	900f883a 	mov	r7,r18
   26990:	d9800704 	addi	r6,sp,28
   26994:	000b883a 	mov	r5,zero
   26998:	8009883a 	mov	r4,r16
   2699c:	d8000115 	stw	zero,4(sp)
   269a0:	dc400015 	stw	r17,0(sp)
   269a4:	00268340 	call	26834 <spi_transmit_receive>
    usleep(milliseconds * 1000);  // Convert to microseconds
   269a8:	0100fa04 	movi	r4,1000
   269ac:	00273700 	call	27370 <usleep>
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											4,
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
		spi_check = alt_avalon_spi_command(base,
   269b0:	000f883a 	mov	r7,zero
   269b4:	000d883a 	mov	r6,zero
   269b8:	000b883a 	mov	r5,zero
   269bc:	8009883a 	mov	r4,r16
   269c0:	d8000215 	stw	zero,8(sp)
   269c4:	dc800115 	stw	r18,4(sp)
   269c8:	dc400015 	stw	r17,0(sp)
   269cc:	00274240 	call	27424 <alt_avalon_spi_command>
    usleep(milliseconds * 1000);  // Convert to microseconds
   269d0:	0100fa04 	movi	r4,1000
   269d4:	00273700 	call	27370 <usleep>
											4,							// The number of bytes to read from the SPI slave, '0' if only writing
											opcode_lock_receive,		// A pointer to the buffer where the received (read) data will be stored, 'NULL' if N/A
											0							// Special control flags for the SPI command
											);
				delay_ms(1);
}
   269d8:	dfc00c17 	ldw	ra,48(sp)
   269dc:	dc800b17 	ldw	r18,44(sp)
   269e0:	dc400a17 	ldw	r17,40(sp)
   269e4:	dc000917 	ldw	r16,36(sp)
   269e8:	dec00d04 	addi	sp,sp,52
   269ec:	f800283a 	ret

000269f0 <__divsi3>:
   269f0:	20001a16 	blt	r4,zero,26a5c <__divsi3+0x6c>
   269f4:	000f883a 	mov	r7,zero
   269f8:	2800020e 	bge	r5,zero,26a04 <__divsi3+0x14>
   269fc:	014bc83a 	sub	r5,zero,r5
   26a00:	39c0005c 	xori	r7,r7,1
   26a04:	200d883a 	mov	r6,r4
   26a08:	00c00044 	movi	r3,1
   26a0c:	2900092e 	bgeu	r5,r4,26a34 <__divsi3+0x44>
   26a10:	00800804 	movi	r2,32
   26a14:	00c00044 	movi	r3,1
   26a18:	00000106 	br	26a20 <__divsi3+0x30>
   26a1c:	10001226 	beq	r2,zero,26a68 <__divsi3+0x78>
   26a20:	294b883a 	add	r5,r5,r5
   26a24:	10bfffc4 	addi	r2,r2,-1
   26a28:	18c7883a 	add	r3,r3,r3
   26a2c:	293ffb36 	bltu	r5,r4,26a1c <__divsi3+0x2c>
   26a30:	18000d26 	beq	r3,zero,26a68 <__divsi3+0x78>
   26a34:	0005883a 	mov	r2,zero
   26a38:	31400236 	bltu	r6,r5,26a44 <__divsi3+0x54>
   26a3c:	314dc83a 	sub	r6,r6,r5
   26a40:	10c4b03a 	or	r2,r2,r3
   26a44:	1806d07a 	srli	r3,r3,1
   26a48:	280ad07a 	srli	r5,r5,1
   26a4c:	183ffa1e 	bne	r3,zero,26a38 <__divsi3+0x48>
   26a50:	38000126 	beq	r7,zero,26a58 <__divsi3+0x68>
   26a54:	0085c83a 	sub	r2,zero,r2
   26a58:	f800283a 	ret
   26a5c:	0109c83a 	sub	r4,zero,r4
   26a60:	01c00044 	movi	r7,1
   26a64:	003fe406 	br	269f8 <__divsi3+0x8>
   26a68:	0005883a 	mov	r2,zero
   26a6c:	003ff806 	br	26a50 <__divsi3+0x60>

00026a70 <__modsi3>:
   26a70:	20001716 	blt	r4,zero,26ad0 <__modsi3+0x60>
   26a74:	000f883a 	mov	r7,zero
   26a78:	2005883a 	mov	r2,r4
   26a7c:	2800010e 	bge	r5,zero,26a84 <__modsi3+0x14>
   26a80:	014bc83a 	sub	r5,zero,r5
   26a84:	00c00044 	movi	r3,1
   26a88:	2900092e 	bgeu	r5,r4,26ab0 <__modsi3+0x40>
   26a8c:	01800804 	movi	r6,32
   26a90:	00c00044 	movi	r3,1
   26a94:	00000106 	br	26a9c <__modsi3+0x2c>
   26a98:	30001026 	beq	r6,zero,26adc <__modsi3+0x6c>
   26a9c:	294b883a 	add	r5,r5,r5
   26aa0:	31bfffc4 	addi	r6,r6,-1
   26aa4:	18c7883a 	add	r3,r3,r3
   26aa8:	293ffb36 	bltu	r5,r4,26a98 <__modsi3+0x28>
   26aac:	18000b26 	beq	r3,zero,26adc <__modsi3+0x6c>
   26ab0:	1806d07a 	srli	r3,r3,1
   26ab4:	11400136 	bltu	r2,r5,26abc <__modsi3+0x4c>
   26ab8:	1145c83a 	sub	r2,r2,r5
   26abc:	280ad07a 	srli	r5,r5,1
   26ac0:	183ffb1e 	bne	r3,zero,26ab0 <__modsi3+0x40>
   26ac4:	38000126 	beq	r7,zero,26acc <__modsi3+0x5c>
   26ac8:	0085c83a 	sub	r2,zero,r2
   26acc:	f800283a 	ret
   26ad0:	0109c83a 	sub	r4,zero,r4
   26ad4:	01c00044 	movi	r7,1
   26ad8:	003fe706 	br	26a78 <__modsi3+0x8>
   26adc:	2005883a 	mov	r2,r4
   26ae0:	003ff806 	br	26ac4 <__modsi3+0x54>

00026ae4 <__udivsi3>:
   26ae4:	200d883a 	mov	r6,r4
   26ae8:	2900152e 	bgeu	r5,r4,26b40 <__udivsi3+0x5c>
   26aec:	28001416 	blt	r5,zero,26b40 <__udivsi3+0x5c>
   26af0:	00800804 	movi	r2,32
   26af4:	00c00044 	movi	r3,1
   26af8:	00000206 	br	26b04 <__udivsi3+0x20>
   26afc:	10000e26 	beq	r2,zero,26b38 <__udivsi3+0x54>
   26b00:	28000416 	blt	r5,zero,26b14 <__udivsi3+0x30>
   26b04:	294b883a 	add	r5,r5,r5
   26b08:	10bfffc4 	addi	r2,r2,-1
   26b0c:	18c7883a 	add	r3,r3,r3
   26b10:	293ffa36 	bltu	r5,r4,26afc <__udivsi3+0x18>
   26b14:	18000826 	beq	r3,zero,26b38 <__udivsi3+0x54>
   26b18:	0005883a 	mov	r2,zero
   26b1c:	31400236 	bltu	r6,r5,26b28 <__udivsi3+0x44>
   26b20:	314dc83a 	sub	r6,r6,r5
   26b24:	10c4b03a 	or	r2,r2,r3
   26b28:	1806d07a 	srli	r3,r3,1
   26b2c:	280ad07a 	srli	r5,r5,1
   26b30:	183ffa1e 	bne	r3,zero,26b1c <__udivsi3+0x38>
   26b34:	f800283a 	ret
   26b38:	0005883a 	mov	r2,zero
   26b3c:	f800283a 	ret
   26b40:	00c00044 	movi	r3,1
   26b44:	003ff406 	br	26b18 <__udivsi3+0x34>

00026b48 <__umodsi3>:
   26b48:	2005883a 	mov	r2,r4
   26b4c:	2900132e 	bgeu	r5,r4,26b9c <__umodsi3+0x54>
   26b50:	28001216 	blt	r5,zero,26b9c <__umodsi3+0x54>
   26b54:	01800804 	movi	r6,32
   26b58:	00c00044 	movi	r3,1
   26b5c:	00000206 	br	26b68 <__umodsi3+0x20>
   26b60:	30000c26 	beq	r6,zero,26b94 <__umodsi3+0x4c>
   26b64:	28000416 	blt	r5,zero,26b78 <__umodsi3+0x30>
   26b68:	294b883a 	add	r5,r5,r5
   26b6c:	31bfffc4 	addi	r6,r6,-1
   26b70:	18c7883a 	add	r3,r3,r3
   26b74:	293ffa36 	bltu	r5,r4,26b60 <__umodsi3+0x18>
   26b78:	18000626 	beq	r3,zero,26b94 <__umodsi3+0x4c>
   26b7c:	1806d07a 	srli	r3,r3,1
   26b80:	11400136 	bltu	r2,r5,26b88 <__umodsi3+0x40>
   26b84:	1145c83a 	sub	r2,r2,r5
   26b88:	280ad07a 	srli	r5,r5,1
   26b8c:	183ffb1e 	bne	r3,zero,26b7c <__umodsi3+0x34>
   26b90:	f800283a 	ret
   26b94:	2005883a 	mov	r2,r4
   26b98:	f800283a 	ret
   26b9c:	00c00044 	movi	r3,1
   26ba0:	003ff606 	br	26b7c <__umodsi3+0x34>

00026ba4 <__mulsi3>:
   26ba4:	0005883a 	mov	r2,zero
   26ba8:	20000726 	beq	r4,zero,26bc8 <__mulsi3+0x24>
   26bac:	20c0004c 	andi	r3,r4,1
   26bb0:	2008d07a 	srli	r4,r4,1
   26bb4:	18000126 	beq	r3,zero,26bbc <__mulsi3+0x18>
   26bb8:	1145883a 	add	r2,r2,r5
   26bbc:	294b883a 	add	r5,r5,r5
   26bc0:	203ffa1e 	bne	r4,zero,26bac <__mulsi3+0x8>
   26bc4:	f800283a 	ret
   26bc8:	f800283a 	ret

00026bcc <malloc>:
   26bcc:	008000b4 	movhi	r2,2
   26bd0:	200b883a 	mov	r5,r4
   26bd4:	111fe917 	ldw	r4,32676(r2)
   26bd8:	0026c781 	jmpi	26c78 <_malloc_r>

00026bdc <free>:
   26bdc:	008000b4 	movhi	r2,2
   26be0:	200b883a 	mov	r5,r4
   26be4:	111fe917 	ldw	r4,32676(r2)
   26be8:	0026f801 	jmpi	26f80 <_free_r>

00026bec <sbrk_aligned>:
   26bec:	008000f4 	movhi	r2,3
   26bf0:	10a12e17 	ldw	r2,-31560(r2)
   26bf4:	defffd04 	addi	sp,sp,-12
   26bf8:	dc400115 	stw	r17,4(sp)
   26bfc:	dc000015 	stw	r16,0(sp)
   26c00:	dfc00215 	stw	ra,8(sp)
   26c04:	2023883a 	mov	r17,r4
   26c08:	2821883a 	mov	r16,r5
   26c0c:	1000041e 	bne	r2,zero,26c20 <sbrk_aligned+0x34>
   26c10:	000b883a 	mov	r5,zero
   26c14:	0026f380 	call	26f38 <_sbrk_r>
   26c18:	00c000f4 	movhi	r3,3
   26c1c:	18a12e15 	stw	r2,-31560(r3)
   26c20:	800b883a 	mov	r5,r16
   26c24:	8809883a 	mov	r4,r17
   26c28:	0026f380 	call	26f38 <_sbrk_r>
   26c2c:	10ffffd8 	cmpnei	r3,r2,-1
   26c30:	1800071e 	bne	r3,zero,26c50 <sbrk_aligned+0x64>
   26c34:	043fffc4 	movi	r16,-1
   26c38:	8005883a 	mov	r2,r16
   26c3c:	dfc00217 	ldw	ra,8(sp)
   26c40:	dc400117 	ldw	r17,4(sp)
   26c44:	dc000017 	ldw	r16,0(sp)
   26c48:	dec00304 	addi	sp,sp,12
   26c4c:	f800283a 	ret
   26c50:	140000c4 	addi	r16,r2,3
   26c54:	00ffff04 	movi	r3,-4
   26c58:	80e0703a 	and	r16,r16,r3
   26c5c:	143ff626 	beq	r2,r16,26c38 <sbrk_aligned+0x4c>
   26c60:	808bc83a 	sub	r5,r16,r2
   26c64:	8809883a 	mov	r4,r17
   26c68:	0026f380 	call	26f38 <_sbrk_r>
   26c6c:	10bfffe0 	cmpeqi	r2,r2,-1
   26c70:	103ff126 	beq	r2,zero,26c38 <sbrk_aligned+0x4c>
   26c74:	003fef06 	br	26c34 <sbrk_aligned+0x48>

00026c78 <_malloc_r>:
   26c78:	defffb04 	addi	sp,sp,-20
   26c7c:	00bfff04 	movi	r2,-4
   26c80:	dc400115 	stw	r17,4(sp)
   26c84:	2c4000c4 	addi	r17,r5,3
   26c88:	88a2703a 	and	r17,r17,r2
   26c8c:	8c400204 	addi	r17,r17,8
   26c90:	dc800215 	stw	r18,8(sp)
   26c94:	dfc00415 	stw	ra,16(sp)
   26c98:	dcc00315 	stw	r19,12(sp)
   26c9c:	dc000015 	stw	r16,0(sp)
   26ca0:	88800328 	cmpgeui	r2,r17,12
   26ca4:	2025883a 	mov	r18,r4
   26ca8:	10002a1e 	bne	r2,zero,26d54 <_malloc_r+0xdc>
   26cac:	04400304 	movi	r17,12
   26cb0:	89402936 	bltu	r17,r5,26d58 <_malloc_r+0xe0>
   26cb4:	9009883a 	mov	r4,r18
   26cb8:	002731c0 	call	2731c <__malloc_lock>
   26cbc:	008000f4 	movhi	r2,3
   26cc0:	10a12f17 	ldw	r2,-31556(r2)
   26cc4:	1021883a 	mov	r16,r2
   26cc8:	80002d1e 	bne	r16,zero,26d80 <_malloc_r+0x108>
   26ccc:	880b883a 	mov	r5,r17
   26cd0:	9009883a 	mov	r4,r18
   26cd4:	0026bec0 	call	26bec <sbrk_aligned>
   26cd8:	1021883a 	mov	r16,r2
   26cdc:	10bfffd8 	cmpnei	r2,r2,-1
   26ce0:	1000561e 	bne	r2,zero,26e3c <_malloc_r+0x1c4>
   26ce4:	008000f4 	movhi	r2,3
   26ce8:	14212f17 	ldw	r16,-31556(r2)
   26cec:	8005883a 	mov	r2,r16
   26cf0:	1000481e 	bne	r2,zero,26e14 <_malloc_r+0x19c>
   26cf4:	80004c26 	beq	r16,zero,26e28 <_malloc_r+0x1b0>
   26cf8:	84c00017 	ldw	r19,0(r16)
   26cfc:	000b883a 	mov	r5,zero
   26d00:	9009883a 	mov	r4,r18
   26d04:	84e7883a 	add	r19,r16,r19
   26d08:	0026f380 	call	26f38 <_sbrk_r>
   26d0c:	9880461e 	bne	r19,r2,26e28 <_malloc_r+0x1b0>
   26d10:	80800017 	ldw	r2,0(r16)
   26d14:	9009883a 	mov	r4,r18
   26d18:	88a3c83a 	sub	r17,r17,r2
   26d1c:	880b883a 	mov	r5,r17
   26d20:	0026bec0 	call	26bec <sbrk_aligned>
   26d24:	10bfffe0 	cmpeqi	r2,r2,-1
   26d28:	10003f1e 	bne	r2,zero,26e28 <_malloc_r+0x1b0>
   26d2c:	80800017 	ldw	r2,0(r16)
   26d30:	1445883a 	add	r2,r2,r17
   26d34:	80800015 	stw	r2,0(r16)
   26d38:	008000f4 	movhi	r2,3
   26d3c:	10a12f17 	ldw	r2,-31556(r2)
   26d40:	10000226 	beq	r2,zero,26d4c <_malloc_r+0xd4>
   26d44:	10c00117 	ldw	r3,4(r2)
   26d48:	1c00351e 	bne	r3,r16,26e20 <_malloc_r+0x1a8>
   26d4c:	10000115 	stw	zero,4(r2)
   26d50:	00001806 	br	26db4 <_malloc_r+0x13c>
   26d54:	883fd60e 	bge	r17,zero,26cb0 <_malloc_r+0x38>
   26d58:	00800304 	movi	r2,12
   26d5c:	90800015 	stw	r2,0(r18)
   26d60:	0005883a 	mov	r2,zero
   26d64:	dfc00417 	ldw	ra,16(sp)
   26d68:	dcc00317 	ldw	r19,12(sp)
   26d6c:	dc800217 	ldw	r18,8(sp)
   26d70:	dc400117 	ldw	r17,4(sp)
   26d74:	dc000017 	ldw	r16,0(sp)
   26d78:	dec00504 	addi	sp,sp,20
   26d7c:	f800283a 	ret
   26d80:	81000017 	ldw	r4,0(r16)
   26d84:	2449c83a 	sub	r4,r4,r17
   26d88:	20001f16 	blt	r4,zero,26e08 <_malloc_r+0x190>
   26d8c:	20c00330 	cmpltui	r3,r4,12
   26d90:	1800161e 	bne	r3,zero,26dec <_malloc_r+0x174>
   26d94:	84400015 	stw	r17,0(r16)
   26d98:	8447883a 	add	r3,r16,r17
   26d9c:	1400111e 	bne	r2,r16,26de4 <_malloc_r+0x16c>
   26da0:	008000f4 	movhi	r2,3
   26da4:	10e12f15 	stw	r3,-31556(r2)
   26da8:	80800117 	ldw	r2,4(r16)
   26dac:	19000015 	stw	r4,0(r3)
   26db0:	18800115 	stw	r2,4(r3)
   26db4:	9009883a 	mov	r4,r18
   26db8:	00273200 	call	27320 <__malloc_unlock>
   26dbc:	013ffe04 	movi	r4,-8
   26dc0:	808002c4 	addi	r2,r16,11
   26dc4:	80c00104 	addi	r3,r16,4
   26dc8:	1104703a 	and	r2,r2,r4
   26dcc:	10c9c83a 	sub	r4,r2,r3
   26dd0:	10ffe426 	beq	r2,r3,26d64 <_malloc_r+0xec>
   26dd4:	8121883a 	add	r16,r16,r4
   26dd8:	1887c83a 	sub	r3,r3,r2
   26ddc:	80c00015 	stw	r3,0(r16)
   26de0:	003fe006 	br	26d64 <_malloc_r+0xec>
   26de4:	10c00115 	stw	r3,4(r2)
   26de8:	003fef06 	br	26da8 <_malloc_r+0x130>
   26dec:	80c00117 	ldw	r3,4(r16)
   26df0:	1400031e 	bne	r2,r16,26e00 <_malloc_r+0x188>
   26df4:	008000f4 	movhi	r2,3
   26df8:	10e12f15 	stw	r3,-31556(r2)
   26dfc:	003fed06 	br	26db4 <_malloc_r+0x13c>
   26e00:	10c00115 	stw	r3,4(r2)
   26e04:	003feb06 	br	26db4 <_malloc_r+0x13c>
   26e08:	8005883a 	mov	r2,r16
   26e0c:	84000117 	ldw	r16,4(r16)
   26e10:	003fad06 	br	26cc8 <_malloc_r+0x50>
   26e14:	1021883a 	mov	r16,r2
   26e18:	10800117 	ldw	r2,4(r2)
   26e1c:	003fb406 	br	26cf0 <_malloc_r+0x78>
   26e20:	1805883a 	mov	r2,r3
   26e24:	003fc606 	br	26d40 <_malloc_r+0xc8>
   26e28:	00800304 	movi	r2,12
   26e2c:	90800015 	stw	r2,0(r18)
   26e30:	9009883a 	mov	r4,r18
   26e34:	00273200 	call	27320 <__malloc_unlock>
   26e38:	003fc906 	br	26d60 <_malloc_r+0xe8>
   26e3c:	84400015 	stw	r17,0(r16)
   26e40:	003fdc06 	br	26db4 <_malloc_r+0x13c>

00026e44 <_puts_r>:
   26e44:	defffd04 	addi	sp,sp,-12
   26e48:	dc000015 	stw	r16,0(sp)
   26e4c:	2021883a 	mov	r16,r4
   26e50:	2809883a 	mov	r4,r5
   26e54:	dfc00215 	stw	ra,8(sp)
   26e58:	dc400115 	stw	r17,4(sp)
   26e5c:	2823883a 	mov	r17,r5
   26e60:	0026f1c0 	call	26f1c <strlen>
   26e64:	81400217 	ldw	r5,8(r16)
   26e68:	00c000b4 	movhi	r3,2
   26e6c:	18dc2004 	addi	r3,r3,28800
   26e70:	28c00115 	stw	r3,4(r5)
   26e74:	100f883a 	mov	r7,r2
   26e78:	880d883a 	mov	r6,r17
   26e7c:	8009883a 	mov	r4,r16
   26e80:	00270800 	call	27080 <__sfvwrite_small_dev>
   26e84:	10ffffe0 	cmpeqi	r3,r2,-1
   26e88:	1800091e 	bne	r3,zero,26eb0 <_puts_r+0x6c>
   26e8c:	81400217 	ldw	r5,8(r16)
   26e90:	018000b4 	movhi	r6,2
   26e94:	01c00044 	movi	r7,1
   26e98:	28800117 	ldw	r2,4(r5)
   26e9c:	319eed04 	addi	r6,r6,31668
   26ea0:	8009883a 	mov	r4,r16
   26ea4:	103ee83a 	callr	r2
   26ea8:	10bfffe0 	cmpeqi	r2,r2,-1
   26eac:	0085c83a 	sub	r2,zero,r2
   26eb0:	dfc00217 	ldw	ra,8(sp)
   26eb4:	dc400117 	ldw	r17,4(sp)
   26eb8:	dc000017 	ldw	r16,0(sp)
   26ebc:	dec00304 	addi	sp,sp,12
   26ec0:	f800283a 	ret

00026ec4 <puts>:
   26ec4:	008000b4 	movhi	r2,2
   26ec8:	200b883a 	mov	r5,r4
   26ecc:	111fe917 	ldw	r4,32676(r2)
   26ed0:	0026e441 	jmpi	26e44 <_puts_r>

00026ed4 <memcpy>:
   26ed4:	2005883a 	mov	r2,r4
   26ed8:	0007883a 	mov	r3,zero
   26edc:	30c0011e 	bne	r6,r3,26ee4 <memcpy+0x10>
   26ee0:	f800283a 	ret
   26ee4:	28cf883a 	add	r7,r5,r3
   26ee8:	39c00003 	ldbu	r7,0(r7)
   26eec:	10c9883a 	add	r4,r2,r3
   26ef0:	18c00044 	addi	r3,r3,1
   26ef4:	21c00005 	stb	r7,0(r4)
   26ef8:	003ff806 	br	26edc <memcpy+0x8>

00026efc <memset>:
   26efc:	2005883a 	mov	r2,r4
   26f00:	218d883a 	add	r6,r4,r6
   26f04:	2007883a 	mov	r3,r4
   26f08:	1980011e 	bne	r3,r6,26f10 <memset+0x14>
   26f0c:	f800283a 	ret
   26f10:	18c00044 	addi	r3,r3,1
   26f14:	197fffc5 	stb	r5,-1(r3)
   26f18:	003ffb06 	br	26f08 <memset+0xc>

00026f1c <strlen>:
   26f1c:	2005883a 	mov	r2,r4
   26f20:	10c00007 	ldb	r3,0(r2)
   26f24:	1800021e 	bne	r3,zero,26f30 <strlen+0x14>
   26f28:	1105c83a 	sub	r2,r2,r4
   26f2c:	f800283a 	ret
   26f30:	10800044 	addi	r2,r2,1
   26f34:	003ffa06 	br	26f20 <strlen+0x4>

00026f38 <_sbrk_r>:
   26f38:	defffe04 	addi	sp,sp,-8
   26f3c:	dc000015 	stw	r16,0(sp)
   26f40:	008000f4 	movhi	r2,3
   26f44:	2021883a 	mov	r16,r4
   26f48:	2809883a 	mov	r4,r5
   26f4c:	dfc00115 	stw	ra,4(sp)
   26f50:	10213015 	stw	zero,-31552(r2)
   26f54:	00273240 	call	27324 <sbrk>
   26f58:	10ffffd8 	cmpnei	r3,r2,-1
   26f5c:	1800041e 	bne	r3,zero,26f70 <_sbrk_r+0x38>
   26f60:	00c000f4 	movhi	r3,3
   26f64:	18e13017 	ldw	r3,-31552(r3)
   26f68:	18000126 	beq	r3,zero,26f70 <_sbrk_r+0x38>
   26f6c:	80c00015 	stw	r3,0(r16)
   26f70:	dfc00117 	ldw	ra,4(sp)
   26f74:	dc000017 	ldw	r16,0(sp)
   26f78:	dec00204 	addi	sp,sp,8
   26f7c:	f800283a 	ret

00026f80 <_free_r>:
   26f80:	28003e26 	beq	r5,zero,2707c <_free_r+0xfc>
   26f84:	28bfff17 	ldw	r2,-4(r5)
   26f88:	defffd04 	addi	sp,sp,-12
   26f8c:	dc000115 	stw	r16,4(sp)
   26f90:	dfc00215 	stw	ra,8(sp)
   26f94:	2c3fff04 	addi	r16,r5,-4
   26f98:	1000010e 	bge	r2,zero,26fa0 <_free_r+0x20>
   26f9c:	80a1883a 	add	r16,r16,r2
   26fa0:	d9000015 	stw	r4,0(sp)
   26fa4:	002731c0 	call	2731c <__malloc_lock>
   26fa8:	008000f4 	movhi	r2,3
   26fac:	10a12f17 	ldw	r2,-31556(r2)
   26fb0:	d9000017 	ldw	r4,0(sp)
   26fb4:	1000071e 	bne	r2,zero,26fd4 <_free_r+0x54>
   26fb8:	80000115 	stw	zero,4(r16)
   26fbc:	008000f4 	movhi	r2,3
   26fc0:	14212f15 	stw	r16,-31556(r2)
   26fc4:	dfc00217 	ldw	ra,8(sp)
   26fc8:	dc000117 	ldw	r16,4(sp)
   26fcc:	dec00304 	addi	sp,sp,12
   26fd0:	00273201 	jmpi	27320 <__malloc_unlock>
   26fd4:	8080092e 	bgeu	r16,r2,26ffc <_free_r+0x7c>
   26fd8:	81400017 	ldw	r5,0(r16)
   26fdc:	8147883a 	add	r3,r16,r5
   26fe0:	10c0041e 	bne	r2,r3,26ff4 <_free_r+0x74>
   26fe4:	10c00017 	ldw	r3,0(r2)
   26fe8:	10800117 	ldw	r2,4(r2)
   26fec:	1947883a 	add	r3,r3,r5
   26ff0:	80c00015 	stw	r3,0(r16)
   26ff4:	80800115 	stw	r2,4(r16)
   26ff8:	003ff006 	br	26fbc <_free_r+0x3c>
   26ffc:	1007883a 	mov	r3,r2
   27000:	10800117 	ldw	r2,4(r2)
   27004:	10000126 	beq	r2,zero,2700c <_free_r+0x8c>
   27008:	80bffc2e 	bgeu	r16,r2,26ffc <_free_r+0x7c>
   2700c:	19400017 	ldw	r5,0(r3)
   27010:	194d883a 	add	r6,r3,r5
   27014:	34000b1e 	bne	r6,r16,27044 <_free_r+0xc4>
   27018:	81800017 	ldw	r6,0(r16)
   2701c:	298b883a 	add	r5,r5,r6
   27020:	19400015 	stw	r5,0(r3)
   27024:	194d883a 	add	r6,r3,r5
   27028:	11bfe61e 	bne	r2,r6,26fc4 <_free_r+0x44>
   2702c:	11800017 	ldw	r6,0(r2)
   27030:	10800117 	ldw	r2,4(r2)
   27034:	314b883a 	add	r5,r6,r5
   27038:	19400015 	stw	r5,0(r3)
   2703c:	18800115 	stw	r2,4(r3)
   27040:	003fe006 	br	26fc4 <_free_r+0x44>
   27044:	8180032e 	bgeu	r16,r6,27054 <_free_r+0xd4>
   27048:	00800304 	movi	r2,12
   2704c:	20800015 	stw	r2,0(r4)
   27050:	003fdc06 	br	26fc4 <_free_r+0x44>
   27054:	81800017 	ldw	r6,0(r16)
   27058:	818b883a 	add	r5,r16,r6
   2705c:	1140041e 	bne	r2,r5,27070 <_free_r+0xf0>
   27060:	11400017 	ldw	r5,0(r2)
   27064:	10800117 	ldw	r2,4(r2)
   27068:	298b883a 	add	r5,r5,r6
   2706c:	81400015 	stw	r5,0(r16)
   27070:	80800115 	stw	r2,4(r16)
   27074:	1c000115 	stw	r16,4(r3)
   27078:	003fd206 	br	26fc4 <_free_r+0x44>
   2707c:	f800283a 	ret

00027080 <__sfvwrite_small_dev>:
   27080:	2880000b 	ldhu	r2,0(r5)
   27084:	1080020c 	andi	r2,r2,8
   27088:	10002526 	beq	r2,zero,27120 <__sfvwrite_small_dev+0xa0>
   2708c:	2880008f 	ldh	r2,2(r5)
   27090:	defffb04 	addi	sp,sp,-20
   27094:	dcc00315 	stw	r19,12(sp)
   27098:	dc800215 	stw	r18,8(sp)
   2709c:	dc400115 	stw	r17,4(sp)
   270a0:	dc000015 	stw	r16,0(sp)
   270a4:	dfc00415 	stw	ra,16(sp)
   270a8:	2027883a 	mov	r19,r4
   270ac:	2821883a 	mov	r16,r5
   270b0:	3025883a 	mov	r18,r6
   270b4:	3823883a 	mov	r17,r7
   270b8:	1000100e 	bge	r2,zero,270fc <__sfvwrite_small_dev+0x7c>
   270bc:	8080000b 	ldhu	r2,0(r16)
   270c0:	10801014 	ori	r2,r2,64
   270c4:	8080000d 	sth	r2,0(r16)
   270c8:	00bfffc4 	movi	r2,-1
   270cc:	00000d06 	br	27104 <__sfvwrite_small_dev+0x84>
   270d0:	88810050 	cmplti	r2,r17,1025
   270d4:	880f883a 	mov	r7,r17
   270d8:	1000011e 	bne	r2,zero,270e0 <__sfvwrite_small_dev+0x60>
   270dc:	01c10004 	movi	r7,1024
   270e0:	8140008f 	ldh	r5,2(r16)
   270e4:	900d883a 	mov	r6,r18
   270e8:	9809883a 	mov	r4,r19
   270ec:	00271280 	call	27128 <_write_r>
   270f0:	00bff20e 	bge	zero,r2,270bc <__sfvwrite_small_dev+0x3c>
   270f4:	88a3c83a 	sub	r17,r17,r2
   270f8:	90a5883a 	add	r18,r18,r2
   270fc:	047ff416 	blt	zero,r17,270d0 <__sfvwrite_small_dev+0x50>
   27100:	0005883a 	mov	r2,zero
   27104:	dfc00417 	ldw	ra,16(sp)
   27108:	dcc00317 	ldw	r19,12(sp)
   2710c:	dc800217 	ldw	r18,8(sp)
   27110:	dc400117 	ldw	r17,4(sp)
   27114:	dc000017 	ldw	r16,0(sp)
   27118:	dec00504 	addi	sp,sp,20
   2711c:	f800283a 	ret
   27120:	00bfffc4 	movi	r2,-1
   27124:	f800283a 	ret

00027128 <_write_r>:
   27128:	defffe04 	addi	sp,sp,-8
   2712c:	dc000015 	stw	r16,0(sp)
   27130:	008000f4 	movhi	r2,3
   27134:	2021883a 	mov	r16,r4
   27138:	2809883a 	mov	r4,r5
   2713c:	300b883a 	mov	r5,r6
   27140:	380d883a 	mov	r6,r7
   27144:	dfc00115 	stw	ra,4(sp)
   27148:	10213015 	stw	zero,-31552(r2)
   2714c:	00273740 	call	27374 <write>
   27150:	10ffffd8 	cmpnei	r3,r2,-1
   27154:	1800041e 	bne	r3,zero,27168 <_write_r+0x40>
   27158:	00c000f4 	movhi	r3,3
   2715c:	18e13017 	ldw	r3,-31552(r3)
   27160:	18000126 	beq	r3,zero,27168 <_write_r+0x40>
   27164:	80c00015 	stw	r3,0(r16)
   27168:	dfc00117 	ldw	ra,4(sp)
   2716c:	dc000017 	ldw	r16,0(sp)
   27170:	dec00204 	addi	sp,sp,8
   27174:	f800283a 	ret

00027178 <alt_ic_isr_register>:
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
   27178:	00272041 	jmpi	27204 <alt_iic_isr_register>

0002717c <alt_ic_irq_enable>:
  NIOS2_READ_STATUS (context);
   2717c:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27180:	00bfff84 	movi	r2,-2
   27184:	1884703a 	and	r2,r3,r2
   27188:	1001703a 	wrctl	status,r2
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();

  alt_irq_active |= (1 << id);
   2718c:	00800044 	movi	r2,1
   27190:	d1216017 	ldw	r4,-31360(gp)
   27194:	114a983a 	sll	r5,r2,r5
   27198:	290ab03a 	or	r5,r5,r4
   2719c:	d1616015 	stw	r5,-31360(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   271a0:	d0a16017 	ldw	r2,-31360(gp)
   271a4:	100170fa 	wrctl	ienable,r2
  NIOS2_WRITE_STATUS (context);
   271a8:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_enable(irq);
}
   271ac:	0005883a 	mov	r2,zero
   271b0:	f800283a 	ret

000271b4 <alt_ic_irq_disable>:
  NIOS2_READ_STATUS (context);
   271b4:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   271b8:	00bfff84 	movi	r2,-2
   271bc:	1884703a 	and	r2,r3,r2
   271c0:	1001703a 	wrctl	status,r2
  alt_irq_active &= ~(1 << id);
   271c4:	00bfff84 	movi	r2,-2
   271c8:	d1216017 	ldw	r4,-31360(gp)
   271cc:	114a183a 	rol	r5,r2,r5
   271d0:	290a703a 	and	r5,r5,r4
   271d4:	d1616015 	stw	r5,-31360(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
   271d8:	d0a16017 	ldw	r2,-31360(gp)
   271dc:	100170fa 	wrctl	ienable,r2
  NIOS2_WRITE_STATUS (context);
   271e0:	1801703a 	wrctl	status,r3
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
    return alt_irq_disable(irq);
}
   271e4:	0005883a 	mov	r2,zero
   271e8:	f800283a 	ret

000271ec <alt_ic_irq_enabled>:
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
   271ec:	000730fa 	rdctl	r3,ienable

    return (irq_enabled & (1 << irq)) ? 1: 0;
   271f0:	00800044 	movi	r2,1
   271f4:	1144983a 	sll	r2,r2,r5
   271f8:	10c4703a 	and	r2,r2,r3
}
   271fc:	1004c03a 	cmpne	r2,r2,zero
   27200:	f800283a 	ret

00027204 <alt_iic_isr_register>:
{
  int rc = -EINVAL;  
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
  alt_irq_context status;

  if (id < ALT_NIRQ)
   27204:	28800808 	cmpgei	r2,r5,32
   27208:	1000161e 	bne	r2,zero,27264 <alt_iic_isr_register+0x60>
{
   2720c:	defffe04 	addi	sp,sp,-8
   27210:	dfc00115 	stw	ra,4(sp)
   27214:	dc000015 	stw	r16,0(sp)
  NIOS2_READ_STATUS (context);
   27218:	0021303a 	rdctl	r16,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   2721c:	00bfff84 	movi	r2,-2
   27220:	8084703a 	and	r2,r16,r2
   27224:	1001703a 	wrctl	status,r2
     * state.
     */

    status = alt_irq_disable_all();

    alt_irq[id].handler = isr;
   27228:	280690fa 	slli	r3,r5,3
   2722c:	008000f4 	movhi	r2,3
   27230:	10a19604 	addi	r2,r2,-31144
   27234:	10c5883a 	add	r2,r2,r3
   27238:	11800015 	stw	r6,0(r2)
    alt_irq[id].context = isr_context;
   2723c:	11c00115 	stw	r7,4(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   27240:	30000626 	beq	r6,zero,2725c <alt_iic_isr_register+0x58>
   27244:	002717c0 	call	2717c <alt_ic_irq_enable>
  NIOS2_WRITE_STATUS (context);
   27248:	8001703a 	wrctl	status,r16

    alt_irq_enable_all(status);
  }

  return rc; 
}
   2724c:	dfc00117 	ldw	ra,4(sp)
   27250:	dc000017 	ldw	r16,0(sp)
   27254:	dec00204 	addi	sp,sp,8
   27258:	f800283a 	ret
    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
   2725c:	00271b40 	call	271b4 <alt_ic_irq_disable>
   27260:	003ff906 	br	27248 <alt_iic_isr_register+0x44>
  int rc = -EINVAL;  
   27264:	00bffa84 	movi	r2,-22
}
   27268:	f800283a 	ret

0002726c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   2726c:	deffff04 	addi	sp,sp,-4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   27270:	010000b4 	movhi	r4,2
   27274:	014000b4 	movhi	r5,2
   27278:	dfc00015 	stw	ra,0(sp)
   2727c:	211eee04 	addi	r4,r4,31672
   27280:	295fee04 	addi	r5,r5,32696
   27284:	21400426 	beq	r4,r5,27298 <alt_load+0x2c>
  {
    while( to != end )
    {
      *to++ = *from++;
   27288:	018000b4 	movhi	r6,2
   2728c:	319fee04 	addi	r6,r6,32696
   27290:	310dc83a 	sub	r6,r6,r4
   27294:	0026ed40 	call	26ed4 <memcpy>
  if (to != from)
   27298:	010000b4 	movhi	r4,2
   2729c:	014000b4 	movhi	r5,2
   272a0:	21000804 	addi	r4,r4,32
   272a4:	29400804 	addi	r5,r5,32
   272a8:	21400426 	beq	r4,r5,272bc <alt_load+0x50>
      *to++ = *from++;
   272ac:	018000b4 	movhi	r6,2
   272b0:	31806004 	addi	r6,r6,384
   272b4:	310dc83a 	sub	r6,r6,r4
   272b8:	0026ed40 	call	26ed4 <memcpy>
  if (to != from)
   272bc:	010000b4 	movhi	r4,2
   272c0:	014000b4 	movhi	r5,2
   272c4:	211d7004 	addi	r4,r4,30144
   272c8:	295d7004 	addi	r5,r5,30144
   272cc:	21400426 	beq	r4,r5,272e0 <alt_load+0x74>
      *to++ = *from++;
   272d0:	018000b4 	movhi	r6,2
   272d4:	319eee04 	addi	r6,r6,31672
   272d8:	310dc83a 	sub	r6,r6,r4
   272dc:	0026ed40 	call	26ed4 <memcpy>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   272e0:	002758c0 	call	2758c <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   272e4:	dfc00017 	ldw	ra,0(sp)
   272e8:	dec00104 	addi	sp,sp,4
  alt_icache_flush_all();
   272ec:	00275901 	jmpi	27590 <alt_icache_flush_all>

000272f0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   272f0:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   272f4:	0009883a 	mov	r4,zero
{
   272f8:	dfc00015 	stw	ra,0(sp)
  alt_irq_init (NULL);
   272fc:	00273d00 	call	273d0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   27300:	00273f00 	call	273f0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   27304:	d1a16117 	ldw	r6,-31356(gp)
   27308:	d1616217 	ldw	r5,-31352(gp)
   2730c:	d1216317 	ldw	r4,-31348(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   27310:	dfc00017 	ldw	ra,0(sp)
   27314:	dec00104 	addi	sp,sp,4
  main (alt_argc, alt_argv, alt_envp);
   27318:	00201bc1 	jmpi	201bc <main>

0002731c <__malloc_lock>:
 * this requires that malloc is never called by an interrupt service routine.
 */

void __malloc_lock ( struct _reent *_r )
{
}
   2731c:	f800283a 	ret

00027320 <__malloc_unlock>:

/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
   27320:	f800283a 	ret

00027324 <sbrk>:
  NIOS2_READ_STATUS (context);
   27324:	0007303a 	rdctl	r3,status
  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
   27328:	00bfff84 	movi	r2,-2
   2732c:	1884703a 	and	r2,r3,r2
   27330:	1001703a 	wrctl	status,r2
  char *prev_heap_end; 

  context = alt_irq_disable_all();

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   27334:	d0a01a17 	ldw	r2,-32664(gp)
   27338:	017fff04 	movi	r5,-4
   2733c:	108000c4 	addi	r2,r2,3
   27340:	1144703a 	and	r2,r2,r5
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
   27344:	014000f4 	movhi	r5,3
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
   27348:	d0a01a15 	stw	r2,-32664(gp)
  if ((heap_end + incr) > __alt_heap_limit) {
   2734c:	1109883a 	add	r4,r2,r4
   27350:	29500004 	addi	r5,r5,16384
   27354:	2900032e 	bgeu	r5,r4,27364 <sbrk+0x40>
  NIOS2_WRITE_STATUS (context);
   27358:	1801703a 	wrctl	status,r3
    alt_irq_enable_all(context);
    return (caddr_t)-1;
   2735c:	00bfffc4 	movi	r2,-1
   27360:	f800283a 	ret
  }
#endif

  prev_heap_end = heap_end; 
  heap_end += incr; 
   27364:	d1201a15 	stw	r4,-32664(gp)
   27368:	1801703a 	wrctl	status,r3
#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
} 
   2736c:	f800283a 	ret

00027370 <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   27370:	00274fc1 	jmpi	274fc <alt_busy_sleep>

00027374 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   27374:	213fffc4 	addi	r4,r4,-1
   27378:	210000a8 	cmpgeui	r4,r4,2
   2737c:	2000041e 	bne	r4,zero,27390 <write+0x1c>
#ifdef ALT_STDOUT_PRESENT
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
   27380:	010000b4 	movhi	r4,2
   27384:	000f883a 	mov	r7,zero
   27388:	211fec04 	addi	r4,r4,32688
   2738c:	00273f41 	jmpi	273f4 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   27390:	d0a01c17 	ldw	r2,-32656(gp)
   27394:	10000926 	beq	r2,zero,273bc <write+0x48>
{
   27398:	deffff04 	addi	sp,sp,-4
   2739c:	dfc00015 	stw	ra,0(sp)
   273a0:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   273a4:	00c01444 	movi	r3,81
   273a8:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   273ac:	00bfffc4 	movi	r2,-1
   273b0:	dfc00017 	ldw	ra,0(sp)
   273b4:	dec00104 	addi	sp,sp,4
   273b8:	f800283a 	ret
   273bc:	d0a15f04 	addi	r2,gp,-31364
        ALT_ERRNO = EBADFD;
   273c0:	00c01444 	movi	r3,81
   273c4:	10c00015 	stw	r3,0(r2)
}
   273c8:	00bfffc4 	movi	r2,-1
   273cc:	f800283a 	ret

000273d0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   273d0:	deffff04 	addi	sp,sp,-4
   273d4:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS, NIOS);
   273d8:	00275b80 	call	275b8 <altera_nios2_gen2_irq_init>
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   273dc:	00800044 	movi	r2,1
   273e0:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   273e4:	dfc00017 	ldw	ra,0(sp)
   273e8:	dec00104 	addi	sp,sp,4
   273ec:	f800283a 	ret

000273f0 <alt_sys_init>:
void alt_sys_init( void )
{
    ALTERA_AVALON_JTAG_UART_INIT ( DEBUG, DEBUG);
    ALTERA_AVALON_SPI_INIT ( ESC_SPI, ESC_SPI);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, SYSID);
}
   273f0:	f800283a 	ret

000273f4 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   273f4:	20c00017 	ldw	r3,0(r4)
{
   273f8:	3005883a 	mov	r2,r6

  const char * end = ptr + count;
   273fc:	2989883a 	add	r4,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   27400:	01bfffd4 	movui	r6,65535
  while (ptr < end)
   27404:	29000136 	bltu	r5,r4,2740c <altera_avalon_jtag_uart_write+0x18>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);

  return count;
}
   27408:	f800283a 	ret
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   2740c:	19c00137 	ldwio	r7,4(r3)
   27410:	31fffc2e 	bgeu	r6,r7,27404 <altera_avalon_jtag_uart_write+0x10>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   27414:	29c00007 	ldb	r7,0(r5)
   27418:	29400044 	addi	r5,r5,1
   2741c:	19c00035 	stwio	r7,0(r3)
   27420:	003ff806 	br	27404 <altera_avalon_jtag_uart_write+0x10>

00027424 <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
   27424:	d8800017 	ldw	r2,0(sp)
   27428:	da000117 	ldw	r8,4(sp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   2742c:	00c00044 	movi	r3,1
{
   27430:	da400217 	ldw	r9,8(sp)
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   27434:	1946983a 	sll	r3,r3,r5
  const alt_u8 * write_end = write_data + write_length;
   27438:	399b883a 	add	r13,r7,r6
  alt_u8 * read_end = read_data + read_length;
   2743c:	4099883a 	add	r12,r8,r2
  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
   27440:	20c00535 	stwio	r3,20(r4)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
   27444:	48c0008c 	andi	r3,r9,2
   27448:	1800021e 	bne	r3,zero,27454 <alt_avalon_spi_command+0x30>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
   2744c:	00c10004 	movi	r3,1024
   27450:	20c00335 	stwio	r3,12(r4)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
   27454:	20c00037 	ldwio	r3,0(r4)
  alt_32 credits = 1;
   27458:	00c00044 	movi	r3,1
  alt_u32 write_zeros = read_length;
   2745c:	1015883a 	mov	r10,r2
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27460:	22c00204 	addi	r11,r4,8
   27464:	21400237 	ldwio	r5,8(r4)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
   27468:	2b80100c 	andi	r14,r5,64
   2746c:	2940200c 	andi	r5,r5,128
   27470:	70000126 	beq	r14,zero,27478 <alt_avalon_spi_command+0x54>
   27474:	1800101e 	bne	r3,zero,274b8 <alt_avalon_spi_command+0x94>
      }
      else
        credits = -1024;
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
   27478:	283ff926 	beq	r5,zero,27460 <alt_avalon_spi_command+0x3c>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
   2747c:	21400037 	ldwio	r5,0(r4)

      if (read_ignore > 0)
        read_ignore--;
      else
        *read_data++ = (alt_u8)rxdata;
      credits++;
   27480:	18c00044 	addi	r3,r3,1
      if (read_ignore > 0)
   27484:	30001a26 	beq	r6,zero,274f0 <alt_avalon_spi_command+0xcc>
        read_ignore--;
   27488:	31bfffc4 	addi	r6,r6,-1

      if (read_ignore == 0 && read_data == read_end)
   2748c:	303ff41e 	bne	r6,zero,27460 <alt_avalon_spi_command+0x3c>
   27490:	6200071e 	bne	r12,r8,274b0 <alt_avalon_spi_command+0x8c>
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
   27494:	58c00037 	ldwio	r3,0(r11)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
   27498:	18c0080c 	andi	r3,r3,32
   2749c:	183ffd26 	beq	r3,zero,27494 <alt_avalon_spi_command+0x70>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
   274a0:	4a40004c 	andi	r9,r9,1
   274a4:	4800011e 	bne	r9,zero,274ac <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
   274a8:	20000335 	stwio	zero,12(r4)

  return read_length;
}
   274ac:	f800283a 	ret
   274b0:	000d883a 	mov	r6,zero
   274b4:	003fea06 	br	27460 <alt_avalon_spi_command+0x3c>
    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
   274b8:	00ffef0e 	bge	zero,r3,27478 <alt_avalon_spi_command+0x54>
      credits--;
   274bc:	18ffffc4 	addi	r3,r3,-1
      if (write_data < write_end)
   274c0:	3b40052e 	bgeu	r7,r13,274d8 <alt_avalon_spi_command+0xb4>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
   274c4:	3b800044 	addi	r14,r7,1
   274c8:	39c00003 	ldbu	r7,0(r7)
   274cc:	21c00135 	stwio	r7,4(r4)
   274d0:	700f883a 	mov	r7,r14
   274d4:	003fe806 	br	27478 <alt_avalon_spi_command+0x54>
      else if (write_zeros > 0)
   274d8:	50000326 	beq	r10,zero,274e8 <alt_avalon_spi_command+0xc4>
        write_zeros--;
   274dc:	52bfffc4 	addi	r10,r10,-1
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
   274e0:	20000135 	stwio	zero,4(r4)
   274e4:	003fe406 	br	27478 <alt_avalon_spi_command+0x54>
        credits = -1024;
   274e8:	00ff0004 	movi	r3,-1024
   274ec:	003fe206 	br	27478 <alt_avalon_spi_command+0x54>
        *read_data++ = (alt_u8)rxdata;
   274f0:	41400005 	stb	r5,0(r8)
   274f4:	42000044 	addi	r8,r8,1
   274f8:	003fe506 	br	27490 <alt_avalon_spi_command+0x6c>

000274fc <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   274fc:	defffe04 	addi	sp,sp,-8
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   27500:	008666b4 	movhi	r2,6554
{
   27504:	dc000015 	stw	r16,0(sp)
   27508:	dfc00115 	stw	ra,4(sp)
  if (big_loops)
   2750c:	10a66604 	addi	r2,r2,-26216
{
   27510:	2021883a 	mov	r16,r4
  if (big_loops)
   27514:	1100182e 	bgeu	r2,r4,27578 <alt_busy_sleep+0x7c>
  big_loops = us / (INT_MAX/
   27518:	014666b4 	movhi	r5,6554
   2751c:	29666644 	addi	r5,r5,-26215
   27520:	0026ae40 	call	26ae4 <__udivsi3>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   27524:	00e00034 	movhi	r3,32768
  big_loops = us / (INT_MAX/
   27528:	1009883a 	mov	r4,r2
      __asm__ volatile (
   2752c:	18ffffc4 	addi	r3,r3,-1
    for(i=0;i<big_loops;i++)
   27530:	0005883a 	mov	r2,zero
      __asm__ volatile (
   27534:	18ffffc4 	addi	r3,r3,-1
   27538:	183ffe1e 	bne	r3,zero,27534 <alt_busy_sleep+0x38>
    for(i=0;i<big_loops;i++)
   2753c:	10800044 	addi	r2,r2,1
   27540:	113ffc16 	blt	r2,r4,27534 <alt_busy_sleep+0x38>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   27544:	017999b4 	movhi	r5,58982
   27548:	295999c4 	addi	r5,r5,26215
   2754c:	0026ba40 	call	26ba4 <__mulsi3>
   27550:	1405883a 	add	r2,r2,r16
   27554:	100690ba 	slli	r3,r2,2
   27558:	1885883a 	add	r2,r3,r2
    __asm__ volatile (
   2755c:	10bfffc4 	addi	r2,r2,-1
   27560:	103ffe1e 	bne	r2,zero,2755c <alt_busy_sleep+0x60>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   27564:	0005883a 	mov	r2,zero
   27568:	dfc00117 	ldw	ra,4(sp)
   2756c:	dc000017 	ldw	r16,0(sp)
   27570:	dec00204 	addi	sp,sp,8
   27574:	f800283a 	ret
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
   27578:	200490ba 	slli	r2,r4,2
   2757c:	1105883a 	add	r2,r2,r4
    __asm__ volatile (
   27580:	10bfffc4 	addi	r2,r2,-1
   27584:	00bffe16 	blt	zero,r2,27580 <alt_busy_sleep+0x84>
   27588:	003ff606 	br	27564 <alt_busy_sleep+0x68>

0002758c <alt_dcache_flush_all>:
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
   2758c:	f800283a 	ret

00027590 <alt_icache_flush_all>:
void alt_icache_flush_all (void)
{
#if NIOS2_ICACHE_SIZE > 0
  alt_icache_flush (0, NIOS2_ICACHE_SIZE);
#endif
}
   27590:	f800283a 	ret

00027594 <alt_exception_cause_generated_bad_addr>:
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
  switch (cause) {
   27594:	213ffe84 	addi	r4,r4,-6
   27598:	20800428 	cmpgeui	r2,r4,16
   2759c:	1000041e 	bne	r2,zero,275b0 <alt_exception_cause_generated_bad_addr+0x1c>
   275a0:	00a2c8d4 	movui	r2,35619
   275a4:	1104d83a 	srl	r2,r2,r4
   275a8:	1080004c 	andi	r2,r2,1
   275ac:	f800283a 	ret
   275b0:	0005883a 	mov	r2,zero
    return 0;

  default:
    return 0;
  }
}
   275b4:	f800283a 	ret

000275b8 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   275b8:	000170fa 	wrctl	ienable,zero
}
   275bc:	f800283a 	ret
